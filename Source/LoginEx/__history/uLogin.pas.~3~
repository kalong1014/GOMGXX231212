unit uLogin;

interface

uses
  Windows, Messages, Classes, SysUtils, uSocket, uCliTypes, uEDCode, EDCode,
  Forms, Controls, uServerList, Grobal2, OverbyteIcsHttpProt, ShellAPI,
  uUpdateTools, ComCtrls, OverbyteIcsPing, ExtCtrls, IOUtils, Graphics,
  uKernelMonitor, uWil, OverbyteIcsUrl, rtcInfo, uGameEngine, Math, uCommon,
  Generics.Collections, OverbyteIcsWndControl, OverbyteIcsWSocket,
  OverbyteIcsWSocketS, uMD5, RAR, RAR_DLL, rtcDataCli, rtcHttpCli,
  rtcConn, ScktCompSy, Share, uLog, StdCtrls, Dialogs, uMiniResDownloader, ZLib,
  uSyncObj, StrUtils;

type
  TMessageType = (mtNormal, mtError, mtWaringin);
  TuClientApp = class;
  TMiniResourcesClient = class;

  TResourceRequest = class(TRtcDataRequest)
  private
    FTempFileName: String;
    FFile: TFileStream;
    FClient: TMiniResourcesClient;
    FFileList: TStrings;
    FType: Byte;
    FStartTime: LongWord;
    FFileName, FPath: String;
    FImageIndex: Integer;

    procedure DoBeginRequest(Sender: TRtcConnection);
    procedure DoResponseAbort(Sender: TRtcConnection);
    procedure DoDataReceived(Sender: TRtcConnection);
    procedure RebuildMiniRequest(const AFileName: String; AType: Byte;
      AImageIndex: Integer; AImportant: Boolean);
    procedure ExecuteImage(AResponse: TRtcClientResponse);
    procedure ExecuteRar(AResponse: TRtcClientResponse);
    procedure DoRARListFile(Sender: TObject;
      const FileInformation: TRARFileItem);
  public
    constructor Create(AResourcesClient: TMiniResourcesClient);
    destructor Destroy; override;
  end;

  TMiniResourcesClient = class
  private
    FApp: TuClientApp;
    FClient: TRtcHttpClient;
    FThreads, FRequests, FFreeThreads: TFixedThreadList;
    FMiniPwd: String;
    FMaxThreads: Integer;
    procedure Clear;
    procedure Remove(ARequest: TResourceRequest);
    function CheckNeedDown(ARequest: pTMiniResRequest): Boolean;
    procedure DoDownload(ARequest: pTMiniResRequest);
    procedure LoadMiniSrvList;
  public
    constructor Create(AApp: TuClientApp);
    destructor Destroy; override;

    procedure SetServerInfo(const AServerAddr, AServerPort: String);
    procedure AddDownload(ARequest: pTMiniResRequest);
    procedure Run;

    property Client: TRtcHttpClient read FClient;
  end;

  TuClientApp = class(TInterfacedObject, IuApplication)
  private
    FAtCheckVer, FTryConnecting: Boolean;
    FCode: Byte;
    FMainForm: TForm;
    FClientSocket: TuClientSocket;
    FServerInfo: uServerList.TServerInfo;
    FBufferStr, FNewAccount: String;
    FMiniUrl: String;
    FTimer, FMiniTimer, FMiniDownTimer: TTimer;
    FConnected: Boolean;
    FImageList: TList;
    FResManager: TDownLoaderManager;
    FBusy: Boolean;
    FNeedTokenID: Boolean;
    procedure OnConnected(Sender: TObject; Socket: TCustomWinSocket);
    procedure OnClosed(Sender: TObject; Socket: TCustomWinSocket);
    procedure OnDataAvailable(Sender: TObject; Socket: TCustomWinSocket);
    procedure OnError(Sender: TObject; Socket: TCustomWinSocket;
      ErrorEvent: TErrorEvent; var ErrorCode: Integer);
    procedure DoCheckMySelfNeedUpdate(UpdateItem: TUpdateItem;
      var Need: Boolean);

    procedure LoadServerInfoFromStream(AStram: TStringStream); //读取服务器列表信息
    procedure LoadServerListFromServerInfo; //根据读取到的服务器列表 设置窗体按钮 的一些点击信息
    procedure ExtractEmbbedResources(F: TStream);
    function GetLocalConfigureFileName: String;
    procedure LoadLocalConfigure;
    procedure SaveLocalConfigure;
    procedure SendCSocket(const ASendData: AnsiString);
    procedure DoFileBegin(Sender: TObject);
    procedure DoFileEnd(Sender: TObject);
    procedure DoProgress(UpdateItem: TUpdateItem; AllSize, APosition: Integer);
    procedure DoBegin(UpdateItem: TUpdateItem; AllSize: Integer);
    procedure DoEnd(UpdateItem: TUpdateItem; AllSize: Integer);
    procedure DecodeMessagePacket(const ADatablock: AnsiString);
    procedure DoTimer(Sender: TObject);
    procedure DoMiniTimer(Sender: TObject);
    procedure DoMiniDownTimer(Sender: TObject);
    function ChooseFastMiniUrl(List:TStrings):String;

    procedure SetButtonEnabled(Value: Boolean);
    function GetTitle: String;
    procedure SendCloseAllClient;
    procedure OnKernelEvent(ErrorCode: Integer);
    function GetMaxClient: Integer;
  protected
    procedure StartGame;
    procedure Close;
    procedure RegisterID;
    procedure ChangePassWord;
    procedure OpenURL(const Url: String);
    procedure GetBackPassWord();
    procedure Config;
  public
    TreeView: TuTreeView;
    constructor Create;
    destructor Destroy; override;
    procedure Open;
    procedure Print(MessageType: TMessageType; const Message: String);
    procedure PrintEx(AUpdateItem: TUpdateItem; const Message: String);
    procedure TreeChangeNode(Sender: TObject; Node: TTreeNode);
    procedure TreeMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure ServerComboboxChange(Sender: TObject);
    function CheckServerInfo: Boolean;
    procedure UpdateFiles;
    function UpdateMySelf: Boolean;
    procedure UpdateSysFiles;
    procedure UpdateBgFiles;
    procedure ShowMailForm(Show: Boolean);
    procedure SendNewAccount(AUEntry: TUserEntryInfo; AUEntryAdd: TUserEntryAddInfo);
    procedure SendChangePassWord(const ID, OldPass, NewPass: String);
    procedure SendGetBackPassWord(const ID, NewPass, Q1, A1, Q2, A2,
      birthday: String);
    procedure DownLoadMiniClientVerFile(const Url: String); // 读取微端版本描述文件。
    property Title: String read GetTitle;
    property CheckVer: Boolean read FAtCheckVer;
    property MainForm: TForm read FMainForm write FMainForm;
    property MaxClient: Integer read GetMaxClient;
  end;

  // 微端及更新列表需要时更新部分
  TFileState = (ftNormal, ftDowning, ftDowned);

  TFileItem = class
    FileName: String;
    State: TFileState;
    Url: String;
    Path: String;
    Zip: Boolean;
    MiniServer: Boolean;
    DownKind: TupDownKind;
    procedure BeginDown;
    procedure EndDown;
  end;

  TFileDownManager = class
  private
    FFiles: TObjectDictionary<String, TFileItem>;
    constructor Create;
    destructor Destroy; override;
    function TryGet(const AName: String; out AFileItem: TFileItem): Boolean;
    procedure AddFile(const AName, AUrl, APath: String; MiniSrv: Boolean;
      Zip: Boolean; ADownKind: TupDownKind);
  end;

var
  boNeedSuicide: Boolean = False;
  boCreateShortCut: Boolean = False;
  uClientApp: TuClientApp;
  uFullScreen: Boolean = False;
  uWaitVBlank: Boolean = True;
  u3D: Boolean = False;
  uSCREENWIDTH: Integer = 1024;
  uSCREENHEIGHT: Integer = 768;
  uServerName: string;
  uDisplayName: string;
  uServerKey: AnsiString = '';
  uServeraddr: string;
  uServerPort: Integer;
  uHomePath: string;
  uRARDLLFile: String = '';
  uDXDLLFile: string = '';
  uPngForm: Boolean = True;
  uAlphaForm: Boolean = True;
  FileDownManager: TFileDownManager;
  uHandles: TStrings;
  uUseLisence: Boolean = False;
  uDateEditLisence: string;

{$IFDEF DEBUG}
const
  STR_SERVERLISTURL =  'http://127.0.0.1:8080/lb.txt';
  STR_MINIURL = 'http://127.0.0.1:8080';
  STR_MINIPWD = '123465';
//  STR_SERVERLISTURL =  'http://182.92.121.41:18088/ServerList/1.txt';
//  STR_MINIURL = 'http://182.92.121.41:18088/';
//  STR_MINIPWD = '813223';
{$ENDIF}

function GetWindowsDirectory: String;
function LoadExecutableStructure: TuExecutableStructure;
function GetDisplayBitsoixel: Integer;
procedure InitLoginData();

var
  g_PasswordFileName : String;

implementation

uses uTypes, Registry, uNewAccount, uGameSetting, uChangPwd, RegularExpressions,
  uGetBackPwd, uSplashFrm{, MiTeC_Routines}, ComObj,
  ActiveX,
  ShlObj;

function GetShellFolders(strDir: string): string;
const
  regPath = '\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders';
var
  Reg: TRegistry;
  strFolders: string;
begin
  Reg := TRegistry.Create;
  try
    Reg.RootKey := HKEY_CURRENT_USER;
    if Reg.OpenKey(regPath, False) then
    begin
      strFolders := Reg.ReadString(strDir);
    end;
  finally
    Reg.Free;
  end;
  result := strFolders;
end;

procedure CreateLinkToDesktop(const ExeName, LinkName: String);
var
  ATmpObject: IUnknown;
  ATmpSLink: IShellLink;
  ATmpPFile: IPersistFile;
  PIDL: PItemIDList;
  StartupDirectory: array [0 .. MAX_PATH] of Char;
  LinkFilename: WideString;
  DeskTopPath: String;
begin
  OleInitialize(nil);
  try
    DeskTopPath := GetShellFolders('Desktop') + '\'; // 是取得桌面文件夹的路径
    if FileExists(DeskTopPath + LinkName + '.lnk') then
    begin
      OleUninitialize;
      Exit;
    end;

    ATmpObject := CreateComObject(CLSID_ShellLink);
    ATmpSLink := ATmpObject as IShellLink;
    ATmpPFile := ATmpObject as IPersistFile;
    with ATmpSLink do begin
      SetPath(PChar(ExtractFilePath(ParamStr(0)) + '\' + ExtractFileName(ParamStr(0))));
      SetArguments(PChar(''));
      SetWorkingDirectory(PChar(ExtractFilePath(ParamStr(0))));
    end;
    LinkFilename :=  DeskTopPath + Application.Title + '.lnk';
    ATmpPFile.Save(PWChar(LinkFilename), False);

//    ATmpObject := CreateComObject(CLSID_ShellLink);
//    ATmpSLink := ATmpObject as IShellLink;
//    ATmpPFile := ATmpObject as IPersistFile;
//    ATmpSLink.SetPath(pChar(ExeName));
//    ATmpSLink.SetWorkingDirectory(pChar(ExtractFilePath(ExeName)));
//    SHGetSpecialFolderLocation(0, CSIDL_DESKTOPDIRECTORY, PIDL);
//    ATmpSLink.SetDescription(PWideChar(LinkName));
//    ATmpSLink.SetIconLocation(pChar(ExeName), 0);
//    SHGetPathFromIDList(PIDL, StartupDirectory);
//    LinkFilename := String(StartupDirectory) + '\' + LinkName + '.lnk';
//    ATmpPFile.Save(PWideChar(LinkFilename), False);
  finally
    OleUninitialize;
  end;
end;

function GetDisplayBitsoixel: Integer;
var
  AScreenDC: THandle;
begin
  AScreenDC := CreateDC('DISPLAY', nil, nil, nil);
  result := GetDeviceCaps(AScreenDC, BITSPIXEL);
end;

function GetWindowsDirectory: String;
var
  WinPath: pChar;
begin
  WinPath := StrAlloc(255);
  try
    Windows.GetWindowsDirectory(WinPath, 256);
    result := WinPath;
    result := SysUtils.IncludeTrailingPathDelimiter(result);
  finally
    StrDispose(WinPath);
  end;
end;

function GetHttpHeaderValue(Header: TStrings; const Name: String): String;
var
  I: Integer;
begin
  result := '';
  for I := 0 to Header.Count - 1 do
    if Pos(Name + ':', Header[I]) = 1 then
    begin
      result := Header[I];
      Delete(result, 1, Length(Name + ':'));
      result := Trim(result);
      Break;
    end;
end;

function ISIPAddress(const Address: String): Boolean;
begin
  result := TRegEx.Match(Address,
    '((?:(?:25[0-5]|2[0-4]\d|((1\d{2})|([1-9]?\d)))\.){3}(?:25[0-5]|2[0-4]\d|((1\d{2})|([1-9]?\d))))')
    .Success;
end;

function GetHostIP(const AHost: String): String;
var
  IPPing: TPing;
begin
  IPPing := TPing.Create(nil);
  try
    IPPing.Address := AHost;
    IPPing.Ping;
    result := IPPing.HostIP;
  finally
    IPPing.Free;
  end;
end;

procedure _ParseURL(const AUrl: String; var AServerAddr, AServerPort: String);
var
  AProto, AUser, APass, APath: String;
begin
  OverbyteIcsUrl.ParseURL(AUrl, AProto, AUser, APass, AServerAddr,
    AServerPort, APath);
  if not ISIPAddress(AServerAddr) then
    AServerAddr := GetHostIP(AServerAddr);
end;

function LoadExecutableStructure: TuExecutableStructure;
var
  AFile: TFileStream;
  AExecutableStream, ATmp: TMemoryStream;
  ABuf: PAnsiChar;
  DataSize: Integer;
  ExecutableStreamLen:Int64;
begin
  // ShowMessage(IntToStr(SizeOf(TuExecutableStructure)));
  try
{$IFDEF DEBUG} //这里主要要修改
    result.Title := uEDCode.DecodeSource('1077vh0AmFvqAZJIrZyggIV7'); //调试登陆器 调试登录器标题
    result.ServerListURL := '';
    result.SkinDataLen := 0;
    result.Offset := 0;
{$ELSE}
    AFile := TFileStream.Create(Application.ExeName, fmOpenRead or fmShareDenyNone);
    // AFile :=  TFileStream.Create('E:\JONE\trunk\Source\Debug Data\LoginData.dat', fmOpenRead or fmShareDenyNone);
   //AFile :=  TFileStream.Create('D:\热血传奇\DebugEmResource.exe', fmOpenRead or fmShareDenyNone);
    AExecutableStream := TMemoryStream.Create;
    ATmp := TMemoryStream.Create;
    DataSize := SizeOf(TuExecutableStructure) + 16;
    GetMem(ABuf, DataSize);
    try
      AFile.Position := AFile.Size - DataSize;
      AFile.ReadBuffer(ABuf^, DataSize);
      AExecutableStream.WriteBuffer(ABuf^, DataSize);

      uEDCode.DecodeStream(AExecutableStream, ATmp,
        uEDCode.DecodeSource
        ('ynzPX3rxRYZNE+HC/cYSMS49UszSY71Yq53qkw23HAUpL32klGBAwHZLr9x4WGaIqL2YGTmj18XxZ5vVHuVjOH2HLb6SaIf3hEDfdzZ9zOQ=')
        );   //58C3CCD4-010E-4F11-8050-BB09060B4895
      AExecutableStream.Clear;
      uEDCode.DecodeStream(ATmp, AExecutableStream,
        uEDCode.DecodeSource
        ('gyXzX1z8FbTnvt6GHW1Itzc5DBVImlq4pMFx3wpXbUXs8ZpXFjRoLrlGHOoXnpPZDtKuYl4e8pu/d7Pp7imIJw/BMuOXhtzUbUcCfWdWa10=')
        );  //08719071-B701-4F41-A8FB-3F4F04406621
      AExecutableStream.Seek(0, soFromBeginning);
      AExecutableStream.ReadBuffer(result, SizeOf(TuExecutableStructure));
    finally
      AFile.Free;
      AExecutableStream.Free;
      ATmp.Free;
      FreeMem(ABuf);
    end;
{$ENDIF}
  except
    on E: Exception do
    begin
      uLog.TLogger.AddLog
        (uEDCode.DecodeSource
        ('CJWYNoWrQGKNVBMjBGU8SBA6At2n9GraGnzXW5v1XQVrEw==') + E.Message);
      // 获取头信息失败,错误信息:
      Application.Terminate;
    end;
  end;
end;

{ TuClientApp }

procedure TuClientApp.ChangePassWord;
begin
  if uUseLisence then begin
    if StrToDate(uEDCode.DecodeLisence(uDateEditLisence)) < Now then begin
      Application.MessageBox
           (pChar(uEDCode.DecodeSource
           ('57PXggNvZJ2Bdpg+d55Imk4oFo8uM8rpYIEO4eoE7EBZmlPRi/8=')),
           pChar(uEDCode.DecodeSource('Lzwm4byCg5BJE0C4')), MB_OK or MB_ICONERROR);
      if FConnected then
        FClientSocket.Close;
      Exit;
    end;
  end;

  FRMChangePWD.Left := FMainForm.Left +
    (FMainForm.Width - FRMChangePWD.Width) div 2;
  FRMChangePWD.Top := FMainForm.Top +
    (FMainForm.Height - FRMChangePWD.Height) div 2;
  FRMChangePWD.Initializa;
  FRMChangePWD.ShowModal;
end;

procedure TuClientApp.GetBackPassWord;
begin
  if uUseLisence then begin
    if StrToDate(uEDCode.DecodeLisence(uDateEditLisence)) < Now then begin
      Application.MessageBox
           (pChar(uEDCode.DecodeSource
           ('57PXggNvZJ2Bdpg+d55Imk4oFo8uM8rpYIEO4eoE7EBZmlPRi/8=')),
           pChar(uEDCode.DecodeSource('Lzwm4byCg5BJE0C4')), MB_OK or MB_ICONERROR);
      if FConnected then
        FClientSocket.Close;
      Exit;
    end;
  end;
  frmGetBackPwd.Left := FMainForm.Left +
    (FMainForm.Width - frmGetBackPwd.Width) div 2;
  frmGetBackPwd.Top := FMainForm.Top +
    (FMainForm.Height - frmGetBackPwd.Height) div 2;
  frmGetBackPwd.Initializa;
  frmGetBackPwd.ShowModal;
end;

function TuClientApp.CheckServerInfo: Boolean;

  function TryGetServerInfo(const ALine, AUrl: String): Boolean;
  var
    AHttp: THttpCli;
  begin
    result := False;
    if AUrl <> '' then
    begin
      AHttp := THttpCli.Create(nil);
      try
        AHttp.Agent :=
          'Mozilla/5.0 (Windows NT 5.1; rv:8.0) Gecko/20100101 Firefox/8.0';
        AHttp.RcvdStream := TStringStream.Create;
        AHttp.Url := AUrl;
        AHttp.NoCache := True;
        try
          AHttp.Get;
          AHttp.RcvdStream.Seek(0, soBeginning);
          LoadServerInfoFromStream(TStringStream(AHttp.RcvdStream));
          AHttp.RcvdStream.Seek(0, soBeginning);
          if not IOUtils.TDirectory.Exists
            (IncludeTrailingPathDelimiter(uHomePath) +
            IncludeTrailingPathDelimiter(FServerInfo.ResFolder)) then
            IOUtils.TDirectory.CreateDirectory
              (IncludeTrailingPathDelimiter(uHomePath) +
              IncludeTrailingPathDelimiter(FServerInfo.ResFolder));
          result := True;
        except
          on E: Exception do
          begin
            uLog.TLogger.AddLog
              (Format(uEDCode.DecodeSource
              ('aSppaPUhmalrplQ1I3xA+PxNy92NqLHm5Nrqm1Q5iz4ty1MEklnOQW2lpaE='),
              [ALine, E.Message])); // 获取列表失败,错误信息(%s):%s

          end;
        end;
      finally
        if AHttp.RcvdStream <> nil then
          AHttp.RcvdStream.Free;

        FreeAndNil(AHttp);
      end;
    end;
  end;

  function CheckServerInfoDone: Boolean;
  begin
    result := False;
    if FServerInfo.ServerList.Count > 0 then
    begin
      Print(mtNormal, uEDCode.DecodeSource
        ('doujYTE9uoBNuzXWKa+ctV8537kdbYpN0SxfqhqEYr0='));   //更新登陆器列表完成...
      result := True;
    end
    else
      Print(mtError, uEDCode.DecodeSource
        ('vw2df3Oe1AaF3FQ5A2l0U4dJ8x6RedXSuWsRuhO6n40='));  //获取登陆器列表失败...
  end;

var
  AHandled: Boolean;
  AServerItem: TServerItem;
{$IFDEF Commercial}
  AResource: {$IFDEF DEBUG}TMemoryStream{$ELSE}TResourceStream{$ENDIF};
  ATmp: TMemoryStream;
  AHeader: TuExecutableHeader;
{$ELSE}
  AExecutableStructure: TuExecutableStructure;
{$ENDIF}
  AServerAddr, AServerPort: String;
begin
  Result := False;
  AExecutableStructure := LoadExecutableStructure;
{$IFDEF DEBUG}
  AExecutableStructure.ServerListURL := STR_SERVERLISTURL;
{$ENDIF}
  if (AExecutableStructure.ServerListURL <> '') and
    (AExecutableStructure.ServerListURL <> 'local') then
  begin
    if not TryGetServerInfo(uEDCode.DecodeSource('ROXuhkd0tAeGyAQp9XO/hg=='),
      AExecutableStructure.ServerListURL) then
    begin
      Print(mtNormal, '获取主服务器列表信息失败,正在尝试获取1号备用列表');
      if not TryGetServerInfo(uEDCode.DecodeSource('ROXuhkd0tAeGyAQp9XO/hg=='),
        AExecutableStructure.ServerListURL2) then
      begin
        Print(mtNormal, '获取1号备用服务器列表信息失败,正在尝试获取2号备用列表');
        if not TryGetServerInfo
          (uEDCode.DecodeSource('ROXuhkd0tAeGyAQp9XO/hg=='),
          AExecutableStructure.ServerListURL3) then
        begin
          Print(mtNormal, '无法获取服务器列表...');
        end
        else
          AHandled := True;
      end
      else
        AHandled := True;
    end
    else
      AHandled := True;
    result := CheckServerInfoDone;
  end
  else
  begin
{$IFDEF DEBUG}
    FResManager.PassWord := STR_MINIPWD;
    FResManager.ResURL := STR_MINIURL;
{$ENDIF}
    FServerInfo.ResFolder := uEDCode.DecodeSource
      ('ieTl9JjZ2g0ayWKOp1a0g/J7zoxaYZ86Etc=');
    AServerItem := FServerInfo.ServerList.Add;
    AServerItem.GroupName := uEDCode.DecodeSource('Eh7v4dXiKHmouMOEmP1I8w==');
    AServerItem.DisplayName := uEDCode.DecodeSource
      ('KzdtL/Loqm1oRZ58B9hvUY4pct5cFS4+eoy1KF55NGrbotxgWJVGGBqulFUePMHa');
    AServerItem.Host := uEDCode.DecodeSource
      ('kAeYZJrNBzfxsjAzkgrdTqHeSflbLLnM1GY=');
    AServerItem.Port := 7000;
    AServerItem.ImageIndex := 1;

    AServerItem := FServerInfo.ServerList.Add;
    AServerItem.GroupName := uEDCode.DecodeSource('UcRJQRb/loYQFTX8vUF0Hw==');
    AServerItem.DisplayName := uEDCode.DecodeSource
      ('PrGAYcF9ImNEU9H2uPds4eS8qrjfAHbk0AWD/XuI1lAptFoEo0MhAYe0XYIMPeC4swX/0A==');
    AServerItem.Host := uEDCode.DecodeSource
      ('5+mijMg+H1VW9XRCjQ66Obu48Bx4vWQpaIXpx6JO');
    AServerItem.Port := 7000;
    AServerItem.ImageIndex := 1;

    AServerItem := FServerInfo.ServerList.Add;
    AServerItem.GroupName := uEDCode.DecodeSource('nLYfQuMIyPQbyZvvVNZ6Jw==');
    AServerItem.DisplayName := uEDCode.DecodeSource
      ('bX3289f9dCgZyPJoi/LtTOFyfo4TVRU+A8G+sfasBopfAo3QZOXvoi8myBUh9zFxuEakPw==');
    AServerItem.Host := uEDCode.DecodeSource
      ('Kh/+htnc+fpeW8237WochDNEeAFm3gNknnrPcjg1');
    AServerItem.Port := 7000;
    AServerItem.ImageIndex := 1;
    LoadLocalConfigure;

     if uUseLisence then begin
       if StrToDate(uEDCode.DecodeLisence(uDateEditLisence)) < Now then begin
         Application.MessageBox
              (pChar(uEDCode.DecodeSource
              ('57PXggNvZJ2Bdpg+d55Imk4oFo8uM8rpYIEO4eoE7EBZmlPRi/8=')),
              pChar(uEDCode.DecodeSource('Lzwm4byCg5BJE0C4')), MB_OK or MB_ICONERROR);
            Application.Terminate;

       end;
     end;

    LoadServerListFromServerInfo;
    result := True;
  end;
end;

function TuClientApp.ChooseFastMiniUrl(List:TStrings):string;
  function _GetResponse(const AUrl: String): Integer;
  var
    AHttp: THttpCli;
    L: LongWord;
  begin
    Result := -1;
    L := GetTickCount;
    try
      AHttp := THttpCli.Create(nil);
      AHttp.Agent := 'Mozilla/5.0 (Windows NT 5.1; rv:8.0) Gecko/20100101 Firefox/8.0';
      AHttp.URL := AUrl;
      try
        AHttp.Get;
        if AHttp.StatusCode = 200 then
          Result := GetTickCount - L;
      except
        On E:EHttpException do
        begin
          if AHttp.StatusCode = 404 then
            Result := GetTickCount - L;
        end;
        on E:Exception do
        begin                                       //获取最优微端列表服务器信息报错,错误信息:
           uLog.TLogger.AddLog(uEDCode.DecodeSource('oK3rRYHr9sOUP7C23NVeWL7aiWKvQ9cwW1ZiKIrnpnKNjkomQ4SJqIgaagdfykGImR0=') + E.Message);  //获取最优微端列表服务器信息报错,错误信息:
        end;
      end;
    finally
      AHttp.Free;
    end;
  end;

var
  I, AMinTime, ATime: Integer;
  AUrl, APingUrl, AMinUrl, AServerAddr, AServerPort: String;
begin
  try
    AMinTime := High(Integer);
    AMinUrl := '';
    for I := 0 to List.Count - 1 do
    begin
      AUrl := List[I];
      if AUrl[Length(AUrl)] <> '/' then
        AUrl := AUrl + '/';
      APingUrl := AUrl + 'Resources/Ping';
      ATime := _GetResponse(APingUrl);
      if ATime <> -1 then
      begin
        AMinTime := Min(AMinTime, ATime);
        if AMinTime = ATime then
          AMinUrl := AUrl;
      end;
    end;
    Result := AMinUrl;
  finally
    List.Free;
  end;
end;


procedure TuClientApp.Close;
begin
  if (FResManager.ClientCount = 0) or
    (Application.MessageBox('关闭登陆器的同时客户端也将会被关闭，确定执行吗吗？',
    pChar(Application.Title), MB_YESNO) = ID_YES) then
  begin
    if FConnected then
      FClientSocket.Close;
    Application.Terminate;
  end;
end;

procedure TuClientApp.Config;
begin
  FrmSetting.Left := FMainForm.Left +
    (FMainForm.Width - FrmSetting.Width) div 2;
  FrmSetting.Top := FMainForm.Top +
    (FMainForm.Height - FrmSetting.Height) div 2;
  FrmSetting.LoadConfig;
  if FrmSetting.ShowModal = mrOK then
  begin
    SaveLocalConfigure;
  end;
end;

constructor TuClientApp.Create;
var
  List: TStringList;
begin
  FAtCheckVer := True;
  FCode := 0;
  Randomize;
  FTimer := TTimer.Create(nil);
  FMiniTimer := TTimer.Create(nil);
  FMiniDownTimer := TTimer.Create(nil);
  FMiniDownTimer.Interval := 10;
  FTimer.Enabled := False;
  FMiniTimer.Enabled := False;
  FMiniDownTimer.Enabled := False;
  FTimer.OnTimer := DoTimer;
  FMiniTimer.OnTimer := DoMiniTimer;
  FMiniDownTimer.OnTimer := DoMiniDownTimer;
  FMiniUrl := '';
  FServerInfo := uServerList.TServerInfo.Create;
  FClientSocket := uSocket.TuClientSocket.Create(nil);
  FClientSocket.OnRead := OnDataAvailable;
  FClientSocket.OnConnect := OnConnected;
  FClientSocket.OnDisconnect := OnClosed;
  FClientSocket.OnError := OnError;

  FResManager := TDownLoaderManager.Create;

  DMKernelMonitor := TDMKernelMonitor.Create(Application);
  DMKernelMonitor.OnKernelEvent := OnKernelEvent;
end;

destructor TuClientApp.Destroy;
begin
  SendCloseAllClient;
  FreeAndNil(FClientSocket);
  FreeAndNil(FTimer);
  FreeAndNil(FMiniTimer);
  FreeAndNil(FMiniDownTimer);
  FreeAndNil(FServerInfo);
  FResManager.Free;
  DMKernelMonitor.Free;
  inherited;
end;

procedure TuClientApp.LoadServerListFromServerInfo;

  function FindGroupNode(ATreeView: TuTreeView; const Name: String): TTreeNode;
  var
    I: Integer;
  begin
    for I := 0 to ATreeView.Items.Count - 1 do
      if (ATreeView.Items[I].Level = 0) and SameText(ATreeView.Items[I].Text,
        Name) then
      begin
        result := ATreeView.Items[I];
        Exit;
      end;

    result := ATreeView.Items.Add(nil, Name);
    if (ATreeView.Images <> nil) and (ATreeView.Images.Count > 0) then
    begin
      result.ImageIndex := 0;
      result.SelectedIndex := 0;
    end;
  end;

var
  I, J: Integer;
  Comp: TComponent;
  AParentNode, ACurNode: TTreeNode;
begin
  for I := 0 to FMainForm.ComponentCount - 1 do
  begin
    Comp := FMainForm.Components[I];
    if Comp.ClassType = TuWebBrowser then
      TuWebBrowser(Comp).Navigate(FServerInfo.LoginURL)
    else if Comp.ClassType = TuURLButton then
    begin
      case TuURLButton(Comp).URLKind of
        ukCustom:
          ;
        ukHomePage:
          TuURLButton(Comp).Url := FServerInfo.HomeURL;
        ukPayPage:
          TuURLButton(Comp).Url := FServerInfo.PayURL;
        ukContactPage:
          TuURLButton(Comp).Url := FServerInfo.ContactURL;
      end;
      TuURLButton(Comp).Enabled := TuURLButton(Comp).Url <> '';
    end;
  end;

  for I := 0 to FMainForm.ComponentCount - 1 do
  begin
    Comp := FMainForm.Components[I];
    if Comp.ClassType = TuTreeView then
    begin
      TuTreeView(Comp).Items.BeginUpdate;
      TuTreeView(Comp).Items.Clear;
      for J := 0 to FServerInfo.ServerList.Count - 1 do
      begin
        AParentNode := FindGroupNode(TuTreeView(Comp),
          FServerInfo.ServerList.Items[J].GroupName);
        ACurNode := TuTreeView(Comp).Items.AddChildObject(AParentNode,
          FServerInfo.ServerList.Items[J].DisplayName,
          FServerInfo.ServerList.Items[J]);
        if (TuTreeView(Comp).Images <> nil) and
          (FServerInfo.ServerList.Items[J].ImageIndex > -1) and
          (TuTreeView(Comp).Images.Count > FServerInfo.ServerList.Items[J]
          .ImageIndex) then
        begin
          ACurNode.ImageIndex := FServerInfo.ServerList.Items[J].ImageIndex;
          ACurNode.SelectedIndex := FServerInfo.ServerList.Items[J].ImageIndex;
        end;
      end;
      TuTreeView(Comp).FullExpand;
      TuTreeView(Comp).Items.EndUpdate;
    end
    else if Comp.ClassType = TuServerCombobox then
    begin
      TuServerCombobox(Comp).Items.BeginUpdate;
      TuServerCombobox(Comp).Items.Clear;
      for J := 0 to FServerInfo.ServerList.Count - 1 do
      begin
        TuServerCombobox(Comp).Items.AddObject(FServerInfo.ServerList.Items[J]
          .DisplayName, FServerInfo.ServerList.Items[J]);
      end;
      TuServerCombobox(Comp).Items.EndUpdate;
      TuServerCombobox(Comp).ItemIndex := 0;
    end;
  end;
end;

function TuClientApp.GetLocalConfigureFileName: String;
begin
  result := IOUtils.TPath.GetTempPath + '\' + Application.Title + '.ini';
end;

function TuClientApp.GetMaxClient: Integer;
begin
  result := FServerInfo.MaxClient;
end;

procedure TuClientApp.LoadLocalConfigure;
var
  S: String;
  AIni: TFastIniFile;
  LS: TStrings;
begin
  if FileExists(GetLocalConfigureFileName) then
  begin
    AIni := TFastIniFile.Create(GetLocalConfigureFileName);
    try
      if AIni.ValueExist('客户端', '分辨率') then
      begin
        LS := TStringList.Create;
        try
          EnumDisplayMode(LS);
          S := AIni.ReadString('客户端', '分辨率', '');
          if (S <> '') and (LS.IndexOf(S) <> -1) then
          begin
            LS.Clear;
            ExtractStrings(['x'], [], pChar(S), LS);
            uSCREENWIDTH := StrToInt(LS.Strings[0]);
            uSCREENHEIGHT := StrToInt(LS.Strings[1]);
          end;
        finally
          LS.Free;
        end;
      end;
      if AIni.ValueExist('客户端', '窗口化') then
        uFullScreen := AIni.ReadBoolean('客户端', '窗口化', True);
      if AIni.ValueExist('客户端', '垂直同步') then
        uWaitVBlank := AIni.ReadBoolean('客户端', '垂直同步', True);
      if AIni.ValueExist('客户端', '3D加速') then
        u3D := AIni.ReadBoolean('客户端', '3D加速', True);
    finally
      AIni.Free;
    end;
  end;
end;

procedure TuClientApp.DownLoadMiniClientVerFile(const Url: String);
var
  AHttp: THttpCli;
  M: TMemoryStream;
  FileName:String;
  SaveFileName:String;
begin
  //先删除之前的文件。
  if FileExists(IncludeTrailingPathDelimiter(uHomePath) + IncludeTrailingPathDelimiter(FServerInfo.ResFolder) +'MiniVer.db') then
    IOUtils.TFile.Delete(IncludeTrailingPathDelimiter(uHomePath) + IncludeTrailingPathDelimiter(FServerInfo.ResFolder) +'MiniVer.db');
  FileName := Url+ 'MiniVer.db';
  TThread.CreateAnonymousThread( procedure()
  begin
    if Url <> '' then
    begin AHttp := THttpCli.Create(nil);
    try
      AHttp.Agent := 'Mozilla/5.0 (Windows NT 5.1; rv:8.0) Gecko/20100101 Firefox/8.0';
      AHttp.RcvdStream := TMemoryStream.Create;
      AHttp.Url := FileName;
      AHttp.NoCache := True;
      ResDownLoadLog('开始请求微端版本描述文件,URL:' + FileName,5);
      try
        AHttp.Get;
        M := TMemoryStream.Create;
        AHttp.RcvdStream.Seek(0, soBeginning); M.CopyFrom(AHttp.RcvdStream, 0);

        if not IOUtils.TDirectory.Exists(IncludeTrailingPathDelimiter(uHomePath) + IncludeTrailingPathDelimiter(FServerInfo.ResFolder)) then
           IOUtils.TDirectory.CreateDirectory(IncludeTrailingPathDelimiter(uHomePath) + IncludeTrailingPathDelimiter(FServerInfo.ResFolder));
        SaveFileName := IncludeTrailingPathDelimiter(uHomePath) + IncludeTrailingPathDelimiter(FServerInfo.ResFolder) +'MiniVer.db';


        ResDownLoadLog('微端版本描述文件下载成功保存路径:' + SaveFileName,5);
        M.Position := 0;
        Self.FResManager.PassWord := FServerInfo.MiniPwd;
        Self.FResManager.LoadResVerPackFromStream(M);
        M.SaveToFile(SaveFileName);
        M.Free;
      except
      on E: Exception do
      begin
        uLog.TLogger.AddLog(Format('%s, 原因:%s',['下载微端版本描述文件失败', E.Message])); // 获取列表失败,错误信息(%s):%s
      end;
      end;
    finally
      if AHttp.RcvdStream <> nil then
        AHttp.RcvdStream.Free;

      FreeAndNil(AHttp);
    end;
    end
  end).Start;
end;

procedure TuClientApp.SaveLocalConfigure;
var
  AIni: TFastIniFile;
begin
  AIni := TFastIniFile.Create(GetLocalConfigureFileName);
  try
    AIni.WriteString('客户端', '分辨率',
      Format('%dx%d', [uSCREENWIDTH, uSCREENHEIGHT]));
    AIni.WriteBoolean('客户端', '窗口化', uFullScreen);
    AIni.WriteBoolean('客户端', '垂直同步', uWaitVBlank);
    AIni.WriteBoolean('客户端', '3D加速', u3D);
  finally
    AIni.Free;
  end;
end;

procedure TuClientApp.LoadServerInfoFromStream(AStram: TStringStream);
var
  MiniURList:TStringList;
  MiniURL:String;
begin
  AStram.Seek(0, soFromBeginning);
  FServerInfo.Clear;
  FServerInfo.LoadFromString(AStram.DataString);

  if FServerInfo.EnabledMini and (FServerInfo.MiniURL <> '') then
  begin
    //根据服务端设置的列表信息设置微端信息。
    MiniURList := TStringList.Create;
    MiniURList.Text := FServerInfo.MiniURL;
    MiniURL := ChooseFastMiniUrl(MiniURList);

    FResManager.PassWord := FServerInfo.MiniPwd;
    FResManager.ResURL := MiniURL;

    //下载微端描述
    DownLoadMiniClientVerFile(MiniURL);
    FResManager.StartWork(12,4);
    FResManager.StartSocekt;
  end else
  begin
    FResManager.StartSocekt;
  end;

  uFullScreen := FServerInfo.FullScreen;
  uWaitVBlank := FServerInfo.VBlank;
  u3D := FServerInfo.Do3D;
  uUseLisence := FServerInfo.UseLisence;
  uDateEditLisence := FServerInfo.DataTimeLisence;

  if uUseLisence then begin
    if StrToDate(uEDCode.DecodeLisence(uDateEditLisence)) < Now then begin
      Application.MessageBox
           (pChar(uEDCode.DecodeSource
           ('57PXggNvZJ2Bdpg+d55Imk4oFo8uM8rpYIEO4eoE7EBZmlPRi/8=')),
           pChar(uEDCode.DecodeSource('Lzwm4byCg5BJE0C4')), MB_OK or MB_ICONERROR);
      if FConnected then
        FClientSocket.Close;
      FResManager.Terminate;
    end;
  end;

  case FServerInfo.DisplaySize of
    ds1024:
      begin
        uSCREENWIDTH := 1024;
        uSCREENHEIGHT := 768;
      end;
    ds800:
      begin
        uSCREENWIDTH := 800;
        uSCREENHEIGHT := 600;
      end;
  end;
  LoadServerListFromServerInfo;
  LoadLocalConfigure;

  g_PasswordFileName := IOUtils.TPath.GetTempFileName;
  DeleteFile(g_PasswordFileName);
  g_PasswordFileName := g_PasswordFileName + '.dat';
  FServerInfo.SecurityFiles.SaveToFile(g_PasswordFileName);
end;


procedure TuClientApp.OnClosed(Sender: TObject; Socket: TCustomWinSocket);
begin
  if FConnected then
    Print(mtError, uEDCode.DecodeSource('1pP/phZEGSQZ2meRqYzQkRg5MWRM7Q=='))
  else
    Print(mtError, uEDCode.DecodeSource('nybSuBY8hoYgDtURMaJUT/Wnw6k='));
  FConnected := False;
  FTryConnecting := False;
  FNeedTokenID := True;
  SetButtonEnabled(False);
end;

procedure TuClientApp.OnConnected(Sender: TObject; Socket: TCustomWinSocket);
begin
  if Socket.Connected then
  begin
    FConnected := True;
    FTryConnecting := False;
    Print(mtNormal, uEDCode.DecodeSource('9KqkbGkhj5+OKvYAhVVhCsxAfwqraA=='));
    SetButtonEnabled(True);
  end;
end;

function ArrestStringEx(Source: AnsiString; SearchAfter, ArrestBefore: AnsiChar;
  var ArrestStr: AnsiString): AnsiString;
var
  srclen: Integer;
  GoodData: Boolean;
  I, n: Integer;
begin
  ArrestStr := '';
  if Source = '' then
  begin
    result := '';
    Exit;
  end;

  try
    srclen := Length(Source);
    GoodData := False;
    if srclen >= 2 then
      if Source[1] = SearchAfter then
      begin
        Source := Copy(Source, 2, srclen - 1);
        srclen := Length(Source);
        GoodData := True;
      end
      else
      begin
        n := Pos(SearchAfter, Source);
        if n > 0 then
        begin
          Source := Copy(Source, n + 1, srclen - (n));
          srclen := Length(Source);
          GoodData := True;
        end;
      end;

    if GoodData then
    begin
      n := Pos(ArrestBefore, Source);
      if n > 0 then
      begin
        ArrestStr := Copy(Source, 1, n - 1);
        result := Copy(Source, n + 1, srclen - n);
      end
      else
      begin
        result := SearchAfter + Source;
      end;
    end
    else
    begin
      for I := 1 to srclen do
      begin
        if Source[I] = SearchAfter then
        begin
          result := Copy(Source, I, srclen - I + 1);
          Break;
        end;
      end;
    end;
  except
    ArrestStr := '';
    result := '';
  end;
end;

procedure TuClientApp.OnDataAvailable(Sender: TObject;
  Socket: TCustomWinSocket);
//{$I __MakeTokenID.INC}
//{$I __GetTokenID.INC}
var
  AData: AnsiString;
begin
//  if FNeedTokenID then
//  begin
//    try
//      AData := Socket.ReceiveText;
//      AData := Copy(AData, 2, Length(AData) - 2);
//      AData := __GetTokenID(AData);
//      SendCSocket(__MakeTokenID(AData));
//      FNeedTokenID := False;
//    except
//    end;
//    Exit;
//  end;
  FBufferStr := FBufferStr + Socket.ReceiveText;
  if FBufferStr <> '' then
  begin
    while Length(FBufferStr) >= 2 do
    begin
      if Pos('!', FBufferStr) <= 0 then
        Break;
      FBufferStr := ArrestStringEx(FBufferStr, '#', '!', AData);
      if AData <> '' then
        DecodeMessagePacket(AData)
      else if Pos('!', FBufferStr) = 0 then
        Break;
    end;
  end;
end;

procedure TuClientApp.OnError(Sender: TObject; Socket: TCustomWinSocket;
  ErrorEvent: TErrorEvent; var ErrorCode: Integer);
begin
  FTryConnecting := False;
  case ErrorCode of
    10038:
      ;
    10060, 10061:
      Print(mtError, uEDCode.DecodeSource('5RjFuennb8+e8gdZZLL9hZVztWw3lw=='));    //无法连接服务器
  else
    Print(mtError, uEDCode.DecodeSource('QvtH6Jr+vHQD8AEPyy5f527shJpjQw=='));    //服务器连接异常
  end;
  SetButtonEnabled(False);
  ErrorCode := 0;
end;

procedure TuClientApp.OnKernelEvent(ErrorCode: Integer);
begin
  FResManager.BoardCastIdent(ErrorCode);
  case ErrorCode of
    10016, 10017:
      Print(mtError, '发现系统速度不正常，请勿使用加速软件');
    10018, 10019:
      Print(mtError, '发现系统内运行有外挂软件');
  end;
end;

procedure TuClientApp.Open;
begin
  FTimer.Enabled := True;
end;

procedure TuClientApp.OpenURL(const Url: String);
var
  AReg: TRegistry;
  ACmdStr: String;
begin
  AReg := TRegistry.Create;
  try
    AReg.RootKey := HKEY_CLASSES_ROOT;
    AReg.OpenKey(uEDCode.DecodeSource
      ('m+i2X409qhTWTBz+y77zRuSg6+dOKTfQOv52oIBe6pRQXE3Rxm6SSSie6eBlrDyf4hoekrnE'),    //HTTP\Shell\open\command
      False);
    ACmdStr := AReg.ReadString('');
    ACmdStr := Copy(ACmdStr, Pos('"', ACmdStr) + 1, Length(ACmdStr));
    ACmdStr := Copy(ACmdStr, 1, Pos('"', ACmdStr) - 1);
    if ACmdStr <> '' then
      ShellExecute(0, 'open', pChar(ACmdStr), pChar(Url), nil, sw_shownormal)
    else
      ShellExecute(0, nil, pChar(Url), nil, nil, sw_shownormal);
  finally
    AReg.Free;
  end;
end;

procedure TuClientApp.Print(MessageType: TMessageType; const Message: String);
var
  I: Integer;
begin
  if FMainForm <> nil then
  begin
    for I := 0 to FMainForm.ComponentCount - 1 do
      if FMainForm.Components[I] is TuInfLable then
      begin
        case MessageType of
          mtNormal:
            TuInfLable(FMainForm.Components[I]).Font.Color := clLime;
          mtError:
            TuInfLable(FMainForm.Components[I]).Font.Color := clRed;
          mtWaringin:
            TuInfLable(FMainForm.Components[I]).Font.Color := clYellow;
        end;
        TuInfLable(FMainForm.Components[I]).Caption := Message;
      end;
  end;
end;

procedure TuClientApp.PrintEx(AUpdateItem: TUpdateItem; const Message: String);
begin
  Print(mtNormal, Message);
end;

procedure TuClientApp.RegisterID;
begin
  if uUseLisence then begin
    if StrToDate(uEDCode.DecodeLisence(uDateEditLisence)) < Now then begin
      Application.MessageBox
           (pChar(uEDCode.DecodeSource
           ('57PXggNvZJ2Bdpg+d55Imk4oFo8uM8rpYIEO4eoE7EBZmlPRi/8=')),
           pChar(uEDCode.DecodeSource('Lzwm4byCg5BJE0C4')), MB_OK or MB_ICONERROR);
      if FConnected then
        FClientSocket.Close;
      Exit;
    end;
  end;
  FrmNewAccount.Left := FMainForm.Left +
    (FMainForm.Width - FrmNewAccount.Width) div 2;
  FrmNewAccount.Top := FMainForm.Top +
    (FMainForm.Height - FrmNewAccount.Height) div 2;
  FrmNewAccount.Initializa(FServerInfo);
  FrmNewAccount.ShowModal;
end;

procedure TuClientApp.SendChangePassWord(const ID, OldPass, NewPass: String);
var
  Msg: TDefaultMessage;
begin
  Msg := MakeDefaultMsg(CM_CHANGEPASSWORD, 0, 0, 0, 0);
  SendCSocket(EncodeMessage (msg) + EncodeString (id + #9 + OldPass + #9 + NewPass));
end;

procedure TuClientApp.SendGetBackPassWord(const ID, NewPass, Q1, A1, Q2, A2,
  birthday: String);
var
  S: PPlatfromString;
  Msg: TDefaultMessage;
begin
//  Msg := MakeDefaultMsg(CM_GETBACKPASSWORD, 0, 0, 0, 0);
//  S := EncodeString(ID) + '/' + EncodeString(NewPass) + '/' + EncodeString(Q1) +
//    '/' + EncodeString(A1) + '/' + EncodeString(Q2) + '/' + EncodeString(A2) +
//    '/' + EncodeString(birthday);
//  SendCSocket(EncodeMessage(Msg) + S);
end;

procedure TuClientApp.SendCloseAllClient;
begin
  if FResManager <> nil then
    FResManager.BoardCastIdent(10020);
end;

procedure TuClientApp.SendCSocket(const ASendData: AnsiString);
begin
  if FClientSocket.Active then
  begin
    FClientSocket.SendText(AnsiString('#' + IntToStr(FCode) + ASendData + '!'));
    Inc(FCode);
    if FCode >= 10 then
      FCode := 1;
  end;
end;

procedure TuClientApp.SendNewAccount(AUEntry: TUserEntryInfo; AUEntryAdd: TUserEntryAddInfo);
var
  Msg: TDefaultMessage;
begin
  FNewAccount := AUEntry.LoginId;
  Msg := MakeDefaultMsg(CM_ADDNEWUSER, 0, 0, 0, 0);
  SendCSocket (EncodeMessage (msg) + EncodeBuffer(@AUEntry, sizeof(TUserEntryInfo))+ EncodeBuffer(@AUEntryAdd, sizeof(TUserEntryAddInfo)));
end;

procedure TuClientApp.SetButtonEnabled(Value: Boolean);
var
  I: Integer;
  Comp: TComponent;
begin
  for I := 0 to FMainForm.ComponentCount - 1 do
  begin
    Comp := FMainForm.Components[I];
    if Comp.ClassType = TuStartBtton then
      TuStartBtton(Comp).Enabled := Value
    else if Comp.ClassType = TuGetBackPassButton then
      TuGetBackPassButton(Comp).Enabled := Value
    else if Comp.ClassType = TuRegisterButton then
      TuRegisterButton(Comp).Enabled := Value
    else if Comp.ClassType = TuChangePassButton then
      TuChangePassButton(Comp).Enabled := Value;

  end;
end;

procedure TuClientApp.ShowMailForm(Show: Boolean);
begin
  if FMainForm <> nil then
  begin
    if Show then
      FMainForm.Show
    else
      FMainForm.Hide;
  end;
end;

procedure TuClientApp.StartGame;
var
  StartupInfo: TStartupInfoW;
  sCommandLine, AClientFile: String;
  ProcessInfo: TProcessInformation;
  AStartupInfo: TMirStartupInfo;
  AProcessHandle: THandle;
  S: TResourceStream;
  H: Integer;
  ResVerPackFileName:String;
begin
  if not FResManager.SocketStart then
  begin
    FResManager.StartSocekt;
    if not FResManager.SocketStart then
    begin
      Print(mtError,'无法建立与客户端通信的信道！启动失败。');
    end;

  end;
  H := LoadLibrary('Data\d3dx9_33.dll');
  if (H = 0) then
  begin
    try
      S := TResourceStream.Create(HInstance, 'DXDLL32', RT_RCDATA);
      try
        uDXDLLFile := ExtractFilePath(ParamStr(0)) + 'Data\d3dx9_33.dll';
        S.SaveToFile(uDXDLLFile);
      finally
        S.Free;
      end;
    except

    end;
  end;

  if H <> 0 then
  begin
    FreeLibrary(0);
  end;

  if uUseLisence then begin
    if StrToDate(uEDCode.DecodeLisence(uDateEditLisence)) < Now then begin
      Application.MessageBox
           (pChar(uEDCode.DecodeSource
           ('57PXggNvZJ2Bdpg+d55Imk4oFo8uM8rpYIEO4eoE7EBZmlPRi/8=')),
           pChar(uEDCode.DecodeSource('Lzwm4byCg5BJE0C4')), MB_OK or MB_ICONERROR);
      if FConnected then
        FClientSocket.Close;
      Exit;
    end;
  end;
  AClientFile := uEDCode.DecodeSource
    ('4Wc1uVmcxwOYfNPNe6uq9w/PXLoK+AgAXFiTf+HnzVkPsg==');      //MirClient.dat
{$IFDEF DEBUG}
  AClientFile := 'Mir2.exe';
{$ELSE}
  if FServerInfo.ClientFileName <> '' then
    AClientFile := FServerInfo.ClientFileName;
{$ENDIF}
  if FileExists(uHomePath + AClientFile) then
  begin
    if uHandles.Count >= FServerInfo.MaxClient then
    begin
      Application.MessageBox
        (pChar(uEDCode.DecodeSource('QfPUjrLrlJfXEzz5RF+RibSwy4oGx+LhLBa1R7Zi') //不可打开更多的客户端！
        ), pChar(uEDCode.DecodeSource('bgHxoNQTSRrs53CY')),  //提示
        MB_OK or MB_ICONERROR);
      Exit;
    end;
    FillChar(AStartupInfo, SizeOf(TMirStartupInfo), #0);
    AStartupInfo.sDisplayName := uDisplayName;
    AStartupInfo.sServerName := uServerName;
    AStartupInfo.sServeraddr := uServeraddr;
    AStartupInfo.nServerPort := uServerPort;
    AStartupInfo.sServerKey := uServerKey;
    AStartupInfo.boFullScreen := uFullScreen;
    AStartupInfo.boWaitVBlank := uWaitVBlank;
    AStartupInfo.bo3D := u3D;
    AStartupInfo.boMini := FServerInfo.EnabledMini;

    AStartupInfo.nScreenWidth := uSCREENWIDTH;
    AStartupInfo.nScreenHegiht := uSCREENHEIGHT;
    AStartupInfo.sResourceDir := IncludeTrailingPathDelimiter(FServerInfo.ResFolder);
    AStartupInfo.nLocalMiniPort := FResManager.Port;
    AStartupInfo.PassWordFileName := g_PasswordFileName;
    AStartupInfo.sWebSite := FServerInfo.HomeURL;
    AStartupInfo.sPaySite := FServerInfo.PayURL;

    if FResManager <> nil then
    begin
      //检查 微端管理器是否加载了微端文件。
      if not FResManager.IsResVerFileRead then
      begin
        ResVerPackFileName := uHomePath + IncludeTrailingPathDelimiter(FServerInfo.ResFolder) + 'MiniVer.db';
        FResManager.LoadResVerPackFromFile(ResVerPackFileName);
      end;

      //没有读取到微端版本配置文件。 关闭微端。
      if not FResManager.IsResVerFileRead then
      begin
        AStartupInfo.boMini := False;
      end;
    end else
    begin
      ShowMessage('微端管理器遇到故障,将以无微端模式进行');
    end;
    GetStartupInfoW(StartupInfo);
    StartupInfo.wShowWindow := SW_SHOW;
    StartupInfo.dwFlags := STARTF_USEFILLATTRIBUTE;
    StartupInfo.dwFillAttribute := FOREGROUND_INTENSITY or BACKGROUND_BLUE;
    sCommandLine := Format('%s%s %s', [uHomePath, AClientFile,
      uEDCode.EncodeSourceData(AStartupInfo, SizeOf(TMirStartupInfo))]);

    if not CreateProcessW(nil, pChar(sCommandLine), nil, nil, True, 0, nil,
      pChar(uHomePath), StartupInfo, ProcessInfo) then
      Print(mtError, uEDCode.DecodeSource('BlrFc46B/47yIdkXWRfomlBJEjcHXA==') +   //游戏启动失败.
        'Error:' + IntToStr(GetLastError()))
    else
    begin
      AProcessHandle := OpenProcess(PROCESS_ALL_ACCESS, False,
        ProcessInfo.dwProcessId);
      uHandles.Add(IntToStr(AProcessHandle));
      Application.Minimize;
      if uHandles.Count >= FServerInfo.MaxClient then
        Application.MainForm.Hide;
    end;
  end
  else
    Print(mtError,
      Format(uEDCode.DecodeSource
      ('D83Xbh7125X0ahSBeucUOny9e1ecUWYYIa/tHTMxWtuIl7ngS1ASb8FKRsz0sQ=='),  //客户端文件“%s”不存在，无法启动游戏
      [AClientFile]));
end;

procedure TuClientApp.TreeChangeNode(Sender: TObject; Node: TTreeNode);
var
  blValue: Boolean;
  Address: String;
begin
  // SetButtonEnabled(False);
  // blValue :=  (Node<>nil) and Assigned(Node.Data) and (TObject(Node.Data) is TServerItem) and (TServerItem(Node.Data).Host<>'') and (TServerItem(Node.Data).Port>0);
  // if not blValue then
  // begin
  // Print(mtWaringin, uEDCode.DecodeSource('pHxkWHQbA1+5VMYIU4qGOWetLmksQrITEwM='));
  // Exit;
  // end;
  //
  // if FTryConnecting then
  // FClientSocket.Close;
  //
  // Address :=  TServerItem(Node.Data).Host;
  // if Address = '' then
  // Exit;
  //
  // if not ISIPAddress(Address) then
  // Address :=  GetHostIP(Address);
  // TServerItem(Node.Data).Active :=  True;
  // uServerName :=  TServerItem(Node.Data).DisplayName;
  // uServerKey := TServerItem(Node.Data).Key;
  // SetNetPassWord(uServerKey);
  // uServeraddr :=  Address;
  // uServerPort :=  TServerItem(Node.Data).Port;
  // FTryConnecting  :=  True;
  // FConnected      :=  False;
  // FClientSocket.Close;
  // FClientSocket.Address  :=  Address;
  // FClientSocket.Port  :=  TServerItem(Node.Data).Port;
  // FNeedTokenID := True;
  // Print(mtWaringin, uEDCode.DecodeSource('1UTznp4LeuNig406kS+AAUD3twwKAw=='));
  // FClientSocket.Open;
end;

procedure TuClientApp.TreeMouseDown(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
var
  blValue: Boolean;
  Address: String;
  Node: TTreeNode;
begin
  Node := TreeView.GetNodeAt(X, Y);
  if Node = nil then
    Exit;

  SetButtonEnabled(False);
  blValue := (Node <> nil) and Assigned(Node.Data) and
    (TObject(Node.Data) is TServerItem) and (TServerItem(Node.Data).Host <> '')
    and (TServerItem(Node.Data).Port > 0);
  if not blValue then
  begin
    Print(mtWaringin, uEDCode.DecodeSource
      ('pHxkWHQbA1+5VMYIU4qGOWetLmksQrITEwM='));  //请选择服务器...
    Exit;
  end;

  if FTryConnecting then
    FClientSocket.Close;

  Address := TServerItem(Node.Data).Host;
  if Address = '' then
    Exit;

  if not ISIPAddress(Address) then
    Address := GetHostIP(Address);
  TServerItem(Node.Data).Active := True;
  uDisplayName := TServerItem(Node.Data).DisplayName;
  uServerName := TServerItem(Node.Data).ServerName;
  uServerKey := TServerItem(Node.Data).Key;
  if uServerKey <> '' then SetPublicKey(StrToInt(uServerKey));
  uServeraddr := Address;
  uServerPort := TServerItem(Node.Data).Port;
  FTryConnecting := True;
  FConnected := False;
  FClientSocket.Close;
  FClientSocket.Address := Address;
  FClientSocket.Port := TServerItem(Node.Data).Port;
  FNeedTokenID := True;
  Print(mtWaringin, uEDCode.DecodeSource('1UTznp4LeuNig406kS+AAUD3twwKAw=='));       //正在连接服务器
  FClientSocket.Open;
end;

procedure TuClientApp.ServerComboboxChange(Sender: TObject);
var
  blValue: Boolean;
  Address: String;
  AServerItem: TServerItem;
begin
  if FAtCheckVer then
    Exit;

  SetButtonEnabled(False);

  blValue := False;
  AServerItem := nil;
  if TuServerCombobox(Sender).ItemIndex <> -1 then
    AServerItem := TServerItem(TuServerCombobox(Sender).Items.Objects
      [TuServerCombobox(Sender).ItemIndex]);
  blValue := (AServerItem <> nil) and (AServerItem.Host <> '') and
    (AServerItem.Port > 0);
  if not blValue then
  begin
    Print(mtWaringin, uEDCode.DecodeSource
      ('csTh6zOVfTD6D+49BY26wOWb8mv+42+1XFM='));     //请选择服务器...
    Exit;
  end;

  if FTryConnecting then
    FClientSocket.Close;

  Address := AServerItem.Host;
  if Address = '' then
    Exit;

  if not ISIPAddress(Address) then
    Address := GetHostIP(Address);
  AServerItem.Active := True;
  uDisplayName := AServerItem.DisplayName;
  uServerName := AServerItem.ServerName;
  uServerKey := AServerItem.Key;
  if uServerKey <> '' then SetPublicKey(StrToInt(uServerKey));
  uServeraddr := Address;
  uServerPort := AServerItem.Port;
  FTryConnecting := True;
  FConnected := False;
  FClientSocket.Close;
  FClientSocket.Address := Address;
  FClientSocket.Port := AServerItem.Port;
  FNeedTokenID := True;
  Print(mtWaringin, uEDCode.DecodeSource('CxZ+peh8VRK43ZKz7wmJfToIw0qkiw=='));    //正在连接服务器
  FClientSocket.Open;
end;

function TuClientApp.UpdateMySelf: Boolean;

  procedure CreateAndExecBatFile(const SelfName, OldExeName, ExeName,
    UpdateDir: String; SourceFiles, DestFiles: TStrings);
  var
    I: Integer;
    BatchFile: TextFile;
    BatchFileName: string;
    ProcessInfo: TProcessInformation;
    StartupInfo: TStartupInfo;
  begin
    BatchFileName := IOUtils.TPath.GetTempPath + uCommon.MakeNewGUID32 + '.bat';
    AssignFile(BatchFile, BatchFileName);
    Rewrite(BatchFile);

    if SelfName <> '' then
    begin
      WriteLn(BatchFile, ':DelMySelf');
      WriteLn(BatchFile, 'del "' + SelfName + '"');
      WriteLn(BatchFile, 'if exist "' + SelfName + '" goto DelMySelf');
    end;

    if OldExeName <> '' then
    begin
      WriteLn(BatchFile, ':DelMyOldExe');
      WriteLn(BatchFile, 'del "' + OldExeName + '"');
      WriteLn(BatchFile, 'if exist "' + OldExeName + '" goto DelMyOldExe');
    end;

    // 依次删除原始文件
    for I := 0 to DestFiles.Count - 1 do
    begin
      WriteLn(BatchFile, ':DeleteDest' + IntToStr(I));
      WriteLn(BatchFile, 'del "' + DestFiles[I] + '"');
      WriteLn(BatchFile, 'if exist "' + DestFiles[I] + '" goto DeleteDest' +
        IntToStr(I));
    end;
    // 移动文件
    for I := 0 to SourceFiles.Count - 1 do
    begin
      WriteLn(BatchFile, ':moveFile' + IntToStr(I));
      WriteLn(BatchFile, 'move "' + SourceFiles[I] + '" "' + DestFiles
        [I] + '"');
      WriteLn(BatchFile, 'if exist "' + SourceFiles[I] + '" goto moveFile' +
        IntToStr(I));
    end;
    if (UpdateDir <> '') and (IncludeTrailingPathDelimiter(UpdateDir) <>
      IncludeTrailingPathDelimiter(IOUtils.TPath.GetTempPath)) then
      WriteLn(BatchFile, 'rd/s/q "' + UpdateDir + '"'); // h除更新文件A
    WriteLn(BatchFile, '"' + ExeName + '"'); // 再次启动自己
    WriteLn(BatchFile, 'del %0');
    CloseFile(BatchFile);

    FillChar(StartupInfo, SizeOf(StartupInfo), $00);
    StartupInfo.dwFlags := STARTF_USESHOWWINDOW;
    StartupInfo.wShowWindow := SW_HIDE;
    if CreateProcess(nil, PWideChar(BatchFileName), nil, nil, False,
      IDLE_PRIORITY_CLASS, nil, nil, StartupInfo, ProcessInfo) then
    begin
      CloseHandle(ProcessInfo.hThread);
      CloseHandle(ProcessInfo.hProcess);
    end;
  end;

var
  AUpdateItem: TUpdateItem;
  ATool: TUpdateTool;
  ASourceFiles, ADestFiles: TStrings;
  I: Integer;
  ASourceFile: String;
begin
  result := False;
  if FServerInfo.LoginVerURL <> '' then
  begin
    Print(mtNormal, uEDCode.DecodeSource
      ('8FSAvNt7L2zxmYSbifRRadW09/E14YQWOC3X0Q=='));    //检查登陆器版本...
    AUpdateItem := TUpdateItem.Create(nil);
    try
      AUpdateItem.Url := FServerInfo.LoginVerURL;
      AUpdateItem.Zip := FServerInfo.LoginVerZip;
      AUpdateItem.DownKind := FServerInfo.LoginVerKind;
      AUpdateItem.Path := '\';
      AUpdateItem.FileName := FServerInfo.LoginVerFile;
      AUpdateItem.Code := FServerInfo.LoginVerMD5;
      ATool := TUpdateTool.CreateTool(AUpdateItem);
      if ATool <> nil then
      begin
        ASourceFiles := TStringList.Create;
        ADestFiles := TStringList.Create;
        try
          ATool.HomePath := SysUtils.IncludeTrailingPathDelimiter(uHomePath);
          ATool.RARDLLFile := uRARDLLFile;
          ATool.OnProgress := DoProgress;
          ATool.OnPrint := PrintEx;
          ATool.OnCheckNeedUpdateEvent := DoCheckMySelfNeedUpdate;
          ATool.DeleteTempFile := False;
          if ATool.CheckNeedUpdate then
          begin
            try
              Print(mtNormal,
                uEDCode.DecodeSource
                ('Mf5hfDxGGblftHEU8GvC7xvA4pztjF+e2TzmDg=='));    //开始下载登陆器...
              ATool.Prepare;
              if ATool.DoDownload then
              begin
                ATool.ExtractFiles(ASourceFiles);
                if not AUpdateItem.Zip then
                begin
                  ADestFiles.Add(ATool.HomePath + AUpdateItem.FileName);
                end
                else
                begin
                  for I := 0 to ASourceFiles.Count - 1 do
                  begin
                    ASourceFile := StringReplace(ASourceFiles[I],
                      ATool.ExtractPath, '', []);
                    ADestFiles.Add(ATool.HomePath + ASourceFile);
                  end;
                end;
                Print(mtNormal,
                  uEDCode.DecodeSource
                  ('nv3Y+HI5bHIxA8qW3oW7KtL+BGKqX8gbJb1IyHo7U5dpmDegaWjOFA=='));    //登陆器更新完成，请重新打开登陆器
                CreateAndExecBatFile(Application.ExeName,
                  ATool.HomePath + ExtractFileName(Application.ExeName),
                  ATool.HomePath + AUpdateItem.FileName, ATool.ExtractPath,
                  ASourceFiles, ADestFiles);
                result := True;
                boNeedSuicide := False;
              end;
            except
              on E: Exception do
                uLog.TLogger.AddLog
                  (uEDCode.DecodeSource
                  ('x/br6AWRLn5hXPzNhwbLYQPsAa4rkEbgpI8NHakzFukdL05Cp10=') +
                  E.Message); // 登录器自我更新报错,错误信息:
            end;
          end;
        finally
          ATool.Free;
          ASourceFiles.Free;
          ADestFiles.Free;
        end;
      end;
    finally
      AUpdateItem.Free;
    end;
  end;
end;

procedure TuClientApp.UpdateSysFiles;
var
  FUpdateManager: TUpdateManager;
  I: Integer;
  Comp: TComponent;
begin
  FUpdateManager := TUpdateManager.Create(FServerInfo);
  try
    FUpdateManager.HomePath := uHomePath;
    for I := 0 to FMainForm.ComponentCount - 1 do
    begin
      Comp := FMainForm.Components[I];
      if Comp.ClassType = TuAllProgressBar then
      begin
        TuAllProgressBar(Comp).Min := 0;
        TuAllProgressBar(Comp).Max := FServerInfo.SysFileCount;
        TuAllProgressBar(Comp).Position := 0;
      end;
    end;
    FUpdateManager.RARDLLFile := uRARDLLFile;
    FUpdateManager.OnFileBegin := DoFileBegin;
    FUpdateManager.OnFileEnd := DoFileEnd;
    FUpdateManager.OnPrint := Self.PrintEx;
    FUpdateManager.OnProgress := Self.DoProgress;
    FUpdateManager.OnBeginUpdateItem := Self.DoBegin;
    FUpdateManager.OnEndUpdateItem := Self.DoEnd;
    try
      FUpdateManager.DownloadBy(dtSystem);
      Print(mtNormal, uEDCode.DecodeSource
        ('/Bm6tisYX8fVIs2869PlHVzPTdzVCRIeicwNASmmPGrBFPKjB4U='));  //关键更新已完成,可以进入游戏了
    except
      on E: Exception do
      begin
        uLog.TLogger.AddLog
          (uEDCode.DecodeSource
          ('TZVGYalKnJzClvN6I99T9/3RIq7E4KytzG3Qu3W9dcDhfekO') + E.Message);
        // 更新必要文件报错,错误信息:
        Print(mtError,
          uEDCode.DecodeSource('inFK3/hbDOOFvZgBySuCYdMT/mZM9g=='));     //更新异常...
      end;
    end;
  finally
    FreeAndNil(FUpdateManager);
  end;
end;

procedure TuClientApp.UpdateBgFiles;
var
  FUpdateManager: TUpdateManager;
  I: Integer;
  Comp: TComponent;
begin
  FUpdateManager := TUpdateManager.Create(FServerInfo);
  try
    FUpdateManager.HomePath := uHomePath;
    for I := 0 to FMainForm.ComponentCount - 1 do
    begin
      Comp := FMainForm.Components[I];
      if Comp.ClassType = TuAllProgressBar then
      begin
        TuAllProgressBar(Comp).Min := 0;
        TuAllProgressBar(Comp).Max := FServerInfo.BgFileCount;
        TuAllProgressBar(Comp).Position := 0;
      end;
    end;
    FUpdateManager.RARDLLFile := uRARDLLFile;
    FUpdateManager.OnFileBegin := DoFileBegin;
    FUpdateManager.OnFileEnd := DoFileEnd;
    FUpdateManager.OnPrint := Self.PrintEx;
    FUpdateManager.OnProgress := Self.DoProgress;
    FUpdateManager.OnBeginUpdateItem := Self.DoBegin;
    FUpdateManager.OnEndUpdateItem := Self.DoEnd;
    try
      FUpdateManager.DownloadBy(dtBackground);
      Print(mtNormal, uEDCode.DecodeSource
        ('Q2u7O9Au6AV0gcTYI/WRmqmxrDDGbeuBeUwFPIiJQjp8Vw=='));    //所有后台文件更新完成...
    except
      Print(mtError, uEDCode.DecodeSource('yBcnzPCmWGTQE+MIL9Aaxp2DY3NK+Q=='));   //更新异常...
    end;
  finally
    FreeAndNil(FUpdateManager);
  end;
end;

procedure TuClientApp.UpdateFiles;
var
  FUpdateManager: TUpdateManager;
  I: Integer;
  Comp: TComponent;
begin
  FUpdateManager := TUpdateManager.Create(FServerInfo);
  try
    FUpdateManager.HomePath := uHomePath;
    for I := 0 to FMainForm.ComponentCount - 1 do
    begin
      Comp := FMainForm.Components[I];
      if Comp.ClassType = TuAllProgressBar then
      begin
        TuAllProgressBar(Comp).Min := 0;
        TuAllProgressBar(Comp).Max := FServerInfo.FileCount;
        TuAllProgressBar(Comp).Position := 0;
      end;
    end;
    FUpdateManager.RARDLLFile := uRARDLLFile;
    FUpdateManager.OnFileBegin := DoFileBegin;
    FUpdateManager.OnFileEnd := DoFileEnd;
    FUpdateManager.OnPrint := Self.PrintEx;
    FUpdateManager.OnProgress := Self.DoProgress;
    FUpdateManager.OnBeginUpdateItem := Self.DoBegin;
    FUpdateManager.OnEndUpdateItem := Self.DoEnd;
    try
      FUpdateManager.Download;
      Print(mtNormal, uEDCode.DecodeSource
        ('KWYTf5MJ+7B4CHBhCf9J1CexMtrdTCbwXOdhlKZy7Gc='));  //更新完成,可以进入游戏了
    except
      Print(mtError, uEDCode.DecodeSource('Nkz0l8ucNEG+GTpDdAyNIvVyOf6KGQ=='));   //更新异常...
    end;
  finally
    FreeAndNil(FUpdateManager);
  end;
end;

procedure TuClientApp.DoFileBegin(Sender: TObject);
var
  I: Integer;
  Comp: TComponent;
begin
  for I := 0 to FMainForm.ComponentCount - 1 do
  begin
    Comp := FMainForm.Components[I];
    if Comp.ClassType = TuCurProgressBar then
    begin
      TuCurProgressBar(Comp).Min := 0;
      TuCurProgressBar(Comp).Max := 100;
      TuCurProgressBar(Comp).Position := 0;
    end;
  end;
end;

procedure TuClientApp.DoFileEnd(Sender: TObject);
var
  I: Integer;
  Comp: TComponent;
begin
  for I := 0 to FMainForm.ComponentCount - 1 do
  begin
    Comp := FMainForm.Components[I];
    if Comp.ClassType = TuCurProgressBar then
      TuCurProgressBar(Comp).Position := TuCurProgressBar(Comp).Max
    else if Comp.ClassType = TuAllProgressBar then
      TuAllProgressBar(Comp).Position := TuAllProgressBar(Comp).Position + 1;
  end;
end;

procedure TuClientApp.DoProgress(UpdateItem: TUpdateItem;
  AllSize, APosition: Integer);
var
  I: Integer;
  Comp: TComponent;
begin
  for I := 0 to FMainForm.ComponentCount - 1 do
  begin
    Comp := FMainForm.Components[I];
    if Comp.ClassType = TuCurProgressBar then
    begin
      TuCurProgressBar(Comp).Min := 0;
      TuCurProgressBar(Comp).Max := AllSize;
      TuCurProgressBar(Comp).Position := APosition;
    end;
  end;
end;

procedure TuClientApp.DoTimer(Sender: TObject);
var
  I: Integer;
  APosition: Cardinal;
  AExecutableStructure: TuExecutableStructure;
  AFile: TFileStream;
  ARequest:PTMiniResRequest;
//  m_DataList: TStringList;
begin
  FTimer.Enabled := False;
  if CheckServerInfo then
  begin
    if UpdateMySelf then
    begin
      Application.Terminate;
    end
    else
    begin
{$IFDEF RELEASE}
      AExecutableStructure := LoadExecutableStructure;
      APosition := AExecutableStructure.Offset +
        AExecutableStructure.SkinDataLen;
      AFile := TFileStream.Create(Application.ExeName, fmOpenRead or fmShareDenyNone);

      //AFile :=  TFileStream.Create('D:\热血传奇\DebugEmResource.exe', fmOpenRead or fmShareDenyNone);
      try
        AFile.Position := APosition;
        if AFile.Size - AFile.Position > SizeOf(TuExecutableStructure) + 16 then
        begin
          Print(mtNormal,
            uEDCode.DecodeSource('fy8uS3plT3+o3jtsc1pLsaCob+eaidJgZyfBSDUa'));     //开始释放必备文件...
          try
            ExtractEmbbedResources(AFile);
          except
            on E: Exception do
              uLog.TLogger.AddLog
                (uEDCode.DecodeSource
                ('VFqZeRlfXg49lzXD2m0Q0avgiIZoaHxE7Dfm9y/n0DPqW/CL') +
                E.Message); // 释放内嵌资源报错,错误信息:
          end;
          Print(mtNormal,
            uEDCode.DecodeSource('xYyo9qOYUkB5B0HIhvrUkmLLSsEGUFXS13dYUIwJ'));   //释放必备文件完成...
        end;
      finally
        AFile.Free;
      end;
{$ENDIF}
      boCreateShortCut := FServerInfo.CreateShortCut;
      if ExtractFilePath(Application.ExeName) = uHomePath then
      begin
        if boCreateShortCut then
          CreateLinkToDesktop(Application.ExeName, Application.Title);
      end;
      for I := 0 to FServerInfo.FileCount - 1 do
      begin
        if FServerInfo.UpdateItems[I].Enable then
        begin
          // 必要更新
          if FServerInfo.UpdateItems[I].DownType = dtDownIfNeed then
            FileDownManager.AddFile(FServerInfo.UpdateItems[I].FileName,
              FServerInfo.UpdateItems[I].Url, FServerInfo.UpdateItems[I].Path,
              False, FServerInfo.UpdateItems[I].Zip,
              FServerInfo.UpdateItems[I].DownKind);
        end;
      end;

      if FServerInfo.SysFileCount > 0 then
        UpdateSysFiles;
      if FServerInfo.BgFileCount > 0 then
        UpdateBgFiles;
      FMiniTimer.Enabled := FServerInfo.EnabledMini;
      DMKernelMonitor.Speed := True;
      FAtCheckVer := False;
    end;
  end
  else
    FAtCheckVer := False;

//  m_DataList := TStringList.Create;
//  m_DataList.LoadFromFile('.\Data\WilInfo.txt');
//  for I := 0 to m_DataList.Count - 1 do begin
//    if FileExists(GetCurrentDir + '\' + m_DataList[I]) then Continue;
//    New(ARequest);
//    ARequest._Type := 0;
//    ARequest.FileName := m_DataList[I];
//    ARequest.Index := 0;
//    ARequest.Important := True;
//    ARequest.FailCount := 0;
//    ARequest.Data := 0;
//    Self.FResManager.m_RecvMsgList.Append(ARequest);
//  end;
//
//  m_DataList.Free;
end;

procedure TuClientApp.ExtractEmbbedResources(F: TStream);

  function ISValidateFileExt(const AFileName: String): Boolean;
  var
    AExt: String;
  begin
    AExt := UpperCase(ExtractFileExt(AFileName));
    result := (AExt = '.DATA') or (AExt <> '.DAT') or (AExt <> '.WZL') or
      (AExt <> '.WZX') or (AExt <> '.WIL') or (AExt <> '.WIX') or
      (AExt <> '.MP3') or (AExt <> '.WAV') or (AExt <> '.MAP') or
      (AExt <> '.LST') or (AExt <> '.TXT') or (AExt <> '.HTML');
  end;
var
  AFileItem: TEmbeddedFile;
  ATempFileName,FileName: String;
  ANewFile: TFileStream;
  APath:String;
  Extract:Boolean;
  ATempFileStream:TFileStream;
begin
  while F.Position < F.Size - (SizeOf(TuExecutableStructure) + 16) do
  begin
    FillChar(AFileItem, SizeOf(TEmbeddedFile), #0);
    F.Read(AFileItem, SizeOf(TEmbeddedFile));
    if AFileItem.Size > 0 then
    begin
      Extract := True;
      APath := AFileItem.Path;
      if (APath <> '') and (APath[1] = '$') then
      begin
        Delete(APath, 1, 1);
        APath := IncludeTrailingPathDelimiter(FServerInfo.ResFolder) + APath;
      end;

      APath := uHomePath + IncludeTrailingPathDelimiter(APath);
      APath := StringReplace(APath, '\\', '\', [rfReplaceAll]);
      if not DirectoryExists(APath) then
        ForceDirectories(APath);

      FileName := APath + ExtractFileName(AFileItem.FileName);
      if FileExists(FileName) then
         Extract := False;
      if AFileItem.Replace then
        Extract := True;

      try
        if Extract then
        begin
         //如果要释放的目标文件存在 则删除目标文件
          if FileExists(FileName) then
          begin
            DeleteFile(FileName);
          end;
          //检查是否删除成功
          if not FileExists(FileName) then
          begin
            if not AFileItem.ZLib then
            begin
              ANewFile := TFileStream.Create(FileName,fmCreate or fmShareDenyNone);
              try
                ANewFile.CopyFrom(F, AFileItem.Size);
              finally
                ANewFile.Free;
              end;
            end else
            begin
              ATempFileName := IOUtils.TPath.GetTempFileName;
              try
                ATempFileStream := TFileStream.Create(ATempFileName,fmCreate or fmShareDenyNone);
                try
                  ATempFileStream.CopyFrom(F, AFileItem.Size);
                  ATempFileStream.Position := 0;
                  ANewFile := TFileStream.Create(FileName,fmCreate or fmShareDenyNone);
                  ZDecompressStream(ATempFileStream,ANewFile);
                finally
                  ANewFile.Free;
                  ATempFileStream.Free;
                end;
              finally
                if FileExists(ATempFileName) then
                  IOUtils.TFile.Delete(ATempFileName);
              end;
            end;
          end else
          begin
            uLog.TLogger.AddLog('释放内嵌资源错误:文件被占用无法操作。' + AFileItem.FileName); // 释放内嵌资源报错,错误信息:
          end;

        end;
      except
        on E: Exception do
            uLog.TLogger.AddLog
              (uEDCode.DecodeSource
              ('onkfZLVICBEgj9XCaGgJqpDhr5h/y35k/4wFeGo2OoO5CiKv') + E.Message +
              '(' + AFileItem.FileName + ')'); // 释放内嵌资源报错,错误信息:
      end;
    end;
  end;
end;

procedure TuClientApp.DoMiniDownTimer(Sender: TObject);
begin

end;

procedure TuClientApp.DoMiniTimer(Sender: TObject);
var
  AServerAddr, AServerPort: String;
begin

end;

function TuClientApp.GetTitle: String;
begin
  Result := LoadExecutableStructure.Title;
end;

procedure TuClientApp.DoBegin(UpdateItem: TUpdateItem; AllSize: Integer);
var
  I: Integer;
  Comp: TComponent;
begin
  for I := 0 to FMainForm.ComponentCount - 1 do
  begin
    Comp := FMainForm.Components[I];
    if Comp.ClassType = TuCurProgressBar then
    begin
      TuCurProgressBar(Comp).Min := 0;
      TuCurProgressBar(Comp).Max := AllSize;
    end;
  end;
end;

procedure TuClientApp.DoCheckMySelfNeedUpdate(UpdateItem: TUpdateItem;
  var Need: Boolean);
begin
  Need := UpdateItem.Code <> uMD5.MD5File(Application.ExeName);
end;

procedure TuClientApp.DoEnd(UpdateItem: TUpdateItem; AllSize: Integer);
var
  I: Integer;
  Comp: TComponent;
begin
  for I := 0 to FMainForm.ComponentCount - 1 do
  begin
    Comp := FMainForm.Components[I];
    if Comp.ClassType = TuAllProgressBar then
      TuAllProgressBar(Comp).Position := TuAllProgressBar(Comp).Position + 1;
  end;
end;

procedure TuClientApp.DecodeMessagePacket(const ADatablock: AnsiString);
var
  AHead, ABody: string;
  Msg: TDefaultMessage;
begin
  if ADatablock[1] = '+' then
    Exit;
  if Length(ADatablock) < DEFBLOCKSIZE then
    Exit;
  AHead := Copy(ADatablock, 1, DEFBLOCKSIZE);
  ABody := Copy(ADatablock, DEFBLOCKSIZE + 1, Length(ADatablock) -
    DEFBLOCKSIZE);
  Msg := DecodeMessage(AHead);
  case Msg.Ident of
    SM_SEND_PUBLICKEY:
      begin
         SetPublicKey( msg.Param xor msg.Tag );
      end;
    SM_NEWID_SUCCESS:
      begin
        Application.MessageBox
          (pChar(uEDCode.DecodeSource('s/Krsg/y5kV1GuCAUMpsblbIPg6IBFiqkTc=') +      //您的帐号创建成功。
          #13 + uEDCode.DecodeSource
          ('eHbPG/6lCwYQDXrss3slBqYWV95eLw6jNF89/WN3pO4+Mg==') + #13 +       //请妥善保管您的帐号和密码，
          uEDCode.DecodeSource
          ('GVsVY3o350DMxRe4TdT9ZbDQavYOWXJ9vfhuyNez+d8jdrr2OoH0FLu6Ow6kjVfNVgemTTeH')  //并且不要因任何原因把帐号和密码告诉任何其他人。
          ), pChar(uEDCode.DecodeSource('Zmp/dIlRTu1YuZ5MYwPAWA==')), MB_OK);     //提示信息
        FrmNewAccount.Close;
      end;
    SM_NEWID_FAIL:
      begin
        case Msg.Recog of
          0:
            begin
              Application.MessageBox
                (pChar(uEDCode.DecodeSource('702M5aET43qb1llW07sU3A==') +
                FNewAccount + uEDCode.DecodeSource
                ('BERuRCWFmKJBOrEmKNCDgIn3czCp+Aw0JSuMWpxsya77Jw==') + #13 +
                uEDCode.DecodeSource('tfBzgZI5WNOJVV9p7Lgee8gT2craQt9EHt9+MFm2')
                ), pChar(uEDCode.DecodeSource
                ('0hokG7tk2I9oajkrVaEZEw==')), MB_OK);
            end;
          1:
            begin
              Application.MessageBox
                (pChar(uEDCode.DecodeSource
                ('6+Tgoj7qUqtwbUUQuUilEVCmZlIyUlwYX7WH5ESz2Gzs3jyYfeQRVw==')),
                pChar(uEDCode.DecodeSource('UNLfM/oJq2DdKWBlYQO90w==')), MB_OK);
            end;
          -2:
            Application.MessageBox
              (pChar(uEDCode.DecodeSource
              ('Eag9UHy8Jmz9VSij9WCO21d/HNQs70SBLPjTKw==')),
              pChar(uEDCode.DecodeSource('/vkbj22O5boBLHmxZQ6VzA==')), MB_OK);
        else
          Application.MessageBox
            (pChar(uEDCode.DecodeSource
            ('p/PF8WYG0mPpNrAt80svekiRZ1JmWyzZsW4et7orl/fNAotX18Ea7Wwy+q6vAa8GsWYIc+fhYh+5UnWiEYJto5hBHf0Ffw==')
            + IntToStr(Msg.Recog)),
            pChar(uEDCode.DecodeSource('XK3eF/Gup7JerjeZUsMifA==')), MB_OK);
        end;
        FrmNewAccount.sbOK.Enabled := True;
        Exit;
      end;
    SM_CHGPASSWD_SUCCESS:
      begin
        FRMChangePWD.Close;
        Application.MessageBox
          (pChar(DecodeSource('LR2x4HaEKOaCM6+QUGHA31rmxxyl2A==')),
          pChar(uEDCode.DecodeSource('6nPMswWj6fRLMKwUVnhHNQ==')), MB_OK);
        Exit;
      end;
    SM_CHGPASSWD_FAIL:
      begin
        FRMChangePWD.btnOK.Enabled := True;
        case Msg.Recog of
          0:
            Application.MessageBox
              (pChar(uEDCode.DecodeSource
              ('I3aj9708GR/AVzGUft8lndv4sHrW/H6NskWkIkrq')),
              pChar(uEDCode.DecodeSource('KCG2xZu0D3r3sTs6pzQ7+Q==')), MB_OK);
          -1:
            Application.MessageBox
              (pChar(uEDCode.DecodeSource
              ('Cay+R1gf/jKNFyeOWDD87eiXRUrXr3RvMm/E+oDd')),
              pChar(uEDCode.DecodeSource('lrQZAb58PFsyrMVxGqZ1uA==')), MB_OK);
          -2:
            Application.MessageBox
              (pChar(uEDCode.DecodeSource('XyhpleIriHO9lLs+ME6ukeVgPSH6dA==')),
              pChar(uEDCode.DecodeSource('tDnOIdfx9peRVg2PdjoxnQ==')), MB_OK);
        else
          Application.MessageBox
            (pChar(uEDCode.DecodeSource
            ('pXCkRWPX1XoIAKaAdYhQz2sTjYiFNKV8Xo4JJQJYiYKmcg==')),
            pChar(uEDCode.DecodeSource('AqjSXSeHX9hXnb20VsLzqQ==')), MB_OK);
        end;
        Exit;
      end;
//    SM_GETBACKPASSWD_SUCCESS:
//      begin
//        frmGetBackPwd.Close;
//        Application.MessageBox
//          (pChar(uEDCode.DecodeSource('W4aKYE3fZuVuXFv/kAV9aLOJrQioSw==')),
//          pChar(uEDCode.DecodeSource('AMP35wBOwhfvcIKSfeDDYQ==')), MB_OK);
//        Exit;
//      end;
//    SM_GETBACKPASSWD_FAIL:
//      begin
//        frmGetBackPwd.btnOK.Enabled := True;
//        case Msg.Recog of
//          0:
//            Application.MessageBox
//              (pChar(uEDCode.DecodeSource
//              ('AUdKL1UBqNxKj9ilbWBDPKB58DHlsfVDglNu/iAe')),
//              pChar(uEDCode.DecodeSource('LvrcyOuA3B1Cv/wpBd/u1Q==')),
//              MB_OK + MB_ICONERROR);
//          -1:
//            Application.MessageBox
//              (pChar(uEDCode.DecodeSource
//              ('F8y6MxH3bpKFdPsBheUbmW1eZujQ5xfpmdZqgw==')),
//              pChar(uEDCode.DecodeSource('DEl4YApTFFAArlGwK0EC9Q==')),
//              MB_OK + MB_ICONERROR);
//          -2:
//            Application.MessageBox
//              (pChar(uEDCode.DecodeSource
//              ('HctdtXzhAmpYXHuP0fbMB41MRvjL4MjJPgc=') + #13 +
//              uEDCode.DecodeSource
//              ('GhchPeJADdf/TNCc/1v5rYw8s/HP5LrjyKNCtorwJDFj09bX/3w=')),
//              pChar(uEDCode.DecodeSource('k/VoU8jiZ9ZRKE9gRTZGoA==')),
//              MB_OK + MB_ICONERROR);
//          -3:
//            Application.MessageBox
//              (pChar(uEDCode.DecodeSource
//              ('2BfWTW06JqCbgxqKoQF46LOhH7pJlY0ZkEgtEA==')),
//              pChar(uEDCode.DecodeSource('+Vgu5XtsIhuvdaXZi+HD4g==')),
//              MB_OK + MB_ICONERROR);
//        else
//          Application.MessageBox
//            (pChar(uEDCode.DecodeSource('xio2/KGmwPm5V5WXALnVokXF')),
//            pChar(uEDCode.DecodeSource('z7774Z/Dnxug/LVg/ulblA==')),
//            MB_OK + MB_ICONERROR);
//        end;
//        Exit;
//      end;
  end;
end;

procedure ExtractRARDll;
var
  S: TResourceStream;
begin
  try
    S := TResourceStream.Create(HInstance, 'UNRAR', RT_RCDATA);
    try
      uRARDLLFile := TPath.GetTempFileName;
      S.SaveToFile(uRARDLLFile);
    finally
      S.Free;
    end;
  except
    on E: Exception do
    begin
      Application.MessageBox
        (pChar(uEDCode.DecodeSource
        ('ZDtkH8XO46Ke0C7tunAtS3JDa1YyfwOQS49yf16PxCKni3It')),   //启动登陆器失败，登陆器已损坏
        pChar(uEDCode.DecodeSource('lQxJf8XqibsIv7VR')), MB_OK + MB_ICONERROR);  //提示
      Application.Terminate;
    end;
  end;
end;

{ TFileDownManager }

procedure TFileDownManager.AddFile(const AName, AUrl, APath: String;
  MiniSrv: Boolean; Zip: Boolean; ADownKind: TupDownKind);
var
  AFileItem: TFileItem;
begin
  if not TryGet(UpperCase(AName), AFileItem) then
  begin
    AFileItem := TFileItem.Create;
    AFileItem.FileName := UpperCase(AName);
    AFileItem.State := ftNormal;
    AFileItem.MiniServer := MiniSrv;
    AFileItem.Url := AUrl;
    AFileItem.Path := APath;
    AFileItem.Zip := Zip;
    AFileItem.DownKind := ADownKind;
    FFiles.AddOrSetValue(AFileItem.FileName, AFileItem);
  end;
end;

constructor TFileDownManager.Create;
begin
  FFiles := TObjectDictionary<String, TFileItem>.Create([doOwnsValues]);
end;

destructor TFileDownManager.Destroy;
begin
  FreeAndNil(FFiles);
  inherited;
end;

function TFileDownManager.TryGet(const AName: String;
  out AFileItem: TFileItem): Boolean;
begin
  result := FFiles.TryGetValue(UpperCase(AName), AFileItem);
end;

{ TFileItem }

procedure TFileItem.BeginDown;
begin
  State := ftDowning;
end;

procedure TFileItem.EndDown;
begin
  State := ftDowned;
end;

{ TResourceRequest }

constructor TResourceRequest.Create(AResourcesClient: TMiniResourcesClient);
begin
  inherited Create(nil);
  Client := AResourcesClient.FClient;
  FFileList := TStringList.Create;
  FClient := AResourcesClient;
  OnDataReceived := DoDataReceived;
  OnBeginRequest := DoBeginRequest;
  OnResponseAbort := DoResponseAbort;
  FTempFileName := IOUtils.TPath.GetTempFileName;
  FFile := TFileStream.Create(FTempFileName, fmCreate);
end;

destructor TResourceRequest.Destroy;
begin
  if FFile <> nil then
    FreeAndNil(FFile);
  FreeAndNil(FFileList);
  if TFile.Exists(FTempFileName) then
    TFile.Delete(FTempFileName);
  inherited;
end;

procedure TResourceRequest.DoBeginRequest(Sender: TRtcConnection);
begin
  TRtcDataClient(Sender).WriteHeader;
end;

procedure TResourceRequest.DoResponseAbort(Sender: TRtcConnection);
begin
  if FType in [0, 1] then
    RebuildMiniRequest(FFileName, FType, FImageIndex, False);
end;

procedure TResourceRequest.DoDataReceived(Sender: TRtcConnection);
var
  ABytes: RtcByteArray;
begin
  with TRtcDataClient(Sender) do
  begin
    if not inMainThread then
      Sync(DoDataReceived)
    else
    begin
      ABytes := Sender.ReadEx;
      FFile.WriteBuffer(ABytes[0], Length(ABytes));
      if Response.Done then
      begin
        case FType of
          0:
            ExecuteImage(Response);
          1:
            begin
              FreeAndNil(FFile);
              ExecuteRar(Response);
            end;
          2:
            begin
              FFile.Position := 0;
              //if Response.StatusCode = 200 then

            end;
        end;
        FClient.Remove(Self);
      end;
    end;
  end;
end;

procedure TResourceRequest.DoRARListFile(Sender: TObject;
  const FileInformation: TRARFileItem);
begin
  FFileList.Add(FileInformation.FileNameW);
end;

procedure TResourceRequest.RebuildMiniRequest(const AFileName: String;
  AType: Byte; AImageIndex: Integer; AImportant: Boolean);
var
  AMiniRequest: pTMiniResRequest;
begin
  New(AMiniRequest);
  FillChar(AMiniRequest^, SizeOf(TMiniResRequest), #0);
  AMiniRequest._Type := AType;
  AMiniRequest.Important := AImportant;
  AMiniRequest.FileName := AFileName;
  AMiniRequest.Index := AImageIndex;
  FClient.FRequests.LockList.Add(AMiniRequest);
  FClient.FRequests.UnlockList;
end;

procedure TResourceRequest.ExecuteImage(AResponse: TRtcClientResponse);
var
  AImages: TWMImages;
  ABuff, ZBuf: PAnsiChar;
  ZBufSize, APosition: Integer;
begin
  if AResponse.StatusCode = 200 then
  begin
    if ImagesManager.TryGet(UpperCase(FFileName), AImages) then
    begin
      try
        if FFile.Size > 0 then
        begin
          FFile.Position := 0;
          GetMem(ABuff, FFile.Size);
          try
            FFile.ReadBuffer(ABuff^, FFile.Size);
            uCommon.DecompressBufZ(ABuff, FFile.Size, 0, ZBuf, ZBufSize);
            FFile.Size := 0;
            FFile.WriteBuffer(ZBuf^, ZBufSize);
            FFile.Position := 0;
            ImagesManager.WriteImage(FFileName, FImageIndex, FFile, APosition);
            if ImagesManager.TryGet(UpperCase(FFileName), AImages) then
              AImages.EndDownload(FImageIndex);
           // uClientApp.SendImageLoaded(FFileName, FImageIndex, APosition);
          finally
            FreeMem(ABuff);
            FreeMem(ZBuf);
          end;
        end
        else
        begin
          if ImagesManager.TryGet(UpperCase(FFileName), AImages) then
            AImages.EndDownload(FImageIndex);
        end;
      except
        on E: Exception do
        begin
          AImages.ResetDownload(FImageIndex);
          RebuildMiniRequest(FFileName, FType, FImageIndex, False);
        end;
      end;
    end;
  end
  else
    RebuildMiniRequest(FFileName, FType, FImageIndex, False);
end;

procedure TResourceRequest.ExecuteRar(AResponse: TRtcClientResponse);
var
  ARar: TRar;
  I: Integer;
  AExtractPath: String;
begin
  ARar := TRar.Create(nil);
  ARar.DllName := uRARDLLFile;
  ARar.OnListFile := DoRARListFile;
  try
    if ARar.OpenFile(FTempFileName) then
    begin
      AExtractPath := IncludeTrailingPathDelimiter(IOUtils.TPath.GetTempPath) +
        IOUtils.TPath.GetGUIDFileName + '\';
      IOUtils.TDirectory.CreateDirectory(AExtractPath);
      ARar.Extract(AExtractPath, True, nil);
      for I := 0 to FFileList.Count - 1 do
      begin
        if IOUtils.TFile.Exists(FPath + FFileList.Strings[I]) then
          IOUtils.TFile.Delete(FPath + FFileList.Strings[I]);
        IOUtils.TFile.Copy(AExtractPath + FFileList.Strings[I],
          FPath + FFileList.Strings[I]);
      end;
      IOUtils.TDirectory.Delete(AExtractPath, True);
    end;
  finally
    FreeAndNil(ARar);
  end;
  //uClientApp.SendFileDownloaded(FFileName);
end;

{ TMiniResourcesClient }

constructor TMiniResourcesClient.Create(AApp: TuClientApp);
begin
  FApp := AApp;
  FClient := TRtcHttpClient.Create(nil);
  FClient.AutoConnect := True;
  FClient.MultiThreaded := True;
  FMaxThreads := 10;
  FThreads := TFixedThreadList.Create;
  FRequests := TFixedThreadList.Create;
  FFreeThreads := TFixedThreadList.Create;
end;

destructor TMiniResourcesClient.Destroy;
begin
  Clear;
  FreeAndNil(FClient);
  FreeAndNil(FThreads);
  FreeAndNil(FRequests);
  FreeAndNil(FFreeThreads);
  inherited;
end;

procedure TMiniResourcesClient.AddDownload(ARequest: pTMiniResRequest);
begin
  if CheckNeedDown(ARequest) then
  begin
    if ARequest.Important then
      DoDownload(ARequest)
    else
    begin
      FRequests.LockList.Add(ARequest);
      FRequests.UnlockList;
    end;
  end
  else
    FreeMem(ARequest);
end;

function TMiniResourcesClient.CheckNeedDown(ARequest: pTMiniResRequest)
  : Boolean;
var
  AImages: TWMImages;
  AFileItem: TFileItem;
begin
  result := False;
  case ARequest._Type of
    0:
      result := ImagesManager.TryGet(UpperCase(ARequest.FileName), AImages) and
        AImages.CanDownload(ARequest.Index);
    1:
      result := FileDownManager.TryGet(ARequest.FileName, AFileItem) and
        (AFileItem.State = ftNormal);
  end;
end;

procedure TMiniResourcesClient.Clear;
var
  I: Integer;
  AList: TList;
begin
  AList := FThreads.LockList;
  try
    for I := 0 to AList.Count - 1 do
      TRtcDataRequest(AList[I]).Free;
    AList.Clear;
  finally
    FThreads.UnlockList;
  end;
  AList := FRequests.LockList;
  try
    for I := 0 to AList.Count - 1 do
      FreeMem(AList[I]);
    AList.Clear;
  finally
    FRequests.UnlockList;
  end;
end;

procedure TMiniResourcesClient.DoDownload(ARequest: pTMiniResRequest);
var
  AImages: TWMImages;
  AFileItem: TFileItem;
  AResRequest: TResourceRequest;
begin
  case ARequest._Type of
    0:
      begin
        if ImagesManager.TryGet(UpperCase(ARequest.FileName), AImages) and
          AImages.CanDownload(ARequest.Index) then
        begin
          AImages.BeginDownload(ARequest.Index);
          try
            AResRequest := TResourceRequest.Create(Self);
            FThreads.LockList.Add(AResRequest);
            FThreads.UnlockList;
            AResRequest.Request.Method := 'Get';
            AResRequest.Request.FileName := '/Resources/File';
            AResRequest.Request.Query.Text := 'Params=' +
              UrlEncode(EncodeData(ARequest^, SizeOf(TMiniResRequest),
              FMiniPwd));
            AResRequest.FType := 0;
            AResRequest.FStartTime := GetTickCount;
            AResRequest.FFileName := ARequest.FileName;
            AResRequest.FImageIndex := ARequest.Index;
            AResRequest.Post;
            FreeMem(ARequest);
          except
            on E: Exception do
            begin
              AImages.ResetDownload(ARequest.Index);
              FRequests.Add(ARequest);
            end;
          end;
        end;
      end;
    1:
      begin
        if FileDownManager.TryGet(ARequest.FileName, AFileItem) and
          (AFileItem.State = ftNormal) then
        begin
          AFileItem.BeginDown;
          try
            AResRequest := TResourceRequest.Create(Self);
            FThreads.LockList.Add(AResRequest);
            FThreads.UnlockList;
            AResRequest.Request.Method := 'Get';
            AResRequest.Request.FileName := '/Resources/File';
            AResRequest.Request.Query.Text := 'Params=' +
              UrlEncode(EncodeData(ARequest^, SizeOf(TMiniResRequest),
              FMiniPwd));
            AResRequest.FType := 1;
            AResRequest.FStartTime := GetTickCount;
            AResRequest.FFileName := ARequest.FileName;
            AResRequest.FPath := ExtractFilePath(ARequest.FileName);
            AResRequest.FImageIndex := 0;
            AResRequest.Post;
            FreeMem(ARequest);
          except
            on E: Exception do
              AFileItem.State := ftNormal;
          end;
        end;
      end;
  end;
end;

procedure TMiniResourcesClient.LoadMiniSrvList;
var
  AResRequest: TResourceRequest;
begin
  AResRequest := TResourceRequest.Create(Self);
  FThreads.LockList.Add(AResRequest);
  FThreads.UnlockList;
  AResRequest.Request.Method := 'Get';
  AResRequest.Request.FileName := '/Resources/List';
  AResRequest.Request.Query.Text := 'Params=' +
    UrlEncode(uEDCode.EncodeSource(uClientApp.FServerInfo.MiniPwd));
  AResRequest.FType := 2;
  AResRequest.Post;
end;

procedure TMiniResourcesClient.Remove(ARequest: TResourceRequest);
var
  AList: TList;
begin
  AList := FThreads.LockList;
  try
    AList.Remove(ARequest);
  finally
    FThreads.UnlockList;
  end;
  FFreeThreads.LockList.Add(ARequest);
  FFreeThreads.UnlockList;
end;

procedure TMiniResourcesClient.Run;
var
  ARequest: pTMiniResRequest;
  ACount, I: Integer;
  AList: TList;
begin
  ACount := FThreads.LockList.Count;
  FThreads.UnlockList;
  if ACount < FMaxThreads then
  begin
    AList := FRequests.LockList;
    try
      while (ACount < FMaxThreads) and (AList.Count > 0) do
      begin
        ARequest := AList[0];
        AList.Delete(0);
        DoDownload(ARequest);
        Inc(ACount);
      end;
    finally
      FRequests.UnlockList;
    end;
  end;

  AList := FFreeThreads.LockList;
  try
    for I := 0 to AList.Count - 1 do
      TResourceRequest(AList[I]).Free;
    AList.Clear;
  finally
    FFreeThreads.UnlockList;
  end;
end;

procedure TMiniResourcesClient.SetServerInfo(const AServerAddr,
  AServerPort: String);
begin
  FClient.ServerAddr := AServerAddr;
  FClient.ServerPort := AServerPort;
end;

procedure InitLoginData();
begin
  uClientApp := TuClientApp.Create;
  uCliTypes._Application := uClientApp;
  FileDownManager := TFileDownManager.Create;
  uHandles := TStringList.Create;
end;

initialization

ExtractRARDll;

finalization

uCliTypes._Application := nil;
uClientApp := nil;
DeleteFile(uRARDLLFile);
FreeAndNil(FileDownManager);
FreeAndNil(uHandles);

end.

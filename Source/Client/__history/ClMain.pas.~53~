unit ClMain;

interface

uses
  Windows, Messages, MMSystem, SysUtils, Classes, Graphics, Controls, Forms,
  Dialogs, IOUtils, NativeConnectors, AbstractCanvas, AbstractTextures, MShare,
  AsphyreTypes, AsphyreTextureFonts, AbstractDevices, AsphyreEventTypes,
  AsphyreEvents, AsphyreSwapChains, AsphyreRenderTargets, AsphyreFactory,
  AsphyreDef, Vectors2, Vectors2px, uGameEngine, pngimage, DirectX, DrawScrn, DWinCtl,
  IntroScn, PlayScn, MapUnit, WIL, Grobal2, Actor, StdCtrls, clEvent, ScktComp,
  ExtCtrls, HUtil32, EdCode, ClFunc, magiceff, SoundUtil, IniFiles, MaketSystem,
  RelationShip, Registry, jpeg, StallSystem, types;

const
  BO_FOR_TEST = FALSE;
  BoServerIniFile = FALSE;   // 使用配置文件为TRUE，
  KoreanVersion = FALSE;
  EnglishVersion = FALSE;
  ChinaVersion = FALSE;
  TaiwanVersion = FALSE;
  BoUseFindHack = FALSE;
  BoNeedPatch = FALSE;
   // 2003/02/11
  BoDebugModeScreen = TRUE;

  MonitorsID = 0;

   // 2003/04/01
  VERSION_YEAR = 2005; //2003;
  VERSION_MON = 5; //8;
  VERSION_DAY = 1; //5;

  LocalLanguage: TImeMode = imOpen;
  SERVERADDR: string = '127.0.0.1';         //服务器IP地址
  TESTSERVERADDR = '61.153.61.246';         // 韩国测试区服务器IP地址
  kornetworldaddress = '61.153.61.246';      //韩服世界服务器IP地址
  NEARESTPALETTEINDEXFILE = 'Data\npal.idx';
//  SCREENWIDTH = 800;
//  SCREENHEIGHT = 600;
  MAXBAGITEMCL = 52;
  ENEMYCOLOR = 69;
  MAXFONT = 4;
  MAXVIEWOBJECT = 20;
  FontKorArr: array[0..MAXFONT-1] of string = (
                '宋体',
                '楷体',
                '仿宋',
                '黑体'
            );

  FontEngArr: array[0..MAXFONT-1] of string = (
                'Courier New',
                'Arial',
                'MS Sans Serif',
                'Microsoft Sans Serif'
            );
  CurFont: integer = 0;
  CurFontName: string = '宋体';
   //HIT
  HIT_INCLEVEL = 14;
  HIT_INCSPEED = 60;
  HIT_BASE = 1400;
  RUN_STRUCK_DELAY: integer = 0{3 * 1000};

type
  TDuraWarning = record
    ItemName: string;
    MakeIndex: Integer;
    DuraCount: Byte;
    UpDura: Integer;
    TAKEON_OK: Boolean;
    Dura_Ok: Boolean;
  end;

  TKornetWorld = record
    CPIPcode: string;
    SVCcode: string;
    LoginID: string;
    CheckSum: string;
  end;

  TOneClickMode = (toNone, toKornetWorld);

  TTimerCommand = (tcSoftClose, tcReSelConnect, tcFastQueryChr, tcQueryItemPrice);

  TChrAction = (caWalk, caRun, caHit, caSpell, caSitdown);

  TConnectionStep = (cnsLogin, cnsSelChr, cnsReSelChr, cnsPlay);

  TDirectDrawCreate = function(lpGUID: PGUID; out lplpDD: IDirectDraw; pUnkOuter: IUnknown): HRESULT; stdcall;

  TMovingItem = record
    Index: integer;
    Item: TClientItem;
  end;

  PTMovingItem = ^TMovingItem;

  TMiniViewObject = record
    Index: integer;
    x, y: integer;
    LastTick: longword;
  end;

  PTMiniViewObject = ^TMiniViewObject;

  TFrmMain = class(TForm, IApplication)
    CSocket: TClientSocket;
    Timer1: TTimer;
    MouseTimer: TTimer;
    WaitMsgTimer: TTimer;
    SelChrWaitTimer: TTimer;
    CmdTimer: TTimer;
    MinTimer: TTimer;
    CloseTimer: TTimer;
    LoadingTimmer: TTimer;
    CheckHackTimer: TTimer;
    ImageLogo: TImage;
    RunTimer: TTimer;
    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    procedure FormKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);
    procedure DXDraw1MouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DXDraw1MouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure FormKeyPress(Sender: TObject; var Key: Char);
    procedure DXDraw1Finalize(Sender: TObject);
    procedure CSocketConnect(Sender: TObject; Socket: TCustomWinSocket);
    procedure CSocketDisconnect(Sender: TObject; Socket: TCustomWinSocket);
    procedure CSocketError(Sender: TObject; Socket: TCustomWinSocket; ErrorEvent: TErrorEvent; var ErrorCode: Integer);
    procedure CSocketRead(Sender: TObject; Socket: TCustomWinSocket);
    procedure Timer1Timer(Sender: TObject);
    procedure MsgProg;
    procedure DXDraw1MouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure MouseTimerTimer(Sender: TObject);
    procedure FormClose(Sender: TObject; var Action: TCloseAction);
    procedure DXDraw1DblClick(Sender: TObject);
    procedure WaitMsgTimerTimer(Sender: TObject);
    procedure SelChrWaitTimerTimer(Sender: TObject);
    procedure DXDraw1Click(Sender: TObject);
    procedure CmdTimerTimer(Sender: TObject);
    procedure MinTimerTimer(Sender: TObject);
    procedure CheckHackTimerTimer(Sender: TObject);
    procedure SendTimeTimerTimer(Sender: TObject);
    procedure DelitemProg;
    procedure MainCancelItemMoving;
    procedure FormKeyUp(Sender: TObject; var Key: Word; Shift: TShiftState);
    procedure FormShow(Sender: TObject);
    procedure FormCloseQuery(Sender: TObject; var CanClose: Boolean);
    procedure LoadingTimmerTimer(Sender: TObject);
    procedure RunTimerTimer(Sender: TObject);
  private
    SocStr, BufferStr: string;
    WarningLevel: integer;
    TimerCmd: TTimerCommand;
    MakeNewId: string;
    ActionLockTime: longword;
    LastHitTime: longword;
    ActionFailLock: Boolean;
    FailAction, FailDir: integer;
    FailActionTime: longword;
    ActionKey: word;
    mousedowntime: longword;
    WaitingMsg: TDefaultMessage;
    WaitingStr: string;
    boSizeMove: Boolean;
    boInFocus: Boolean;

    FboDisplayChange: Boolean;
    FIDDraw: IDirectDraw;
    FDDrawHandle: THandle;
    FHotKeyId: Integer;
    FCriticalSection: TRTLCriticalSection;
    FCheckLibTime: LongWord;
    TempItemList: TList;
    function CheckPtInMinMap(X,Y:Integer):Boolean;
    procedure CheckMapView;
    procedure SpeedHackTimerTimer(Sender: TObject);
    procedure FindWHHackTimerTimer(Sender: TObject);
    procedure RunEffectTimerTimer(Sender: TObject);
    procedure ProcessKeyMessages;
    procedure ProcessActionMessages;
    procedure CheckSpeedHack(rtime: Longword);
    procedure CheckSpeedHackChina(stime: longword);
    procedure DecodeMessagePacket(datablock: string);
    procedure ActionFailed;
    function GetMagicByKey(Key: AnsiChar): PTClientMagic;
    function FindMagicId(ID: integer): PTClientMagic;
    function  FindMagicName(body: string): PTClientMagic;
    procedure UseMagic(tx, ty: integer; pcm: PTClientMagic);
    procedure UseMagicSpell(who, effnum, targetx, targety, magic_id: integer);
    procedure UseMagicFire(who, efftype, effnum, targetx, targety, target: integer);
    procedure UseMagicFireFail(who: integer);
    procedure CloseAllWindows;
    procedure ClearDropItems;
    procedure ResetGameVariables;
    procedure ChangeServerClearGameVariables;
    procedure _DXDrawMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    function CheckDoorAction(dx, dy: integer): Boolean;
    procedure ClientGetPasswdSuccess(body: string);
    procedure ClientGetNeedUpdateAccount(body: string);
    procedure ClientGetSelectServer;
    procedure ClientGetReceiveChrs(body: string);
    procedure ClientGetStartPlay(body: string);
    procedure ClientGetReconnect(body: string);
    procedure ClientGetMapDescription(body: string);
    procedure ClientGetAdjustBonus(bonus: integer; body: string);
    procedure ClientGetAddItem(body: string);
    procedure ClientGetUpdateItem(body: string);
    procedure ClientGetDelItem(body: string; flag: integer);
    procedure ClientGetDelItems(body: string);
    procedure ClientGetBagItmes(body: string);
    procedure ClientGetDropItemFail(iname: string; sindex: integer);
    procedure ClientGetShowItem(itemid, x, y, looks: integer; body: string);
    procedure ClientGetHideItem(itemid, x, y: integer);
    procedure ClientGetSenduseItems(body: string);
    procedure ClientGetAddMagic(body: string);
    procedure ClientGetDelMagic(magid: integer);
    procedure ClientGetMyMagics(checksum: integer; body: string);
    procedure ClientGetMagicLvExp(magid, maglv, magtrain: integer);
    procedure ClientGetSound(soundid: integer);
    procedure ClientGetDuraChange(uidx, newdura, newduramax: integer);
    procedure ClientGetMerchantSay(merchant, face: integer; saying: string);
    procedure ClientGetSendGoodsList(merchant, count: integer; body: string);
    procedure ClientGetDecorationList(merchant, count: integer; body: string);
    procedure ClientGetJangwonList(Page, count: integer; body: string);
    procedure ClientGetGABoardList(ListNum, Page, MaxPage: integer; body: string);
    procedure ClientGetGABoardRead(body: string);
    procedure ClientGetSendMakeDrugList(merchant: integer; body: string);
    procedure ClientGetSendMakeItemList(merchant: integer; body: string);
    procedure ClientGetSendUserSell(merchant: integer);
    procedure ClientGetSendUserRepair(merchant: integer);
    procedure ClientGetSendUserStorage(merchant: integer);
    procedure ClientGetSendUserMaketSell(merchant: integer);
    procedure ClientGetSaveItemList(merchant, currentpage, maxpage, bStorageType: integer; bodystr: string);
    procedure ClientGetSendDetailGoodsList(merchant, count, topline: integer; bodystr: string);
    procedure ClientGetSendNotice(body: string);
    procedure ClientGetGroupMembers(bodystr: string);
    procedure ClientGetOpenGuildDlg(bodystr: string);
    procedure ClientGetSendGuildMemberList(body: string);
    procedure ClientGetDealRemoteAddItem(body: string);
    procedure ClientGetDealRemoteDelItem(body: string);
    procedure ClientGetReadMiniMap(mapindex: integer);
    procedure ClientGetChangeGuildName(body: string);
    procedure ClientGetSendUserState(body: string);
    procedure ClientGetUserInfo(msg: TDefaultMessage; body: string);
    procedure ClientGetDelFriend(msg: TDefaultMessage; body: string);
    procedure ClientGetFriendInfo(msg: TDefaultMessage; body: string);
    procedure ClientGetFriendResult(msg: TDefaultMessage; body: string);
    procedure ClientGetTagAlarm(msg: TDefaultMessage; body: string);
    procedure ClientGetTagList(msg: TDefaultMessage; body: string);
    procedure ClientGetTagInfo(msg: TDefaultMessage; body: string);
    procedure ClientGetTagRejectList(msg: TDefaultMessage; body: string);
    procedure ClientGetTagRejectAdd(msg: TDefaultMessage; body: string);
    procedure ClientGetTagRejectDelete(msg: TDefaultMessage; body: string);
    procedure ClientGetTagResult(msg: TDefaultMessage; body: string);
    procedure ClientFriendSort(var datalist: TList; firstname: string);
    procedure ClientGetLMList(msg: TDefaultMessage; body: string);
    procedure ClientGetLMOptionChange(msg: TDefaultMessage);
    procedure ClientGetLMRequest(msg: TDefaultMessage; body: string);
    procedure ClientGetLMResult(msg: TDefaultMessage; body: string);
    procedure ClientGetLMDelete(msg: TDefaultMessage; body: string);
    procedure ClientGetServerUnBind(Body:String);
    procedure ClientGetAttackMode( mode :byte);
    procedure RecalcNotReadCount;
    procedure RecalcOnlinUserCount;
    // 20003-09-05 Encrypt LoginId,PasswordmCharName
    function GetLoginId: string;
    procedure SetLogId(id: string);
    function GetLoginPasswd: string;
    procedure SetLoginPasswd(pw: string);
    function GetCharName: string;
    procedure SetCharName(name: string);
    procedure ClientGetShopItems(body: string; Int: Integer);

    // For ASP
    procedure OnAsphyreCreate(Sender: TObject; Param: Pointer;
      var Handled: Boolean);
    procedure OnAsphyreDestroy(Sender: TObject; Param: Pointer;
      var Handled: Boolean);
    procedure OnDeviceInit(Sender: TObject; Param: Pointer;
      var Handled: Boolean);
    procedure OnDeviceCreate(Sender: TObject; Param: Pointer;
      var Handled: Boolean);
    procedure OnDeviceDestroy(Sender: TObject; Param: Pointer;
      var Handled: Boolean);
    procedure OnDeviceReset(Sender: TObject; Param: Pointer;
      var Handled: Boolean);
    procedure OnDeviceLost(Sender: TObject; Param: Pointer;
      var Handled: Boolean);
    procedure RenderEvent(Sender: TObject);
    procedure HandleConnectFailure();
    procedure DoGetTextHeight(const Text: String; Font: TFont;
      var Value: Integer);
    procedure DoGetTextWidth(const Text: String; Font: TFont;
      var Value: Integer);
    procedure DoGetTextExtent(const Text: string; Font: TFont;
      var Value: TSize);
  protected
    { IApplication }
    procedure AddToChatBoardString(const Message: String;
      FColor, BColor: TColor);
    procedure LoadImage(const FileName: String; Index, Position: Integer);
//    procedure AddMessageDialog(const Text: String; Buttons: TMsgDlgButtons;
//      Handler: TMessageHandler = nil; Size: Integer = 1);
    procedure Terminate;
    procedure DisConnect;
    function _CurPos: TPoint;
  public
    Certification: integer;
    ActionLock: Boolean;
    SpeedHackTimer: TTimer;
    FindWHHackTimer: TTimer;
    RunEffectTimer: TTimer;
    WhisperName: string;
    m_CheckTick: LongWord; 
    // 20003-09-05 Encrypt LoginId,PasswordmCharName
    EncLoginId, EncLoginPasswd, EncCharName: string;
    EncEncLoginID: string;
    FLoginIDLock: Boolean;
    property LoginId: string read GetLoginId write SetLogId;
    property LoginPasswd: string read GetLoginPasswd write SetLoginPasswd;
    property CharName: string read GetCharName write SetCharName;
    procedure WMSysCommand(var Message: TWMSysCommand); message WM_SYSCOMMAND;
    procedure InitializeClient;
    procedure ProcOnIdle;
    procedure AppLogout;
    procedure AppExit;
    procedure PrintScreenNow;
    procedure EatItem(idx: integer);
    procedure SendClientMessage(msg, Recog, param, tag, series: integer);
    procedure SendClientMessage2(msg, Recog, param, tag, series: integer; str: string);
    procedure SendVersionNumber;
    procedure SendLogin(uid, passwd: string);
    procedure SendNewAccount(ue: TUserEntryInfo; ua: TUserEntryAddInfo);
    procedure SendUpdateAccount(ue: TUserEntryInfo; ua: TUserEntryAddInfo);
    procedure SendSelectServer(svname: string);
    procedure SendChgPw(id, passwd, newpasswd: string);
    procedure SendNewChr(uid, uname, shair, sjob, ssex: string);
    procedure SendQueryChr;
    procedure SendDelChr(chrname: string);
    procedure SendSelChr(chrname: string);
    procedure SendRunLogin;
    procedure SendSay(str: string; n: Byte = 0);
    procedure SendActMsg(ident, x, y, dir: integer);
    procedure SendSpellMsg(ident, x, y, dir, target: integer);
    procedure SendQueryUserName(targetid, x, y: integer);
    procedure SendDropItem(name: string; itemserverindex: integer);
    procedure SendDropCountItem(iname: string; mindex, icount: integer);
    procedure SendPickup;
    procedure SendTakeOnItem(where: byte; itmindex: integer; itmname: string);
    procedure SendTakeOffItem(where: byte; itmindex: integer; itmname: string);
    procedure SendEat(idx, itmindex: integer; itmname: string);
    procedure UpgradeItem(ItemIndex, jewelIndex: integer; StrItem, StrJewel: string);
    procedure SendItemSumCount(OrgItemIndex, ExItemIndex: integer; StrOrgItem, StrExItem: string);
    procedure UpgradeItemResult(ItemIndex: integer; wResult: word; str: string);
    procedure UpgradeItemResultt(ItemIndex: integer; wResult: word; str: string);
    procedure SendButchAnimal(x, y, dir, actorid: integer);
    procedure SendMagicKeyChange(magid: integer; keych: AnsiChar);
    procedure SendMerchantDlgSelect(merchant: integer; rstr: string);
    procedure SendQueryPrice(merchant, itemindex: integer; itemname: string);
    procedure SendQueryRepairCost(merchant, itemindex: integer; itemname: string);
    procedure SendSellItem(merchant, itemindex: integer; itemname: string; Count: word);
    procedure SendRepairItem(merchant, itemindex: integer; itemname: string);
    procedure SendStorageItem(merchant, itemindex: integer; itemname: string; Count: word);
    procedure SendMaketSellItem(merchant, itemindex: integer; price: string; Count: word);
    procedure SendGetDetailItem(merchant, menuindex: integer; itemname: string);
    procedure SendGetJangwonList(Page: integer);
    procedure SendGABoardRead(Body: string);
    procedure SendGetMarketPageList(merchant, pagetype: integer; itemname: string);
    procedure SendBuyMarket(merchant, sellindex: integer);
    procedure SendCancelMarket(merchant, sellindex: integer);
    procedure SendGetPayMarket(merchant, sellindex: integer);
    procedure SendMarketClose;
    procedure SendBuyItem(merchant, itemserverindex: integer; itemname: string; Count: word);
    procedure SendBuyDecoItem(merchant, DecoItemNum: integer);
    procedure SendTakeBackStorageItem(merchant, itemserverindex: integer; itemname: string; Count: word);
    procedure SendMakeDrugItem(merchant: integer; itemname: string);
    procedure SendMakeItemSel(merchant: integer; itemname: string);
    procedure SendMakeItem(merchant: integer; data: string);
    procedure SendDropGold(dropgold: integer);
    procedure SendGroupMode(onoff: Boolean);
    procedure SendCreateGroup(withwho: string);
    procedure SendWantMiniMap;
    procedure SendDealTry;
    procedure SendGuildDlg;
    procedure SendCancelDeal;
    procedure SendAddDealItem(ci: TClientItem);
    procedure SendDelDealItem(ci: TClientItem);
    procedure SendChangeDealGold(gold: integer);
    procedure SendDealEnd;
    procedure SendAddGroupMember(withwho: string);
    procedure SendDelGroupMember(withwho: string);
    procedure SendGuildHome;
    procedure SendGuildMemberList;
    procedure SendGuildAddMem(who: string);
    procedure SendGuildDelMem(who: string);
    procedure SendGuildUpdateNotice(notices: string);
    procedure SendGABoardUpdateNotice(notice, CurPage: integer; bodyText: string);
    procedure SendGABoardModify(CurPage: integer; bodyText: string);
    procedure SendGABoardDel(CurPage: integer; bodyText: string);
    procedure SendGABoardNoticeCheck;
    procedure SendGetGABoardList(Page: integer);
    procedure SendGuildUpdateGrade(rankinfo: string);
    procedure SendSpeedHackUser(code: integer);
    procedure SendAdjustBonus(remain: integer; babil: TNakedAbility);
    procedure UseNormalEffect(effnum, effx, effy: integer);
    procedure UseNormalEffectEx (effdir, effx, effy: integer);
    procedure UseLoopNormalEffect(ActorID: integer; EffectIndex, LoopTime: Word);
    procedure AttackTarget(target: TActor);
    procedure SendAddFriend(data: string; FriendType: integer);
    procedure SendDelFriend(data: string);
    procedure SendMail(data: string);
    procedure SendReadingMail(data: string);
    procedure SendDelMail(data: string);
    procedure SendLockMail(data: string);
    procedure SendUnLockMail(data: string);
    procedure SendMailList;
    procedure SendRejectList;
    procedure SendUpdateFriend(data: string);
    procedure SendAddReject(data: string);
    procedure SendDelREject(data: string);
    procedure SendLMOPtionChange(OptionType: integer; Enable: integer);
    procedure SendLMRequest(ReqType: integer; ReqSeq: integer);
    procedure SendRufuseMaster(ReqType: integer = 0; ReqSeq: integer = 0);
    procedure SendLMSeparate(ReqType: integer; data: string);
    procedure SendDeath(targetid: Integer);
    function IsMyMember(name: string): Boolean;
    function TargetInSwordLongAttackRange(ndir: integer): Boolean;
    function TargetInSwordWideAttackRange(ndir: integer): Boolean;
    function TargetInSwordCrossAttackRange(ndir: integer): Boolean;
    procedure OnProgramException(Sender: TObject; E: Exception);
    procedure SendSocket(sendstr: string);
    function ServerAcceptNextAction: Boolean;
    function CanNextAction: Boolean;
    function CanNextHit: Boolean;
    function IsUnLockAction(action, adir: integer): Boolean;
    procedure ActiveCmdTimer(cmd: TTimerCommand);
    function IsGroupMember(uname: string): Boolean;
    procedure AppOnIdle(Sender: TObject; var Done: Boolean);
    procedure FullScreen(boFull: Boolean);
    procedure DisplayChange(boReset: Boolean);
    procedure WMMove(var Message: TWMMove); message WM_MOVE;
    procedure WMHotKey(var Msg: Tmessage);
    procedure TurnDuFu(pcm: PTClientMagic);
    procedure CreateParams(var Params: TCreateParams); override;
    procedure SendStallInfo(cr: TClientStallItems; cnt: Integer);
    procedure ShowDuraWarning;
    procedure AutoEatItem;
    procedure AutoPickUpItem;
    procedure ClientChangeUi;
    procedure SendGetPing;
    procedure ClientGetPing;
    function FillBagStallItem(ststus: Byte): Boolean;
    procedure SendShoping(sItemName: string);
    procedure SendPresend(sPlayer, sItemName: string);
  end;

procedure DecodeLicenseStrings(strlist: TStringlist);
function CheckMirProgram: Boolean;
procedure WaitAndPass(msec: longword);
procedure DebugOutStr (const msg: string);
procedure ChangeWalkHitValues(level, speed, weightsum, rundelay: integer);
procedure TogglePlaySoundEffect;
function GetFileCheckSum(flname: string): integer;


var
  FrmMain: TFrmMain;
  DScreen: TDrawScreen;
  IntroScene: TIntroScene;
  LoginScene: TLoginScene;
  SelectChrScene: TSelectChrScene;
  PlayScene: TPlayScene;
  LoginNoticeScene: TLoginNotice;
  DropedItemList: TList;
  ChangeFaceReadyList: TList;
  TerminateNow: Boolean;
  ViewList: array[1..MAXVIEWOBJECT] of TMiniViewObject;
  ViewListCount: Integer;
  MainParam1, MainParam2, MainParam3, MainParam4, MainParam5, MainParam6: string;
  //DObjList: TList;
  EventMan: TClEventManager;
  ServerCount: integer;
  ServerCaptionArr: array[0..31] of string;
  ServerNameArr: array[0..31] of string;
  KornetWorld: TKornetWorld;
  ServerName: string;
  MapTitle: string;
  GuildName: string;
  GuildRankName: string;
  Map: TMap;
  MySelf: THumActor;
  MyDrawActor: THumActor;
  UseItems: array[0..U_TRANS] of TClientItem;       //8->12
  ItemArr: array[0..MAXBAGITEMCL - 1] of TClientItem;
  DealItems: array[0..9] of TClientItem;
  MakeItemArr: array[0..5] of TClientItem;
  DealRemoteItems: array[0..19] of TClientItem;
  SaveItemList: TList;
  MenuItemList: TList;
  DealGold, DealRemoteGold: integer;
  BoDealEnd: Boolean;
  DealWho: string;
  MagicList: TList;
  MouseItem, MouseStateItem, MouseUserStateItem: TClientItem;
  FreeActorList: TList;
  BoServerChanging: Boolean;
  BoBagLoaded: Boolean;
  BoOptionLoaded: Boolean;
  BoOneTimePassword: Boolean;
  FirstServerTime: longword;
  FirstClientTime: longword;
  //ServerTimeGap: int64;
  TimeFakeDetectCount: integer;
  MainAniCount: integer;
  ClientVersion: integer;
  FirstServerTimeChina: longword;
  FirstClientTimeChina: longword;
  TimeFakeDetectCountChina: integer;
  checkfaketime: longword;
  checkchecksumtime: longword;
  SHGetTime: longword;
  SHTimerTime: longword;
  SHFakeCount: integer;
  SHHitSpeedCount: integer;
  LatestClientTime2: longword;
  FirstClientTimerTime: longword;
  LatestClientTimerTime: longword;
  FirstClientGetTime: longword;
  LatestClientGetTime: longword;
  TimeFakeDetectSum: integer;
  TimeFakeDetectTimer: integer;
  BonusPoint, SaveBonusPoint: integer;
  BonusTick: TNakedAbility;
  BonusAbil: TNakedAbility;
  NakedAbil: TNakedAbility;
  BonusAbilChg: TNakedAbility;
  SellDlgItem: TClientItem;
  SellDlgItemSellWait: TClientItem;
  DealDlgItem: TClientItem;
  MakingDlgItem: TClientItem;
  BoQueryPrice: Boolean;
  QueryPriceTime: longword;
  SellPriceStr: string;
  BoOneClick: Boolean;
  OneClickMode: TOneClickMode;
  BoFirstTime: Boolean;
  FAppTerminated: Boolean;
  FailureHandled: Boolean; //ASP增加
  ConnectionStep: TConnectionStep;
  BoWellLogin: Boolean;
  ServerConnected: Boolean;
  ViewFog: Boolean;
  DayBright: integer;
  AreaStateValue: integer;
  MyHungryState: integer;
  BoPlaySoundEffect: Boolean;
  LastAttackTime: longword;
  LastMoveTime: longword;
  ItemMoving: Boolean;
  MovingItem: TMovingItem;
  //
  g_WaitingDetectItem: TMovingItem;
  g_WaitingStallItem: TMovingItem;
  g_HelpStringList:tstringlist;
  g_HelpPosition:integer;
  //-
  DelTempItem: TClientItem;
  UpItemItem: TClientItem;
  WaitingUseItem: TMovingItem;
  EatingItem: TClientItem;
  EatTime: longword;
  LatestStruckTime: longword;
  LatestSpellTime: longword;
  LatestFireHitTime: longword;
  LatestRushRushTime: longword;
  LatestHitTime: longword;
  LatestMagicTime: longword;
  DizzyDelayStart: longword;
  DizzyDelayTime: integer;
  DoFadeOut: Boolean;
  DoFadeIn: Boolean;
  FadeIndex: integer;
  DoFastFadeOut: Boolean;
  BoStopAfterAttack: Boolean;
  BoAttackSlow: Boolean;
  BoMoveSlow, BoMoveSlow2: Boolean;
  MoveSlowLevel: integer;
  MoveSlowValue: integer;
  MapMoving: Boolean;
  MapMovingWait: Boolean;
//  CheckBadMapMode: Boolean;
  BoCheckSpeedHackDisplay: Boolean;
  BoWantMiniMap: Boolean;
  BoDrawMiniMap: Boolean;
  ViewMiniMapStyle: integer=1;
  ViewMiniMapTran:Boolean=false;
  g_ShowMiniMapXY:Boolean=false;
  g_MinMapWidth:Integer=180;
  ViewGeneralMapStyle: integer;
  PrevVMMStyle: integer;
  MiniMapIndex: integer=-1;
  MCX: integer;
  MCY: integer;
  MouseX, MouseY: integer;
  g_MouseX,g_MouseY:Integer;
  TargetX: integer;
  TargetY: integer;
  TargetCret, FocusCret: TActor;
  MagicTarget, AutoTarget: TActor;
  TargetCase: Byte;
  BoAutoDig: Boolean;
  BoSelectMyself: Boolean;
  FocusItem: PTDropItem;
  MagicDelayTime: longword;
  MagicPKDelayTime: longword;
  ChrAction: TChrAction;
  NoDarkness: Boolean;
  RunReadyCount: integer;
  SoftClosed: Boolean;
  SelChrAddr: string;
  SelChrPort: integer;
//  ImgMixSurface: TDirectDrawSurface;
//  ImgLargeMixSurface: TDirectDrawSurface;
//  MiniMapSurface: TDirectDrawSurface;
  CurMerchant: integer;
  MDlgX, MDlgY: integer;
  changegroupmodetime: longword;
  dealactiontime: longword;
  querymsgtime: longword;
  DupSelection: integer;
  MsgYesIagree: string;
  MsgNoImnot: string;
  AllowGroup: Boolean;
  SellStHold: Boolean;
  GroupMembers: TStringList;
  GroupIdList: TList; // MonOpenHp
  FriendMembers: TList;
  BlackMembers: TList;
  MailLists: TList;
  BlockLists: TStringList;
  MailAlarm: Boolean;
  WantMailList: Boolean;
  ConnectFriend: integer;
  ConnectBlack: integer;
  NotReadMailCount: integer;
  fLover: TRelationShipMgr;
  fMaster: TRelationShipMgr;
  fPupil: TRelationShipMgr;
  MySpeedPoint, MyHitPoint, MyAntiPoison, MyPoisonRecover, MyHealthRecover, MySpellRecover, MyAntiMagic: integer;
  AvailIDDay, AvailIDHour: word;
  AvailIPDay, AvailIPHour: word;
  CaptureSerial: integer;
  SendCount, ReceiveCount: integer;
  TestSendCount, TestReceiveCount: integer;
  SpellCount, SpellFailCount, FireCount: integer;
  DebugCount, DebugCount1, DebugCount2: integer;
  LastestClientGetTime: longword;
  ToolMenuHook: HHOOK;
  LastHookKey: integer;
  LastHookKeyTime: longword;
  BoNextTimePowerHit: Boolean;
  BoCanLongHit: Boolean;
  BoCanWideHit: Boolean;
  BoCanCrossHit: Boolean;
  BoCanTwinHit: Boolean;
  BoNextTimeFireHit: Boolean;
  BoCanStoneHit: Boolean;
  WalkCheckSum_fake1: integer;
  WalkCheckSum_fake2: integer;
  WalkCheckSum_fake3: integer;
  WalkCheckSum1: integer;
  HitCheckSum1: integer;
  HitCheckSum_fake1: integer;
  HitCheckSum_fake2: integer;
  HitCheckSum_fake3: integer;
  pWalkCheckSum2: ^integer;
  pHitCheckSum2: ^integer;
  pWalkCheckSum3: ^integer;
  pHitCheckSum3: ^integer;
  DarkLevel: integer;
  DayBright_fake: integer;
  DarkLevel_fake: integer;
  pDayBrightCheck: ^integer;
  pDarkLevelCheck: ^integer;
  pLocalFileCheckSum: ^integer;
  pClientCheckSum1: ^integer;
  pClientCheckSum2: ^integer;
  pClientCheckSum3: ^integer;
  BoSendFileCheckSum: Boolean;
  EffectNum: Byte;
  BoMsgDlgTimeCheck: Boolean;
  MsgDlgMaxStr: Byte;
  SpeedHackUse: Boolean;
  hfindWnd: Integer;
  BoViewEffect: Boolean;
  DropItemView: Boolean;
  gCheckTime: longword;
  mirapphandle: HWnd;
  GameClose: Boolean;
  CouplePower: Boolean;
  TabClickTime: longword;
  gFps: integer;
  FpsLastTime: longword;
  AngelFastDraw: Boolean;
  StBeltAutoFill: Boolean;
  BtInDex: integer;
  BeltType: integer;
  gAutoRun: Boolean;
  g_boShowName: Boolean;
  BackSoundLoopTime: longword;

  LoadingWaitTime: integer;
  LoadingWait: Boolean;
  g_dwKeyTimeTick: longword;
  g_WeightSet:Byte;
  g_DuraWarning: array[U_DRESS..U_TRANS] of TDuraWarning;
  g_MapDuraWarning: Boolean = true;

  ScrollingBarText : string;
  ScrollingBarTimes : Byte;
  BoShowScrollingBar : Boolean;
  ScrollingFColor : Integer;
  ScrollingBColor : Integer;
  ScrollingTextLeft: Integer;
  g_MaasonName : string;
  g_RunTick: Cardinal;

implementation

uses
  FState, DlgConfig, uDXLoader, cliUtil, uCommon, NgShare,  uLocalMessageer,
  UHelpStr, uSMBIOS, uDiskSN, MD5, ShellAPI, FWeb, frmWebBroser, CommCtrl;

{$R *.DFM}

{ IApplication }

procedure TfrmMain.AddToChatBoardString(const Message: String;
  FColor, BColor: TColor);
begin
  DScreen.AddChatBoardString(Message, FColor, BColor);
end;

procedure TfrmMain.LoadImage(const FileName: String; Index, Position: Integer);
begin
  LibManager.LoadImage(FileName, Index, Position); // todo
end;

//procedure TfrmMain.AddMessageDialog(const Text: String; Buttons: TMsgDlgButtons;
//  Handler: TMessageHandler; Size: Integer);
//var
//  AItem: PTMessageDialogItem;
//begin
//  New(AItem);
//  AItem.Text := Text;
//  AItem.Buttons := Buttons;
//  AItem.Handler := Handler;
//  AItem.Size := Size;
//  FDlgMessageList.Add(AItem);
//end;

function TfrmMain._CurPos: TPoint;
begin
  GetCursorPos(Result);
  Result := frmMain.ScreenToClient(Result);
  Result.X := Round(g_FScreenWidth / ClientWidth * Result.X);
  Result.Y := Round(g_FScreenHeight / ClientHeight * Result.Y);
end;

procedure TfrmMain.Terminate;
begin
  Application.Terminate;
end;

procedure TfrmMain.DisConnect;
begin
  CSocket.Close;
end;


function GetDuraHint(nTpye: Byte; ClientItem: TClientItem): Boolean;
begin
  Result := False;
  if not g_MapDuraWarning then
  begin
    if (g_DuraWarning[nTpye].ItemName <> ClientItem.S.Name) and (g_DuraWarning[nTpye].Dura_Ok) and (g_DuraWarning[nTpye].MakeIndex <> ClientItem.MakeIndex) then
    begin
      g_DuraWarning[nTpye].ItemName := ClientItem.S.Name;
      g_DuraWarning[nTpye].MakeIndex := ClientItem.MakeIndex;
      g_DuraWarning[nTpye].DuraCount := 0;
    end;
    if (ClientItem.Dura >= 1500) then
    begin
      if (g_DuraWarning[nTpye].DuraCount = 0) and g_DuraWarning[nTpye].Dura_Ok then
      begin
        Result := True;
        g_DuraWarning[nTpye].Dura_Ok := False;
      end;
      if g_DuraWarning[nTpye].DuraCount = 0 then
        g_DuraWarning[nTpye].DuraCount := 1;
    end
    else if (ClientItem.Dura >= 500) then
    begin
      if g_DuraWarning[nTpye].DuraCount = 0 then
        g_DuraWarning[nTpye].DuraCount := 1;
      if (g_DuraWarning[nTpye].DuraCount = 1) and g_DuraWarning[nTpye].Dura_Ok then
      begin
        Result := True;
        g_DuraWarning[nTpye].Dura_Ok := False;
      end;
      if g_DuraWarning[nTpye].DuraCount = 1 then
        g_DuraWarning[nTpye].DuraCount := 2;
    end
    else if (ClientItem.Dura >= 100) then
    begin
      if g_DuraWarning[nTpye].DuraCount = 0 then
        g_DuraWarning[nTpye].DuraCount := 2;
      if (g_DuraWarning[nTpye].DuraCount = 2) and g_DuraWarning[nTpye].Dura_Ok then
      begin
        Result := True;
        g_DuraWarning[nTpye].Dura_Ok := False;
      end;
      if g_DuraWarning[nTpye].DuraCount = 2 then
        g_DuraWarning[nTpye].DuraCount := 3;
    end;
  end
  else
  begin
    if g_DuraWarning[nTpye].TAKEON_OK then
    begin
      Exit;
    end;
    if (g_DuraWarning[nTpye].ItemName <> ClientItem.S.Name) or (g_DuraWarning[nTpye].MakeIndex <> ClientItem.MakeIndex) then
    begin
      g_DuraWarning[nTpye].ItemName := ClientItem.S.Name;
      g_DuraWarning[nTpye].MakeIndex := ClientItem.MakeIndex;
      g_DuraWarning[nTpye].DuraCount := 0;
    end;
    if (ClientItem.Dura >= 1500) then
    begin
      if g_DuraWarning[nTpye].DuraCount = 0 then
        Result := True;
      if g_DuraWarning[nTpye].DuraCount = 0 then
        g_DuraWarning[nTpye].DuraCount := 1;
    end
    else if (ClientItem.Dura >= 500) then
    begin
      if g_DuraWarning[nTpye].DuraCount = 0 then
        g_DuraWarning[nTpye].DuraCount := 1;
      if g_DuraWarning[nTpye].DuraCount = 1 then
        Result := True;
      if g_DuraWarning[nTpye].DuraCount = 1 then
        g_DuraWarning[nTpye].DuraCount := 2;
    end
    else if (ClientItem.Dura >= 100) then
    begin
      if g_DuraWarning[nTpye].DuraCount = 0 then
        g_DuraWarning[nTpye].DuraCount := 2;
      if g_DuraWarning[nTpye].DuraCount = 2 then
        Result := True;
      if g_DuraWarning[nTpye].DuraCount = 2 then
        g_DuraWarning[nTpye].DuraCount := 3;
    end;
    if nTpye >= U_CHARM then
      g_MapDuraWarning := false;
  end;
end;

function GetDuraHint1(nTpye: Byte; ClientItem: TClientItem): Boolean;
begin
  Result := False;
  begin
    if (g_DuraWarning[nTpye].ItemName <> ClientItem.S.Name) or (g_DuraWarning[nTpye].MakeIndex <> ClientItem.MakeIndex) then
    begin
      g_DuraWarning[nTpye].ItemName := ClientItem.S.Name;
      g_DuraWarning[nTpye].MakeIndex := ClientItem.MakeIndex;
      g_DuraWarning[nTpye].DuraCount := 0;
    end;
    if (ClientItem.Dura >= 1500) then
    begin
      if g_DuraWarning[nTpye].DuraCount = 0 then
        Result := True;
      if g_DuraWarning[nTpye].DuraCount = 0 then
        g_DuraWarning[nTpye].DuraCount := 1;
    end
    else if (ClientItem.Dura >= 500) then
    begin
      if g_DuraWarning[nTpye].DuraCount = 0 then
        g_DuraWarning[nTpye].DuraCount := 1;
      if g_DuraWarning[nTpye].DuraCount = 1 then
        Result := True;
      if g_DuraWarning[nTpye].DuraCount = 1 then
        g_DuraWarning[nTpye].DuraCount := 2;
    end
    else if (ClientItem.Dura >= 100) then
    begin
      if g_DuraWarning[nTpye].DuraCount = 0 then
        g_DuraWarning[nTpye].DuraCount := 2;
      if g_DuraWarning[nTpye].DuraCount = 2 then
        Result := True;
      if g_DuraWarning[nTpye].DuraCount = 2 then
        g_DuraWarning[nTpye].DuraCount := 3;
    end;
    if nTpye >= U_CHARM then
      g_MapDuraWarning := false;
  end;
end;

procedure DecodeLicenseStrings(strlist: TStringlist);
var
  i: integer;
  str: string;
begin
  for i := 0 to strlist.Count - 1 do
  begin
    str := strlist[i];
    strlist[i] := DecodeString(str);
  end;
end;

procedure ChangeWalkHitValues(level, speed, weightsum, rundelay: integer);
begin
  WalkCheckSum_fake1 := 10 + Random(1000);
  WalkCheckSum_fake2 := 100 + Random(1000);
  WalkCheckSum_fake3 := 1000 + Random(1000);
  WalkCheckSum1 := Random(100);
  pWalkCheckSum2^ := Random(10000);
  pWalkCheckSum3^ := Random(10000);

   //

  HitCheckSum_fake1 := 10 + Random(1000);
  HitCheckSum_fake2 := 100 + Random(1000);
  HitCheckSum_fake3 := 1000 + Random(1000);

  HitCheckSum1 := level * HIT_INCLEVEL + abs(speed) * HIT_INCSPEED + weightsum + rundelay;

  pHitCheckSum2^ := (HitCheckSum1 * 4) xor $FFFFFFFF;
  pHitCheckSum3^ := (HitCheckSum1 * 20) xor $FFFFFFFF;
end;

function CheckMirProgram: Boolean;
var
  pstr, cstr: array[0..255] of char;
begin
  Result := FALSE;
  StrPCopy(pstr, 'Legend of Mir 2');
  mirapphandle := FindWindow(nil, pstr);
  if (mirapphandle <> 0) and (mirapphandle <> Application.Handle) then
  begin
{$IFNDEF COMPILE}
    SetActiveWindow(mirapphandle);
    Result := TRUE;
{$ENDIF}
    exit;
  end;
end;

procedure WaitAndPass(msec: longword);
var
  start: longword;
begin
  start := GetTickCount;
  while GetTickCount - start < msec do
  begin
    Application.ProcessMessages;
  end;
end;

procedure DebugOutStr (const msg: string);
var
  flname: string;
  fhandle: TextFile;
begin
  exit; //如果想DEBUG，这里要注释掉
  flname := '.\!debug.txt';
  if FileExists(flname) then
  begin
    AssignFile(fhandle, flname);
    Append(fhandle);
  end
  else
  begin
    AssignFile(fhandle, flname);
    Rewrite(fhandle);
  end;
  WriteLn(fhandle, TimeToStr(Time) + ' ' + msg);
  CloseFile(fhandle);
end;

function KeyboardHookProc(Code: Integer; wParam: Integer; lParam: Integer): Longint; stdcall;
begin
  Result := 0;
  if ((wParam = VK_TAB) or (wParam = VK_F9) or (wParam = VK_F10) or (wParam = VK_F11) or (wParam = VK_F12)) then begin
    if (Code = HC_ACTION) and (lParam shr 31 = 0) then begin
      if (wParam = VK_TAB) then begin
        if FrmDlg.DLogin.Visible then begin
          if FocusedControl = FrmDlg.DEditID then
            SetDFocus(FrmDlg.DEditPass)
          else if FocusedControl = FrmDlg.DEditPass then
            SetDFocus(FrmDlg.DEditID);
        end;
      end;
      if (wParam = VK_F9) then begin
        if (MySelf <> nil) then begin
          FrmDlg.OpenItemBag;
          frmMain.SetFocus;
        end;
        Result := 1;
        Exit;
      end;
      if (wParam = VK_F10) then begin
        if (MySelf <> nil) then begin
          FrmDlg.StatePage := 0;
          FrmDlg.OpenMyStatus;
          frmMain.SetFocus;
        end;
        Result := 1;
        Exit;
      end;
      if (wParam = VK_F11) then begin
        if (MySelf <> nil) then begin
          FrmDlg.StatePage := 3;
          FrmDlg.OpenMyStatus;
          frmMain.SetFocus;
        end;
        Result := 1;
        Exit;
      end;

      if (wParam = VK_F12) then begin
        if (MySelf <> nil) then begin
          if g_boMirNg then
          FrmDlg.DOptionClick(nil);
        end;
        Result := 1;
        Exit;
      end;
    end;
  end;
  Result := CallNextHookEx(ToolMenuHook, Code, wParam, lParam);
end;

procedure TogglePlaySoundEffect;
begin
//  BoPlaySoundEffect := not BoPlaySoundEffect;
//  if BoPlaySoundEffect then
  g_SndMgr.Silent := not g_SndMgr.Silent;
  if not g_SndMgr.Silent then
    DScreen.AddChatBoardString('[音效 开]', clWhite, clBlack)
  else
    DScreen.AddChatBoardString('[音效 关]', clWhite, clBlack);
end;

function GetFileCheckSum(flname: string): integer;
type
  pinteger = ^Integer;
var
  pbuf: PChar;
  i, n, handle, bsize, cval, csum: integer;
begin
  Result := 0;
  if FileExists(flname) then
  begin
    handle := FileOpen(flname, fmOpenRead or fmShareDenyNone);
    if handle > 0 then
    begin
      bsize := FileSeek(handle, 0, 2);
      GetMem(pbuf, (bsize + 3) div 4 * 4);
      FillChar(pbuf^, (bsize + 3) div 4 * 4, 0);
      FileSeek(handle, 0, 0);
      FileRead(handle, pbuf^, bsize);
      FileClose(handle);

      csum := 0;
      for i := 0 to (bsize + 3) div 4 - 1 do
      begin
        cval := pinteger(pbuf)^;
        pbuf := PChar(integer(pbuf) + 4);
        csum := csum xor cval;
      end;

      Result := csum;
    end;
  end;
end;




//--------------------------------------------------------------------------------------

// 20003-09-05 Encrypt LoginId,PasswordmCharName
function TFrmMain.GetLoginId: string;
begin
  Result := '';

  if FLoginIDLock = false then
  begin
    Result := DecodeString(EncLoginId);
  end
  else
  begin
    if EncLoginId = DecodeString(EncEncLoginId) then
      Result := DecodeString(EncLoginId);
  end

end;

procedure TFrmMain.SetLogId(id: string);
begin
  if FLoginIDLock = false then
  begin
    EncLoginId := EncodeString(id);
    EncEncLoginId := EncodeString(EncLoginId);
  end;
end;

function TFrmMain.GetLoginPasswd: string;
begin
  Result := DecodeString(EncLoginPasswd);
end;

procedure TFrmMain.SetLoginPasswd(pw: string);
begin
  if FLoginIDLock = false then
  begin
    EncLoginPasswd := EncodeString(pw);
  end;
end;

function TFrmMain.GetCharName: string;
begin
  Result := DecodeString(EncCharName);
end;

procedure TFrmMain.SetCharName(name: string);
begin
  EncCharName := EncodeString(name);
end;

procedure TFrmMain.FormCreate(Sender: TObject);
var
  flname, str, uDXDLLFile: string;
  ini: TIniFile;
  i, n, nHandle, ExStyle: integer;
  S: TResourceStream;
  P: TPngImage;
  ALogoLoaded: Boolean;
begin
  nHandle := LoadLibrary('bass.dll');
  if (nHandle = 0) then
  begin
    try
      S := TResourceStream.Create(HInstance, 'BASSDLL', RT_RCDATA);
      try
        uDXDLLFile := ExtractFilePath(ParamStr(0)) + 'Data\bass.dll';
        S.SaveToFile(uDXDLLFile);
      finally
        S.Free;
      end;
    except
    end;
  end;

  if nHandle <> 0 then
  begin
    FreeLibrary(0);
  end;
  Color := clWhite;
  ExStyle := GetWindowLong(Application.Handle, GWL_EXSTYLE);
  ExStyle := ExStyle or WS_EX_TOOLWINDOW;
  SetWindowLong(Application.Handle, GWL_EXSTYLE, ExStyle);

{$IFDEF DEBUG}
  if ParamStr(1) = '' then begin
    with g_MirStartupInfo do begin  //调试模式正式模式外网设置
      sServerName := '蓝色风云';  //玛法传奇/
//      sServeraddr := '43.142.238.11';   //39.99.225.101
      sServeraddr:= '127.0.0.1';   //39.99.225.101
      sServerKey:= '123465';
      sResourceDir:= 'Resource\';
      nServerPort:= 7000;          //7677
      boFullScreen:= False;
      boWaitVBlank:= True;
      bo3D:= False;
      boMini:= False;//开启后启用微端
//      nScreenWidth:= 800;    //分辨率修改
//      nScreenHegiht:= 600;
      nScreenWidth:= 1024;
      nScreenHegiht:= 768;
      nLocalMiniPort:= 0;//10555;  //开启后启用微端
      sLogo:= '';
      PassWordFileName:= '';
      GUIFScreenWidth := nScreenWidth;
      GUIFScreenHeight:= nScreenHegiht;
    end;
  end;

  if not IOUtils.TDirectory.Exists(
    IncludeTrailingPathDelimiter(ExtractFilePath(Application.Exename)+g_MirStartupInfo.sResourceDir)) then
    IOUtils.TDirectory.CreateDirectory
      (IncludeTrailingPathDelimiter(ExtractFilePath(Application.Exename)+g_MirStartupInfo.sResourceDir));
{$ENDIF}

 // g_MirStartupInfo.sServerName:= '龙的传说';    //本地通讯链接
 // g_MirStartupInfo.sServeraddr:= '127.0.0.1';
 // g_MirStartupInfo.nServerPort:= 7676;
  g_Application := Self;

  ALogoLoaded := False;
  if (g_MirStartupInfo.sLogo <> '') and FileExists(g_MirStartupInfo.sLogo) then
  begin
    try
      ImageLogo.Picture.LoadFromFile(g_MirStartupInfo.sLogo);
      ALogoLoaded := True;
    except
    end;
    DeleteFile(g_MirStartupInfo.sLogo);
  end;

  try
    if not ALogoLoaded then
    begin
      P := TPngImage.Create;
      P.LoadFromResourceName(HInstance, 'LOGO');
      ImageLogo.Picture.Graphic := P;
      P.Free;
    end;
  except
  end;

  FrmWeb := TFrmWeb.Create(Self);
  FrmWeb.Parent := Self;

  g_FScreenWidth := g_MirStartupInfo.nScreenWidth;

  g_FScreenHeight := g_MirStartupInfo.nScreenHegiht;
  g_boFullScreen := g_MirStartupInfo.boFullScreen;

  g_boLockFullScreen := g_MirStartupInfo.boFullScreen;

  AbstractDevices.UseHardWare := False;

  SERVERADDR := g_MirStartupInfo.sServeraddr;
  CSocket.Port := g_MirStartupInfo.nServerPort;
  ServerCount := 1;
  ServerCaptionArr[0] := g_MirStartupInfo.sServerName;
  ServerNameArr[0] := g_MirStartupInfo.sServerName;


  ResourceDir := ExcludeTrailingPathDelimiter
    (StringReplace(g_MirStartupInfo.sResourceDir, '/', '\', [rfReplaceAll]));
  repeat
    if (ResourceDir <> '') and (ResourceDir[1] in ['.', '\']) then
      Delete(ResourceDir, 1, 1);
  until (ResourceDir = '') or not(ResourceDir[1] in ['.', '\']);
  if ResourceDir = '' then
    ResourceDir := 'Resource';
  ResourceDir := IncludeTrailingPathDelimiter(ResourceDir);
  WIL.ResDir := ResourceDir;
  Wil.ExceptionOut := DebugOutStr;
  UserCfgDir := ResourceDir + 'Users\';
  FAppTerminated := False;
  // 获取客户端所有资源文件目录
  WIL.GetClientLibFile(ResourceDir);

  //如果加载微端版本文件没有成功那么直接关闭微端。
  if not LibManager.LoadMiniImageFile(WIL.ResDir + 'MiniVer.db' ) then
  begin
    ConsoleDebug(Format('因为没有在资源目录下:%s,发现有微端控制信息,所以设置微端关闭',[WIL.ResDir]));
    g_MirStartupInfo.boMini := False;
  end;


  FboDisplayChange := False;
  FDDrawHandle := 0;
  FIDDraw := nil;
  InitializeCriticalSection(FCriticalSection);
  ScreenChanged();

  FAppTerminated := False;

  FillChar(g_DuraWarning, SizeOf(TDuraWarning) * 12, #0);
  for I := U_DRESS to U_TRANS - 1 do
  begin
    g_DuraWarning[I].TAKEON_OK := True;
    g_DuraWarning[I].Dura_Ok := False;
  end;
  TempItemList := TList.Create;
  g_HelpStringList:=Tstringlist.Create;
  g_HelpStringList.Text:=g_HelpStr;

{$IFDEF DEBUG}
  CheckHackTimer.Enabled := False;
{$ELSE}
  CheckHackTimer.Enabled := True;
{$ENDIF}
//  CheckHackTimer.Enabled := True;   // 强制开启外挂检测

  Randomize;

  m_Point := ClientOrigin;
  if g_boFullScreen then begin
    BorderStyle := bsNone;
    BorderIcons := [];
    if (Screen.MonitorCount > 1) then
    begin
      Left := Screen.Monitors[MonitorsID].Left;
      Top := Screen.Monitors[MonitorsID].Top;
      Width := Screen.Monitors[MonitorsID].Width;
      Height := Screen.Monitors[MonitorsID].Height;
    end else begin
      Left := 0;
      Top := 0;
    end;

    WindowState := wsMaximized;
    ClientWidth := g_FScreenWidth;
    ClientHeight := g_FScreenHeight;
    DisplayChange(False);
  end else begin
    FrmMain.BorderStyle := bsSingle;
    ClientWidth := g_FScreenWidth;
    ClientHeight := g_FScreenHeight;
  end;
  ImageLogo.Left := (ClientWidth - ImageLogo.Width) div 2;
  ImageLogo.Top := (ClientHeight - ImageLogo.Height) div 2;



  g_SndMgr := TSoundMgr.Create(Self.Handle);
  g_SndMgr.volume := Round(g_btSoundVolume / 68 * 100);
  g_SndMgr.Silent := not g_boSound;
  g_LocalMessager := TLocalMessageer.Create;

  g_LocalMessager.SetMini(g_MirStartupInfo.boMini);
  if g_MirStartupInfo.nLocalMiniPort > 0 then
  begin
    g_LocalMessager.SetPort(g_MirStartupInfo.nLocalMiniPort);
    g_LocalMessager.Open;
    ConsoleDebug(Format('设置本地通信:%d',[g_MirStartupInfo.nLocalMiniPort]));
  end;

  g_SndMgr.LoadSoundList('.\wav\sound.lst');


  boSizeMove := False;

  Randomize;

  new(pWalkCheckSum2);
  new(pHitCheckSum2);
  new(pWalkCheckSum3);
  new(pHitCheckSum3);

  new(pDayBrightCheck);
  new(pDarkLevelCheck);
  new(pLocalFileCheckSum);
  new(pClientCheckSum1);
  new(pClientCheckSum2);
  new(pClientCheckSum3);

//  if BoServerIniFile then
//  begin
//    ini := TIniFile.Create('.\mirsetup.ini');
//    if ini <> nil then
//    begin
//      SERVERADDR := ini.ReadString('Setup', 'ServerAddr', SERVERADDR);
//      // 2003/08/29 IME 滚弊荐沥
//      LocalLanguage := imSAlpha;
//      CurFontName := ini.ReadString('Setup', 'FontName', CurFontName);
//      MsgYesIagree := ini.ReadString('Setup', 'Message1', '');
//      MsgNoImnot := ini.ReadString('Setup', 'Message2', '');
//      ServerCount := _MIN(32, ini.ReadInteger('Server', 'ServerCount', 1));
//      for i := 0 to ServerCount - 1 do
//      begin
//        str := 'Server' + IntToStr(i + 1) + 'Caption';
//        ServerCaptionArr[i] := ini.ReadString('Server', str, '');
//        str := 'Server' + IntToStr(i + 1) + 'Name';
//        ServerNameArr[i] := ini.ReadString('Server', str, '');
//      end;
//      g_bo物品窗口 := ini.ReadBool('Setup', 'WupinUI', g_bo物品窗口);
//      g_bo主界面 := ini.ReadBool('Setup', 'Bottom', g_bo主界面);
//      ini.Free;
//    end;
//  end
//  else
//  begin
//    SERVERADDR := '127.0.0.1'; //服务器IP地址
//    ServerCount := 1;  //服务器数量  1就表示1个区
//    ServerNameArr[0] := '龙的传说';     //  服务器名字
//    ServerCaptionArr[0] := ServerNameArr[0];
//    ServerNameArr[1] := '烈焰';    //第二个服务器名字
//    ServerCaptionArr[1] := ServerNameArr[1];
//    ServerNameArr[2] := '光芒';    //第三个服务器名字
//    ServerCaptionArr[2] := ServerNameArr[2];
//    ServerNameArr[3] := '淡水';    //第四个服务器名字
//    ServerCaptionArr[3] := ServerNameArr[3];
//    ServerNameArr[4] := '流云';    //第五个服务器名字
//    ServerCaptionArr[4] := ServerNameArr[4];
//    ServerNameArr[5] := '疾风';    //第六个服务器名字
//    ServerCaptionArr[5] := ServerNameArr[5];
//    ServerNameArr[6] := '新浪';    //第七个服务器名字
//    ServerCaptionArr[6] := ServerNameArr[6];
//    ServerNameArr[7] := '蜀山';    //第八个服务器名字
//    ServerCaptionArr[7] := ServerNameArr[7];
//  end;
  ToolMenuHook := SetWindowsHookEx(WH_KEYBOARD, @KeyboardHookProc, 0, GetCurrentThreadID);

  ClientVersion := VERSION_YEAR * 10000 + VERSION_MON * 100 + VERSION_DAY;

  LoadMapDescList('Data\MapDesc.dat'); //地图备注文件载入

  DScreen := TDrawScreen.Create;
  IntroScene := TIntroScene.Create;
  LoginScene := TLoginScene.Create;
  SelectChrScene := TSelectChrScene.Create;
  PlayScene := TPlayScene.Create;
  LoginNoticeScene := TLoginNotice.Create;

  Map := TMap.Create;
  DropedItemList := TList.Create;
  MagicList := TList.Create;
  FreeActorList := TList.Create;
   //DObjList := TList.Create;
  EventMan := TClEventManager.Create;
  ChangeFaceReadyList := TList.Create;
  g_SendSayList := TStringlist.Create;
   // 2003/02/11
  ViewListCount := 0;
  FillChar(ViewList, sizeof(TMiniViewObject) * MAXVIEWOBJECT, #0);

  for n := Low(g_ShopListArr) to High(g_ShopListArr) do
    g_ShopListArr[n] := TList.Create;

  Myself := nil;
   // 2003/03/15 物品库存扩张
  FillChar(UseItems, sizeof(UseItems), #0);            //9->13
  FillChar(ItemArr, sizeof(TClientItem) * MAXBAGITEMCL, #0);
  FillChar(DealItems, sizeof(TClientItem) * 10, #0);
  FillChar(DealRemoteItems, sizeof(TClientItem) * 20, #0);
  SaveItemList := TList.Create;
  MenuItemList := TList.Create;
  WaitingUseItem.Item.S.Name := '';  //临时保存穿戴窗口服务器和通信之间
  EatingItem.S.Name := '';

  TargetX := -1;
  TargetY := -1;
  TargetCret := nil;
  FocusCret := nil;
  FocusItem := nil;
  MagicTarget := nil;
  AutoTarget := nil;
  TargetCase := 1; // AutoTarget

  DebugCount := 0;
  DebugCount1 := 0;
  DebugCount2 := 0;
  TestSendCount := 0;
  TestReceiveCount := 0;
  BoServerChanging := FALSE;
//  BoBagLoaded := FALSE;
  BoOptionLoaded := FALSE;
  BoAutoDig := FALSE;

  LatestClientTime2 := 0;
  FirstClientTime := 0;
  FirstServerTime := 0;
  FirstClientTimerTime := 0;
  LatestClientTimerTime := 0;
  FirstClientGetTime := 0;
  LatestClientGetTime := 0;

  TimeFakeDetectCount := 0;
  TimeFakeDetectTimer := 0;
  TimeFakeDetectSum := 0;
  TimeFakeDetectCountChina := 0;

  SHGetTime := 0;
  SHTimerTime := 0;
  SHFakeCount := 0;
  SHHitSpeedCount := 0;

  DayBright := 3; //广
  DayBright_fake := DayBright;
  pDayBrightCheck^ := DayBright;
  ViewFog := TRUE;
  DarkLevel := 0;
  DarkLevel_fake := DarkLevel;
  pDarkLevelCheck^ := DarkLevel;

  ScrollingBarText := '';
  ScrollingBarTimes := 0;
  BoShowScrollingBar := FALSE;
  ScrollingFColor := 0;
  ScrollingBColor := 0;
  ScrollingTextLeft := 0;

  AreaStateValue := 0;
  ConnectionStep := cnsLogin;
  BoWellLogin := FALSE;
  ServerConnected := FALSE;
  SocStr := '';
  WarningLevel := 0;  //坏包接收次数（包复制的可能性）
  ActionFailLock := FALSE;
  MapMoving := FALSE;
  MapMovingWait := FALSE;
//   CheckBadMapMode := FALSE;
  BoCheckSpeedHackDisplay := FALSE;
   //BoViewMiniMap := FALSE;
  BoWantMiniMap := FALSE;
  BoDrawMiniMap := FALSE;
  ViewMiniMapStyle := 0;  //0：不可见，1：半透明，2：直接
  ViewGeneralMapStyle := 0;
  PrevVMMStyle := 1;
  FailDir := 0;
  FailAction := 0;
  FailActionTime := GetTickCount;
  DupSelection := 0;

  LastAttackTime := GetTickCount;
  LastMoveTime := GetTickCount;
  LatestSpellTime := GetTickCount;
  TabClickTime := GetTickCount;

  BoFirstTime := TRUE;
  ItemMoving := FALSE;
  DoFadeIn := FALSE;
  DoFadeOut := FALSE;
  DoFastFadeOut := FALSE;
  BoAttackSlow := FALSE;
  BoStopAfterAttack := FALSE;

  BoMoveSlow := FALSE;
  BoMoveSlow2 := FALSE;
  BoNextTimePowerHit := FALSE;
  BoCanLongHit := FALSE;
  BoCanWideHit := FALSE;
   // 2003/03/15  新武功
  BoCanCrossHit := FALSE;
  BoCanTwinHit := FALSE;
  BoNextTimeFireHit := FALSE;

  BoPlaySoundEffect := TRUE;

  NoDarkness := FALSE;
  SoftClosed := FALSE;
  BoQueryPrice := FALSE;
  SellPriceStr := '';

  AllowGroup := FALSE;
  SellStHold := FALSE;
  GroupMembers := TStringList.Create;
  GroupIdList := TList.Create; // MonOpenHp
   // 2003/04/15 朋友，注意
  FriendMembers := TList.Create;
  BlackMembers := TList.Create;
  MailLists := TList.Create;
  BlockLists := TStringList.Create;
  MailAlarm := false;
  WantMailList := false;
   

   // 2003/07/08 恋人
  fLover := TRelationShipMgr.Create;
  fMaster := TRelationShipMgr.Create;
  fPupil := TRelationShipMgr.Create;

  MainWinHandle := handle;
  g_FrmMainWinHandle := handle;

   //一键式、短号世界等..
  BoOneClick := FALSE;
  OneClickMode := toNone;

  CSocket.Active := FALSE;
//  CSocket.Port := 7676;   //登录网关通讯端口
  if MainParam1 = '' then
    CSocket.Address := SERVERADDR
  else
  begin
    if (MainParam1 <> '') and (MainParam2 = '') then  //参数1个
      CSocket.Address := MainParam1;
    if (MainParam2 <> '') and (MainParam3 = '') then
    begin  //两个参数的情况。
      CSocket.Address := MainParam1;
      CSocket.Port := Str_ToInt(MainParam2, 0);
    end;
    if (MainParam3 <> '') then
    begin  //如果有3个参数，则合并连接
      if CompareText(MainParam1, '/KWG') = 0 then
      begin
            //短号世界
        CSocket.Address := kornetworldaddress;  //game.megapass.net';
        CSocket.Port := 9000;
        BoOneClick := TRUE;
        OneClickMode := toKornetWorld;
        with KornetWorld do
        begin
          CPIPcode := MainParam2;
          SVCcode := MainParam3;
          LoginID := MainParam4;
          CheckSum := MainParam5; //'dkskxhdkslxlkdkdsaaaasa';
        end;
      end
      else
      begin
            //对于一般的一键式集成闸机
        CSocket.Address := MainParam2;
        CSocket.Port := Str_ToInt(MainParam3, 0);
        BoOneClick := TRUE;
      end;
    end;
  end;
  if BO_FOR_TEST then
    CSocket.Address := TESTSERVERADDR;

  SpeedHackTimer := TTimer.Create(self);
  SpeedHackTimer.Interval := 250;
  SpeedHackTimer.Enabled := TRUE;
  SpeedHackTimer.OnTimer := SpeedHackTimerTimer;

  FindWHHackTimer := TTimer.Create(self);
  FindWHHackTimer.Interval := 5000;
  FindWHHackTimer.Enabled := TRUE;
  FindWHHackTimer.OnTimer := FindWHHackTimerTimer;

  RunEffectTimer := TTimer.Create(self); // 龙副本落雷之路，熔岩之路
  RunEffectTimer.Interval := 400;
  RunEffectTimer.Enabled := False;
  RunEffectTimer.OnTimer := RunEffectTimerTimer;
  RunEffectTimer.Tag := 555;

   // MainSurface := nil;
  pLocalFileCheckSum^ := GetFileCheckSum(ParamStr(0));
  BoSendFileCheckSum := FALSE;

   //DebugColor1 := 0;
   //DebugColor2 := 0;
   //DebugColor3 := 0;
   //DebugColor4 := 0;
  EffectNum := 0; // FireDragon

  EncLoginId := '';
  EncLoginPasswd := '';
  EncCharName := '';
  FLoginIDLock := false;

  g_Market := TMarketItemManager.Create;

  BoMsgDlgTimeCheck := False;
  MsgDlgMaxStr := 30;
  SpeedHackUse := False;
  BoViewEffect := True;
//   BackSoundLoopTime := GetTickcount;
  gCheckTime := GetTickcount;

  GameClose := False;
  CouplePower := False;
  StBeltAutoFill := False;
  BtInDex := -1;
  BeltType := 1;
  DropItemView := True;
  gAutoRun := False;
  g_boShowName := False;

  gFps := 0;
  FpsLastTime := GetTickcount;
  AngelFastDraw := False;
  //cSocket.Active := TRUE;
  LoadingWaitTime :=0;
  LoadItemFilter;

  InitializeClient;
end;

procedure TFrmMain.InitializeClient;
begin
  if TerminateNow then begin
    FrmMain.Close;
    exit;
  end;

  if g_boFullScreen then begin
    BorderStyle := bsNone;
    BorderIcons := [];
    if (Screen.MonitorCount > 0) then
    begin
      Left := Screen.Monitors[0].Left;
      Top := Screen.Monitors[0].Top;
      Width := Screen.Monitors[0].Width;
      Height := Screen.Monitors[0].Height;
    end else begin
      Left := 0;
      Top := 0;
    end;
    WindowState := wsMaximized;
    ClientWidth := g_FScreenWidth;
    ClientHeight := g_FScreenHeight;
    m_Point := ClientOrigin;
  end else begin
    FrmMain.BorderStyle := bsSingle;
    ClientWidth := g_FScreenWidth;
    ClientHeight := g_FScreenHeight;
  end;
  ImageLogo.Left := (ClientWidth - ImageLogo.Width) div 2;
  ImageLogo.Top := (ClientHeight - ImageLogo.Height) div 2;

  DebugOutStr ('----------------------- started ------------------------');
//  Application.OnMessage := AppMessage;
  Application.OnException := OnProgramException;
  Application.OnIdle := AppOnIdle;
//  Application.OnRestore := OnProgramRestore;

  if uDXLoader.LoadDirectX then
  begin
    ConsoleDebug('D3D9初始化成功');
    EventAsphyreCreate.Subscribe(ClassName, OnAsphyreCreate);
    EventAsphyreDestroy.Subscribe(ClassName, OnAsphyreDestroy);
    EventDeviceInit.Subscribe(ClassName, OnDeviceInit);
    EventDeviceCreate.Subscribe(ClassName, OnDeviceCreate);
    EventDeviceDestroy.Subscribe(ClassName, OnDeviceDestroy);
    EventDeviceLost.Subscribe(ClassName, OnDeviceDestroy);
    EventDeviceReset.Subscribe(ClassName, OnDeviceCreate);
    EventDeviceLost.Subscribe(ClassName, OnDeviceDestroy);
  end
  else
  begin
    Application.MessageBox('DirectX装载失败，请确认机器是否安装DirectX9！', '提示', MB_OK);
    Application.Terminate;
  end;
end;

procedure TFrmMain.OnProgramException(Sender: TObject; E: Exception);
begin
  DebugOutStr(E.Message);
end;

procedure TFrmMain.WMSysCommand(var Message: TWMSysCommand);
begin
  if Message.CmdType = SC_MINIMIZE then begin
    DisplayChange(True);
  end
  else if Message.CmdType = SC_RESTORE then begin
    if g_boFullScreen then DisplayChange(False);
  end;
  inherited;
end;

procedure TFrmMain.FormDestroy(Sender: TObject);
var
  i: Integer;
begin
  FAppTerminated := True;
  TempItemList.Free;
  g_HelpStringList.Free;

  FIDDraw := nil;
  if FDDrawHandle > 0 then FreeLibrary(FDDrawHandle);
  if ToolMenuHook <> 0 then UnhookWindowsHookEx(ToolMenuHook);
   //SoundCloseProc;
   //DXTimer.Enabled := FALSE;
  Timer1.Enabled := FALSE;
  MinTimer.Enabled := FALSE;

  DScreen.Finalize;
  PlayScene.Finalize;
  LoginNoticeScene.Finalize;

  for i := Low(g_ShopListArr) to High(g_ShopListArr) do g_ShopListArr[i].Free;

  DScreen.Free;
  IntroScene.Free;
  LoginScene.Free;
  SelectChrScene.Free;
  g_SendSayList.Free;
  PlayScene.Free;
  LoginNoticeScene.Free;
  SaveItemList.Free;
  MenuItemList.Free;

  DebugOutStr('----------------------- closed -------------------------');
  Map.Free;
  DropedItemList.Free;
  MagicList.Free;
  FreeActorList.Free;
  ChangeFaceReadyList.Free;
   //if MainSurface <> nil then MainSurface.Free;

  DeleteCriticalSection(FCriticalSection);

  g_SndMgr.Terminate;
//  g_SndMgr.Free;

  EventMan.Free;

  if RunEffectTimer <> nil then
    RunEffectTimer.Free;
  if FindWHHackTimer <> nil then
    FindWHHackTimer.Free;
  if SpeedHackTimer <> nil then
    SpeedHackTimer.Free;

   //困殴惑痢
  g_Market.Free;
  FrmWeb.free;
  if (Assigned(g_GameDevice)) then
    g_GameDevice.DisConnect();
  NativeAsphyreConnect.Done();
  EventProviders.Unsubscribe(ClassName);
  Application.Terminate;
end;

function ComposeColor(Dest, Src: TRGBQuad; Percent: Integer): TRGBQuad;
begin
  with Result do
  begin
    rgbRed := Src.rgbRed + ((Dest.rgbRed - Src.rgbRed) * Percent div 256);
    rgbGreen := Src.rgbGreen + ((Dest.rgbGreen - Src.rgbGreen) * Percent div 256);
    rgbBlue := Src.rgbBlue + ((Dest.rgbBlue - Src.rgbBlue) * Percent div 256);
    rgbReserved := 0;
  end;
end;

procedure TFrmMain.DXDraw1Finalize(Sender: TObject);
begin
   //DXTimer.Enabled := FALSE;
end;

type
  TInt64Decompose = packed record
    case Integer of
      1:
        (nInt64: Int64;);
      2:
        (nInteger1: Integer;
        nInteger2: Integer;);
  end;

procedure TFrmMain.FormClose(Sender: TObject; var Action: TCloseAction);
begin
 Action:=caFree;
   //Savebags ('.\Data\' + ServerName + '.' + CharName + '.itm', @ItemArr);
   //DxTimer.Enabled := FALSE;
end;


{------------------------------------------------------------}

procedure TFrmMain.ProcOnIdle;
var
  done: Boolean;
begin
   AppOnIdle (self, done);
   Sleep(1); //修正窗口占用CPU过高
end;

procedure TFrmMain.AppLogout;
begin
  if mrOk = FrmDlg.DMessageDlg('您想退出到选择角色界面吗？', [mbOk, mbCancel]) then
  begin
    SendClientMessage(CM_SOFTCLOSE, 0, 0, 0, 0);
    PlayScene.ClearActors;
    CloseAllWindows;
    SaveNgInfo;
{$IFDEF RELEASE}
    LoadingWaitTime := 0;
{$ENDIF}
    if not BoOneClick then
    begin
      SoftClosed := TRUE;
      ActiveCmdTimer(tcSoftClose);
    end
    else
    begin
      ActiveCmdTimer(tcReSelConnect);
    end;
//    if BoBagLoaded then
//      Savebags('.\Data\' + ServerName + '.' + CharName + '.itm', @ItemArr);

//    BoBagLoaded := FALSE;
  end;
end;

procedure TFrmMain.AppExit;  //游戏窗口化右上角关闭游戏提示语
begin
  if mrOk = FrmDlg.DMessageDlg('您确定要退出传奇吗？', [mbOk, mbCancel]) then
  begin
//    if BoBagLoaded then
//      Savebags('.\Data\' + ServerName + '.' + CharName + '.itm', @ItemArr);
//
//    BoBagLoaded := FALSE;
    SaveNgInfo;
    Application.Terminate;
  end;
end;

procedure TfrmMain.PrintScreenNow;
  function IntToStr2(n: integer): string;
  begin
    if n < 10 then
      Result := '0' + IntToStr(n)
    else
      Result := IntToStr(n);
  end;
var
  flname: string;
  bmp: TBitmap;
  dc: HDC;
  lpPal: PLOGPALETTE;
  n: Integer;
begin
  if not DirectoryExists('.\Images') then CreateDir('.\Images');
  while TRUE do
  begin
    flname := '.\Images\' + ServerName + '_Images' + IntToStr2(CaptureSerial) + '.bmp';
    if not FileExists(flname) then
      break;
    Inc(CaptureSerial);
  end;
  bmp := TBitmap.Create;
  bmp.PixelFormat := pf16bit;
  bmp.Width := frmMain.ClientWidth;
  bmp.Height := frmMain.ClientHeight;
  dc := GetDC(0);
  if (dc = 0) then
    exit;
  if (GetDeviceCaps(dc, RASTERCAPS) and RC_PALETTE = RC_PALETTE) then
  begin
    GetMem(lpPal, sizeof(TLOGPALETTE) + (255 * sizeof(TPALETTEENTRY)));
    FillChar(lpPal^, sizeof(TLOGPALETTE) + (255 * sizeof(TPALETTEENTRY)), #0);
    lpPal^.palVersion := $300;
    lpPal^.palNumEntries := GetSystemPaletteEntries(dc, 0, 256, lpPal^.palPalEntry);
    if (lpPal^.PalNumEntries <> 0) then
    begin
      bmp.Palette := CreatePalette(lpPal^);
    end;
    FreeMem(lpPal, sizeof(TLOGPALETTE) + (255 * sizeof(TPALETTEENTRY)));
  end;
  BitBlt(bmp.Canvas.Handle, 0, 0, bmp.Width, bmp.Height, Dc, frmMain.ClientOrigin.X, frmMain.ClientOrigin.Y, SRCCOPY);
  ReleaseDC(0, dc);

  n := 0;
  bmp.Canvas.Brush.Style := bsClear;
  bmp.Canvas.Font.Color := clWhite;
  if MySelf <> nil then
  begin
    bmp.Canvas.TextOut(0, 0, ServerName + ' ' + MySelf.UserName);
    n := 1;
  end;
  bmp.Canvas.TextOut(0, (n) * 12, 'Version=' + IntToStr(ClientVersion));
  bmp.Canvas.TextOut(0, (n + 1) * 12, DateToStr(Date));
  bmp.Canvas.TextOut(0, (n + 2) * 12, TimeToStr(Time));
  bmp.SaveToFile(flName);
  bmp.Free;

  DScreen.AddChatBoardString('[屏幕截图：' +ServerName + '_Images' +
    IntToStr2(CaptureSerial) + '.bmp'+']', clGreen, clWhite)
end;

{------------------------------------------------------------}

procedure TFrmMain.ProcessKeyMessages;
begin
  case ActionKey of
    VK_F1, VK_F2, VK_F3, VK_F4, VK_F5, VK_F6, VK_F7, VK_F8:
      begin
        UseMagic(MouseX, MouseY, GetMagicByKey(AnsiChar((ActionKey - VK_F1) + byte('1')))); //屏幕坐标
            //DScreen.AddSysMsg ('KEY' + IntToStr(Random(10000)));
        ActionKey := 0;
        TargetX := -1;
        exit;
      end;
      // 2003/08/20 =>添加魔法快捷键  // AddMagicKey
    VK_F1 - 100, VK_F2 - 100, VK_F3 - 100, VK_F4 - 100, VK_F5 - 100, VK_F6 - 100, VK_F7 - 100, VK_F8 - 100:
      begin
        UseMagic(MouseX, MouseY, GetMagicByKey(AnsiChar((ActionKey - (VK_F1 - 100)) + byte('1') + 20))); //屏幕坐标
        ActionKey := 0;
        TargetX := -1;
        exit;
      end;
      //-----------
  end;
end;

procedure TFrmMain.ProcessActionMessages;
var
  mx, my, dx, dy, crun: integer;
  ndir, adir, mdir: byte;
  bowalk, bostop: Boolean;
  stdcount: integer;
label
  LB_WALK;
begin
  if Myself = nil then
    exit;

   //Move
  if (TargetX >= 0) and CanNextAction and ServerAcceptNextAction then
  begin //ActionLock当它被释放时，ActionLock 在操作完成之前被释放。
    if (TargetX <> Myself.XX) or (TargetY <> Myself.YY) then
    begin
      mx := Myself.XX;
      my := Myself.YY;
      dx := TargetX;
      dy := TargetY;
      ndir := GetNextDirection(mx, my, dx, dy);
      case ChrAction of
        caWalk:
          begin
LB_WALK:
               //DScreen.AddSysMsg ('caWalk ' + IntToStr(Myself.XX) + ' ' +
               //                               IntToStr(Myself.YY) + ' ' +
               //                               IntToStr(TargetX) + ' ' +
               //                               IntToStr(TargetY));
            crun := Myself.CanWalk;
            if IsUnLockAction(CM_WALK, ndir) and (crun > 0) then
            begin
              GetNextPosXY(ndir, mx, my);
              bowalk := TRUE;
              bostop := FALSE;
              if not PlayScene.CanWalk(mx, my) then
              begin
                bowalk := FALSE;
                adir := 0;
                if not bowalk then
                begin  //入口检查
                  mx := Myself.XX;
                  my := Myself.YY;
                  GetNextPosXY(ndir, mx, my);
                  if CheckDoorAction(mx, my) then
                    bostop := TRUE;
                end;
                if not bostop and not PlayScene.CrashMan(mx, my) then
                begin //人不自动躲避..
                  mx := Myself.XX;
                  my := Myself.YY;
                  adir := PrivDir(ndir);
                  GetNextPosXY(adir, mx, my);
                  if not Map.CanMove(mx, my) then
                  begin
                    mx := Myself.XX;
                    my := Myself.YY;
                    adir := NextDir(ndir);
                    GetNextPosXY(adir, mx, my);
                    if Map.CanMove(mx, my) then
                      bowalk := TRUE;
                  end
                  else
                    bowalk := TRUE;
                end;
                if bowalk then
                begin
                  Myself.UpdateMsg(CM_WALK, mx, my, adir, 0, 0, '', 0);
                  LastMoveTime := GetTickCount;
                end
                else
                begin
                  mdir := GetNextDirection(Myself.XX, Myself.YY, dx, dy);
                  if mdir <> Myself.Dir then
                    Myself.SendMsg(CM_TURN, Myself.XX, Myself.YY, mdir, 0, 0, '', 0);
                  TargetX := -1;
                end;
              end
              else
              begin
                Myself.UpdateMsg(CM_WALK, mx, my, ndir, 0, 0, '', 0);
                LastMoveTime := GetTickCount;
              end;
            end
            else
            begin
              TargetX := -1;
            end;
          end;
        caRun:
          begin
            if g_bo免助跑 then
              stdcount := 0 //0为取消助跑  1需要助跑
            else begin
              stdcount := 1;
//              if Myself.OpenStruck then
//                RunReadyCount := -3; //-1=2步，-2=3步...以此类推，逃生步数
            end;
            if (MySelf.State and $01000000) <> 0 then
              stdcount := 0;

            if RunReadyCount >= stdcount {1} then
            begin
              Myself.OpenStruck := False;
              crun := Myself.CanRun;
              if (GetDistance(mx, my, dx, dy) >= 2) and (crun > 0) then
              begin
                if IsUnLockAction(CM_RUN, ndir) then
                begin
                  GetNextRunXY(ndir, mx, my);
                  if PlayScene.CanRun(Myself.XX, Myself.YY, mx, my) then
                  begin
                    Myself.UpdateMsg(CM_RUN, mx, my, ndir, 0, 0, '', 0);
                    LastMoveTime := GetTickCount;
                  end
                  else
                  begin
                    mx := Myself.XX;
                    my := Myself.YY;
                    goto LB_WALK;
                  end;
                end
                else
                  TargetX := -1;
              end
              else
              begin
                     //if crun = -1 then begin
                        //DScreen.AddSysMsg ('瘤陛篮 钝 荐 绝嚼聪促.');
                        //TargetX := -1;
                     //end;
                goto LB_WALK;     //眉仿捞 绝绰版快.
                     {if crun = -2 then begin
                        DScreen.AddSysMsg ('泪矫饶俊 钝 荐 乐嚼聪促.');
                        TargetX := -1;
                     end; }
              end;
            end
            else
            begin
              Inc(RunReadyCount);
              goto LB_WALK;
            end;
          end;
      end;
    end;
  end;
  TargetX := -1; //一次一个空间..
  if Myself.RealActionMsg.Ident > 0 then
  begin
    FailAction := Myself.RealActionMsg.Ident; //为失败做准备
    FailDir := Myself.RealActionMsg.Dir;
    FailActionTime := GetTickCount;
    if Myself.RealActionMsg.Ident = CM_SPELL then
    begin
      SendSpellMsg(Myself.RealActionMsg.Ident, Myself.RealActionMsg.X, Myself.RealActionMsg.Y, Myself.RealActionMsg.Dir, Myself.RealActionMsg.State);
    end
    else
      SendActMsg(Myself.RealActionMsg.Ident, Myself.RealActionMsg.X, Myself.RealActionMsg.Y, Myself.RealActionMsg.Dir);
    Myself.RealActionMsg.Ident := 0;

      //收到菜单后，如果你走超过10步，它会自动消失。
    if MDlgX <> -1 then
      if (abs(MDlgX - Myself.XX) >= 8) or (abs(MDlgY - Myself.YY) >= 8) then
      begin
        FrmDlg.CloseMDlg;
        FrmDlg.SafeCloseDlg;

{            if(FrmDlg.DMakeItemDlg.Visible) then
               FrmDlg.DMakeItemDlgOkClick(FrmDlg.DMakeItemDlgCancel, 0, 0);
            if FrmDlg.DItemMarketDlg.Visible then FrmDlg.CloseItemMarketDlg;
            if(FrmDlg.DJangwonListDlg.Visible) then
               FrmDlg.DJangwonCloseClick(FrmDlg.DJangwonClose, 0, 0);
            if(FrmDlg.DGABoardListDlg.Visible) then
               FrmDlg.DGABoardListCloseClick(FrmDlg.DGABoardListClose, 0, 0);
            if(FrmDlg.DGABoardDlg.Visible) then
               FrmDlg.DGABoardCloseClick(FrmDlg.DGABoardClose, 0, 0);}

        MDlgX := -1;
      end;
  end;
end;

procedure TFrmMain.FormKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);
var
  msg, wc, dir, mx, my: integer;
  ini: TIniFile;
  TempStr: string;
begin
//  DScreen.AddChatBoardString ('FormKeyDown Key=> '+IntToStr(Key), clGreen, clWhite);
  if Key = VK_CONTROL then boWhisperLen := True;
  case Key of
    VK_PAUSE:
      begin
        Key := 0;
        PrintScreenNow;
      end;
//    {$IFDEF DEBUG}
//    VK_RETURN: begin
//        if (ssAlt in Shift) and (Key = VK_RETURN) then begin
//          Key := 0;
//          FullScreen(not g_boFullScreen);
//          Exit;
//        end;
//      end;
//    {$ELSE}
//    VK_RETURN: begin
//        if (ssAlt in Shift) and (Key = VK_RETURN) then begin
//          Key := 0;
//          if g_boLockFullScreen then Exit;
//          FullScreen(not g_boFullScreen);
//          Exit;
//        end;
//      end;
//    {$ENDIF}
  end;
  if ssCtrl in Shift then boWhisperLen := True;
//  //增加全屏窗口切换
//  if (ssAlt in Shift) and (Key = VK_RETURN) then begin
//    FullScreen(not g_boFullScreen);
  //end;

  if g_DWinMan.KeyDown(Key, Shift) then
    exit;

  if (Myself = nil) or (DScreen.CurrentScene <> PlayScene) then
    exit;

//   if PlayScene.EdChat.Visible then begin
//      exit;
//   end;
  if (ssShift in Shift) then
  begin
    if g_NgConfigInfo.boNotNeedShift then
      if g_boShiftUp then
      begin
        g_boShiftUp := False;
      end;
  end;



  mx := Myself.XX;
  my := Myself.YY;
  case Key of
    VK_F1, VK_F2, VK_F3, VK_F4, VK_F5, VK_F6, VK_F7, VK_F8:
    begin
       if MySelf.m_StallMgr.OnSale then //
        begin
        //
        Exit;
        end;
      if ssCtrl in Shift then
      begin
        if (GetTickCount - LatestSpellTime > (g_MAGICSPEED{500} + MagicDelayTime)) then      //技能间隔延迟 默认是500
        begin
          ActionKey := Key - 100;
        end;
        Key := 0;
      end
      else
      begin //-----
                  if g_NgConfigInfo.boAutoMagic  then begin
               g_NgConfigInfo.boAutoMagic := False;
               FrmDlg.DCheckSdoAutoMagic.Checked := False;
               DScreen.AddChatBoardString('自动练功结束', clGreen, clWhite);    //解决自动练功连续魔法问题。
            end;
        if (GetTickCount - LatestSpellTime > (g_MAGICSPEED{500} + MagicDelayTime)) then
        begin
          ActionKey := Key;
        end;
        Key := 0;
      end;
    end;
    VK_F9:
      begin
        FrmDlg.OpenItemBag;
      end;
    VK_F10:
      begin
        FrmDlg.StatePage := 0;
        FrmDlg.OpenMyStatus;
        Key := 0
      end;
    VK_F11:
      begin
        FrmDlg.StatePage := 3;
        FrmDlg.OpenMyStatus;
      end;
    Vk_F12:
      begin
        if g_boMirNg then
          FrmDlg.DOptionClick(Self);

        Key := 0
      end;

{    VK_RETURN:
        begin
          PlayScene.EdChat.Visible := TRUE;
          PlayScene.EdChat.SetFocus;
          SetImeMode(PlayScene.EdChat.Handle, imOpen);
          if FrmDlg.BoGuildChat then
          begin
            PlayScene.EdChat.Text := '!~';
            PlayScene.EdChat.SelStart := Length(PlayScene.EdChat.Text);
            PlayScene.EdChat.SelLength := 0;
          end
          else
          begin
            PlayScene.EdChat.Text := '';
          end;
//               LocalLanguage := imSAlpha;
        end; }

    word('R'):
      begin
        if (ssAlt in Shift) and (GetTickCount > m_CheckTick) then
        begin
          m_CheckTick := GetTickCount + 1000;
          SendClientMessage(CM_QUERYBAGITEMS, 0, 0, 0, 0);
        end;
      end;
    word('H'):
      begin
        if ssCtrl in Shift then
        begin
          SendSay('@AttackMode');
        end;
      end;
    word('A'):
      begin
        if ssCtrl in Shift then
        begin
          SendSay('@Rest');
        end;
      end;
    word('F'):
      begin
        if ssCtrl in Shift then
        begin

        end;
      end;
    word('X'):
      begin
        if Myself = nil then
          exit;
         if ssAlt in Shift then
         begin
           if g_bo战斗退出 then
           begin
            AppLogOut;
           end;

           if (not g_bo战斗退出) then
           begin
           if (GetTickCount - LatestStruckTime > 10000) and
              (GetTickCount - LatestMagicTime > 10000) and
              (GetTickCount - LatestHitTime > 10000) or
              (Myself.Death) then
               begin
                  FrmMain.SendClientMessage(CM_CANCLOSE, 0, 0, 0, 0);
               end
               else
                 DScreen.AddChatBoardString('在战斗的时候你不能退出游戏', clYellow, clRed);
           end;


  {               if (GetTickCount - LatestStruckTime > 10000) and
                    (GetTickCount - LatestMagicTime > 10000) and
                    (GetTickCount - LatestHitTime > 10000) or
                    (Myself.Death) then
                 begin
                    AppLogOut;
                 end else
                    DScreen.AddChatBoardString ('在战斗的时候你不能退出游戏', clYellow, clRed);}

         end;
      end;
      word('W'): begin
        if GetTickCount - g_dwKeyTimeTick > 200 then begin
          g_dwKeyTimeTick := GetTickCount;
          if ssAlt in Shift then begin  //添加编组
            if FocusCret <> nil then
               if GroupMembers.Count = 0 then
                  SendCreateGroup(FocusCret.UserName)
               else SendAddGroupMember(FocusCret.UserName);
          end;
        end;
      end;
      word('E'): begin
        if GetTickCount - g_dwKeyTimeTick > 200 then begin
          g_dwKeyTimeTick := GetTickCount;
          if ssAlt in Shift then begin  //删除队员
            if FocusCret <> nil then
              SendDelGroupMember(FocusCret.UserName)
          end;
        end;
      end;
     word('Q'):
      begin
        if Myself = nil then
          exit;
        if ssAlt in Shift then
        begin
          if g_bo战斗退出 then
          begin
           AppExit;
          end;
          if (not g_bo战斗退出) then
          begin
          if (GetTickCount - LatestStruckTime > 10000) and
             (GetTickCount - LatestMagicTime > 10000) and
             (GetTickCount - LatestHitTime > 10000) or
             (Myself.Death) then
            begin
              AppExit;
            end
            else
            DScreen.AddChatBoardString('在战斗的时候你不能退出游戏', clYellow, clRed);
          end;
        end;
      end;
  end;
  case Key of
    VK_UP:
      if (ssCtrl in Shift) and FrmDlg.DEdChat.Visible then begin
        if g_SendSayListIdx > 0 then
          Dec(g_SendSayListIdx);
        if g_SendSayListIdx < g_SendSayList.count then
          FrmDlg.DEdChat.Text := g_SendSayList[g_SendSayListIdx];
        Key := 0;
      end else begin
        with DScreen do
          if ChatBoardTop > 0 then begin
            Dec(ChatBoardTop);
          end;
      end;
    VK_DOWN:
      if (ssCtrl in Shift) and FrmDlg.DEdChat.Visible then begin
        if g_SendSayListIdx < g_SendSayList.count - 1 then
          Inc(g_SendSayListIdx);
        if g_SendSayListIdx < g_SendSayList.count then
          FrmDlg.DEdChat.Text := g_SendSayList[g_SendSayListIdx];
        Key := 0;
      end else begin
        with DScreen do begin
          if ChatBoardTop < ChatStrs.count - 1 then begin
            Inc(ChatBoardTop);
          end;
        end;
      end;
    VK_PRIOR:
      with DScreen do
      begin
        if ChatBoardTop > VIEWCHATLINE then
          ChatBoardTop := ChatBoardTop - VIEWCHATLINE
        else
          ChatBoardTop := 0;
      end;
    VK_NEXT:
      with DScreen do
      begin
        if ChatBoardTop + VIEWCHATLINE < ChatStrs.Count - 1 then
          ChatBoardTop := ChatBoardTop + VIEWCHATLINE
        else
          ChatBoardTop := ChatStrs.Count - 1;
        if ChatBoardTop < 0 then
          ChatBoardTop := 0;
      end;
  end;
end;

procedure TFrmMain.FormKeyPress(Sender: TObject; var Key: Char);
var
  i: integer;
begin
//  DScreen.AddChatBoardString ('FormKeyPress Key=> '+IntToStr(byte(Key)), clGreen, clWhite);
  if FrmDlg.DSelServerDlg.Visible then
  begin
//          MessageDlg ('FormKeyPress Key=> '+IntToStr(byte(Key)), mtWarning, [mbOk], 0);
    case byte(Key) of
      byte('1'):
        FrmDlg.DSServer1Click(FrmDlg.DSServer1, 1, 1);
      byte('2'):
        FrmDlg.DSServer1Click(FrmDlg.DSServer2, 1, 1);
      byte('3'):
        FrmDlg.DSServer1Click(FrmDlg.DSServer3, 1, 1);
      byte('4'):
        FrmDlg.DSServer1Click(FrmDlg.DSServer4, 1, 1);
      byte('5'):
        FrmDlg.DSServer1Click(FrmDlg.DSServer5, 1, 1);
      byte('6'):
        FrmDlg.DSServer1Click(FrmDlg.DSServer6, 1, 1);
      byte('7'):
        FrmDlg.DSServer1Click(FrmDlg.DSServer7, 1, 1);
      byte('8'):
        FrmDlg.DSServer1Click(FrmDlg.DSServer8, 1, 1);
    end;
    Exit;
  end;

  if g_DWinMan.KeyPress(Key) then
    exit;

  if (byte(Key) = 13) and FrmDlg.DSelectChr.Visible and (not FrmDlg.DCreateChr.Visible) then
  begin
    SelectChrScene.SelChrStartClick;
    Exit;
  end;

  if DScreen.CurrentScene = PlayScene then
  begin
  //  FrmDlg.EdChatKeyPress(Sender,Key);//打开输入   2022/6/2
   // if FrmDlg.DEdChat.Visible and (FrmDlg.DEdChat <> MouseCaptureControl) or  (FrmDlg.DCountDlgCancel.Visible)then begin
   if FrmDlg.DEdChat.Visible or FrmDlg.DCountDlg.Visible or FrmDlg.DGABoardDlg.Visible or FrmDlg.DMemo.Visible and (FrmDlg.DEdChat <> MouseCaptureControl)  then begin
      frmMain.SendSay(FrmDlg.DEdChat.Text);
      FrmDlg.DEdChat.Text := '';
      FrmDlg.DEdChat.Visible := False;
//      Key := #0;


//     FrmDlg.DEdChat.SetFocus;
      Exit;
    end;
//    if FrmDlg.DEdChat.Visible then
//    begin
//      exit;
//    end;
    case byte(Key) of
{$ifdef Debug}     //窗口调试
      Byte('L'), Byte('l'):
        if not frmDlgConfig.Showing then
          frmDlgConfig.Open;   //调试窗口位置
{$endif}
//      byte('I'), byte('i'):
//        begin
//          FrmDlg.OpenItemBag;
//        end;
//      byte('C'), byte('c'):
//        begin
//          FrmDlg.StatePage := 0;
//          FrmDlg.OpenMyStatus;
//        end;
//      byte('S'), byte('s'):
//        begin
//          FrmDlg.StatePage := 3;
//          FrmDlg.OpenMyStatus;
//        end;
//      byte('A'), byte('a'):
//        begin
//          SendSay('@Rest');
//        end;


        //取消显示翅膀效果快捷键
//      byte('K'), byte('k'):
//        begin
//          BoViewEffect := not BoViewEffect;
//          if BoViewEffect then
//            DScreen.AddChatBoardString('<显示翅膀效果>', clGreen, clWhite)
//          else
//            DScreen.AddChatBoardString('<不显示翅膀效果>', clGreen, clWhite)
//        end;
      byte('O'), byte('o'):
        FrmDlg.DMyStateClick(FrmDlg.DOption, 0, 0);
//      byte('`'):
//        begin
//          SendPickup;
//          TabClickTime := GetTickCount;
//        end;
//      byte('V'), byte('v'):
//        begin
//          FrmDlg.DBotMiniMapClick(nil, 0, 0);
//        end;

        //取消B键大地图功能
//      byte('B'), byte('b'):
//        begin
//          FrmMain.SendWantMiniMap;
//          if ViewGeneralMapStyle < 2 then
//          begin
//            Inc(ViewGeneralMapStyle);
//          end
//          else
//            ViewGeneralMapStyle := 0;
//        end;


            // 取消U键月灵快速绘制
//      byte('U'), byte('u'):
//        begin
//          if AngelFastDraw then
//          begin
//            AngelFastDraw := False;
//            DScreen.AddChatBoardString('<月灵的快速绘制开启>', clGreen, clWhite)
//          end
//          else
//          begin
//            AngelFastDraw := True;
//            DScreen.AddChatBoardString('<月灵的快速绘制关闭>', clGreen, clWhite)
//          end;
//        end;
          //隐藏尸体
          byte('Q'), byte('q'):
             begin
                if not g_NgConfigInfo.boNotDeath and not g_boMirNg then begin
                   g_NgConfigInfo.boNotDeath := True;
                   DScreen.AddChatBoardString ('[开启:隐藏尸体]', clGreen, clWhite)
                end
                else begin
                if g_NgConfigInfo.boNotDeath and not g_boMirNg then begin
                   g_NgConfigInfo.boNotDeath := False;
                   DScreen.AddChatBoardString ('[关闭:隐藏尸体]', clGreen, clWhite)
                end;
               end;
             end;



                   //人物显名开关，若开启人物显名，需关闭攻城区域显名
          byte('N'), byte('n'):
             begin
                if g_boShowName and not g_boMirNg then begin
                   g_boShowName := False;
                   DScreen.AddChatBoardString ('[关闭:人物显名]', clGreen, clWhite)
                end
                else begin
                if not g_boMirNg then begin
                   g_boShowName := True;
                   DScreen.AddChatBoardString ('[开启:人物显名]', clGreen, clWhite)
                end;
               end;
             end;

          byte('・'),byte('`'):
            begin
                SendPickup;
              TabClickTime := GetTickCount;
            end;

      byte('D'), byte('d'): //自动跑路
        begin
          RunReadyCount := 0;
          if gAutoRun then
          begin
            gAutoRun := False;
            DScreen.AddChatBoardString('<设置:停止跑不停>', clGreen, clWhite)
          end
          else
         begin
            gAutoRun := True;
            DScreen.AddChatBoardString('<设置:开启跑不停>', clGreen, clWhite)
         end;
         end;


      byte('P'), byte('p'):
        begin
          FrmDlg.DBotGroupClick(nil, 0, 0);
        end;
      byte('T'), byte('t'):
        begin
          FrmDlg.DBotTradeClick(nil, 0, 0);
        end;
      byte('G'), byte('g'):
        begin
          FrmDlg.DBotGuildClick(nil, 0, 0);
        end;


//      byte('W'), byte('w'):
//        begin
//          FrmDlg.DBotFriendClick(nil, 0, 0);
//        end;
//         //  邮件快捷键
//      byte('M'), byte('m'):
//        begin
//          FrmDlg.DBotMemoClick(nil, 0, 0);
//        end;
//         //  关系快捷键
//      byte('L'), byte('l'):
//        begin
//          FrmDlg.DBotMasterClick(nil, 0, 0);
//        end;

      byte('1')..byte('6'):
        begin
        //  FrmDlg.SwapBujuk(byte(Key) - byte('1'));

          StBeltAutoFill := True;
          EatItem(byte(Key) - byte('1')); //骇飘 酒捞袍阑 荤侩茄促.
        end;
      27: //ESC
        begin
          CloseAllWindows;    //关闭所有游戏内打开的快捷窗口
        end;
      byte(' '), 13: //盲泼 冠胶          //这里打开输入
        begin
          FrmDlg.DEdChat.Visible := TRUE;
          FrmDlg.DEdChat.SetFocus;
//          SetImeMode(PlayScene.EdChat.Handle, imOpen);
          if FrmDlg.BoGuildChat then
          begin
            FrmDlg.DEdChat.Text := '!~';
            FrmDlg.DEdChat.ChangeCurPos(AnsiTextLength(FrmDlg.DEdChat.Text), True);  //ASP修改
            FrmDlg.DEdChat.SelStart := AnsiTextLength(FrmDlg.DEdChat.Text);
            FrmDlg.DEdChat.SelLength := 0;
          end
          else
          begin
            FrmDlg.DEdChat.Text := '';
          end;
//               LocalLanguage := imSAlpha;
        end;
      byte('@'), byte('!'), byte(','), byte('/'):
        begin
          FrmDlg.DEdChat.Visible := TRUE;
          FrmDlg.DEdChat.SetFocus;
          LocalLanguage := imSHanguel;
//          SetImeMode(PlayScene.EdChat.Handle, LocalLanguage);
          if Key = '/' then
          begin
            if WhisperName = '' then
              FrmDlg.DEdChat.Text := Key
            else if Length(WhisperName) > 2 then
              FrmDlg.DEdChat.Text := '/' + WhisperName + ' '
            else
              FrmDlg.DEdChat.Text := Key;
              FrmDlg.DEdChat.ChangeCurPos(AnsiTextLength(FrmDlg.DEdChat.Text), True);
              FrmDlg.DEdChat.SelStart := Length(FrmDlg.DEdChat.Text);
              FrmDlg.DEdChat.SelLength := 0;
          end
          else if Key = ',' then
          begin
            if Copy(fLover.GetDisplay(0), length(STR_LOVER) + 1, 6) <> '' then
              FrmDlg.DEdChat.Text := '⒔'
            else
              FrmDlg.DEdChat.Text := Key;
              FrmDlg.DEdChat.ChangeCurPos(AnsiTextLength(FrmDlg.DEdChat.Text), True);
              FrmDlg.DEdChat.SelStart := Length(FrmDlg.DEdChat.Text);
              FrmDlg.DEdChat.SelLength := 0;
          end
          else
          begin
            FrmDlg.DEdChat.Text := Key;
            FrmDlg.DEdChat.ChangeCurPos(AnsiTextLength(FrmDlg.DEdChat.Text), True);
            FrmDlg.DEdChat.SelStart := 1;
            FrmDlg.DEdChat.SelLength := 0;
          end;
          LocalLanguage := imSAlpha;
        end;
    end;
    Key := #0;
  end;
end;

function TFrmMain.GetMagicByKey(Key: AnsiChar): PTClientMagic;
var
  i: integer;
  pm: PTClientMagic;
begin
  Result := nil;
  for i := 0 to MagicList.Count - 1 do
  begin
    pm := PTClientMagic(MagicList[i]);
    if pm.Key = Key then
    begin
      Result := pm;
      break;
    end;
  end;
end;

function TFrmMain.FindMagicId(ID: integer): PTClientMagic;
var
  i: integer;
  pm: PTClientMagic;
begin
  Result := nil;
  for i := 0 to MagicList.Count - 1 do
  begin
    pm := PTClientMagic(MagicList[i]);
    if pm.Def.MagicId = ID then
    begin
      Result := pm;
      break;
    end;
  end;
end;

function TfrmMain.FindMagicName(body: string): PTClientMagic;
var
  I: Integer;
  pm: PTClientMagic;
begin
  Result := nil;
  for I := 0 to MagicList.Count - 1 do
  begin
    pm := PTClientMagic(MagicList[I]);
    if pm.Def.MagicName = body then
    begin
      Result := pm;
      Break;
    end;
  end;
end;

var
  g_dwOverSpaceWarningTick: LongWord;

procedure TFrmMain.UseMagic(tx, ty: integer; pcm: PTClientMagic);
var
  tdir, targx, targy, targid: integer;
  pmag: PTUseMagicInfo;
  meff: TMagicEff;
  TempTarget: TActor;
  SpellSpend: word;
label
  NoLock;
begin
  if pcm = nil then
    exit;
  TempTarget := nil;
//   if (pcm.Def.Spell + pcm.Def.DefSpell <= Myself.Abil.MP) or (pcm.Def.EffectType = 0) then begin
  SpellSpend := Round(pcm.Def.Spell / (pcm.Def.MaxTrainLevel + 1) * (pcm.Level + 1)) + pcm.Def.DefSpell;
  if (SpellSpend <= Myself.Abil.MP) or (pcm.Def.EffectType = 0) then
  begin
    if pcm.Def.EffectType = 0 then
    begin
         //if CanNextAction and ServerAcceptNextAction then begin
      if pcm.Def.MagicId = SWD_FIREHIT then
      begin
        if GetTickCount - LatestFireHitTime < 10 * 1000 then
        begin
          exit;
        end;
      end;

      if pcm.Def.MagicId = SWD_RUSHRUSH then
      begin
        if GetTickCount - LatestRushRushTime < 3 * 1000 then
        begin
          exit;
        end;
      end;

      if pcm.Def.MagicId = SWD_TWINHIT then
      begin
        BoStopAfterAttack := TRUE;
        if BoViewEffect then
        begin
          meff := TCharEffect.Create(210, 6, MySelf);
          meff.NextFrameTime := 120;
          meff.ImgLib := WMagic2;
          PlayScene.EffectList.Add(meff);
        end;
      end;

      if GetTickCount - LatestSpellTime > g_MAGICSPEED{500} then
      begin
        LatestSpellTime := GetTickCount;
        MagicDelayTime := 0; //pcm.Def.DelayTime;
        SendSpellMsg(CM_SPELL, Myself.Dir{x}, 0, pcm.Def.MagicId, 0);
      end else begin
      end;
    end
    else
    begin
      tdir := GetFlyDirection(390, 175, tx, ty);

//      TurnDuFu(pcm);

      if (pcm.Def.MagicId in [1, 5, 6, 11, 13, 32, 35, 39, 46, 48, 49]) and  (g_bo锁定人物 and g_bo锁定怪物) then
      begin   //魔法锁定人物或者怪物
        TargetCase := 1;
        if (FocusCret <> nil) and not FocusCret.Death then
        case FocusCret.Race of
          0:
            begin
              if g_bo锁定人物 then
                MagicTarget := FocusCret
              else goto NoLock;
            end;
        else
          begin
            if g_bo锁定怪物 then
              MagicTarget := FocusCret
            else goto NoLock;
          end;
        end;
      end
      else
      begin
        NoLock:
//        if autotarget <> nil then AutoTarget := nil;
        TargetCase := 2;
        if (FocusCret <> nil) and (not FocusCret.Death) then
        begin
            AutoTarget := FocusCret;
        end;
        if (AutoTarget <> nil) and AutoTarget.Death then
          AutoTarget := nil;
      end;

      if TargetCase = 2 then begin
        if (AutoTarget <> nil) and (pcm.Def.MagicId in [1, 5, 6, 11, 13,32, 35, 39, 46, 48, 49]) then
        case AutoTarget.Race of
          0:
            begin
              if g_bo锁定人物 then
                TempTarget := AutoTarget
              else
                if autotarget <> nil then AutoTarget := nil;
            end;
        else
          begin
            if g_bo锁定怪物 then
              TempTarget := AutoTarget
            else
              if autotarget <> nil then AutoTarget := nil;
          end;
        end;

      end
      else
      begin
        if (pcm.Def.MagicId in [1, 5, 6, 11, 13,32, 35, 39, 46, 48, 49]) then
          TempTarget := MagicTarget
      end;
      if (TempTarget = nil) or (TempTarget <> FocusCret) then
      begin
        if (FocusCret <> nil) and (not FocusCret.Death) then
          TempTarget := FocusCret;
      end;
      if (not PlayScene.IsValidActor(TempTarget)) and (TempTarget <> nil) and (not TempTarget.Death) then
        TempTarget := nil;

      if TargetCase = 1 then
        MagicTarget := TempTarget;

       if pcm.Def.MagicId in [52, 53, 55, 56] then    //22022/5/9加
            AutoTarget := nil;

      if (TempTarget = nil) or TempTarget.Death then
      begin
        PlayScene.CXYfromMouseXY(tx, ty, targx, targy);
        targid := 0;
      end
      else
      begin
        targx := TempTarget.XX;
        targy := TempTarget.YY;
        targid := TempTarget.RecogId;
      end;

      if not (pcm.Def.Effect in [2,6,15,16,19,22,28,29,35,36,41,43,45,50,51,58]) then begin
         if (abs(MySelf.XX - targx) > 8) or (abs(MySelf.YY - targy) > 8) then begin
            if GetTickCount - g_dwOverSpaceWarningTick > 1000 then begin
                g_dwOverSpaceWarningTick := GetTickCount;
                DScreen.AddSysMsg('目标太远了，施展魔法失败！！！');
            end;
            Exit;
           end;
         end;

      if CanNextAction and ServerAcceptNextAction then
      begin
        LatestSpellTime := GetTickCount;
        new(pmag);
        FillChar(pmag^, sizeof(TUseMagicInfo), #0);
        pmag.EffectNumber := pcm.Def.Effect;
        pmag.MagicSerial := pcm.Def.MagicId;
        pmag.ServerMagicCode := 0;
        MagicDelayTime := 200 + pcm.Def.DelayTime;

        TurnDuFu(pcm);

        case pmag.MagicSerial of 2, 14, 15, 16, 17, 18, 19, 21, 12, 25, 26, 28, 29, 30, 31, 40, 41, 42, 43, 50, 51, 58:
        else
          LatestMagicTime := GetTickCount;
        end;
        //魔法攻击人物时是否能立马跑动。
        MagicPKDelayTime := 0;
        if MagicTarget <> nil then
          if MagicTarget.Race = 0 then
          if g_bo免助跑 then
           begin
          //MagicPKDelayTime := 300 + Random(1100);
            MagicPKDelayTime := 100 + Random(50); //(600+200 + MagicDelayTime div 5);
            end else begin
              MagicPKDelayTime := 300 + Random(1100);
            end;
        tdir := GetFlyDirection (Myself.XX, Myself.YY, targx, targy);

        Myself.SendMsg(CM_SPELL, targx, targy, tdir, Integer(pmag), targid, '', 0);
      end; // else
            //Dscreen.AddSysMsg ('过一会你就可以用它了.');
         //Inc (SpellCount);
    end;
  end
  else
    Dscreen.AddSysMsg('没有足够的魔法点数.');
end;

procedure TFrmMain.UseMagicSpell(who, effnum, targetx, targety, magic_id: integer);
var
  actor: TActor;
  adir: integer;
  pmag: PTUseMagicInfo;
begin
  actor := PlayScene.FindActor(who);
  if actor <> nil then
  begin
    adir := GetFlyDirection(actor.XX, actor.YY, targetx, targety);
    new(pmag);
    FillChar(pmag^, sizeof(TUseMagicInfo), #0);
    pmag.EffectNumber := effnum;
    pmag.ServerMagicCode := 0;
    pmag.MagicSerial := magic_id;
    actor.SendMsg(SM_SPELL, 0, 0, adir, Integer(pmag), 0, '', 0);
    Inc(SpellCount);
  end
  else
    Inc(SpellFailCount);
end;

procedure TFrmMain.UseMagicFire(who, efftype, effnum, targetx, targety, target: integer);
var
  actor: TActor;
  adir, sound: integer;
  pmag: PTUseMagicInfo;
begin
  actor := PlayScene.FindActor(who);
  if actor <> nil then
  begin
    actor.SendMsg(SM_MAGICFIRE, target{111magid}, efftype, effnum, targetx, targety, '', sound);
      //if actor = Myself then Dec (SpellCount);
    if FireCount < SpellCount then
      Inc(FireCount);
  end;
end;

procedure TFrmMain.UseMagicFireFail(who: integer);
var
  actor: TActor;
begin
  actor := PlayScene.FindActor(who);
  if actor <> nil then
  begin
    actor.SendMsg(SM_MAGICFIRE_FAIL, 0, 0, 0, 0, 0, '', 0);
  end;
  MagicTarget := nil;
end;

procedure TFrmMain.UseNormalEffect(effnum, effx, effy: integer);
var
  meff, meff2: TMagicEff;
  k: integer;
  bofly: Boolean;
begin
  meff := nil;
  meff2 := nil;
  if not BoViewEffect then
    Exit;
  case effnum of
    NE_HEARTPALP:
      meff := TNormalDrawEffect.Create(effx, effy, WMon14Img, 410, 6, 120, FALSE);
    NE_CLONESHOW:
      meff := TNormalDrawEffect.Create(effx, effy, WMagic2, 670, 10, 150, True);
    NE_THUNDER:
      begin
        PlayScene.NewMagic(nil, MAGIC_DUN_THUNDER, MAGIC_DUN_THUNDER, effx, effy, effx, effy, 0, mtThunder, FALSE, 30, bofly);
        PlaySound(8301);
      end;
    NE_FIRE:
      begin
        PlayScene.NewMagic(nil, MAGIC_DUN_FIRE1, MAGIC_DUN_FIRE1, effx, effy, effx, effy, 0, mtThunder, FALSE, 30, bofly);
        PlayScene.NewMagic(nil, MAGIC_DUN_FIRE2, MAGIC_DUN_FIRE2, effx, effy, effx, effy, 0, mtThunder, FALSE, 30, bofly);
        PlaySound(8302);
      end;
    NE_DRAGONFIRE:
      begin
        PlayScene.NewMagic(nil, MAGIC_DRAGONFIRE, MAGIC_DRAGONFIRE, effx, effy, effx, effy, 0, mtThunder, FALSE, 30, bofly);
        PlaySound(8207);
      end;

    NE_FIREBURN:
      begin
        PlayScene.NewMagic(nil, MAGIC_FIREBURN, MAGIC_FIREBURN, effx, effy, effx, effy, 0, mtThunder, FALSE, 30, bofly);
        PlaySound(8226);
      end;
    NE_FIRECIRCLE:
      begin
        meff := TNormalDrawEffect.Create(effx, effy, WMagic2, 910, 23, 100, True);
      end;
    NE_POISONFOG:
      begin
        meff := TNormalDrawEffect.Create(effx, effy, WMagic2, 1280, 10, 100, True);
        PlaySound(2446);
      end;
    NE_SN_MOVEHIDE:
      begin
        meff := TNormalDrawEffect.Create(effx, effy, WMagic2, 1300, 10, 80, True);
        PlaySound(2447);
      end;
    NE_SN_MOVESHOW:
      begin
        meff := TNormalDrawEffect.Create(effx, effy, WMagic2, 1310, 10, 80, True);
        PlaySound(2447);
      end;
    NE_SN_RELIVE:
      begin
        meff := TNormalDrawEffect.Create(effx, effy, WMagic2, 1330, 10, 100, True);
        PlaySound(2448);
      end;
    NE_FOX_MOVEHIDE:
      begin
        meff := TNormalDrawEffect.Create(effx, effy, WMon24Img, 800, 10, 90, True);
        PlaySound(109);
      end;
    NE_FOX_MOVESHOW:
      begin
        meff := TNormalDrawEffect.Create(effx, effy, WMon24Img, 810, 10, 90, True);
        PlaySound(110);
      end;
    NE_SOULSTONE_HIT:
      begin
        meff := TNormalDrawEffect.Create(effx, effy, WMon24Img, 1410, 10, 120, True);
        PlaySound(157);
      end;
    NE_KINGSTONE_RECALL_1:
      begin
        meff := TNormalDrawEffect.Create(effx, effy, WMagic2, 1370, 10, 110, True);
        PlaySound(2579);
      end;
    NE_KINGSTONE_RECALL_2:
      begin
        meff := TNormalDrawEffect.Create(effx, effy, WMagic2, 1390, 10, 110, True);
        PlaySound(10062);
      end;
    NE_KINGTURTLE_MOBSHOW:
      begin
        meff := TNormalDrawEffect.Create(effx, effy, WMon25Img, 3080, 10, 90, True);
        PlaySound(110);
      end;
    NE_DEFENCEEFFECT:
      begin
        meff := TNormalDrawEffect.Create(effx, effy, WEffectImg, 580, 10, 90, True);
//         PlaySound (110);
      end;
     //阴阳五行阵目标
      NE_YINYANGTARGET: begin
         meff := TNormalDrawEffect.Create (effx, effy,
                                       WMagic3,
                                       660,
                                       10,
                                       150,
                                       True);
      end;

      //阴阳五行阵朋友
      NE_YINYANGFRIEND: begin
         meff := TNormalDrawEffect.Create (effx, effy,
                                       WMagic3,
                                       650,
                                       10,
                                       150,
                                       True);
         PlaySound (10022);
      end;

  end;
  if meff <> nil then
  begin
    meff.MagOwner := Myself;
    PlayScene.EffectList.Add(meff);
  end;
  if meff2 <> nil then
  begin
    meff2.MagOwner := Myself;
    PlayScene.EffectList.Add(meff2);
  end;
end;


procedure TFrmMain.UseNormalEffectEx (effdir, effx, effy: integer);
var
   meff: TMagicEff;
begin
   meff := nil;
   if not BoViewEffect then Exit;

   meff := TNormalDrawEffect.Create (effx, effy,
                                       WMagic2,
                                       1700 + (effdir * 10),
                                       10,
                                       90,
                                       True);
   PlaySound(10562);

   if meff <> nil then begin
      meff.MagOwner := Myself;  //郴 扁霖栏肺
      PlayScene.EffectList.Add (meff);
   end;
end;


procedure TFrmMain.UseLoopNormalEffect(ActorID: integer; EffectIndex, LoopTime: Word);
var
  actor: TActor;
  meff: TMagicEff;
begin
  meff := nil;
  if not BoViewEffect then
    Exit;
  actor := PlayScene.FindActor(ActorID);

  case EffectIndex of
    NE_CLONEHIDE: //分身术
      begin
        meff := TCharEffect.Create(690, 10, actor);
        meff.NextFrameTime := 150;
        meff.RepeatUntil := 0;
        PlaySound(48);
      end;
    NE_MONCAPTURE:
      begin
        meff := TCharEffect.Create(1020, 8, actor);
        meff.NextFrameTime := 110;
        meff.RepeatUntil := GetTickCount + LoopTime;
        PlaySound(10475);
      end;
    NE_BLOODSUCK:
      begin
        meff := TCharEffect.Create(1090, 10, actor);
        meff.NextFrameTime := 100;
        meff.RepeatUntil := 0;
        PlaySound(10485);
      end;
    NE_REVIVALCHARGE: //Reincarnation
      begin
        meff := TCharEffect.Create(1680, 10, actor);
        meff.NextFrameTime := 100;
        meff.RepeatUntil := GetTickCount + 5000;
       // PlayBGM(bmg_revival);
       PlaySound(10544);
      end;
    NE_FLOWERSEFFECT:
      begin
        meff := TCharEffect.Create(1160, 20, actor);
        meff.NextFrameTime := 120;
        meff.RepeatUntil := GetTickCount + LoopTime;
        meff.Blend := False
      end;
    NE_LEVELUP:
      begin
        PlaySound(156);
        meff := TCharEffect.Create(1190, 20, actor);
        meff.NextFrameTime := 80;
        meff.RepeatUntil := GetTickCount + LoopTime;
      end;
    NE_RELIVE:          //复活效果
      begin
//        Exit;
         meff := TCharEffect.Create (1220, 20, actor);
         meff.NextFrameTime := 100;
         meff.RepeatUntil := GetTickCount + LoopTime;
         SilenceSound;
         FrmDlg.DMsgSimpleDlg.Visible := FALSE;
         PlaySound(10543);
      end;
    NE_BIGFORCE:
      begin
        meff := TCharEffect.Create(160, 15, actor);
        meff.NextFrameTime := 80;
        meff.RepeatUntil := 0;
      end;
    NE_FOX_FIRE:
      begin
        meff := TCharEffect.Create(1350, 10, actor);
        meff.NextFrameTime := 100;
        meff.RepeatUntil := GetTickCount + LoopTime;
      end;
    NE_SIDESTONE_PULL:
      begin
        meff := TCharEffect.Create(1410, 10, actor);
        meff.NextFrameTime := 150;
        meff.RepeatUntil := GetTickCount + LoopTime;
        PlaySound(2547);
      end;
    NE_HAPPYBIRTHDAY:
      begin
        PlaySound(158);
//      DScreen.AddChatBoardString ('NE_HAPPYBIRTHDAY', clYellow, clRed);
        meff := TCharEffect.Create(1430, 30, actor);
        meff.NextFrameTime := 100;
        meff.RepeatUntil := GetTickCount + LoopTime;
      end;
    NE_KOREAFIGHTING:
      begin
        PlaySound(161);
        meff := TCharEffect.Create(1470, 30, actor);
        meff.NextFrameTime := 80;
        meff.RepeatUntil := GetTickCount + LoopTime;
      end;
  end;

  if meff <> nil then
  begin
  // meff.ImgLib := WMagic3;

    meff.ImgLib := WMagic2;
    PlayScene.EffectList.Add(meff);
  end;
end;

procedure TFrmMain.EatItem(idx: integer);
  procedure UnBindItem(sn:string);
  var
  i, code , icnt: integer;
  pcm: pTUnbindInfo;
  begin
    if gettickcount - g_nLastUnbindTime < 1000 then exit;

    icnt := BagItemCount;
    if icnt + 11 > MAXBAGITEMCL then exit;

    // 是否有相同的物品
    for I := 0 to MAXBAGITEMCL - 1 do begin
      if ItemArr[i].S.Name = EatingItem.S.Name then
        exit;
    end;

    // 解包代码
    code := -1;
    for i := 0 to g_UnbindItemList.Count - 1 do begin
      pcm := pTUnbindInfo(g_UnbindItemList[i]);
      if pcm.sItemName = EatingItem.S.Name then begin
        code := pcm.nUnbindCode;
        break;
      end;
    end;

    if code = -1 then exit;

    for I := 0 to MAXBAGITEMCL - 1 do begin
      if (ItemArr[i].S.Shape = code) and (ItemArr[i].S.Name <> '') then begin
        g_nLastUnbindTime := gettickcount;
        SendEat(i, ItemArr[i].MakeIndex, ItemArr[i].S.Name);
        ItemArr[i].S.Name := '';
        break;
      end;
    end;
  end;
begin
  if g_boRefreshBagItem then exit;
  if (MovingItem.Item.S.StdMode = 7) and ItemMoving then
  begin
    EatingItem := MovingItem.Item;
    FrmDlg.CancelItemMoving;
    EatTime := GetTickCount;
    SendEat(idx, EatingItem.MakeIndex, EatingItem.S.Name);
//      DScreen.AddChatBoardString ('SendEat-after', clYellow, clRed);
    ItemUseSound(EatingItem.S.StdMode);
    Exit;
  end;

  if idx in [0..MAXBAGITEMCL - 1] then
  begin
    if (EatingItem.S.Name <> '') and (GetTickCount - EatTime > 5 * 1000) then
    begin
      EatingItem.S.Name := '';
    end;
    if (EatingItem.S.Name = '') and (ItemArr[idx].S.Name <> '') and (ItemArr[idx].S.StdMode in [0..3,70,88]) then
    begin
      EatingItem := ItemArr[idx];
      ItemArr[idx].S.Name := '';

      if (ItemArr[idx].S.StdMode = 4) and (ItemArr[idx].S.Shape < 100) then
      begin
        if ItemArr[idx].S.Shape < 50 then
        begin
          if mrYes <> FrmDlg.DMessageDlg(ItemArr[idx].S.Name + '你要开始学习吗？', [mbYes, mbNo]) then
          begin
            ItemArr[idx] := EatingItem;
            exit;
          end;
        end
        else
        begin
          if mrYes <> FrmDlg.DMessageDlg(ItemArr[idx].S.Name + '你要使用吗？', [mbYes, mbNo]) then
          begin
            ItemArr[idx] := EatingItem;
            exit;
          end;
        end;
      end;
      EatTime := GetTickCount;
      SendEat(idx, ItemArr[idx].MakeIndex, ItemArr[idx].S.Name);
      ItemUseSound(ItemArr[idx].S.StdMode);
      UnBindItem(EatingItem.s.Name);
    end;
  end
  else
  begin
    if (idx = -1) and ItemMoving then
    begin
      ItemMoving := FALSE;
      EatingItem := MovingItem.Item;
      MovingItem.Item.S.Name := '';

      if (EatingItem.S.StdMode = 4) and (EatingItem.S.Shape < 100) then
      begin
        if EatingItem.S.Shape < 50 then
        begin
          if mrYes <> FrmDlg.DMessageDlg('"' + EatingItem.S.Name + '"是否开始修炼?', [mbYes, mbNo]) then
          begin
            AddItemBag(EatingItem);
            exit;
          end;
        end
        else
        begin
          if mrYes <> FrmDlg.DMessageDlg('"' + EatingItem.S.Name + '"是否开始修炼?', [mbYes, mbNo]) then
          begin
            AddItemBag(EatingItem);
            exit;
          end;
        end;
      end;
      EatTime := GetTickCount;
      SendEat(idx, EatingItem.MakeIndex, EatingItem.S.Name);
      ItemUseSound(EatingItem.S.StdMode);
      UnBindItem(EatingItem.s.Name);
    end;
  end;
end;

procedure TFrmMain.AutoEatItem;
  function GetItemCount: Integer;
  var
    I, n: Integer;
  begin
    n := 0;
    for I := Low(ItemArr) to High(ItemArr) do
    begin
      if ItemArr[I].s.Name <> '' then
        Inc(n);
    end;
    Result := n;
  end;
  function UnBindItem(sn:string): Boolean;
  var
  i, code , icnt: integer;
  pcm: pTUnbindInfo;
  begin
    if (gettickcount - g_nLastUnbindTime < 1000) then exit;
    if (GetItemCount > 40) then
    begin
       DScreen.AddChatBoardString('您的包袱已满！', GetRGB(255), clBlue);
       exit;
    end;
    Result := False;
    // 解包代码
    code := -1;
    for i := 0 to g_UnbindItemList.Count - 1 do begin
      pcm := pTUnbindInfo(g_UnbindItemList[i]);
      if pcm.sItemName = sn then begin
        code := pcm.nUnbindCode;
        break;
      end;
    end;

    if code = -1 then exit;

    for I := 0 to MAXBAGITEMCL - 1 do begin
      if (ItemArr[i].S.Shape = code) and (ItemArr[i].S.Name <> '') then begin
        g_nLastUnbindTime := gettickcount;
        SendEat(i, ItemArr[i].MakeIndex, ItemArr[i].S.Name);
        ItemArr[i].S.Name := '';
         Result := True;
        break;
      end;
    end;
  end;
var
  TempHp, TempMp, I: Integer;
  boEatItem: Boolean;
begin
  if MySelf <> nil then
  begin
    if g_boRefreshBagItem then exit;
    
    //TempHp := Trunc(MySelf.Abil.HP / MySelf.Abil.MaxHP * 100);
    if g_NgConfigInfo.boSpecialHP and (MySelf.Abil.HP <= g_NgConfigInfo.nSpecialHP) and ((GetTickCount - g_DwSpecialHPTick) > g_NgConfigInfo.nwSpecialHP * 1000) then
    begin
      g_DwSpecialHPTick := GetTickCount;
      boEatItem := False;
      for I := 0 to MAXBAGITEM - 1 do
      begin
        if ItemArr[I].S.Name = '太阳水' then
        begin
          EatItem(i);
          boEatItem := true;
          Break;
        end
        else if ItemArr[I].S.Name = '强效太阳水' then
        begin
          EatItem(i);
          boEatItem := true;
          Break;
        end
        else if ItemArr[I].S.Name = '万年雪霜' then
        begin
          EatItem(i);
          boEatItem := true;
          Break;
        end
        else if ItemArr[I].S.Name = '疗伤药' then
        begin
          EatItem(i);
          boEatItem := true;
          Break;
        end;
      end;
      if not boEatItem then
        DScreen.AddChatBoardString('您的特殊药水已使用完！', GetRGB(255), clBlue);   //你先这么用   到时你知道了  我再给你改
    end;

    //TempHp := Trunc(MySelf.Abil.HP / MySelf.Abil.MaxHP * 100);
    if g_NgConfigInfo.boRanHP and (MySelf.Abil.HP <= g_NgConfigInfo.nRanHP) and ((GetTickCount - g_DwAutoRanHPTick) > g_NgConfigInfo.nwRanHP * 1000) then
    begin
      g_DwAutoRanHPTick := GetTickCount;
      boEatItem := False;
      for I := 0 to MAXBAGITEM - 1 do
      begin
        if ItemArr[I].S.Name = g_NgConfigInfo.sRanItemName then
        begin
          EatItem(i);
          boEatItem := true;
          Break;
        end;
      end;
      if not boEatItem then
        DScreen.AddChatBoardString('您的' + g_NgConfigInfo.sRanItemName + '已使用完！', GetRGB(255), clBlue);   //你先这么用   到时你知道了  我再给你改
    end;

    //TempHp := Trunc(MySelf.Abil.HP / MySelf.Abil.MaxHP * 100);
    if g_NgConfigInfo.boHpPtEat and (MySelf.Abil.HP <= g_NgConfigInfo.nHpPtEat) and ((GetTickCount - g_DwEatHpTick) > g_NgConfigInfo.nwHpPtEat * 1000) then
    begin
      g_DwEatHpTick := GetTickCount;
      boEatItem := False;
      for I := 0 to MAXBAGITEM - 1 do
      begin
        if ItemArr[I].S.Name = '金创药(小量)' then
        begin
          EatItem(i);
          boEatItem := true;
          Break;
        end
        else if ItemArr[I].S.Name = '金创药(中量)' then
        begin
          EatItem(i);
          boEatItem := true;
          Break;
        end
        else if ItemArr[I].S.Name = '强效金创药' then
        begin
          EatItem(i);
          boEatItem := true;
          Break;
        end;
      end;
      if (I >= MAXBAGITEM - 1) and not boEatItem then
      begin
        for I := 0 to MAXBAGITEM - 1 do
        begin
          if UnBindItem('金创药(小量)') then
          begin
            boEatItem := true;
            Break;
          end
          else if UnBindItem('金创药(中量)') then
          begin
            boEatItem := true;
            Break;
          end
          else if UnBindItem('强效金创药') then
          begin
            boEatItem := true;
            Break;
          end;
        end;
      end;
      if not boEatItem then
        DScreen.AddChatBoardString('您的金创药已使用完', GetRGB(255), clBlue);
    end;
   // TempMp := Trunc(MySelf.Abil.MP / MySelf.Abil.MaxMP * 100);
    if g_NgConfigInfo.boMpPtEat and (MySelf.Abil.MP <= g_NgConfigInfo.nMpPtEat) and ((GetTickCount - g_DwEatMpTick) > g_NgConfigInfo.nwMpPtEat * 1000) then
    begin
      g_DwEatMpTick := GetTickCount;
      boEatItem := False;
      for I := 0 to MAXBAGITEM - 1 do
      begin
        if ItemArr[I].S.Name = '魔法药(小量)' then
        begin
          EatItem(i);
          boEatItem := true;
          Break;
        end
        else if ItemArr[I].S.Name = '魔法药(中量)' then
        begin
          EatItem(i);
          boEatItem := true;
          Break;
        end
        else if ItemArr[I].S.Name = '强效魔法药' then
        begin
          EatItem(i);
          boEatItem := true;
          Break;
        end;
      end;
      if (I >= MAXBAGITEM - 1) and not boEatItem then
      begin
        for I := 0 to MAXBAGITEM - 1 do
        begin
          if UnBindItem('魔法药(小量)') then
          begin
            boEatItem := true;
            Break;
          end
          else if UnBindItem('魔法药(中量)') then
          begin
            boEatItem := true;
            Break;
          end
          else if UnBindItem('强效魔法药') then
          begin
            boEatItem := true;
            Break;
          end;
        end;
      end;
      if not boEatItem  then
        DScreen.AddChatBoardString('您的魔法药已使用完', GetRGB(255), clBlue);
    end;
  end;
end;

procedure TFrmMain.AutoPickUpItem;
var
  DropItem: PTDropItem;
  i: Integer;
begin
  if not g_boMirNg then Exit;
  if ServerAcceptNextAction then
  begin
    TempItemList.Clear;
    PlayScene.GetDropItemsList(MySelf.XX, MySelf.YY, TempItemList);
    if TempItemList.Count > 0 then
    begin
      if not g_NgConfigInfo.boPickUpItemAll then
      begin
        for I := 0 to TempItemList.Count - 1 do
        begin
          DropItem := TempItemList.Items[i];
          if DropItem.boPickUp then
          begin
            SendPickup;
            Break;
          end;
        end;
      end
      else
        SendPickup;
    end;
  end;
end;

function TFrmMain.TargetInSwordLongAttackRange(ndir: integer): Boolean;
var
  nx, ny: integer;
  actor: TActor;
begin
 if g_NgConfigInfo.boAutoLongHit  and (g_bo刀刀刺杀) and (Myself.Job = 0) and (FindMagicId(12) <> nil) then begin  //刀刀刺杀
     Result := True;
     Exit;
   end;
  Result := FALSE;
  GetFrontPosition(Myself.XX, Myself.YY, ndir, nx, ny);
  GetFrontPosition(nx, ny, ndir, nx, ny);
  if (abs(Myself.XX - nx) = 2) or (abs(Myself.YY - ny) = 2) then
  begin
    actor := PlayScene.FindActorXY(nx, ny);
    if actor <> nil then
      if not actor.Death then
        Result := TRUE;
  end;
end;

function TFrmMain.TargetInSwordWideAttackRange(ndir: integer): Boolean;
var
  nx, ny, rx, ry, mdir: integer;
  actor, ractor: TActor;
begin
  Result := FALSE;
  GetFrontPosition(Myself.XX, Myself.YY, ndir, nx, ny);
  actor := PlayScene.FindActorXY(nx, ny);

  mdir := (ndir + 1) mod 8;
  GetFrontPosition(Myself.XX, Myself.YY, mdir, rx, ry);
  ractor := PlayScene.FindActorXY(rx, ry);
  if ractor = nil then
  begin
    mdir := (ndir + 2) mod 8;
    GetFrontPosition(Myself.XX, Myself.YY, mdir, rx, ry);
    ractor := PlayScene.FindActorXY(rx, ry);
  end;
  if ractor = nil then
  begin
    mdir := (ndir + 7) mod 8;
    GetFrontPosition(Myself.XX, Myself.YY, mdir, rx, ry);
    ractor := PlayScene.FindActorXY(rx, ry);
  end;

  if (actor <> nil) and (ractor <> nil) then
    if not actor.Death and not ractor.Death then
      Result := TRUE;
end;

function TFrmMain.TargetInSwordCrossAttackRange(ndir: integer): Boolean;
var
  nx, ny, rx, ry, mdir: integer;
  actor, ractor: TActor;
begin
  Result := FALSE;
  GetFrontPosition(Myself.XX, Myself.YY, ndir, nx, ny);
  actor := PlayScene.FindActorXY(nx, ny);

  mdir := (ndir + 1) mod 8;
  GetFrontPosition(Myself.XX, Myself.YY, mdir, rx, ry);
  ractor := PlayScene.FindActorXY(rx, ry);
  if ractor = nil then
  begin
    mdir := (ndir + 2) mod 8;
    GetFrontPosition(Myself.XX, Myself.YY, mdir, rx, ry);
    ractor := PlayScene.FindActorXY(rx, ry);
  end;
  if ractor = nil then
  begin
    mdir := (ndir + 3) mod 8;
    GetFrontPosition(Myself.XX, Myself.YY, mdir, rx, ry);
    ractor := PlayScene.FindActorXY(rx, ry);
  end;
  if ractor = nil then
  begin
    mdir := (ndir + 4) mod 8;
    GetFrontPosition(Myself.XX, Myself.YY, mdir, rx, ry);
    ractor := PlayScene.FindActorXY(rx, ry);
  end;
  if ractor = nil then
  begin
    mdir := (ndir + 5) mod 8;
    GetFrontPosition(Myself.XX, Myself.YY, mdir, rx, ry);
    ractor := PlayScene.FindActorXY(rx, ry);
  end;
  if ractor = nil then
  begin
    mdir := (ndir + 6) mod 8;
    GetFrontPosition(Myself.XX, Myself.YY, mdir, rx, ry);
    ractor := PlayScene.FindActorXY(rx, ry);
  end;
  if ractor = nil then
  begin
    mdir := (ndir + 7) mod 8;
    GetFrontPosition(Myself.XX, Myself.YY, mdir, rx, ry);
    ractor := PlayScene.FindActorXY(rx, ry);
  end;

  if (actor <> nil) and (ractor <> nil) then
    if not actor.Death and not ractor.Death then
      Result := TRUE;
end;

{--------------------- Mouse Interface ----------------------}

procedure TFrmMain.DXDraw1MouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  i, mx, my, msx, msy, sel: integer;
  target: TActor;
  itemnames: string;
begin
  if g_DWinMan.MouseMove(Shift, X, Y) then
    exit;
  if (Myself = nil) or (DScreen.CurrentScene <> PlayScene) then
    exit;
  BoSelectMyself := PlayScene.IsSelectMyself(X, Y);

  target := PlayScene.GetAttackFocusCharacter(X, Y, DupSelection, sel, FALSE);
  if DupSelection <> sel then
    DupSelection := 0;
  if target <> nil then
  begin
    if (target.UserName = '') and (GetTickCount - target.SendQueryUserNameTime > 10 * 1000) then
    begin
      target.SendQueryUserNameTime := GetTickCount;
      SendQueryUserName(target.RecogId, target.XX, target.YY);
    end;
    FocusCret := target;
  end
  else
    FocusCret := nil;

  FocusItem := PlayScene.GetDropItems(X, Y, itemnames);
  if FocusItem <> nil then
  begin
    PlayScene.ScreenXYfromMCXY(FocusItem.X, FocusItem.Y, mx, my);
//      DScreen.AddChatBoardString ('Pos=> '+ IntToStr(((Length(FocusItem.Name) div 2)*6)), clYellow, clRed);
    DScreen.ShowHint(mx + 2 - ((Length(FocusItem.Name) div 2) * 6), my - 10, itemnames, //PTDropItem(ilist[i]).Name,
      clWhite, TRUE);
  end
  else
    DScreen.ClearHint(True);

  g_MouseX := X;
  g_MouseY := Y;
  CheckMapView;
  if g_ShowMiniMapXY then Exit;

  PlayScene.CXYfromMouseXY(X, Y, MCX, MCY);
  MouseX := X;
  MouseY := Y;
  MouseItem.S.Name := '';
  MouseStateItem.S.Name := '';
  MouseUserStateItem.S.Name := '';

//   if ((ssLeft in Shift) or (ssRight in Shift)) and (GetTickCount - mousedowntime > 300) then
  if ((ssLeft in Shift) or (ssRight in Shift) or gAutoRun) and (GetTickCount - mousedowntime > 300) then
    _DXDrawMouseDown(self, mbLeft, Shift, X, Y);

end;

procedure TFrmMain.DXDraw1MouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  mousedowntime := GetTickCount;
  if Myself <> nil then
    if not Myself.OpenStruck then
      RunReadyCount := 0;
  _DXDrawMouseDown(Sender, Button, Shift, X, Y);
end;

procedure TFrmMain.AttackTarget(target: TActor);
var
  tdir, dx, dy, hitmsg: integer;
begin
  hitmsg := CM_HIT;
  if UseItems[U_WEAPON].S.StdMode = 6 then
    hitmsg := CM_HEAVYHIT;

  tdir := GetNextDirection(Myself.XX, Myself.YY, target.XX, target.YY);
  if (abs(Myself.XX - target.XX) <= 1) and (abs(Myself.YY - target.YY) <= 1) and (not target.Death) then
  begin
    if CanNextAction and ServerAcceptNextAction and CanNextHit then
    begin

      if BoNextTimeFireHit and (Myself.Abil.MP >= 7) then
      begin
        BoNextTimeFireHit := FALSE;
        hitmsg := CM_FIREHIT;
      end
      else if BoNextTimePowerHit then
      begin
        BoNextTimePowerHit := FALSE;
        hitmsg := CM_POWERHIT;
      end
      else if BoCanTwinHit and (Myself.Abil.MP >= 10) then
      begin
        hitmsg := CM_TWINHIT;
      end
      else if BoCanWideHit and (Myself.Abil.MP >= 3) and TargetInSwordWideAttackRange (tdir) then
      begin //and (TargetInSwordWideAttackRange (tdir)) then begin
        hitmsg := CM_WIDEHIT;
      end
      else

      if BoCanCrossHit and (Myself.Abil.MP >= 6) then
      begin
        hitmsg := CM_CROSSHIT;
      end
      else
      if g_NgConfigInfo.boAutoLongHit and (g_bo刀刀刺杀) and (Myself.Job = 0) and (FindMagicId(12) <> nil) and (not target.Death)  then begin  //刀刀刺杀
            hitmsg := CM_LONGHIT;
         end
         else if BoCanLongHit and (TargetInSwordLongAttackRange(tdir)) then
      begin
        hitmsg := CM_LONGHIT;
      end;

         //if ((target.Race <> 0) and (target.Race <> RCC_GUARD)) or (ssShift in Shift) then
      Myself.SendMsg(hitmsg, Myself.XX, Myself.YY, tdir, 0, 0, '', 0);
      LatestHitTime := GetTickCount;
    end;
    LastAttackTime := GetTickCount;
  end
  else
  begin
      //if (UseItems[U_WEAPON].S.Shape = 6) and (target <> nil) then begin
      //   Myself.SendMsg (CM_THROW, Myself.XX, Myself.YY, tdir, integer(target), 0, '', 0);
      //   TargetCret := nil;
      //end else begin
    ChrAction := caRun;  // caWalk;    攻击目标远了就跑过去，caWalk是走过去
    GetBackPosition(target.XX, target.YY, tdir, dx, dy);
    targetx := dx;
    targety := dy;
      //end;
  end;
end;

procedure TFrmMain._DXDrawMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
  tdir, nx, ny, hitmsg, sel: integer;
  target: TActor;
  Pt:TPoint;
  ARect:TRect;
begin
  ActionKey := 0;
  BoAutoDig := FALSE;

  if (Button = mbRight) and ItemMoving then
  begin
    FrmDlg.CancelItemMoving;
    exit;
  end;
  if g_DWinMan.MouseDown(Button, Shift, X, Y) then
    exit;

  if ViewMiniMapStyle>0 then
     begin
        ARect:=Rect(g_FScreenWidth-g_MinMapWidth,0,g_FScreenWidth,g_MinMapWidth);
        Pt:=Point(X,Y);
        if types.PtInRect(ARect,Pt) then
           begin
              if Button=mbLeft then
                 begin
                   if g_bo大地图开关 then begin
                    Inc(ViewMiniMapStyle);
                    if ViewMiniMapStyle > 2 then
                       ViewMiniMapStyle := 1;
                   end;

                 end
              else
                 ViewMiniMapTran:=not ViewMiniMapTran;

              if ViewMiniMapStyle=2 then
                 g_MinMapWidth:=200
                 else
                 g_MinMapWidth:=120;
              CheckMapView;
              Exit;
           end;
     end;

  if (Myself = nil) or (DScreen.CurrentScene <> PlayScene) then
    exit;
//
        if MySelf.m_StallMgr.OnSale then //
        begin
        //
        Exit;
        end;
 //
  if ssMiddle in Shift then
  begin
    RunReadyCount := 0;
    if gAutoRun then
    begin
      gAutoRun := False;
      DScreen.AddChatBoardString ('<关闭自由移动>', clGreen, clWhite)
    end
    else
    begin
      gAutoRun := True;
      DScreen.AddChatBoardString ('<开启自由移动>', clGreen, clWhite)
    end;
  end
  else if ssLeft in Shift then
  begin
    if gAutoRun then
    begin
      RunReadyCount := 0;
      gAutoRun := False;
      DScreen.AddChatBoardString ('[停止自由移动]', clGreen, clWhite)
    end;
  end;

    if FrmDlg.DEdChat.Visible then
    FrmDlg.DEdChat.SetFocus;
  if (ssRight in Shift) or gAutoRun then
  begin
    if Shift = [ssRight] then
      Inc(DupSelection);
    target := PlayScene.GetAttackFocusCharacter(X, Y, DupSelection, sel, FALSE);
    if DupSelection <> sel then
      DupSelection := 0;
    if target <> nil then
    begin
      if ssCtrl in Shift then
      begin
        if GetTickCount - LastMoveTime > 1000 then
        begin
          if (target.Race = 0) and (not target.Death) then
          begin
            SendClientMessage(CM_QUERYUSERSTATE, target.RecogId, target.XX, target.YY, 0);
            exit;
          end;
        end;
      end;
    end
    else
      DupSelection := 0;
    if FrmDlg.DEdChat.Visible then
    FrmDlg.DEdChat.SetFocus;
    PlayScene.CXYfromMouseXY(X, Y, MCX, MCY);
    if (abs(Myself.XX - MCX) <= 1) and (abs(Myself.YY - MCY) <= 1) then    //1就是鼠标指向1格外开跑 之前两个0都是1
    begin
      tdir := GetNextDirection(Myself.XX, Myself.YY, MCX, MCY);
      if CanNextAction and ServerAcceptNextAction then
      begin
        Myself.SendMsg(CM_TURN, Myself.XX, Myself.YY, tdir, 0, 0, '', 0);
      end;
    end
    else
    begin
      ChrAction := caRun;

      targetx := MCX;
      targety := MCY;
      exit;
    end;
  end;

  if ssLeft in Shift {Button = mbLeft} then
  begin
    target := PlayScene.GetAttackFocusCharacter(X, Y, DupSelection, sel, TRUE);
    PlayScene.CXYfromMouseXY(X, Y, MCX, MCY);
    TargetCret := nil;

    if (UseItems[U_WEAPON].S.Name <> '') and (target = nil) then
    begin
      if UseItems[U_WEAPON].S.Shape = 19 then
      begin
        tdir := GetNextDirection(Myself.XX, Myself.YY, MCX, MCY);
        GetFrontPosition(Myself.XX, Myself.YY, tdir, nx, ny);
        if not Map.CanMove(nx, ny) or (ssShift in Shift) then
        begin
          if CanNextAction and ServerAcceptNextAction and CanNextHit then
          begin
            Myself.SendMsg(CM_HIT + 1, Myself.XX, Myself.YY, tdir, 0, 0, '', 0);
          end;
          BoAutoDig := TRUE;
          exit;
        end;
      end;
    end;

    if ssAlt in Shift then
    begin
      tdir := GetNextDirection(Myself.XX, Myself.YY, MCX, MCY);
      if CanNextAction and ServerAcceptNextAction then
      begin
        target := PlayScene.ButchAnimal(MCX, MCY);
        if target <> nil then
        begin
          SendButchAnimal(MCX, MCY, tdir, target.RecogId);
          Myself.SendMsg(CM_SITDOWN, Myself.XX, Myself.YY, tdir, 0, 0, '', 0);
          exit;
        end;
        Myself.SendMsg(CM_SITDOWN, Myself.XX, Myself.YY, tdir, 0, 0, '', 0);
      end;
      targetx := -1;
    end
    else
    begin
      if (target <> nil) or (ssShift in Shift) then
      begin
        targetx := -1;
        if target <> nil then
        begin
          if GetTickCount - LastMoveTime > 1500 then
          begin
           if (target is THumActor) and THumActor(target).m_StallMgr.OnSale then begin      //买
              SendClientMessage(CM_CLICKNPC, target.RecogId, 0, 0, 0);
//              g_dwLastMoveTick := GetTickCount;
              Exit;
            end;

            if target.Race = RCC_MERCHANT then
            begin
              SendClientMessage(CM_CLICKNPC, target.RecogId, 0, 0, 0);
              exit;
            end;
          end;

          if (not target.Death) then
          begin
            TargetCret := target;
            if ((target.Race <> 0) and //
              (target.Race <> RCC_GUARD) and //
              (target.Race <> RCC_GUARD2) and //
              (target.Race <> RCC_MERCHANT) and //
              (pos('(', target.UserName) = 0)) or//
              ((ssShift in Shift) or//
              (target.NameColor = ENEMYCOLOR) and g_boShiftOff)//
              then
            begin
              MagicTarget := target; // AutoTarget
              AutoTarget := target; // AutoTarget
              AttackTarget(target);
              LatestHitTime := GetTickCount;

              if BoStopAfterAttack then
              begin
                BoStopAfterAttack := FALSE;
                TargetCret := nil;
                AutoTarget := nil;
              end;
              if (target <> nil) and (ssShift in Shift) then
                AutoTarget := nil;
            end;
          end;
        end
        else
        begin
          tdir := GetNextDirection(Myself.XX, Myself.YY, MCX, MCY);
          if CanNextAction and ServerAcceptNextAction and CanNextHit then
          begin
            hitmsg := CM_HIT + Random(3);
            if BoCanLongHit and (TargetInSwordLongAttackRange(tdir)) then
            begin
              hitmsg := CM_LONGHIT;
            end;
            if BoCanWideHit and (Myself.Abil.MP >= 3) and (TargetInSwordWideAttackRange(tdir)) then
            begin
              hitmsg := CM_WIDEHIT;
            end;
            if BoCanCrossHit and (Myself.Abil.MP >= 6) and (TargetInSwordCrossAttackRange(tdir)) then
            begin
              hitmsg := CM_CROSSHIT;
            end;
            Myself.SendMsg(hitmsg, Myself.XX, Myself.YY, tdir, 0, 0, '', 0);
          end;
          LastAttackTime := GetTickCount;
        end;
      end
      else
      begin
        if (MCX = Myself.XX) and (MCY = Myself.YY) then
        begin
          tdir := GetNextDirection(Myself.XX, Myself.YY, MCX, MCY);
          if CanNextAction and ServerAcceptNextAction then
          begin
            SendPickup;
          end;
        end
        else if GetTickCount - LastAttackTime > 1000 then
        begin
          if ssCtrl in Shift then
          begin
            ChrAction := caRun;
          end
          else
          begin
            ChrAction := caWalk;
          end;
          targetx := MCX;
          targety := MCY;
        end;
      end;
    end;
  end;
  if FrmDlg.DEdChat.Visible then
    FrmDlg.DEdChat.SetFocus;
end;

procedure TFrmMain.DXDraw1DblClick(Sender: TObject);
var
  pt: TPoint;
begin
  GetCursorPos(pt);
  pt := ScreenToClient(pt);
  if g_DWinMan.DblClick(pt.X, pt.Y) then
    exit;
end;

function TFrmmain.CheckDoorAction(dx, dy: integer): Boolean;
var
  nx, ny, ndir, door: integer;
begin
  Result := FALSE;
   //if not Map.CanMove (dx, dy) then begin
      //if (Abs(dx-Myself.XX) <= 2) and (Abs(dy-Myself.YY) <= 2) then begin
  door := Map.GetDoor(dx, dy);
  if door > 0 then
  begin
    if not Map.IsDoorOpen(dx, dy) then
    begin
      SendClientMessage(CM_OPENDOOR, door, dx, dy, 0);
      Result := TRUE;
    end;
  end;
      //end;
   //end;
end;

procedure TFrmMain.DXDraw1MouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  if g_DWinMan.MouseUp(Button, Shift, X, Y) then
    exit;
  if CheckPtInMinMap(X,Y) then
     Exit;
  targetx := -1;
end;

procedure TFrmMain.DXDraw1Click(Sender: TObject);
var
  pt: TPoint;
begin
  GetCursorPos(pt);
  pt := ScreenToClient(pt);
  if g_DWinMan.Click(pt.X, pt.Y) then exit;
end;

procedure TFrmMain.MouseTimerTimer(Sender: TObject);
  function GetMagicTick(MagicTick: LongWord): LongWord;
  begin
    case MagicTick of
      0:
        Result := MagicTick + 2;
      1:
        Result := MagicTick + 1;
    else
      Result := MagicTick;
    end;
  end;
var
  pt: TPoint;
  keyvalue: TKeyBoardState;
  shift: TShiftState;
  pm: PTClientMagic;
  i: integer;
  TempHint: string;
begin
  GetCursorPos(pt);
  SetCursorPos(pt.X, pt.Y);
  if GetTickCount - g_DwItemDuraTick > 30 * 1000 then
  begin
    g_DwItemDuraTick := GetTickCount;
    if (g_bofuguHP) or (g_NgConfigInfo.boDuraWarning) and (MySelf <> nil) and not MySelf.Death then
    begin
      for i := High(UseItems) downto Low(UseItems) do
      begin
        if (UseItems[i].S.name <> '') then
        begin
          if UseItems[i].S.StdMode in [7, 25] then
            Continue;
          if (UseItems[i].Dura < 2500) and (UseItems[i].S.StdMode in [0..50,52,54]) then
          begin
//            DScreen.AddChatBoardString(Format('你的[%s]持久已到底限, 请及时修理更换！',
//              [UseItems[i].S.name]), clWhite, clWebBlue);
//          end;
            if GetDuraHint1(i, UseItems[i]) then
            begin
              case g_DuraWarning[i].DuraCount of
                1:
                  TempHint := '你的[' + UseItems[i].S.Name + ']持久已到2，请及时修理或更换！';
                2:
                  TempHint := '你的[' + UseItems[i].S.Name + ']持久已到1，请及时修理或更换！';
                3:
                  TempHint := '你的[' + UseItems[i].S.Name + ']持久已到底限，请及时修理或更换！';
              end;
              DScreen.AddChatBoardString(TempHint, GetRGB(255), clBlue);
            end;
          end;
        end;
      end;
    end;
  end;
  if TargetCret <> nil then
  begin
    if ActionKey > 0 then
    begin
      ProcessKeyMessages;
    end
    else
    begin
      if not TargetCret.Death and PlayScene.IsValidActor(TargetCret) then
      begin
        FillChar(keyvalue, sizeof(TKeyboardState), #0);
        if GetKeyboardState(keyvalue) then
        begin
          shift := [];
          if ((keyvalue[VK_SHIFT] and $80) <> 0) then
            shift := shift + [ssShift];
          if ((TargetCret.Race <> 0) and //
            (TargetCret.Race <> RCC_GUARD) and //
            (TargetCret.Race <> RCC_GUARD2) and //
            (TargetCret.Race <> RCC_MERCHANT) and //
            (pos('(', TargetCret.UserName) = 0)) or // 有主人的怪物（必须强制攻击）
            (TargetCret.NameColor = ENEMYCOLOR) or //敌人变成自动攻击
            ((ssShift in shift) or g_boShiftOff) and (not FrmDlg.DEdChat.Visible) then
          begin //防止对人的意外攻击
            AttackTarget(TargetCret);
          end; //else begin
                  //TargetCret := nil;
               //end
        end;
      end
      else
        TargetCret := nil;
    end;
  end;
  if BoAutoDig then
  begin //自动挖矿
    if CanNextAction and ServerAcceptNextAction and CanNextHit then
    begin
      Myself.SendMsg(CM_HIT + 1, Myself.XX, Myself.YY, Myself.Dir, 0, 0, '', 0);
    end;
  end;
  AutoEatItem;
  
  if MySelf <> nil then
  begin
    if GetTickCount - g_DwAutoPickUpItemTick > 100 then
    begin
      g_DwAutoPickUpItemTick := GetTickCount;
      AutoPickUpItem;
    end;
    if  (MySelf.Job = 0) and g_NgConfigInfo.boAutoFireHit and (GetTickCount - g_DwAutoFireTick > 1000 * 3) and (MySelf.Abil.MP >= 10) then
    begin
      g_DwAutoFireTick := GetTickCount;
      pm := FindMagicId(26);
      if pm <> nil then
      begin
        UseMagic(MouseX, MouseY, pm);
        ActionKey := 0;
        TargetX := -1;
      end;
    end;
    if  (MySelf.Job = 1) and g_NgConfigInfo.boAutoShield and (GetTickCount - g_DwAutoShieldTick > 1000) and ((MySelf.State and $00100000 = 0)) then
    begin
      g_DwAutoShieldTick := GetTickCount;
      pm := FindMagicId(31);
      if pm <> nil then
      begin
        if pm.Def.Spell + pm.Def.DefSpell <= MySelf.Abil.MP then
        begin
          UseMagic(MySelf.XX, MySelf.YY, pm);
        end;
      end;
    end;
    if (MySelf.Job = 2) and g_NgConfigInfo.boAutoHide and (GetTickCount - g_DwAutoHideTick > 1000 * 2) and ((MySelf.State and $00800000 = 0)) then
    begin
      g_DwAutoHideTick := GetTickCount;
      pm := FindMagicId(18);
      if pm <> nil then
      begin
        if pm.Def.Spell + pm.Def.DefSpell <= MySelf.Abil.MP then
        begin
          UseMagic(MySelf.XX, MySelf.YY, pm);
        end;
      end;
    end;

    if g_NgConfigInfo.boAutoMagic and (GetTickCount - g_DwAutoMagictick > GetMagicTick(g_NgConfigInfo.nwAutoMagic) * 1000) then
  begin
        pm := FindMagicId(g_NgConfigInfo.nAutoMagicID);
        if pm <> nil then
        g_DwAutoMagictick := GetTickCount;
      begin
        if (GetTickCount - LatestSpellTime > (2000{+200} + MagicDelayTime)) then    //解决自动练功连续魔法问题。
        UseMagic(MouseX, MouseY, pm);

    end;
  end;
   end;

 end;

procedure TFrmMain.WaitMsgTimerTimer(Sender: TObject);
var data,AMapName:string;
begin
  if Myself = nil then
    exit;
  if Myself.ActionFinished then
  begin
    WaitMsgTimer.Enabled := FALSE;
    case WaitingMsg.Ident of
      SM_CHANGEMAP:
        begin
        //  MiniMapIndex:=-1;
          FrmDlg.SafeCloseDlg;
          MapMovingWait := FALSE;
          MapMoving := FALSE;
               //地图改变时关闭商店菜单
          if MDlgX <> -1 then
          begin
            FrmDlg.CloseMDlg;
            MDlgX := -1;
          end;
          ClearDropItems;
          EventMan.ClearEvents;
          PlayScene.CleanObjects;
          WaitingStr := GetValidStr3(WaitingStr, data, [#13]);
          AMapName:=data;
          WaitingStr := GetValidStr3(WaitingStr, data, [#13]);

          MapTitle:=data;
          TempMapTitle:=data;
          if strtointdef(WaitingStr,-1)<=0 then
             begin
              BoDrawMiniMap := False;
              MiniMapIndex:=-1;
             end
             else
             ClientGetReadMiniMap(strtointdef(WaitingStr,-1));
         // MapTitle := '';
         g_RunTick := GetTickCount;
          g_MapDesc := GetMapDescList(MapTitle);
          PlayScene.SendMsg(SM_CHANGEMAP, 0, WaitingMsg.Param{x}, WaitingMsg.tag{y}, LOBYTE(WaitingMsg.Series){darkness}, // 侩带怜
            0, 0, 0, AMapName{mapname});

          EffectNum := HIBYTE(WaitingMsg.Series);
          if EffectNum < 0 then
            EffectNum := 0;
          if (EffectNum = 1) or (EffectNum = 2) then
            RunEffectTimer.Enabled := True
          else
            RunEffectTimer.Enabled := False;

          Myself.CleanCharMapSetting(WaitingMsg.Param, WaitingMsg.Tag);
               //DScreen.AddSysMsg (IntToStr(WaitingMsg.Param) + ' ' +
               //                   IntToStr(WaitingMsg.Tag) + ' : My ' +
               //                   IntToStr(Myself.XX) + ' ' +
               //                   IntToStr(Myself.YY) + ' ' +
               //                   IntToStr(Myself.RX) + ' ' +
               //                   IntToStr(Myself.RY) + ' '
               //                  );
          targetx := -1;
          TargetCret := nil;
          FocusCret := nil;

        end;
    end;
  end;
end;
procedure TFrmMain.ShowDuraWarning;
var
  I: Integer;
  TempHint: string;
begin
 if GetTickCount - g_DwItemDuraTick > 30 * 1000 then
  begin
    g_DwItemDuraTick := GetTickCount;
    if (g_NgConfigInfo.boDuraWarning) or (g_bofuguHP) and (MySelf <> nil) and not MySelf.Death then
    begin
      for i := High(UseItems) downto Low(UseItems) do
      begin
        if (UseItems[i].S.name <> '') then
        begin
          if UseItems[i].S.StdMode in [7, 25] then
            Continue;
          if (UseItems[i].Dura < 2500) and (UseItems[i].S.StdMode in [0..50,52,54]) then
          begin
//            DScreen.AddChatBoardString(Format('你的[%s]持久已到底限, 请及时修理更换！',
//              [UseItems[i].S.name]), clWhite, clWebBlue);
//          end;
//            if GetDuraHint1(i, UseItems[i]) then
//            begin
              case g_DuraWarning[i].DuraCount of
                1:
                  TempHint := '你的[' + UseItems[i].S.Name + ']持久已到2，请及时修理或更换！';
                2:
                  TempHint := '你的[' + UseItems[i].S.Name + ']持久已到1，请及时修理或更换！';
                3:
                  TempHint := '你的[' + UseItems[i].S.Name + ']持久已到底限，请及时修理或更换！';
              end;
              DScreen.AddChatBoardString(TempHint, GetRGB(255), clBlue);
           //end;
          end;
        end;
      end;
    end;
  end;
end;
{----------------------- Socket -----------------------}

procedure TFrmMain.SelChrWaitTimerTimer(Sender: TObject);
begin
  SelChrWaitTimer.Enabled := FALSE;
  SendQueryChr;
end;

procedure TFrmMain.ActiveCmdTimer(cmd: TTimerCommand);
begin
  CmdTimer.Enabled := TRUE;
  TimerCmd := cmd;
end;

procedure TFrmMain.CmdTimerTimer(Sender: TObject);
begin
  CmdTimer.Enabled := FALSE;
  CmdTimer.Interval := 1000;
  case TimerCmd of
    tcSoftClose:
      begin
        CmdTimer.Enabled := FALSE;
        CSocket.Socket.Close;
      end;
    tcReSelConnect:
      begin
            //重置游戏变量...
        ResetGameVariables;
            //
        DScreen.ChangeScene(stSelectChr);

        ConnectionStep := cnsReSelChr;
        if not BoOneClick then
        begin
          with CSocket do
          begin
            Active := FALSE;
            Address := SelChrAddr;
            Port := SelChrPort;
            Active := TRUE;
          end;
        end
        else
        begin
          if CSocket.Socket.Connected then
            CSocket.Socket.SendText('$S' + SelChrAddr + '/' + IntToStr(SelChrPort) + '%');
          CmdTimer.Interval := 1;
          ActiveCmdTimer(tcFastQueryChr);
        end;
      end;
    tcFastQueryChr:
      begin
        SendQueryChr;
      end;
  end;
end;

procedure TFrmMain.CloseAllWindows;
begin
  with FrmDlg do
  begin

    CancelItemMoving;
    //-
    if DWHeroStore.Visible then
    DWHeroStore.Visible := False;
    if DWUserStall.Visible then
   DWUserStall.Visible := False;
   if DWStoreItemPrice.Visible then
   DWStoreItemPrice.Visible := False;

    if DStateWin.Visible then
      DStateWin.Visible := FALSE;
    if DUserState1.Visible then
      DUserState1.Visible := FALSE;
    if DItemBag.Visible then
      DItemBag.Visible := FALSE;
    if DMerchantDlg.Visible then
      CloseMDlg;
    if DSellDlg.Visible then
      CloseDSellDlg;
    if DGuildDlg.Visible then
      DGDCloseClick(nil, 0, 0);
    if DDealDlg.Visible then
      DDealCloseClick(nil, 0, 0);
    if DGroupDlg.Visible then
      DGrpDlgCloseClick(nil, 0, 0);
    if DMailListDlg.Visible then
      ToggleShowMailListDlg;
    if DFriendDlg.Visible then
      ToggleShowFriendsDlg;
    if DBlockListDlg.Visible then
      ToggleShowBlockListDlg;
//      if DMemo.Visible then ToggleShowMemoDlg;
    if DMemo.Visible then
      DMemoCloseClick(DMemoClose, 0, 0);
    if DMakeItemDlg.Visible then
      DMakeItemDlgOkClick(DMakeItemDlgCancel, 0, 0);
    if DItemMarketDlg.Visible then
      CloseItemMarketDlg;
//      if DItemMarketDlg.Visible then DItemMarketDlg.Visible := FALSE;

    if DJangwonListDlg.Visible then
      DJangwonCloseClick(DJangwonClose, 0, 0);

    if DGABoardListDlg.Visible then
      DGABoardListCloseClick(DGABoardListClose, 0, 0);
    if DGABoardDlg.Visible then
      DGABoardCloseClick(DGABoardClose, 0, 0);
    if DGADecorateDlg.Visible then
      DGADecorateCloseClick(DGADecorateClose, 0, 0);
    if DMasterDlg.Visible then
      ToggleShowMasterDlg;
    if DLoveDlg.Visible then
      ToggleShowLoveDlg;
    DMsgDlg.Visible := FALSE;
    DMenuDlg.Visible := FALSE;
    DWindowSaveItem.Visible := False;
    DKeySelDlg.Visible := FALSE;
    DDealRemoteDlg.Visible := FALSE;
    DGuildEditNotice.Visible := FALSE;
    DAdjustAbility.Visible := FALSE;
    DMailDlg.Visible := FALSE;
    DWGameConfig.Visible := False;
    g_SendSayList.Clear;
    g_SendSayListIdx := 0;

    DWhisperDlg.Visible := False;

    DCheckWhisper.Checked := False;
//    DWhisperInfoList.Clear;
    DMsgSimpleDlg.Visible := FALSE;

        if DHelpDlg.Visible then
      DHelpDlg.Visible := FALSE;
  end;
  if MDlgX <> -1 then
  begin
    FrmDlg.CloseMDlg;
    MDlgX := -1;
  end;
  ItemMoving := FALSE;  //

  BoMsgDlgTimeCheck := False;
  FrmDlg.MsgDlgClickTime := GetTickCount;
end;

procedure TFrmMain.ClearDropItems;
var
  i: integer;
begin
  for i := 0 to DropedItemList.Count - 1 do
    Dispose(PTDropItem(DropedItemList[i]));
  DropedItemList.Clear;
end;

procedure TFrmMain.ResetGameVariables;
var
  i, ii: integer;
  List: TList;
begin
  CloseAllWindows;
  ClearDropItems;
  for i := 0 to MagicList.Count - 1 do
    Dispose(PTClientMagic(MagicList[i]));
  MagicList.Clear;
  ItemMoving := FALSE;
  WaitingUseItem.Item.S.Name := '';
  EatingItem.S.name := '';
  MovingItem.Item.S.Name := '';

  targetx := -1;
  TargetCret := nil;
  FocusCret := nil;
  MagicTarget := nil;
  ActionLock := FALSE;
  GroupMembers.Clear;
  GroupIdList.Clear;
   // 2003/04/15 朋友，注意
  for i := 0 to FriendMembers.Count - 1 do
    Dispose(PTFriend(FriendMembers[i]));
  FriendMembers.Clear;

  for i := 0 to BlackMembers.Count - 1 do
    Dispose(PTFriend(BlackMembers[i]));
  BlackMembers.Clear;

  BlockLists.Clear;
  for i := 0 to MailLists.Count - 1 do
    Dispose(PTMail(MailLists[i]));
  MailLists.Clear;
  WantMailList := false;

  for i := Low(g_ShopListArr) to High(g_ShopListArr) do begin
    List := g_ShopListArr[i];
    for ii := 0 to List.count - 1 do
      Dispose(pTShopItem(List[ii]));
    List.Clear;
  end;

   //2003/07/08 恋人
  fLover.Clear;
  fMaster.Clear;
  fPupil.Clear;

  GuildRankName := '';
  GuildName := '';

  MapMoving := FALSE;
  WaitMsgTimer.Enabled := FALSE;
  MapMovingWait := FALSE;
  DScreen.ChatBoardTop := 0;
  BoNextTimePowerHit := FALSE;
  BoCanLongHit := FALSE;
  BoCanWideHit := FALSE;
   // 2003/03/15 新武功
  BoCanCrosshit := FALSE;
  BoCanTwinhit := FALSE;
  BoNextTimeFireHit := FALSE;

   // 2003/03/15 内容扩展
  FillChar(UseItems, sizeof(UseItems), #0);        // 9->13
  FillChar(ItemArr, sizeof(TClientItem) * MAXBAGITEMCL, #0);

  with SelectChrScene do
  begin
    FillChar(ChrArr, sizeof(TSelChar) * 3, #0);
    ChrArr[0].FreezeState := TRUE; //默认冻结
    ChrArr[1].FreezeState := TRUE;
  end;
  PlayScene.ClearActors;
  ClearDropItems;
  EventMan.ClearEvents;
  PlayScene.CleanObjects;
   //DXDraw1RestoreSurface (self);
  Myself := nil;

   //重置委托商店;
  g_Market.Clear;
end;

procedure TFrmMain.ChangeServerClearGameVariables;
var
  i, ii: integer;
  List: TList;
begin
  CloseAllWindows;
  ClearDropItems;
  for i := 0 to MagicList.Count - 1 do
    Dispose(PTClientMagic(MagicList[i]));
  MagicList.Clear;
  ItemMoving := FALSE;
  WaitingUseItem.Item.S.Name := '';
  EatingItem.S.name := '';
  targetx := -1;
  TargetCret := nil;
  FocusCret := nil;
  MagicTarget := nil;
  ActionLock := FALSE;
  GroupMembers.Clear;
  GroupIdList.Clear;
   // 2003/04/15 朋友，注意
  for i := 0 to FriendMembers.Count - 1 do
    Dispose(PTFriend(FriendMembers[i]));
  FriendMembers.Clear;

  for i := 0 to BlackMembers.Count - 1 do
    Dispose(PTFriend(BlackMembers[i]));
  BlackMembers.Clear;

  BlockLists.Clear;
  for i := 0 to MailLists.Count - 1 do
    Dispose(PTMail(MailLists[i]));
  MailLists.Clear;
  WantMailList := false;

  for i := Low(g_ShopListArr) to High(g_ShopListArr) do begin
    List := g_ShopListArr[i];
    for ii := 0 to List.count - 1 do
      Dispose(pTShopItem(List[ii]));
    List.Clear;
  end;

   //2003/07/08 恋人
  fLover.clear;
  fMaster.Clear;
  fPupil.Clear;

  GuildRankName := '';
  GuildName := '';

  MapMoving := FALSE;
  WaitMsgTimer.Enabled := FALSE;
  MapMovingWait := FALSE;
  BoNextTimePowerHit := FALSE;
  BoCanLongHit := FALSE;
  BoCanWideHit := FALSE;
   // 2003/03/15 新武功
  BoCanCrosshit := FALSE;
  BoCanTwinhit := FALSE;

  ClearDropItems;
  EventMan.ClearEvents;
  PlayScene.CleanObjects;
end;

procedure TFrmMain.CSocketConnect(Sender: TObject; Socket: TCustomWinSocket);
var
  packet: array[0..255] of char;
  strbuf: array[0..255] of char;
  str: string;
begin
  ServerConnected := TRUE;
  if ConnectionStep = cnsLogin then
  begin
    if OneClickMode = toKornetWorld then
    begin  //通过网络世界登录游戏
      FillChar(packet, 256, #0);
      str := 'KwGwMGS';
      StrPCopy(strbuf, str);
      Move(strbuf, (@packet[0])^, Length(str));
      str := 'CONNECT';
      StrPCopy(strbuf, str);
      Move(strbuf, (@packet[8])^, Length(str));
      str := KornetWorld.CPIPcode;
      StrPCopy(strbuf, str);
      Move(strbuf, (@packet[16])^, Length(str));
      str := KornetWorld.SVCcode;
      StrPCopy(strbuf, str);
      Move(strbuf, (@packet[32])^, Length(str));
      str := KornetWorld.LoginID;
      StrPCopy(strbuf, str);
      Move(strbuf, (@packet[48])^, Length(str));
      str := KornetWorld.CheckSum;
      StrPCopy(strbuf, str);
      Move(strbuf, (@packet[64])^, Length(str));
      Socket.SendBuf(packet, 256);
    end;
    DScreen.ChangeScene(stLogin);
      //SendVersionNumber;
  end;
  if ConnectionStep = cnsSelChr then
  begin
//    Application.MessageBox( PChar('cnsSelChr'), PChar('Check'), IDOK);
    LoginScene.OpenLoginDoor;
    SelChrWaitTimer.Enabled := TRUE;
  end;
  if ConnectionStep = cnsReSelChr then
  begin
    CmdTimer.Interval := 1;
    ActiveCmdTimer(tcFastQueryChr);
  end;
  if ConnectionStep = cnsPlay then
  begin
    if not BoServerChanging then
    begin
      ClearBag;  //重置背包
      DScreen.ClearChatBoard; //重置聊天窗口
      DScreen.ChangeScene(stLoginNotice);
    end
    else
    begin
      ChangeServerClearGameVariables;
    end;
    SendRunLogin;
  end;
  SocStr := '';
  BufferStr := '';
end;

procedure TFrmMain.CSocketDisconnect(Sender: TObject; Socket: TCustomWinSocket);
begin
  ServerConnected := FALSE;
  if (ConnectionStep = cnsLogin) and not BoWellLogin then
  begin
    FrmDlg.DMessageDlg('连接已关闭...', [mbOk]);
    Close;
  end;
//   FrmDlg.DLOGO.Visible := False;
  CloseTimer.Enabled := True;
  if SoftClosed then
  begin
    SoftClosed := FALSE;
{$IFDEF RELEASE}
    LoadingTimmer.Enabled := True;
{$ENDIF}
    ActiveCmdTimer(tcReSelConnect);
  end;
end;

procedure TFrmMain.CSocketError(Sender: TObject; Socket: TCustomWinSocket; ErrorEvent: TErrorEvent; var ErrorCode: Integer);
begin
  ErrorCode := 0;
  Socket.Close;
end;

procedure TFrmMain.CSocketRead(Sender: TObject; Socket: TCustomWinSocket);
var
  n: integer;
  data, data2: string;
begin
  data := Socket.ReceiveText;
   
   //DebugOutStr (data);
   //if pos('GOOD', data) > 0 then DScreen.AddSysMsg (data);

  n := pos('*', data);
  if n > 0 then
  begin
    data2 := Copy(data, 1, n - 1);
    data := data2 + Copy(data, n + 1, Length(data));
      //SendSocket ('*');
    CSocket.Socket.SendText('*');
  end;
  SocStr := SocStr + data;
end;

{-------------------------------------------------------------}

procedure TFrmMain.SendSocket(sendstr: string);
const
  Code: byte = 1;
begin
   //DebugOutStr (sendstr);
  if CSocket.Socket.Connected then
  begin
    CSocket.Socket.SendText('#' + IntToStr(Code) + sendstr + '!');
    Inc(Code);
    if Code >= 10 then
      Code := 1;
  end;
end;

procedure TFrmMain.SendClientMessage(msg, Recog, param, tag, series: integer);
var
  dmsg: TDefaultMessage;
begin
  dmsg := MakeDefaultMsg(msg, Recog, param, tag, series);
  SendSocket(EncodeMessage(dmsg));
end;

procedure TFrmMain.SendClientMessage2(msg, Recog, param, tag, series: integer; str: string);
var
  dmsg: TDefaultMessage;
begin
  dmsg := MakeDefaultMsg(msg, Recog, param, tag, series);
  SendSocket(EncodeMessage(dmsg) + EncodeString(str));
end;

procedure TFrmMain.SendVersionNumber;
var
  msg: TDefaultMessage;
begin
{   msg := MakeDefaultMsg (CM_PROTOCOL, ClientVersion, 0, 0, 0);
   SendSocket (EncodeMessage (msg));}
end;

procedure TFrmMain.SendLogin(uid, passwd: string);
var
  msg: TDefaultMessage;
begin
  LoginId := uid;
  LoginPasswd := passwd;
  msg := MakeDefaultMsg(CM_IDPASSWORD, ClientVersion, 0, 0, 0);
  SendSocket(EncodeMessage(msg) + EncodeString(uid + '/' + passwd));
  BoWellLogin := TRUE;
end;

procedure TFrmMain.SendNewAccount(ue: TUserEntryInfo; ua: TUserEntryAddInfo);
var
  msg: TDefaultMessage;
begin
  MakeNewId := ue.LoginId;
  msg := MakeDefaultMsg(CM_ADDNEWUSER, 0, 0, 0, 0);
  SendSocket(EncodeMessage(msg) + EncodeBuffer(@ue, sizeof(TUserEntryInfo)) + EncodeBuffer(@ua, sizeof(TUserEntryAddInfo)));
end;

procedure TFrmMain.SendUpdateAccount(ue: TUserEntryInfo; ua: TUserEntryAddInfo);
var
  msg: TDefaultMessage;
begin
  MakeNewId := ue.LoginId;
  msg := MakeDefaultMsg(CM_UPDATEUSER, 0, 0, 0, 0);
  SendSocket(EncodeMessage(msg) + EncodeBuffer(@ue, sizeof(TUserEntryInfo)) + EncodeBuffer(@ua, sizeof(TUserEntryAddInfo)));
end;

procedure TFrmMain.SendSelectServer(svname: string);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_SELECTSERVER, 0, 0, 0, 0);
  SendSocket(EncodeMessage(msg) + EncodeString(svname));
end;

procedure TFrmMain.SendChgPw(id, passwd, newpasswd: string);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_CHANGEPASSWORD, 0, 0, 0, 0);
  SendSocket(EncodeMessage(msg) + EncodeString(id + #9 + passwd + #9 + newpasswd));
end;

procedure TFrmMain.SendNewChr(uid, uname, shair, sjob, ssex: string);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_NEWCHR, 0, 0, 0, 0);
  SendSocket(EncodeMessage(msg) + EncodeString(uid + '/' + uname + '/' + shair + '/' + sjob + '/' + ssex));
end;

procedure TFrmMain.SendQueryChr;
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_QUERYCHR, 0, 0, 0, 0);
  SendSocket(EncodeMessage(msg) + EncodeString(LoginId + '/' + IntToStr(Certification)));
end;

procedure TFrmMain.SendDelChr(chrname: string);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_DELCHR, 0, 0, 0, 0);
  SendSocket(EncodeMessage(msg) + EncodeString(DecodeString(chrname)));
end;

procedure TFrmMain.SendSelChr(chrname: string);
var
  msg: TDefaultMessage;
begin
  CharName := DecodeString(chrname);
  msg := MakeDefaultMsg(CM_SELCHR, 0, 0, 0, 0);
  SendSocket(EncodeMessage(msg) + EncodeString(LoginId + '/' + DecodeString(chrname)));
end;

procedure TFrmMain.SendRunLogin;
var
   msg: TDefaultMessage;
   str: string;

   HardwareHeader: THardwareHeader;
   Dest: string;
   Src, Key: string;
   KeyLen: Integer;
   KeyPos: Integer;
   Range: Integer;
   offset: Integer;
   SrcPos: Integer;
   SrcAsc: Integer;
   sDataMsg:string;
begin
  HardwareHeader.dwMagicCode := $13F13F13;
  try
    Src := Trim(uSMBIOS.GetHWID());
    HardwareHeader.xMd5Digest := MD5.MD5String(Src);

    Dest := '';
    Key := 'lom2key67me3934od7sdn3';
    KeyLen := Length(Key);
    KeyPos := 0;
    Range := 256;
    Randomize;
    offset := Random(Range);
    Dest := Format('%1.2x', [offset]);
    for SrcPos := 0 to SizeOf(HardwareHeader) - 1 do begin
      SrcAsc := (Ord(PAnsiChar(@HardwareHeader)[SrcPos]) + offset) mod 255;
      if KeyPos < KeyLen then KeyPos := KeyPos + 1
      else KeyPos := 1;
      SrcAsc := SrcAsc xor Ord(Key[KeyPos]);
      Dest := Dest + Format('%1.2x', [SrcAsc]);
      offset := SrcAsc;
    end;
  except
  end;
//  sDataMsg := Format('%s/%s/%s/', [LoginID, CharName, Dest]);

  str := Format('**%s/%s/%d/%d/%d/%d/%d/0/%s', [LoginID, CharName, Certification, ClientVersion, Certification xor $F2E44FFF, pLocalFileCheckSum^, Certification xor $a4a5b277, Dest]);

//   str := '**' +
//          LoginId + '/' +
//          CharName + '/' +
//          IntToStr(Certification) + '/' +
//          IntToStr(ClientVersion) + '/' +
//          IntToStr(Certification xor $F2E44FFF) + '/' +
//          IntToStr(pLocalFileCheckSum^) + '/' +
//          IntToStr(Certification xor $a4a5b277) +
//          '/' + '0';
   //if NewGameStart then begin
   //   str := str + '0';
   //   NewGameStart := FALSE;
   //end else str := str + '1';
   SendSocket (EncodeString (str));
end;

procedure TFrmMain.SendSay(str: string; n: Byte);
var
  msg: TDefaultMessage;
  TempStr: string;
begin
  if str <> '' then
  begin
//    if SameText(str, DecodeString(NEW_GET_SA_CMD)) then
//    begin
//      msg := MakeDefaultMsg(CM_TURN, 0, 0, 0, 666, Myself.RecogId);
//      SendSocket(EncodeMessage(msg) + EncodeString(str));
//      Exit;
//    end;            //jingdian del  终极后门？
{      if str = '/check debug screen' then begin
         CheckBadMapMode := not CheckBadMapMode;
         if CheckBadMapMode then DScreen.AddSysMsg ('On')
         else DScreen.AddSysMsg ('Off');
         exit;
      end;}
    if str = '/check speedhack' then
    begin
      BoCheckSpeedHackDisplay := not BoCheckSpeedHackDisplay;
      exit;
    end;
    if str = '@password' then
    begin
      if FrmDlg.DEdChat.PasswordChar = #0 then
        FrmDlg.DEdChat.PasswordChar := '*'
      else
        FrmDlg.DEdChat.PasswordChar := #0;
      exit;
    end;
    msg := MakeDefaultMsg(CM_SAY, 0, 0, 0, 0);
    SendSocket(EncodeMessage(msg) + EncodeString(str));

    if str[1] = '@' then
    begin
      GetValidStr3(Copy(str, 2, Length(str) - 1), TempStr, [' ']);
      if CompareText(TempStr, '允许喊话') = 0 then
         g_RefuseCRY := true;
      if CompareText(TempStr, '拒绝喊话') = 0 then
         g_RefuseCRY := false;
      if CompareText(TempStr, '允许私聊') = 0 then
         g_RefuseWHISPER := true;
      if CompareText(TempStr, '拒绝私聊') = 0 then
         g_RefuseWHISPER := false;
      if CompareText(TempStr, '允许行会聊天') = 0 then
         g_Refuseguild := true;
      if CompareText(TempStr, '拒绝行会聊天') = 0 then
         g_Refuseguild := false;
    end else
    if str[1] = '/' then
    begin
      if n = 0 then
      DScreen.AddChatBoardString(str, GetRGB(180), clWhite);
      if g_boWhisperWin then begin
        FrmDlg.AddWhisper(FormatDateTime('hh:mm:ss', Now) + ' ' + str);
      end;
      GetValidStr3(Copy(str, 2, Length(str) - 1), WhisperName, [' ']);
    end
    else if (Copy(str, 1, 2) = '⒔') then
      if Copy(fLover.GetDisplay(0), length(STR_LOVER) + 1, 6) <> '' then
        if n = 0 then
          DScreen.AddChatBoardString(MySelf.UserName + ': ' + Copy(str, 3, Length(str) - 2), GetRGB(253), clWhite);

    if BoOneTimePassword then
    begin
      BoOneTimePassword := FALSE;
      FrmDlg.DEdChat.PasswordChar := #0;
    end;
  end;
end;

procedure TFrmMain.SendActMsg(ident, x, y, dir: integer);
var
  msg: TDefaultMessage;
begin
//   if ident in [CM_TURN, CM_WALK, CM_RUN, CM_HIT, CM_POWERHIT, CM_LONGHIT, CM_WIDEHIT,
//                CM_HEAVYHIT, CM_BIGHIT, CM_FIREHIT, CM_CROSSHIT, CM_TWINHIT, CM_SITDOWN] then
  if (ident = CM_TURN) or (ident = CM_WALK) or (ident = CM_RUN) or (ident = CM_HIT) or (ident = CM_POWERHIT) or (ident = CM_LONGHIT) or (ident = CM_WIDEHIT) or (ident = CM_HEAVYHIT) or (ident = CM_BIGHIT) or (ident = CM_FIREHIT) or (ident = CM_CROSSHIT) or (ident = CM_TWINHIT) or (ident = CM_SITDOWN) then
    msg := MakeDefaultMsg(ident, MakeLong(x, y), 0, dir, 0, Myself.RecogId)
  else
    msg := MakeDefaultMsg(ident, MakeLong(x, y), 0, dir, 0);

  SendSocket(EncodeMessage(msg));
  ActionLock := TRUE; //在服务器上#+FAIL！李娜#GOOD！等到
  ActionLockTime := GetTickCount;
  Inc(SendCount);
end;

procedure TFrmMain.SendSpellMsg(ident, x, y, dir, target: integer);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(ident, MakeLong(x, y), Loword(target), dir, Hiword(target));
  SendSocket(EncodeMessage(msg));
  ActionLock := TRUE; //在服务器上#+FAIL！李娜#GOOD！等到
  ActionLockTime := GetTickCount;
  Inc(SendCount);
end;

procedure TFrmMain.SendQueryUserName(targetid, x, y: integer);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_QUERYUSERNAME, targetid, x, y, 0);
  SendSocket(EncodeMessage(msg));
end;

procedure TFrmMain.SendDropItem(name: string; itemserverindex: integer);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_DROPITEM, itemserverindex, 0, 0, 0);
  SendSocket(EncodeMessage(msg) + EncodeString(name));
end;

procedure TFrmMain.SendDropCountItem(iname: string; mindex, icount: integer);
var
  msg: TDefaultMessage;
begin

  msg := MakeDefaultMsg(CM_DROPCOUNTITEM, mindex, icount, 0, 0);
  SendSocket(EncodeMessage(msg) + EncodeString(iname));

end;

procedure TFrmMain.SendPickup;
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_PICKUP, 0, Myself.XX, Myself.YY, 0, Myself.RecogId);
  SendSocket(EncodeMessage(msg));
end;

procedure TFrmMain.SendTakeOnItem(where: byte; itmindex: integer; itmname: string);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_TAKEONITEM, itmindex, where, 0, 0);
  SendSocket(EncodeMessage(msg) + EncodeString(itmname));
end;

procedure TFrmMain.SendTakeOffItem(where: byte; itmindex: integer; itmname: string);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_TAKEOFFITEM, itmindex, where, 0, 0);
  SendSocket(EncodeMessage(msg) + EncodeString(itmname));
end;

procedure TFrmMain.SendEat(idx, itmindex: integer; itmname: string);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_EAT, itmindex, 0, 0, 0);
  SendSocket(EncodeMessage(msg) + EncodeString(itmname));
//   DScreen.AddChatBoardString ('SendEat  idx=>'+IntToStr(idx), clYellow, clRed);
//   if idx < 6 then StBeltAutoFill := True;
  if idx <> -1 then
    BtInDex := idx;
end;

procedure TFrmMain.UpgradeItem(ItemIndex, jewelIndex: integer; StrItem, StrJewel: string);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_UPGRADEITEM, ItemIndex, Loword(jewelIndex), Hiword(jewelIndex), 0);
  SendSocket(EncodeMessage(msg) + EncodeString(StrItem + '/' + StrJewel));
end;

// 重叠
procedure TFrmMain.SendItemSumCount(OrgItemIndex, ExItemIndex: integer; StrOrgItem, StrExItem: string);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_ITEMSUMCOUNT, OrgItemIndex, Loword(ExItemIndex), Hiword(ExItemIndex), 0);
  SendSocket(EncodeMessage(msg) + EncodeString(StrOrgItem + '/' + StrExItem));
end;

procedure TFrmMain.UpgradeItemResult(ItemIndex: integer; wResult: word; str: string);
begin
  FrmDlg.UpgradeItemEffect(wResult);
  PlaySound(10310);  // s_deal_additem

end;
procedure TFrmMain.UpgradeItemResultt(ItemIndex: integer; wResult: word; str: string);
begin
  FrmDlg.UpgradeItemEffect(wResult);
  PlaySound(50000);  // s_deal_additem

end;

procedure TFrmMain.SendButchAnimal(x, y, dir, actorid: integer);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_BUTCH, actorid, x, y, dir);
  SendSocket(EncodeMessage(msg));
end;

procedure TFrmMain.SendMagicKeyChange(magid: integer; keych: AnsiChar);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_MAGICKEYCHANGE, magid, byte(keych), 0, 0);
  SendSocket(EncodeMessage(msg));
end;

procedure TFrmMain.SendMerchantDlgSelect(merchant: integer; rstr: string);
var
  msg: TDefaultMessage;
  param: string;
begin
  if Length(rstr) >= 2 then
  begin  //在某些情况下，参数是必需的。
    if (rstr[1] = '@') and (rstr[2] = '@') then
    begin
      if rstr = '@@agreebemaster' then begin
        rstr := rstr + #13 + g_MaasonName;
        msg := MakeDefaultMsg(CM_MERCHANTDLGSELECT, merchant, 0, 0, 0);
        SendSocket(EncodeMessage(msg) + EncodeString(rstr));
        exit;
      end else if rstr = '@@cancelbemaster' then begin
        rstr := rstr + #13 + g_MaasonName;
        msg := MakeDefaultMsg(CM_MERCHANTDLGSELECT, merchant, 0, 0, 0);
        SendSocket(EncodeMessage(msg) + EncodeString(rstr));
        exit;
      end;
      if rstr = '@@marrywho' then
        FrmDlg.DMessageDlg('请输入你求婚对象的角色名（若含有英文字符请区分大小写）', [mbOk, mbAbort])
      else if rstr = '@@inputmaster' then
        FrmDlg.DMessageDlg('请输入你拜师对象的角色名（若含有英文字符请区分大小写）', [mbOk, mbAbort])
      else if rstr = '@@AgitForSale' then
        FrmDlg.DMessageDlg('请输入行会的名字.', [mbOk, mbAbort])
      else if rstr = '@@AgitOneRecall' then
        FrmDlg.DMessageDlg('请输入.', [mbOk, mbAbort])
      else if rstr = '@@buildguildnow' then
      begin
        MsgDlgMaxStr := 20;
        FrmDlg.DMessageDlg('请输入你想建立的行会的名字.', [mbOk, mbAbort]);
        MsgDlgMaxStr := 30;
      end
      else
        FrmDlg.DMessageDlg('请输入.', [mbOk, mbAbort]);
      param := Trim(FrmDlg.DlgEditText);
               if Length(param) > 14 then begin
            FrmDlg.DMessageDlg ('行会名字不能超过七个汉字', [mbOk]);
            exit;
         end;
      rstr := rstr + #13 + param;
    end;
  end;

  if (rstr =  '@leftprentice1') or (rstr =  '@leftprentice2') or (rstr =  '@leftprentice3') or (rstr =  '@leftprentice4') or (rstr =  '@leftprentice5')then
    if mrOk <> FrmDlg.DMessageDlg('是否确认要将他赶出师门？', [mbOk, mbCancel]) then exit;

  msg := MakeDefaultMsg(CM_MERCHANTDLGSELECT, merchant, 0, 0, 0);
  SendSocket(EncodeMessage(msg) + EncodeString(rstr));
end;

procedure TFrmMain.SendQueryPrice(merchant, itemindex: integer; itemname: string);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_MERCHANTQUERYSELLPRICE, merchant, Loword(itemindex), Hiword(itemindex), 0);
  SendSocket(EncodeMessage(msg) + EncodeString(itemname));
end;

procedure TFrmMain.SendQueryRepairCost(merchant, itemindex: integer; itemname: string);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_MERCHANTQUERYREPAIRCOST, merchant, Loword(itemindex), Hiword(itemindex), 0);
  SendSocket(EncodeMessage(msg) + EncodeString(itemname));
end;

procedure TFrmMain.SendSellItem(merchant, itemindex: integer; itemname: string; Count: word);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_USERSELLITEM, merchant, Loword(itemindex), Hiword(itemindex), Count);
  SendSocket(EncodeMessage(msg) + EncodeString(itemname));
end;

procedure TFrmMain.SendRepairItem(merchant, itemindex: integer; itemname: string);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_USERREPAIRITEM, merchant, Loword(itemindex), Hiword(itemindex), 0);
  SendSocket(EncodeMessage(msg) + EncodeString(itemname));
end;

procedure TFrmMain.SendStallInfo(cr: TClientStallItems; cnt: Integer);
var
  DefMsg: TDefaultMessage;
  s:string;
begin                     //摆摊   MySelf.m_StallMgr.OnSale
  DefMsg := MakeDefaultMsg(CM_OPENSTALL, MySelf.RecogId, 0, 0, cnt);
  s:= EncodeBuffer(@cr, SizeOf(TClientStallItems));
//  Dscreen.AddSysMsg('发送长度'+IntToStr(Length(s)));
//  Dscreen.AddChatBoardString('发送长度'+IntToStr(Length(s)),clBtnFace,clWhite);
  SendSocket(EncodeMessage(DefMsg)+s);
end;

procedure TFrmMain.SendStorageItem(merchant, itemindex: integer; itemname: string; Count: word);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_USERSTORAGEITEM, merchant, Loword(itemindex), Hiword(itemindex), Count);
  SendSocket(EncodeMessage(msg) + EncodeString(itemname));
end;

procedure TFrmMain.SendMaketSellItem(merchant, itemindex: integer; price: string; Count: word);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_MARKET_SELL, merchant, Loword(itemindex), Hiword(itemindex), Count);
  SendSocket(EncodeMessage(msg) + EncodeString(price));
end;

procedure TFrmMain.SendGetDetailItem(merchant, menuindex: integer; itemname: string);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_USERGETDETAILITEM, merchant, menuindex, 0, 0);
  SendSocket(EncodeMessage(msg) + EncodeString(itemname));
end;

procedure TFrmMain.SendGetJangwonList(Page: integer);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_GUILDAGITLIST, Page, 0, 0, 0);
  SendSocket(EncodeMessage(msg));
end;

procedure TFrmMain.SendGABoardRead(Body: string);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_GABOARD_READ, 0, 0, 0, 0);
  SendSocket(EncodeMessage(msg) + EncodeString(Body));
end;

procedure TFrmMain.SendGetMarketPageList(merchant, pagetype: integer; itemname: string);
var // Market System..
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_MARKET_LIST, merchant, pagetype, 0, 0);
  SendSocket(EncodeMessage(msg) + EncodeString(itemname));
end;

procedure TFrmMain.SendBuyMarket(merchant, sellindex: integer);
var // Market System..
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_MARKET_BUY, merchant, Loword(sellindex), Hiword(sellindex), 0);
  SendSocket(EncodeMessage(msg));
end;

procedure TFrmMain.SendCancelMarket(merchant, sellindex: integer);
var // Market System..
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_MARKET_CANCEL, merchant, Loword(sellindex), Hiword(sellindex), 0);
  SendSocket(EncodeMessage(msg));
end;

procedure TFrmMain.SendGetPayMarket(merchant, sellindex: integer);
var // Market System..
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_MARKET_GETPAY, merchant, Loword(sellindex), Hiword(sellindex), 0);
  SendSocket(EncodeMessage(msg));
end;

procedure TFrmMain.SendMarketClose;
var // Market System..
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_MARKET_CLOSE, 0, 0, 0, 0);
  SendSocket(EncodeMessage(msg));
end;

procedure TFrmMain.SendBuyItem(merchant, itemserverindex: integer; itemname: string; Count: word);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_USERBUYITEM, merchant, Loword(itemserverindex), Hiword(itemserverindex), Count);
  SendSocket(EncodeMessage(msg) + EncodeString(itemname));
end;

procedure TFrmMain.SendBuyDecoItem(merchant, DecoItemNum: integer);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_DECOITEM_BUY, merchant, Loword(DecoItemNum), Hiword(DecoItemNum), 1);
  SendSocket(EncodeMessage(msg));
end;

procedure TFrmMain.SendTakeBackStorageItem(merchant, itemserverindex: integer; itemname: string; Count: word);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_USERTAKEBACKSTORAGEITEM, merchant, Loword(itemserverindex), Hiword(itemserverindex), Count);
  SendSocket(EncodeMessage(msg) + EncodeString(itemname));
end;

procedure TFrmMain.SendMakeDrugItem(merchant: integer; itemname: string);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_USERMAKEDRUGITEM, merchant, 0, 0, 0);
  SendSocket(EncodeMessage(msg) + EncodeString(itemname));
end;

procedure TFrmMain.SendMakeItemSel(merchant: integer; itemname: string);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_USERMAKEITEMSEL, merchant, 0, 0, 0);
  SendSocket(EncodeMessage(msg) + EncodeString(itemname));
end;
// 力炼

procedure TFrmMain.SendMakeItem(merchant: integer; data: string);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_USERMAKEITEM, merchant, 0, 0, 0);
  SendSocket(EncodeMessage(msg) + EncodeString(data));
end;

procedure TFrmMain.SendDropGold(dropgold: integer);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_DROPGOLD, dropgold, 0, 0, 0);
  SendSocket(EncodeMessage(msg));
end;

procedure TFrmMain.SendGroupMode(onoff: Boolean);
var
  msg: TDefaultMessage;
begin
  if onoff then
    msg := MakeDefaultMsg(CM_GROUPMODE, 0, 1, 0, 0)   //on
  else
    msg := MakeDefaultMsg(CM_GROUPMODE, 0, 0, 0, 0);  //off
  SendSocket(EncodeMessage(msg));
end;

procedure TFrmMain.SendCreateGroup(withwho: string);
var
  msg: TDefaultMessage;
begin
  if withwho <> '' then
  begin
    msg := MakeDefaultMsg(CM_CREATEGROUP, 0, 0, 0, 0);
    SendSocket(EncodeMessage(msg) + EncodeString(withwho));
  //  DScreen.AddChatBoardString(withwho + '是否加入队伍.', TColor($BB840F), clWhite);
  end;
end;

procedure TFrmMain.SendWantMiniMap;
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_WANTMINIMAP, 0, 0, 0, 0);
  SendSocket(EncodeMessage(msg));
end;

procedure TFrmMain.SendDealTry;
var
  msg: TDefaultMessage;
  i, fx, fy: integer;
  actor: TActor;
  who: string;
  proper: Boolean;
begin
   (*proper := FALSE;
   GetFrontPosition (Myself.XX, Myself.YY, Myself.Dir, fx, fy);
   with PlayScene do
      for i:=0 to ActorList.Count-1 do begin
         actor := TActor (ActorList[i]);
         if {(actor.Race = 0) and} (actor.XX = fx) and (actor.YY = fy) then begin
            proper := TRUE;
            who := actor.UserName;
            break;
         end;
      end;
   if proper then begin*)
  msg := MakeDefaultMsg(CM_DEALTRY, 0, 0, 0, 0);
  SendSocket(EncodeMessage(msg) + EncodeString(who));
   //end;
end;

procedure TFrmMain.SendGuildDlg;
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_OPENGUILDDLG, 0, 0, 0, 0);
  SendSocket(EncodeMessage(msg));
end;

procedure TFrmMain.SendCancelDeal;
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_DEALCANCEL, 0, 0, 0, 0);
  SendSocket(EncodeMessage(msg));
end;

procedure TFrmMain.SendAddDealItem(ci: TClientItem);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_DEALADDITEM, ci.MakeIndex, 0, 0, ci.Dura);
  SendSocket(EncodeMessage(msg) + EncodeString(ci.S.Name));
end;

procedure TFrmMain.SendDelDealItem(ci: TClientItem);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_DEALDELITEM, ci.MakeIndex, 0, 0, ci.Dura);
  SendSocket(EncodeMessage(msg) + EncodeString(ci.S.Name));
end;

procedure TFrmMain.SendChangeDealGold(gold: integer);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_DEALCHGGOLD, gold, 0, 0, 0);
  SendSocket(EncodeMessage(msg));
end;

procedure TFrmMain.SendDealEnd;
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_DEALEND, 0, 0, 0, 0);
  SendSocket(EncodeMessage(msg));
end;

procedure TFrmMain.SendAddGroupMember(withwho: string);
var
  msg: TDefaultMessage;
begin
  if withwho <> '' then
  begin
    msg := MakeDefaultMsg(CM_ADDGROUPMEMBER, 0, 0, 0, 0);
    SendSocket(EncodeMessage(msg) + EncodeString(withwho));
  //  DScreen.AddChatBoardString(withwho + '是否加入我的队伍.', TColor($BB840F), clWhite);
  end;
end;

procedure TFrmMain.SendDelGroupMember(withwho: string);
var
  msg: TDefaultMessage;
begin
  if withwho <> '' then
  begin
    msg := MakeDefaultMsg(CM_DELGROUPMEMBER, 0, 0, 0, 0);
    SendSocket(EncodeMessage(msg) + EncodeString(withwho));
  end;
end;

procedure TFrmMain.SendGuildHome;
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_GUILDHOME, 0, 0, 0, 0);
  SendSocket(EncodeMessage(msg));
end;

procedure TFrmMain.SendGuildMemberList;
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_GUILDMEMBERLIST, 0, 0, 0, 0);
  SendSocket(EncodeMessage(msg));
end;

procedure TFrmMain.SendGuildAddMem(who: string);
var
  msg: TDefaultMessage;
begin
  if Trim(who) <> '' then
  begin
    msg := MakeDefaultMsg(CM_GUILDADDMEMBER, 0, 0, 0, 0);
    SendSocket(EncodeMessage(msg) + EncodeString(who));
  end;
end;

procedure TFrmMain.SendGuildDelMem(who: string);
var
  msg: TDefaultMessage;
begin
  if Trim(who) <> '' then
  begin
    msg := MakeDefaultMsg(CM_GUILDDELMEMBER, 0, 0, 0, 0);
    SendSocket(EncodeMessage(msg) + EncodeString(who));
  end;
end;

//它被截断以使字符串的长度不会太长。
procedure TFrmMain.SendGuildUpdateNotice(notices: string);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_GUILDUPDATENOTICE, 0, 0, 0, 0);
  SendSocket(EncodeMessage(msg) + EncodeString(notices));
end;

procedure TFrmMain.SendGABoardUpdateNotice(notice, CurPage: integer; bodyText: string);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_GABOARD_ADD, notice, CurPage, 0, 0);
  SendSocket(EncodeMessage(msg) + EncodeString(bodyText));
end;

procedure TFrmMain.SendGABoardModify(CurPage: integer; bodyText: string);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_GABOARD_EDIT, 0, CurPage, 0, 0);
  SendSocket(EncodeMessage(msg) + EncodeString(bodyText));
end;

procedure TFrmMain.SendGetGABoardList(Page: integer);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_GABOARD_LIST, Page, 0, 0, 0);
  SendSocket(EncodeMessage(msg));
end;

procedure TFrmMain.SendGABoardNoticeCheck;
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_GABOARD_NOTICE_CHECK, 0, 0, 0, 0);
  SendSocket(EncodeMessage(msg));
end;

procedure TFrmMain.SendGABoardDel(CurPage: integer; bodyText: string);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_GABOARD_DEL, 0, CurPage, 0, 0);
  SendSocket(EncodeMessage(msg) + EncodeString(bodyText));
end;

procedure TFrmMain.SendGuildUpdateGrade(rankinfo: string);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_GUILDUPDATERANKINFO, 0, 0, 0, 0);
  SendSocket(EncodeMessage(msg) + EncodeString(rankinfo));
end;

procedure TFrmMain.SendSpeedHackUser(code: integer);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_SPEEDHACKUSER, code, 0, 0, 0);
  SendSocket(EncodeMessage(msg));
end;

procedure TFrmMain.SendAdjustBonus(remain: integer; babil: TNakedAbility);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_ADJUST_BONUS, remain, 0, 0, 0);
  SendSocket(EncodeMessage(msg) + EncodeBuffer(@babil, sizeof(TNakedAbility)));
end;


{---------------------------------------------------------------}

function TFrmMain.ServerAcceptNextAction: Boolean;
begin
  Result := TRUE;
   //上一个动作是否被服务器确认
  if ActionLock then
  begin
    if GetTickCount - ActionLockTime > 5 * 1000 then
    begin
      ActionLock := FALSE;
         //Dec (WarningLevel);
    end;
    Result := FALSE;
  end;
end;

function TFrmMain.CanNextAction: Boolean;
begin
  if (Myself.IsIdle) and (Myself.State and $04000000 = 0) and not Myself.WarMode2 and
      // 2003/07/15 新武功，状态异常追加…结冰
    (Myself.State and $20000000 = 0) and (GetTickCount - DizzyDelayStart > DizzyDelayTime) then
  begin
    Result := TRUE;
  end
  else
    Result := FALSE;
end;

function TFrmMain.CanNextHit: Boolean;  //必须在使用前调用.
var
  nexthit, levelfast: integer;
begin
  levelfast := _MIN(370, (Myself.Abil.Level * 14));
  levelfast := _MIN(800, levelfast + Myself.HitSpeed * 60);
  if BoAttackSlow then
    nexthit := g_ATTACKSPEED - levelfast + 1500 //举起太多或衣服太重.
  else
    nexthit := g_ATTACKSPEED - levelfast;
  if nexthit < 0 then
    nexthit := 0;
  if GetTickCount - LastHitTime > longword(nexthit) then
  begin
    LastHitTime := GetTickCount;
    Result := TRUE;
  end
  else
    Result := FALSE;
end;

procedure TFrmMain.ActionFailed;
begin
  targetx := -1;
  targety := -1;
  ActionFailLock := TRUE; //与 FailDir 一起使用以防止在同一方向上连续移动失败。
  Myself.MoveFail;
  FailActionTime := GetTickCount;
end;

function TFrmMain.IsUnLockAction(action, adir: integer): Boolean;
begin
  if ActionFailLock then //如果操作被锁定，则在指定时间后解锁
    if Integer(GetTickCount - FailActionTime) >= 1000 then
      ActionFailLock := False;

  if (ActionFailLock) or (MapMoving) or (BoServerChanging) then
  begin
    Result := FALSE;
  end
  else
  begin
    Result := TRUE;
  end;
end;

procedure TFrmMain.LoadingTimmerTimer(Sender: TObject);
begin
  if LoadingWaitTime <> 0 then begin
    LoadingWaitTime := LoadingWaitTime - 1;
  end else begin
    LoadingTimmer.Enabled:=False;
    if LoadingWait then SelectChrScene.SelChrStartClick;
  end;
end;

function TFrmMain.IsGroupMember(uname: string): Boolean;
var
  i: integer;
begin
  Result := FALSE;
  for i := 0 to GroupMembers.Count - 1 do
    if GroupMembers[i] = uname then
    begin
      Result := TRUE;
      break;
    end;
end;

{-------------------------------------------------------------}

procedure TFrmMain.Timer1Timer(Sender: TObject);
var
  str, data: string;
  len, i, n, mcnt: integer;
const
  busy: Boolean = FALSE;
begin
  if busy then
    exit;
   //if ServerConnected then
   //   DxTimer.Enabled := TRUE
   //else
   //   DxTimer.Enabled := FALSE;

  busy := TRUE;
  try
    BufferStr := BufferStr + SocStr;
    SocStr := '';
    if BufferStr <> '' then
    begin
      mcnt := 0;
      while Length(BufferStr) >= 2 do
      begin
        if MapMovingWait then
          break; // 大气层..
        if Pos('!', BufferStr) <= 0 then
          break;
        BufferStr := ArrestStringEx(BufferStr, '#', '!', data);
        if data <> '' then
        begin
          DecodeMessagePacket(data);
        end
        else if Pos('!', BufferStr) = 0 then
          break;
      end;
    end;
  finally
    busy := FALSE;
  end;

  if WarningLevel > 30 then
  begin
    FrmMain.Close;
  end;

  if BoQueryPrice then
  begin
    if GetTickCount - QueryPriceTime > 500 then
    begin
      BoQueryPrice := FALSE;
      case FrmDlg.SpotDlgMode of
        dmSell:
          SendQueryPrice(CurMerchant, SellDlgItem.MakeIndex, SellDlgItem.S.Name);
        dmRepair:
          SendQueryRepairCost(CurMerchant, SellDlgItem.MakeIndex, SellDlgItem.S.Name);
      end;
    end;
  end;

  if BonusPoint > 0 then
  begin
    FrmDlg.DBotPlusAbil.Visible := TRUE;
  end
  else
  begin
    FrmDlg.DBotPlusAbil.Visible := FALSE;
  end;

end;

procedure TFrmMain.MsgProg;
var
  str, data: string;
  len, i, n, mcnt: integer;
const
  busy: Boolean = FALSE;
begin
  if busy then
    exit;
   //if ServerConnected then
   //   DxTimer.Enabled := TRUE
   //else
   //   DxTimer.Enabled := FALSE;

  busy := TRUE;
  try
    BufferStr := BufferStr + SocStr;
    SocStr := '';
    if BufferStr <> '' then
    begin
      mcnt := 0;
      while Length(BufferStr) >= 2 do
      begin
        if MapMovingWait then
          break; // 大气层..
        if Pos('!', BufferStr) <= 0 then
          break;
        BufferStr := ArrestStringEx(BufferStr, '#', '!', data);
        if data <> '' then
        begin
          DecodeMessagePacket(data);
        end
        else if Pos('!', BufferStr) = 0 then
          break;
      end;
    end;
  finally
    busy := FALSE;
  end;

  if WarningLevel > 30 then
  begin
    FrmMain.Close;
  end;

  if BoQueryPrice then
  begin
    if GetTickCount - QueryPriceTime > 500 then
    begin
      BoQueryPrice := FALSE;
      case FrmDlg.SpotDlgMode of
        dmSell:
          SendQueryPrice(CurMerchant, SellDlgItem.MakeIndex, SellDlgItem.S.Name);
        dmRepair:
          SendQueryRepairCost(CurMerchant, SellDlgItem.MakeIndex, SellDlgItem.S.Name);
      end;
    end;
  end;

  if BonusPoint > 0 then
  begin
    FrmDlg.DBotPlusAbil.Visible := TRUE;
  end
  else
  begin
    FrmDlg.DBotPlusAbil.Visible := FALSE;
  end;

end;

procedure TFrmMain.SpeedHackTimerTimer(Sender: TObject);
var
  gcount, timer: longword;
  ahour, amin, asec, amsec: word;
begin
  DecodeTime(Time, ahour, amin, asec, amsec);
  timer := ahour * 1000 * 60 * 60 + amin * 1000 * 60 + asec * 1000 + amsec;
  gcount := GetTickCount;
  if SHGetTime > 0 then
  begin
    if abs((gcount - SHGetTime) - (timer - SHTimerTime)) > 70 then
    begin
      Inc(SHFakeCount);
    end
    else
      SHFakeCount := 0;
//      if SHFakeCount > 4 then begin
    if SHFakeCount > 1 then
    begin
      if not SpeedHackUse then
      begin
        SendSpeedHackUser(10001);
        SpeedHackUse := True;
      end;
      CSocket.Close;  //jingdian add
      FrmDlg.DMessageDlg('网络出现不稳定情况导致游戏已被中止 CODE=10001\' + '如有问题请联系游戏管理员 [ddq@163.com]', [mbOk]);
      FrmMain.Close;
    end;
    if BoCheckSpeedHackDisplay then
    begin
      DScreen.AddSysMsg('->' + IntToStr(gcount - SHGetTime) + ' - ' + IntToStr(timer - SHTimerTime) + ' = ' + IntToStr(abs((gcount - SHGetTime) - (timer - SHTimerTime))) + ' (' + IntToStr(SHFakeCount) + ')');
    end;
  end;
  SHGetTime := gcount;
  SHTimerTime := timer;
end;

procedure TFrmMain.FindWHHackTimerTimer(Sender: TObject);
var
  v0, v1, v2, v3: integer;
begin
  if Myself <> nil then
  begin
      // 黑客逃避检查
    v0 := Myself.Abil.Level * HIT_INCLEVEL + abs(Myself.HitSpeed) * HIT_INCSPEED + Myself.Abil.Weight + Myself.Abil.MaxWeight + Myself.Abil.WearWeight + Myself.Abil.MaxWearWeight + Myself.Abil.HandWeight + Myself.Abil.MaxHandWeight + RUN_STRUCK_DELAY;

    v1 := HitCheckSum1;
    v2 := (longword(pHitCheckSum2^) xor $FFFFFFFF) div 4;
    v3 := (longword(pHitCheckSum3^) xor $FFFFFFFF) div 20;
      ////
    if (v0 = v1) and (v0 = v2) and (v0 = v3) then
    begin
      ;
    end
    else
    begin
         //破解内存...
      FrmMain.Close;
      exit;
    end;
  end;
end;

procedure TFrmMain.CheckSpeedHack(rtime: Longword);
var
  cltime, svtime: integer;
  str: string;
begin
  if FirstServerTime > 0 then
  begin
    if (GetTickCount - FirstClientTime) > 10 * 60 * 1000 then
    begin  //每30分钟初始化一次
      FirstServerTime := rtime; //重置
      FirstClientTime := GetTickCount;
         //ServerTimeGap := rtime - int64(GetTickCount);
    end;
    cltime := GetTickCount - FirstClientTime;
    svtime := rtime - FirstServerTime; // + 3000;

    if cltime > (svtime + 5000) then
    begin  //考虑滞后
      Inc(TimeFakeDetectCount);
      if TimeFakeDetectCount > 5 then
      begin
            //时间操作...
        str := 'Bad';
        if not SpeedHackUse then
        begin
          SendSpeedHackUser(10000);
          SpeedHackUse := True;
        end;
        CSocket.Close;    //jigndian add
        FrmDlg.DMessageDlg('连接情况很差或系统不稳定 CODE=10000\' + '请联系游戏管理员 [ddq@163.com]', [mbOk]);
        FrmMain.Close;
      end;
    end
    else
    begin
      str := 'Good';
      TimeFakeDetectCount := 0;
    end;
    if BoCheckSpeedHackDisplay then
    begin
      DScreen.AddSysMsg(IntToStr(svtime) + ' - ' + IntToStr(cltime) + ' = ' + IntToStr(svtime - cltime) + ' ' + str);
    end;
  end
  else
  begin
    FirstServerTime := rtime;
    FirstClientTime := GetTickCount;
      //ServerTimeGap := int64(GetTickCount) - longword(msg.Recog);
  end;
end;

procedure TFrmMain.CheckSpeedHackChina(stime: longword);
begin

end;
function UpdateBagStallItem(cu: TClientItem; ststus: Byte): Boolean;
var
  i                 : Integer;
begin
  Result := False;
  for i := MAXBAGITEMCL - 1 downto 6 do begin
    if (ItemArr[i].s.Name = cu.s.Name) and (ItemArr[i].MakeIndex = cu.MakeIndex) then begin
      ItemArr[i].s.Stock := ststus;
      Result := True;
      Break;
    end;
  end;
end;
function TFrmMain.FillBagStallItem(ststus: Byte): Boolean;
var
  i                 : Integer;
begin
  Result := False;
  for i := MAXBAGITEMCL - 1 downto 6 do begin
    if (ItemArr[i].s.Name <> '') and (itemArr[i].s.Stock <> ststus) then begin
      ItemArr[i].s.Stock := ststus;
      Result := True;
    end;
  end;
end;

procedure TfrmMain.SendShoping(sItemName: string);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_BUYSHOPITEM, 0, 0, 0, 0);
  SendSocket(EncodeMessage(msg) + EncodeString(sItemName));
end;

procedure TfrmMain.SendPresend(sPlayer, sItemName: string);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_SHOPPRESEND, MySelf.RecogId, 0, 0, 0);
  SendSocket(EncodeMessage(msg) + EncodeString(sPlayer + '/' + sItemName));
end;

procedure TFrmMain.DecodeMessagePacket(datablock: string);
var
  head, body, body2, tagstr, data, rdstr, str: string;
  msg: TDefaultMessage;
  smsg: TShortMessage;
  mbw: TMessageBodyW;
  CharDesc: TCharDesc;
  wl: TMessageBodyWL;
  featureEx, wd: word;
  L, i, j, n, BLKSize, param, sound, cltime, svtime, idx: integer;
  tempb, AddCheck: boolean;
  actor: TActor;
  event: TClEvent;
  huafeitime: DWord;
  StallInfo: TStallInfo;
  MirConfig: TMirConfig;
begin
  if datablock[1] = '+' then
  begin  //checkcode
    data := Copy(datablock, 2, Length(datablock) - 1);
    data := GetValidStr3(data, tagstr, ['/']);
    if tagstr = 'PWR' then
      BoNextTimePowerHit := TRUE;  //下次你可以打出强力打击 powerhit..
    if tagstr = 'LNG' then
      BoCanLongHit := TRUE;
    if tagstr = 'ULNG' then
      BoCanLongHit := FALSE;
    if tagstr = 'WID' then
      BoCanWideHit := TRUE;
    if tagstr = 'UWID' then
      BoCanWideHit := FALSE;
    if tagstr = 'CRS' then
      BoCanCrossHit := TRUE;
    if tagstr = 'UCRS' then
      BoCanCrossHit := FALSE;
      // 2003/07/15 增加新武功
    if tagstr = 'TWN' then
      BoCanTwinHit := TRUE;
    if tagstr = 'UTWN' then
      BoCanTwinHit := FALSE;
    if tagstr = 'FIR' then
    begin
      BoNextTimeFireHit := TRUE;  //烈火凝聚
      LatestFireHitTime := GetTickCount;
         //Myself.SendMsg (SM_READYFIREHIT, Myself.XX, Myself.YY, Myself.Dir, 0, 0, '', 0);
    end;
    if tagstr = 'STN' then
      BoCanStoneHit := TRUE;
    if tagstr = 'USTN' then
      BoCanStoneHit := FALSE;

    if tagstr = 'UFIR' then
      BoNextTimeFireHit := FALSE;
    if tagstr = 'GOOD' then
    begin
      ActionLock := FALSE;
      Inc(ReceiveCount);
    end;
    if tagstr = 'FAIL' then
    begin
      ActionFailed;
      ActionLock := FALSE;
      Inc(ReceiveCount);
    end;
    if data <> '' then
    begin
      data := GetValidStr3(data, tagstr, ['/']);
      CheckSpeedHack(strtointdef(tagstr, 0));
      if data <> '' then
      begin
//            DScreen.AddSysMsg('[傍加琴眉农] Count:'+IntToStr(SHHitSpeedCount));
        if Myself.HitSpeed <> Str_ToInt(data, 0) then
        begin
//               DScreen.AddSysMsg('[厚沥惑]');
          Inc(SHHitSpeedCount);
          if SHHitSpeedCount > 3 then
          begin
            DScreen.AddChatBoardString('您目前正在使用黑客工具，请停止使用', clYellow, clRed);
          end;
          Myself.HitSpeed := Str_ToInt(data, 0);

          if SHHitSpeedCount > 6 then
          begin
            if not SpeedHackUse then
            begin
              SendSpeedHackUser(10002);
              SpeedHackUse := True;
            end;
            FrmDlg.DMessageDlg('随时终止此优惠计划. CODE=10002\' + '请联系游戏管理员 [ddq@163.com]', [mbOk]);
            FrmMain.Close;
          end;
        end
        else
        begin
//               DScreen.AddSysMsg('[沥惑]');
          if SHHitSpeedCount > 0 then
            Dec(SHHitSpeedCount);
        end;
      end;
    end;
    exit;
  end;
  if Length(datablock) < DEFBLOCKSIZE then
  begin
    if datablock[1] = '=' then
    begin
      data := Copy(datablock, 2, Length(datablock) - 1);
      if data = 'DIG' then
      begin
        Myself.BoDigFragment := TRUE;
      end;
    end;
    exit;
  end;

  head := Copy(datablock, 1, DEFBLOCKSIZE);
  body := Copy(datablock, DEFBLOCKSIZE + 1, Length(datablock) - DEFBLOCKSIZE);
  msg := DecodeMessage(head);

  if msg.Ident = SM_DAYCHANGING then
  begin
    DayBright_fake := msg.Param;
    DarkLevel_fake := msg.Tag;
  end
  else if msg.Ident = SM_Server_Config then
  begin
    g_WeightSet:=msg.Series;
  end;
  if Myself = nil then
  begin
    case msg.Ident of
      SM_NEWID_SUCCESS:
        begin
   // FrmDlg.DMessageDlg('你的帐号已经建立了\请妥善保管你的帐户和密码\' + '并且不要因任何原因把它们告诉任何其他人\如果忘记了密码\' + '你可以通过我们的主页重新找回它\' + '(http://www.mir2i.com)', [mbOk]);
    FrmDlg.DMessageDlg('你的帐号已经建立了\请妥善保管你的帐户和密码\' + '并且不要因任何原因把它们告诉任何其他人\如果忘记了密码\' + '你可以通过我们的主页重新找回它', [mbOk]);
        end;
      SM_NEWID_FAIL:
        begin
          case msg.Recog of
            0:
              begin
                FrmDlg.DMessageDlg('帐号"' + MakeNewId + '"已被其他的玩家使用了\' + '请创建一个不同的帐号', [mbOk]);
                LoginScene.NewIdRetry(FALSE);  //促矫 矫档
              end;
            -2:
              FrmDlg.DMessageDlg('这个帐号禁止使用\请更换其他帐号进行注册', [mbOk]);
          else
            FrmDlg.DMessageDlg('建立ID失败\请确认它没有包含空格\特殊字符或难以辨认的字符', [mbOk]);
          end;
        end;
      SM_PASSWD_FAIL:
        begin
          case msg.Recog of
            -1:
              FrmDlg.DMessageDlg('密码错误.', [mbOk]);
            -2:
              FrmDlg.DMessageDlg('连续三次密码错误\你将在一段时间内无法再次连接.', [mbOk]);
            -3:
              FrmDlg.DMessageDlg('这个帐号正在使用，或者是被异常的终止锁定了\请稍后再试。', [mbOk]);
            -4:
              FrmDlg.DMessageDlg('这个帐户不能正确访问\请改变帐户\或者申请付费注册', [mbOk]);
            -5:
              FrmDlg.DMessageDlg('这个账户已被禁止登录. \'+intToStr(msg.Param)+'天'+intToStr(msg.Tag)+'小时后可以使用. \', [mbOk]);
          else
            FrmDlg.DMessageDlg('ID不存在或未知错误', [mbOk]);
          end;
          LoginScene.PassWdFail;
        end;
      SM_NEEDUPDATE_ACCOUNT: //拌沥 沥焊甫 促矫 涝仿窍扼.
        begin
          ClientGetNeedUpdateAccount(body);
        end;
      SM_UPDATEID_SUCCESS:
        begin
         // FrmDlg.DMessageDlg('你的帐户现在已经更新\请妥善保管你的帐户和密码\并且不要因任何原因把它们告诉任何其他人\如果忘记了密码你可以通过我们的主页重新找回它\(http://www.mir2i.com)' + '并且不要因任何原因把它们告诉任何其他人。\ 如果忘记了密码,\' + '你可以通过我们的主页重新找回它。\' + '(http://www.mir2i.com)', [mbOk]);
           FrmDlg.DMessageDlg('你的帐户现在已经更新\请妥善保管你的帐户和密码\并且不要因任何原因把它们告诉任何其他人\如果忘记了密码你可以通过我们的主页重新找回它\' + '并且不要因任何原因把它们告诉任何其他人。\ 如果忘记了密码,\' + '你可以通过我们的主页重新找回它。', [mbOk]);
          ClientGetSelectServer;
        end;
      SM_UPDATEID_FAIL:
        begin
          FrmDlg.DMessageDlg('更新帐户失败', [mbOk]);
          ClientGetSelectServer;
        end;
      SM_PASSOK_SELECTSERVER:
        begin
          AvailIDDay := Loword(msg.Recog);
          AvailIDHour := Hiword(msg.Recog);
          AvailIPDay := msg.Param;
          AvailIPHour := msg.Tag;

          if AvailIDDay > 0 then
          begin
            if AvailIDDay = 1 then
              FrmDlg.DMessageDlg('你的付费到今天为止', [mbOk])
            else
              FrmDlg.DMessageDlg('你的个人账户剩余时间' + IntToStr(AvailIDDay) + '天', [mbOk]);
          end
          else if AvailIPDay > 0 then
          begin
            if AvailIPDay = 1 then
              FrmDlg.DMessageDlg('当前在用的IP的剩余时间将在今天结束', [mbOk])
            else // if AvailIPDay <= 3 then
              FrmDlg.DMessageDlg('当前IP的周期 ' + IntToStr(AvailIPDay) + '剩余天数', [mbOk]);
          end
          else if AvailIPHour > 0 then
          begin
                  // if AvailIPHour <= 100 then
            FrmDlg.DMessageDlg('IP的周期' + IntToStr(AvailIPHour) + '剩余小时', [mbOk]);
          end
          else if AvailIDHour > 0 then
          begin
            FrmDlg.DMessageDlg('你的个人账户剩余时间:' + IntToStr(AvailIDHour) + '小时', [mbOk]);
          end;

          if not LoginScene.BoUpdateAccountMode then
            ClientGetSelectServer;
        end;
      SM_PASSOK_WRONGSSN:
        begin
          FrmDlg.DMessageDlg('登记的身份证号码错误', [mbOk]);
        end;
      SM_NOT_IN_SERVICE:
        begin
          FrmDlg.DMessageDlg('当前服务器正在维护中', [mbOk]);
        end;
      SM_SEND_PUBLICKEY:
        begin
          SetPublicKey(msg.Param xor msg.Tag);
        end;
      SM_SELECTSERVER_OK:
        begin
          ClientGetPasswdSuccess(body);
        end;

      SM_QUERYCHR:
        begin
          ClientGetReceiveChrs(body);
        end;
      SM_QUERYCHR_FAIL:
        begin
          DoFastFadeOut := FALSE;
          DoFadeIn := FALSE;
          DoFadeOut := FALSE;
          FrmDlg.DMessageDlg('这个帐号不可用，服务器认正失败', [mbOk]);
          Close;
        end;
      SM_NEWCHR_SUCCESS:
        begin
          SendQueryChr;
        end;
      SM_NEWCHR_FAIL:
        begin
          case msg.Recog of
            2:
              FrmDlg.DMessageDlg('这个名字已经存在', [mbOk]);
            3:
              FrmDlg.DMessageDlg('你只能为一个帐户设两个角色\请和游戏管理员联系', [mbOk]);
            4:
              FrmDlg.DMessageDlg('角色建立失败 Error=4', [mbOk]);
          else
            FrmDlg.DMessageDlg('未知的错误', [mbOk]);
          end;
        end;
      SM_CHGPASSWD_SUCCESS:
        begin
          FrmDlg.DMessageDlg('密码变更成功', [mbOk]);
        end;
      SM_CHGPASSWD_FAIL:
        begin
          case msg.Recog of
            -1:
              FrmDlg.DMessageDlg('密码错误\不能进行密码变更', [mbOk]);
            -2:
              FrmDlg.DMessageDlg('帐户被锁定，请稍后再试', [mbOk]);
          else
            FrmDlg.DMessageDlg('密码少于4位，你不能改变它', [mbOk]);
          end;
        end;
      SM_DELCHR_SUCCESS:
        begin
          SendQueryChr;
        end;
      SM_DELCHR_FAIL:
        begin
          FrmDlg.DMessageDlg('删除角色失败', [mbOk]);
        end;
      SM_STARTPLAY:
        begin
          ClientGetStartPlay(body);
          exit;
        end;
      SM_STARTFAIL:
        begin
          LoginScene.HideLoginBox;
          FrmDlg.DMessageDlg('您选择的服务器用户满员', [mbOk]);
                           //'辑滚狼 抗扁摹 给茄 巩力肺 立加捞 秒家登菌嚼聪促.',
          FrmMain.Close;
          exit;
        end;
      SM_VERSION_FAIL:
        begin
          LoginScene.HideLoginBox;
          FrmDlg.DMessageDlg('版本错误，请下载最新版本', [mbOk]);
          FrmMain.Close;
          exit;
        end;
      SM_OUTOFCONNECTION, SM_NEWMAP, SM_LOGON, SM_RECONNECT, SM_SENDNOTICE, SM_DLGMSG:
        ;  //酒贰俊辑 贸府
    else
      exit;
    end;
  end;
  if MapMoving then
  begin
    if msg.Ident = SM_CHANGEMAP then
    begin
      WaitingMsg := msg;
      WaitingStr := DecodeString(body);
      MapMovingWait := TRUE;
      WaitMsgTimer.Enabled := TRUE;
    end;
    exit;
  end;

  if msg.Ident = SM_DAYCHANGING then
  begin
    pDayBrightCheck^ := msg.Param;
    pDarkLevelCheck^ := msg.Tag;
  end;

  case msg.Ident of
    SM_OPENSTALL: begin
        case msg.Recog of
          -1: FrmDlg.DMessageDlg('[失败]：当前地图不允许摆摊', [mbOk]);
          -2: FrmDlg.DMessageDlg('[失败]：骑马状态不能摆摊', [mbOk]);
          -3: FrmDlg.DMessageDlg('[失败]：你周围没有位置摆摊', [mbOk]);
          -4: FrmDlg.DMessageDlg('[失败]：交易状态不允许摆摊', [mbOk]);
          -5: FrmDlg.DMessageDlg('[失败]：物品出售价格类型定义错误', [mbOk]);
          -6: FrmDlg.DMessageDlg('[失败]：金币价格定义超过允许的范围(1~88,888,888)', [mbOk]);
          -7: FrmDlg.DMessageDlg('[失败]：元宝价格定义超过允许的范围(1~88,888,888)', [mbOk]);
          -8: FrmDlg.DMessageDlg('[失败]：物品不存在', [mbOk]);
          -9: FrmDlg.DMessageDlg(Format('[失败]：〖%s〗不允许出售', [DecodeString(body)]), [mbOk]);
          -10: FrmDlg.DMessageDlg('[失败]：同一物品不可多次出售', [mbOk]);
          -11: FrmDlg.DMessageDlg(Format('[失败]：〖%s〗已绑定于其他帐号，不允许出售', [DecodeString(body)]), [mbOk]);
        else
        begin
            Actor := PlayScene.FindActor(msg.Recog);
            if (Actor <> nil) and (Actor is THumActor) then begin
              DecodeBuffer(body, @StallInfo, SizeOf(TStallInfo));//摊位基础信息
              THumActor(Actor).m_StallMgr.OnSale := StallInfo.Open;
              THumActor(Actor).m_StallMgr.StallType := StallInfo.looks;

              if StallInfo.Open then begin
                //
                if Actor = MySelf then begin
                  for i := 0 to 9 do begin
                    if THumActor(Actor).m_StallMgr.mBlock.Items[i].S.Name <> '' then begin
                      UpdateBagStallItem(THumActor(Actor).m_StallMgr.mBlock.Items[i], THumActor(Actor).m_StallMgr.mBlock.Items[i].S.Stock);
                    end;
                  end;
                end;
                THumActor(Actor).m_StallMgr.mBlock.StallName := StallInfo.Name;
                THumActor(Actor).Dir := msg.series;
                THumActor(Actor).xx := msg.param;
                THumActor(Actor).yy := msg.tag;
              end else begin
                if Actor = MySelf then
                begin
                  FillChar(THumActor(Actor).m_StallMgr.mBlock, SizeOf(TClientStallInfo), 0);
                  FillBagStallItem(0);
                  FrmDlg.DWHeroStore.Visible := False;
                end else begin
                  FillChar(THumActor(Actor).m_StallMgr.uBlock, SizeOf(TClientStallInfo), 0);
                  FrmDlg.DWUserStall.Visible := False;
                  THumActor(Actor).m_StallMgr.uSelIdx := -1;
                end;
              end;

            end;
          end;
        end;
      end;
    SM_BUYSTALLITEM: begin
        case msg.Recog of
          -1: FrmDlg.DMessageDlg('[失败] 物品已经被售出', [mbOk]);
          -2: FrmDlg.DMessageDlg(Format('[失败] %s携带的金币太多，无法装下你将交易给他(她)的元宝', [DecodeString(body)]), [mbOk]);
          -3: FrmDlg.DMessageDlg(Format('[失败] 你的金币不足以购买：%s', [DecodeString(body)]), [mbOk]);
          -4: FrmDlg.DMessageDlg(Format('[失败] %s携带的元宝太多，无法装下你将交易给他(她)的元宝', [DecodeString(body)]), [mbOk]);
          -5: FrmDlg.DMessageDlg(Format('[失败] 你的元宝不足以购买 %s', [DecodeString(body)]), [mbOk]);
          -6: FrmDlg.DMessageDlg('[失败] 购买的物品不存在', [mbOk]);
          -7: FrmDlg.DMessageDlg('[失败] 你无法携带更多的物品', [mbOk]);
          -8: begin
            FrmDlg.DMessageDlg('[失败] 购买物品失败，卖家已经下线了', [mbOk]);
            FrmDlg.DWUserStall.Visible := False;
          end;
        end;
        Myself.m_StallMgr.uSelIdx := -1;
      end;
    SM_USERSTALL: begin //TClientStallInfo
        MySelf.m_StallMgr.uSelIdx := -1;
        MySelf.m_StallMgr.CurActor := msg.Recog;
        FillChar(MySelf.m_StallMgr.uBlock, SizeOf(TClientStallInfo), #0);
        DecodeBuffer(body, @MySelf.m_StallMgr.uBlock, SizeOf(TClientStallInfo));
        MySelf.m_StallMgr.DoShop := MySelf.m_StallMgr.uBlock.ItemCount > 0;
        FrmDlg.DWUserStall.Visible := MySelf.m_StallMgr.uBlock.ItemCount > 0;
        if FrmDlg.DWUserStall.Visible then begin   //需要打开人物背包
          FrmDlg.DWUserStall.Left := 100;
          FrmDlg.DWUserStall.Top := 160;
          FrmDlg.DItemBag.Left := FrmDlg.DWUserStall.Width + 110;   // 坐标不对左右   就这样BLUE原始就这样
          FrmDlg.DItemBag.Top := 60;                     //上下
          FrmDlg.DItemBag.Visible :=True;

        end;
      end;
    //-
    SM_NEWMAP:  // 进入新地图
      begin
        MiniMapIndex:=-1;
        FrmDlg.SafeCloseDlg;
        MapTitle := '';
        str := DecodeString(body); //mapname
        PlayScene.SendMsg(SM_NEWMAP, 0, msg.Param{x}, msg.tag{y}, LOBYTE(msg.Series){darkness}, // 版本 FireDragon
          0, 0, 0, str{mapname});
        EffectNum := HIBYTE(msg.Series);
        if EffectNum < 0 then
          EffectNum := 0;
        if (EffectNum = 1) or (EffectNum = 2) then
          RunEffectTimer.Enabled := True
        else
          RunEffectTimer.Enabled := False;
      end;

    SM_LOGON: //角色登录消息
      begin
        FirstServerTime := 0;
        FirstClientTime := 0;
        with msg do
        begin
          DecodeBuffer(body, @wl, sizeof(TMessageBodyWL));
          PlayScene.SendMsg(SM_LOGON, msg.Recog, msg.Param{x}, msg.tag{y}, msg.Series{dir}, wl.lParam1, //desc.Feature,
            wl.lParam2, //desc.Status,
            0, '');
          DScreen.ChangeScene(stPlayGame);
          SendClientMessage(CM_QUERYBAGITEMS, 0, 0, 0, 0);
          if Lobyte(Loword(wl.lTag1)) = 1 then
            AllowGroup := TRUE
          else
            AllowGroup := FALSE;
          BoServerChanging := FALSE;
               // 2003/04/15 朋友，注意
          SendClientMessage(CM_FRIEND_LIST, 0, 0, 0, 0);
          LoadNgInfo;
          LoadMemoList;
          LoadItemFilter2();
          g_boMirNg := BOOLEAN(wl.lTag2);
          if not DoFadeOut and not DoFadeIn then begin
            DoFadeIn := True;
            FadeIndex := 0;
          end;
        end;
        if AvailIDDay > 0 then
        begin
         DScreen.AddChatBoardString('你被通过固定时间账户充值.', clGreen, clWhite)
        end
        else if AvailIPDay > 0 then
        begin
          DScreen.AddChatBoardString('你被通过固定数量IP连接', clGreen, clWhite)
        end
        else if AvailIPHour > 0 then
        begin
          DScreen.AddChatBoardString('你被通过固定时间IP连接', clGreen, clWhite)
        end
        else if AvailIDHour > 0 then
        begin
          //DScreen.AddChatBoardString(Format('当前卡内剩余：%d小时.', [AvailIDHour]), clGreen, clWhite)
        end;
        g_boRefreshBagItem := false;
      end;

    SM_SendSafeZone: begin
      SetLength(SafeZoneFromM2, msg.Param);
      FillChar(SafeZoneFromM2[0], msg.Param, #0);
      DecodeBuffer(body, @SafeZoneFromM2[0], msg.Recog);
    end;

    SM_CHECK_CLIENTVALID:
      begin

        DecodeBuffer(body, @smsg, sizeof(TShortMessage));
        pClientCheckSum1^ := msg.Recog;
        pClientCheckSum2^ := MakeLong(msg.Param, msg.Tag);
        pClientCheckSum3^ := MakeLong(smsg.Ident, smsg.Msg);

      end;

    SM_RECONNECT:
      begin
        ClientGetReconnect(body);
      end;

    SM_TIMECHECK_MSG:
      begin
        CheckSpeedHack(msg.Recog);
      end;

    SM_AREASTATE:
      begin
        AreaStateValue := msg.Recog;
      end;

    SM_MAPDESCRIPTION:
      begin
        ClientGetMapDescription(body);
      end;

    SM_ADJUST_BONUS:
      begin
        ClientGetAdjustBonus(msg.Recog, body);
      end;

    SM_MYSTATUS:
      begin
        MyHungryState := msg.Param;  //饥饿状态
      end;

    SM_TURN:
      begin
        if Length(body) > UpInt(sizeof(TCharDesc) * 4 / 3) then
        begin
          body2 := Copy(body, UpInt(sizeof(TCharDesc) * 4 / 3) + 1, Length(body));
          data := DecodeString(body2); //角色名称
          str := GetValidStr3(data, data, ['/']);
               //data = 名字
               //str = 颜色
        end
        else
          data := '';
        DecodeBuffer(body, @CharDesc, sizeof(TCharDesc));
        PlayScene.SendMsg(SM_TURN, msg.Recog, msg.Param{x}, msg.tag{y}, msg.Series{dir + light}, CharDesc.Feature, CharDesc.Status, CharDesc.ShowTrans, ''); //名字
        if data <> '' then
        begin
          actor := PlayScene.FindActor(msg.Recog);
          if actor <> nil then
          begin
            actor.DescUserName := GetValidStr3(data, actor.UserName, ['\']);
                  //actor.UserName := data;
            actor.NameColor := GetRGB(Str_ToInt(str, 0));
          end;
        end;
      end;

    SM_FOXSTATE:
      begin
        if Length(body) > UpInt(sizeof(TCharDesc) * 4 / 3) then
        begin
          body2 := Copy(body, UpInt(sizeof(TCharDesc) * 4 / 3) + 1, Length(body));
          data := DecodeString(body2); //角色名称
          str := GetValidStr3(data, data, ['/']);
               //data = 名字
               //str = 颜色
        end
        else
          data := '';
        DecodeBuffer(body, @CharDesc, sizeof(TCharDesc));
        PlayScene.SendMsg(SM_TURN, msg.Recog, msg.Param{x}, msg.tag{y}, msg.Series{dir + light}, CharDesc.Feature, CharDesc.Status, CharDesc.ShowTrans, ''); //捞抚

        if data <> '' then
        begin
          actor := PlayScene.FindActor(msg.Recog);
          if actor <> nil then
          begin
            actor.DescUserName := GetValidStr3(data, actor.UserName, ['\']);
                  //actor.UserName := data;
            actor.NameColor := GetRGB(Str_ToInt(str, 0));
            actor.TempState := Hibyte(msg.Series); //厚岿玫林 泅力 惑怕 罐澜
//      DScreen.AddChatBoardString ('SM_FOXSTATE: TempState=> '+InttoStr(actor.TempState), clYellow, clRed);
          end;
        end;
      end;

    SM_BACKSTEP:
      begin
        if Length(body) > UpInt(sizeof(TCharDesc) * 4 / 3) then
        begin
          body2 := Copy(body, UpInt(sizeof(TCharDesc) * 4 / 3) + 1, Length(body));
          data := DecodeString(body2); //某腐 捞抚
          str := GetValidStr3(data, data, ['/']);
               //data = 捞抚
               //str = 祸哎
        end
        else
          data := '';
        DecodeBuffer(body, @CharDesc, sizeof(TCharDesc));
        PlayScene.SendMsg(SM_BACKSTEP, msg.Recog, msg.Param{x}, msg.tag{y}, msg.Series{dir + light}, CharDesc.Feature, CharDesc.Status, CharDesc.ShowTrans, ''); //捞抚
        if data <> '' then
        begin
          actor := PlayScene.FindActor(msg.Recog);
          if actor <> nil then
          begin
            actor.DescUserName := GetValidStr3(data, actor.UserName, ['\']);
                  //actor.UserName := data;
            actor.NameColor := GetRGB(Str_ToInt(str, 0));
          end;
        end;
      end;

    SM_SPACEMOVE_HIDE, SM_SPACEMOVE_HIDE2:
      begin
        if msg.Recog = Myself.RecogId then
        begin
          FrmDlg.SafeCloseDlg;
        end
        else    
          PlayScene.SendMsg(msg.Ident, msg.Recog, msg.Param{x}, msg.tag{y}, 0, 0, 0, 0, '');
      end;

    SM_SPACEMOVE_SHOW, SM_SPACEMOVE_SHOW2:
      begin
        if Length(body) > UpInt(sizeof(TCharDesc) * 4 / 3) then
        begin
          body2 := Copy(body, UpInt(sizeof(TCharDesc) * 4 / 3) + 1, Length(body));
          data := DecodeString(body2); //某腐 捞抚
          str := GetValidStr3(data, data, ['/']);
               //data = 捞抚
               //str = 祸哎
        end
        else
          data := '';
        DecodeBuffer(body, @CharDesc, sizeof(TCharDesc));
        if msg.Recog <> Myself.RecogId then
        begin //如果是其他角色。
          PlayScene.NewActor(msg.Recog, msg.Param, msg.tag, msg.Series, CharDesc.feature, CharDesc.Status);
        end;
        PlayScene.SendMsg(msg.Ident, msg.Recog, msg.Param{x}, msg.tag{y}, msg.Series{dir + light}, CharDesc.Feature, CharDesc.Status, CharDesc.ShowTrans, ''); //捞抚
        if data <> '' then
        begin
          actor := PlayScene.FindActor(msg.Recog);
          if actor <> nil then
          begin
            actor.DescUserName := GetValidStr3(data, actor.UserName, ['\']);
                  //actor.UserName := data;
            actor.NameColor := GetRGB(Str_ToInt(str, 0));
          end;
        end;
      end;
      SM_SPACEMOVE_SHOW_MAGIC,
    SM_SPACEMOVE_SHOW_MAGIC2,

    SM_SPACEMOVE_SHOW_NO:
      begin
        if Length(body) > UpInt(sizeof(TCharDesc) * 4 / 3) then
        begin
          body2 := Copy(body, UpInt(sizeof(TCharDesc) * 4 / 3) + 1, Length(body));
          data := DecodeString(body2); //某腐 捞抚
          str := GetValidStr3(data, data, ['/']);
               //data = 捞抚
               //str = 祸哎
        end
        else
          data := '';
        DecodeBuffer(body, @CharDesc, sizeof(TCharDesc));
        if msg.Recog <> Myself.RecogId then
        begin //如果是其他角色。
          PlayScene.NewActor(msg.Recog, msg.Param, msg.tag, msg.Series, CharDesc.feature, CharDesc.Status);
        end;
        PlayScene.SendMsg(msg.Ident, msg.Recog, msg.Param{x}, msg.tag{y}, msg.Series{dir + light}, CharDesc.Feature, CharDesc.Status, CharDesc.ShowTrans, ''); //捞抚
        if data <> '' then
        begin
          actor := PlayScene.FindActor(msg.Recog);
          if actor <> nil then
          begin
            actor.DescUserName := GetValidStr3(data, actor.UserName, ['\']);
                  //actor.UserName := data;
            actor.NameColor := GetRGB(Str_ToInt(str, 0));
          end;
        end;
      end;

    SM_WALK, SM_RUSH, SM_RUSHKUNG:  //修复野蛮无法同屏使用BUG
      begin
        DecodeBuffer(body, @CharDesc, sizeof(TCharDesc));
        if (msg.Recog <> Myself.RecogId) or (msg.Ident = SM_RUSH) or (msg.Ident = SM_RUSHKUNG) then
          PlayScene.SendMsg(msg.Ident, msg.Recog, msg.Param{x}, msg.tag{y}, msg.Series{dir+light}, CharDesc.Feature, CharDesc.Status, 0, '');
        if (msg.Ident = SM_RUSH) and (msg.Recog = MySelf.RecogId) then begin
          LatestRushRushTime := GetTickCount;
        end;
      end;

    SM_RUN:
      begin
            //DScreen.AddSysMsg ('RUN ' + IntToStr(msg.Param) + ':' + IntToStr(msg.Tag));
        DecodeBuffer(body, @CharDesc, sizeof(TCharDesc));
        if msg.Recog <> Myself.RecogId then
          PlayScene.SendMsg(SM_RUN, msg.Recog, msg.Param{x}, msg.tag{y}, msg.Series{dir+light}, CharDesc.Feature, CharDesc.Status, CharDesc.ShowTrans, '');
      end;

    SM_CHANGELIGHT:
      begin
        actor := PlayScene.FindActor(msg.Recog);
        if actor <> nil then
        begin
          actor.ChrLight := msg.Param;
        end;
      end;

    SM_LAMPCHANGEDURA:
      begin
        if UseItems[U_RIGHTHAND].S.Name <> '' then
        begin
          UseItems[U_RIGHTHAND].Dura := msg.Recog;
        end;
      end;

    SM_MOVEFAIL:      //禁用...
      begin
        ActionFailed;
        ActionLock:= False;
        DecodeBuffer(body, @CharDesc, sizeof(TCharDesc));
        ActionFailLock := False;
        PlayScene.SendMsg(SM_TURN, msg.Recog, msg.Param{x}, msg.tag{y}, msg.Series{dir}, CharDesc.Feature, CharDesc.Status, CharDesc.ShowTrans, '');
      end;

    SM_BUTCH:
      begin
        DecodeBuffer(body, @CharDesc, sizeof(TCharDesc));
        if msg.Recog <> Myself.RecogId then
        begin
          actor := PlayScene.FindActor(msg.Recog);
          if actor <> nil then
            actor.SendMsg(SM_SITDOWN, msg.Param{x}, msg.tag{y}, msg.Series{dir}, 0, 0, '', 0);
        end;
      end;
    SM_SITDOWN:
      begin
        DecodeBuffer(body, @CharDesc, sizeof(TCharDesc));
        if msg.Recog <> Myself.RecogId then
        begin
          actor := PlayScene.FindActor(msg.Recog);
          if actor <> nil then
            actor.SendMsg(SM_SITDOWN, msg.Param{x}, msg.tag{y}, msg.Series{dir}, 0, 0, '', 0);
        end;
      end;

    SM_HIT, SM_HEAVYHIT, SM_POWERHIT, SM_LONGHIT, SM_WIDEHIT,
      // 2003/03/15 脚痹公傍
    SM_CROSSHIT, SM_TWINHIT, SM_STONEHIT, SM_BIGHIT, SM_FIREHIT:
      begin
        if msg.Recog <> Myself.RecogId then
        begin
          actor := PlayScene.FindActor(msg.Recog);
          if actor <> nil then
          begin
            actor.SendMsg(msg.Ident, msg.Param{x}, msg.tag{y}, msg.Series{dir}, 0, 0, '', 0);
            if msg.ident = SM_HEAVYHIT then
            begin
              if body <> '' then
                actor.BoDigFragment := TRUE;
            end;
          end;
        end;
      end;
    SM_FLYAXE:
      begin
        DecodeBuffer(body, @mbw, sizeof(TMessageBodyW));
        actor := PlayScene.FindActor(msg.Recog);
        if actor <> nil then
        begin
          actor.SendMsg(msg.Ident, msg.Param{x}, msg.tag{y}, msg.Series{dir}, 0, 0, '', 0);
          actor.TargetX := mbw.Param1;  //x 投掷目标
          actor.TargetY := mbw.Param2;    //y
          actor.TargetRecog := MakeLong(mbw.Tag1, mbw.Tag2);
        end;
      end;

    SM_LIGHTING, SM_DRAGON_FIRE1, SM_DRAGON_FIRE2, SM_DRAGON_FIRE3, SM_LIGHTING_1..SM_LIGHTING_3:
      begin
        DecodeBuffer(body, @wl, sizeof(TMessageBodyWL));
        actor := PlayScene.FindActor(msg.Recog);
        if actor <> nil then
        begin
          actor.SendMsg(msg.Ident, msg.Param{x}, msg.tag{y}, msg.Series{dir}, 0, 0, '', 0);
          actor.TargetX := wl.lParam1;  //x 投掷目标
          actor.TargetY := wl.lParam2;    //y
          actor.TargetRecog := wl.lTag1;
          actor.MagicNum := wl.lTag2;   //魔法号码
        end;
      end;

      // 2003/02/11 成员的位置信息
      SM_GROUPPOS:
      begin
        DecodeBuffer(body, @mbw, sizeof(TMessageBodyW));
            // 2003/03/04 小组成员探索设置
        actor := PlayScene.FindActor(msg.Recog);
        if actor <> nil then
        begin
//               if not actor.BoOpenHealth then
          AddCheck := True;
          if GroupIdList.Count > 0 then
            for i := 0 to GroupIdList.Count - 1 do
            begin
              if integer(GroupIdList[i]) = actor.RecogId then
              begin
                AddCheck := False;
                Break;
              end;
            end;
          if AddCheck then
            GroupIdList.Add(pointer(actor.RecogId)); // MonOpenHp
          if g_bozuduihp then
          actor.BoOpenHealth := TRUE; //组队血条显示
        end;
        if (msg.Recog <> MySelf.RecogId)  then      
        begin
          idx := -1;
          for i := 1 to MAXVIEWOBJECT do
          begin
            if (ViewList[i].Index = msg.Recog) then
              idx := i;
          end;
          if (idx = -1) then
          begin
            Inc(ViewListCount);
            if (ViewListCount > MAXVIEWOBJECT) then
              ViewListCount := MAXVIEWOBJECT;
            idx := ViewListCount;
          end;
          ViewList[idx].Index := msg.Recog;
          ViewList[idx].X := msg.Param;  {x}
          ViewList[idx].Y := msg.tag;    {y}
          ViewList[idx].LastTick := GetTickCount;
        end;
      end;

    SM_SPELL: //别人施法
      begin
        UseMagicSpell(msg.Recog{who}, msg.Series{effectnum}, msg.Param{tx}, msg.Tag{y}, Str_ToInt(body, 0));
      end;
    SM_MAGICFIRE:
      begin
        DecodeBuffer(body, @param, sizeof(integer));
        UseMagicFire(msg.Recog{who}, Lobyte(msg.Series){efftype}, Hibyte(msg.Series){effnum}, msg.Param{tx}, msg.Tag{y}, param);
      end;
    SM_MAGICFIRE_FAIL:
      begin
        UseMagicFireFail(msg.Recog{who});
      end;

    SM_NORMALEFFECT:
      begin
            //msg.Recog{who},
        UseNormalEffect(msg.Series{辆幅}, msg.Param{X}, msg.Tag{Y});
      end;
      SM_NORMALEFFECTEX:
         begin
            UseNormalEffectEx (msg.Series{DIR}, msg.Param{X}, msg.Tag{Y});
         end;

    SM_LOOPNORMALEFFECT:
      begin
        UseLoopNormalEffect(msg.Recog{RecogID}, msg.Series{辆幅}, msg.Param{矫埃});
//      DScreen.AddChatBoardString ('SM_LOOPNORMALEFFECT: 风橇鸥烙=> ' +IntToStr(msg.Param), clYellow, clRed);
      end;

    SM_OUTOFCONNECTION:
      begin
        DoFastFadeOut := FALSE;
        DoFadeIn := FALSE;
        DoFadeOut := FALSE;
        FrmDlg.DMessageDlg('服务器连接被强行中断\连接时间可能超过限制\或者用户请求重新连接', [mbOk]);
        Application.Terminate;
      end;
      SM_LIXIANGUAJI:  //离线后的小腿
      begin
        if mrOk = FrmDlg.DMessageDlg('因为你上次下线的时后使用了离线挂机功能!\管理员为了避免你在游戏中出现数据错误!\请你小退一下再重新登陆!', [mbOk]) then
      begin
        SendClientMessage(CM_SOFTCLOSE, 0, 0, 0, 0);
        PlayScene.ClearActors;
        CloseAllWindows;
        SaveNgInfo;
{$IFDEF RELEASE}
        LoadingWaitTime := 0;
{$ENDIF}
         if not BoOneClick then
      begin
      SoftClosed := TRUE;
      ActiveCmdTimer(tcSoftClose);
    end
    else
    begin
      ActiveCmdTimer(tcReSelConnect);
    end;
   end;

end;
    SM_DEATH, SM_NOWDEATH:
      begin
        DecodeBuffer(body, @CharDesc, sizeof(TCharDesc));
        actor := PlayScene.FindActor(msg.Recog);

        if actor <> nil then
        begin
          actor.SendMsg(msg.Ident, msg.param{x}, msg.Tag{y}, msg.Series{damage}, CharDesc.Feature, CharDesc.Status, '', CharDesc.ShowTrans);
          actor.Abil.HP := 0;
//          SendDeath(msg.Recog);
        end
        else
        begin
          PlayScene.SendMsg(SM_DEATH, msg.Recog, msg.param{x}, msg.Tag{y}, msg.Series{damage}, CharDesc.Feature, CharDesc.Status, CharDesc.ShowTrans, '');
//          SendDeath(msg.Recog);
        end;
      end;
    SM_SKELETON:
      begin
        DecodeBuffer(body, @CharDesc, sizeof(TCharDesc));
        PlayScene.SendMsg(SM_SKELETON, msg.Recog, msg.param{HP}, msg.Tag{maxHP}, msg.Series{damage}, CharDesc.Feature, CharDesc.Status, CharDesc.ShowTrans, '');
      end;
    SM_ALIVE:
      begin
        DecodeBuffer(body, @CharDesc, sizeof(TCharDesc));
//            UseNormalEffect (NE_RELIVE{辆幅}, MySelf.XX{X}, MySelf.YY{Y});
        PlayScene.SendMsg(SM_ALIVE, msg.Recog, msg.param{HP}, msg.Tag{maxHP}, msg.Series{damage}, CharDesc.Feature, CharDesc.Status, CharDesc.ShowTrans, '');
      end;

    SM_ABILITY:
      begin
        Myself.Gold := msg.Recog;
        Myself.Job := msg.Param;
        DecodeBuffer(body, @Myself.Abil, sizeof(TAbility));
        ChangeWalkHitValues(Myself.Abil.Level, Myself.HitSpeed, Myself.Abil.Weight + Myself.Abil.MaxWeight + Myself.Abil.WearWeight + Myself.Abil.MaxWearWeight + Myself.Abil.HandWeight + Myself.Abil.MaxHandWeight, RUN_STRUCK_DELAY);
      end;

    SM_SUBABILITY:
      begin
        MyHitPoint := Lobyte(msg.Param);
        MySpeedPoint := Hibyte(msg.Param);
        MyAntiPoison := Lobyte(msg.Tag);
        MyPoisonRecover := Hibyte(msg.Tag);
        MyHealthRecover := Lobyte(msg.Series);
        MySpellRecover := Hibyte(msg.Series);
        MyAntiMagic := lobyte(loword(msg.Recog));
      end;

    SM_DAYCHANGING:
      begin
        DayBright := msg.Param;
        DarkLevel := msg.Tag;
        if (DarkLevel = 0) or (g_boMirDark) then
          ViewFog := FALSE
        else
          ViewFog := TRUE;
      end;

    SM_WINEXP:
      begin
        Myself.Abil.Exp := msg.Recog;
        if g_NgConfigInfo.boExpShow then
        begin
          if MakeLong(msg.Param, msg.tag) > g_NgConfigInfo.nExpShow then
            DScreen.AddChatBoardString(IntToStr(MakeLong(msg.Param, msg.tag)) + ' 经验值增加.', clWhite, clRed);
        end
        else
          DScreen.AddChatBoardString(IntToStr(MakeLong(msg.Param, msg.tag)) + ' 经验值增加.', clWhite, clRed);
      end;

    SM_CHANGEFAMEPOINT:
      begin
        Myself.FameName := DecodeString(body);
        Myself.Abil.FameCur := msg.Recog; //函版等 疙己摹
//            DScreen.AddChatBoardString ('SM_CHANGEFAMEPOINT: msg.Recog=> ' + IntToStr(Myself.Abil.FameCur), clWhite, clRed);
//            DScreen.AddChatBoardString ('SM_CHANGEFAMEPOINT: DecodeString (body)=> ' + Myself.FameName, clWhite, clRed);
      end;

    SM_LEVELUP:
      begin
        DScreen.AddSysMsg('升级!');
        // DScreen.AddChatBoardString('您的等级已提升！', TColor($A21C06), TColor($F6B9DE));
        DScreen.AddChatBoardString('恭喜你的等级已经提升,HP,MP已经全部恢复。',clWhite, clPurple);   //升级提示语
        PlaySound(bmp_levelup);
      end;

    SM_HEALTHSPELLCHANGED:
      begin
        actor := PlayScene.FindActor(msg.Recog);
        if actor <> nil then
        begin
          actor.Abil.HP := msg.Param;
          actor.Abil.MP := msg.Tag;
          actor.Abil.MaxHP := msg.Series;
               //actor.BoEatEffect := TRUE;
               //actor.EatEffectFrame := 0;
               //actor.EatEffectTime := GetTickCount;
        end;
      end;

    SM_STRUCK:
      begin
            //wl: TMessageBodyWL;
        DecodeBuffer(body, @wl, sizeof(TMessageBodyWL));
        actor := PlayScene.FindActor(msg.Recog);
        if actor <> nil then
        begin
          if actor = Myself then
          begin
            if Myself.NameColor = 249 then //如果你被红名击中，你不能断开连接。.
              LatestStruckTime := GetTickCount;
          end
          else
          begin
            if actor.CanCancelAction then
              actor.CancelAction;
          end;
          //免后仰
//          if actor = Myself then
//          begin
//            if not g_bo稳如泰山 then
//              actor.UpdateMsg(SM_STRUCK, wl.lTag2, 0, msg.Series{damage}, wl.lParam1, wl.lParam2, '', wl.lTag1{被打的人ID});
//          end
//          else
//          actor.UpdateMsg(SM_STRUCK, wl.lTag2, 0, msg.Series{damage}, wl.lParam1, wl.lParam2, '', wl.lTag1{被打的人ID});
//          actor.Abil.HP := msg.param;
//          actor.Abil.MaxHP := msg.Tag;
          if  (g_bo稳如泰山) and (g_bo绝对泰山) then
         // if Actor.Race <> 0 then       //都不后仰
          begin
            if Actor.Race <> 0 then
              //actor.UpdateMsg(SM_STRUCK, wl.lTag2, 0, msg.Series{damage}, wl.lParam1, wl.lParam2, '', wl.lTag1{被打的人ID});
            actor.UpdateMsg(SM_STRUCK, wl.lTag2, 0, msg.Series{damage}, wl.lParam1, wl.lParam2, '', wl.lTag1{被打的人ID});
            actor.Abil.HP := msg.param;
            actor.Abil.MaxHP := msg.Tag;
          end
          else
//          begin
//            if  g_bo稳如泰山 then
            if actor = Myself then
          begin
            if not g_bo稳如泰山 then
              actor.UpdateMsg(SM_STRUCK, wl.lTag2, 0, msg.Series{damage}, wl.lParam1, wl.lParam2, '', wl.lTag1{被打的人ID});
          end
          else
          actor.UpdateMsg(SM_STRUCK, wl.lTag2, 0, msg.Series{damage}, wl.lParam1, wl.lParam2, '', wl.lTag1{被打的人ID});
          actor.Abil.HP := msg.param;
          actor.Abil.MaxHP := msg.Tag;


        end;
      end;

    SM_CHANGEFACE:
      begin
        actor := PlayScene.FindActor(msg.Recog);
        if actor <> nil then
        begin
          DecodeBuffer(body, @CharDesc, sizeof(TCharDesc));
          actor.WaitForRecogId := MakeLong(msg.Param, msg.Tag);
          actor.WaitForFeature := CharDesc.Feature;
          actor.WaitForStatus := CharDesc.Status;
          actor.bShowTrans := CharDesc.ShowTrans;
          actor.bUpdateShowTrans := True;
          AddChangeFace(actor.WaitForRecogId);
        end;
      end;

    SM_OPENHEALTH:
      begin
        actor := PlayScene.FindActor(msg.Recog);
        if actor <> nil then
        begin
          if actor <> Myself then
          begin
            actor.Abil.HP := msg.Param;
            actor.Abil.MaxHP := msg.Tag;
          end;
          //if g_boMirShowHp then
         // if g_bozuduihp then
          actor.BoOpenHealth := TRUE;
               //actor.OpenHealthTime := 999999999;
               //actor.OpenHealthStart := GetTickCount;
        end;
      end;
    SM_CLOSEHEALTH:
      begin
        actor := PlayScene.FindActor(msg.Recog);
        if actor <> nil then
        begin
          actor.BoOpenHealth := FALSE;
        end;
      end;
    SM_INSTANCEHEALGUAGE:
      begin
        actor := PlayScene.FindActor(msg.Recog);
        if actor <> nil then
        begin
          actor.Abil.HP := msg.param;
          actor.Abil.MaxHP := msg.Tag;
          actor.BoInstanceOpenHealth := TRUE;
          actor.OpenHealthTime := 2 * 1000;
          actor.OpenHealthStart := GetTickCount;
        end;                                                                                    
      end;

    SM_BREAKWEAPON:
      begin
        actor := PlayScene.FindActor(msg.Recog);
        if actor <> nil then
        begin
          if actor is THumActor then
            THumActor(actor).DoWeaponBreakEffect;
        end;
      end;

    SM_CRY, SM_GROUPMESSAGE, //   组消息
    SM_GUILDMESSAGE, SM_WHISPER, SM_SYSMSG_REMARK, SM_SYSMESSAGE: //系统消息
      begin
        str := DecodeString(body);
        if FrmDlg.IsBlockNameList(str) then Exit;
        if msg.Ident = SM_CRY then begin
          if FrmDlg.IsBlockNameList(str) then Exit;
          DScreen.AddChatBoardString(str, GetRGB(Lobyte(msg.Param)), GetRGB(Hibyte(msg.Param)));
        end else if msg.Ident = SM_WHISPER then begin
          if FrmDlg.IsBlockNameList(str) then Exit;

          DScreen.AddChatBoardString(str, GetRGB(Lobyte(msg.Param)), GetRGB(Hibyte(msg.Param)));
          if g_boWhisperWin then begin
            FrmDlg.AddWhisper(FormatDateTime('hh:mm:ss', Now) + ' ' + str);
            if FrmDlg.DCheckWhisper.Checked and (Trim(FrmDlg.DEdtWhisper.Text) <> '') then
              FrmDlg.AutoWhisper(str);
          end;
        end
        else
        if (msg.Ident=SM_SYSMESSAGE) and (msg.tag =120) then
           begin
              DScreen.AddHorn(str, Lobyte(msg.Param), Hibyte(msg.Param), msg.Series);
           end
           else
           begin
              DScreen.AddChatBoardString(str, GetRGB(Lobyte(msg.Param)), GetRGB(Hibyte(msg.Param)));
              if msg.Ident = SM_GUILDMESSAGE then
                FrmDlg.AddGuildChat(str)
              else if msg.Ident = SM_SYSMSG_REMARK then
                DScreen.AddSysMsg('clYellow' + str);
           end;
      end;
    SM_SYSSCROLLMESSAGE:
      begin
         str := DecodeString(body);
//         DScreen.AddHorn(str, Lobyte(msg.Param), Hibyte(msg.Param));
         if FrmDlg.IsBlockNameList(str) then Exit;
         ScrollingBarText := str;
         ScrollingBarTimes := 0;
         ScrollingFColor := GetRGB(Lobyte(msg.Param));
         ScrollingBColor := GetRGB(Hibyte(msg.Param));
         BoShowScrollingBar := TRUE;
         ScrollingTextLeft := 0;
      end;


    SM_HEAR:
      begin
        if g_boOwnerMsg then
        str := DecodeString(body);
        if FrmDlg.IsBlockNameList(str) then Exit;
        DScreen.AddChatBoardString(str, GetRGB(Lobyte(msg.Param)), GetRGB(Hibyte(msg.Param)));
        actor := PlayScene.FindActor(msg.Recog);
        if actor <> nil then
           actor.Say(str);
      end;

    SM_USERNAME:
      begin
        str := DecodeString(body);
        actor := PlayScene.FindActor(msg.Recog);
        if actor <> nil then
        begin
               //Username \ 荤合巩颇 / 疙己龋莫
          actor.FameName := GetValidStr3(str, str, ['/']);
          actor.DescUserName := GetValidStr3(str, actor.Username, ['\']);
          actor.NameColor := GetRGB(msg.Param);
        end;
      end;
    SM_CHANGENAMECOLOR:
      begin
        actor := PlayScene.FindActor(msg.Recog);
        if actor <> nil then
        begin
          actor.NameColor := GetRGB(msg.Param);
        end;
      end;
     SM_SHOWBLUEHEALTH:    //护身显蓝
      begin
          Actor := PlayScene.FindActor(msg.Recog);
          if Actor <> nil then begin
            Actor.BoMagicShield := Boolean(msg.tag);//护身属性
            Actor.Abil.MP := msg.param;
            Actor.Abil.MaxMP := msg.series;
          end;
        end;
    SM_HIDE, SM_GHOST,  //残像..
    SM_DISAPPEAR:
      begin
        if Myself.RecogId <> msg.Recog then
          PlayScene.SendMsg(SM_HIDE, msg.Recog, msg.Param{x}, msg.tag{y}, 0, 0, 0, 0, '');
      end;
    SM_MAA_SONMAE:
      begin
         g_MaasonName := DecodeString(body);
      end;
    SM_DIGUP:
      begin
        DecodeBuffer(body, @wl, sizeof(TMessageBodyWL));
        actor := PlayScene.FindActor(msg.Recog);
        if actor = nil then
          actor := PlayScene.NewActor(msg.Recog, msg.Param, msg.tag, msg.Series, wl.lParam1, wl.lParam2);
        actor.CurrentEvent := wl.lTag1;
        actor.SendMsg(SM_DIGUP, msg.Param{x}, msg.tag{y}, msg.Series{dir + light}, wl.lParam1, wl.lParam2, '', 0);
      end;
    SM_DIGDOWN:
      begin //欢迎来到韩国 msg.Series（方向）收到
        PlayScene.SendMsg(SM_DIGDOWN, msg.Recog, msg.Param{x}, msg.tag{y}, msg.Series, 0, 0, 0, '');
      end;
    SM_SHOWEVENT:
      begin
        DecodeBuffer(body, @smsg, sizeof(TShortMessage));
        event := TClEvent.Create(msg.Recog, Loword(msg.Tag){x}, msg.Series{y}, msg.Param{e-type});
        event.Dir := 0;
        event.EventParam := smsg.Ident;
        EventMan.AddEvent(event);  //clvent可能是Free
        case msg.Param of
        ET_FIREFLOWER_1, ET_FIREFLOWER_2, ET_FIREFLOWER_3, ET_FIREFLOWER_4, ET_FIREFLOWER_5, ET_FIREFLOWER_6, ET_FIREFLOWER_7, ET_FIREFLOWER_8, ET_FIREFLOWER_9: PlaySound(Protechny_ground); //烟花声音
       end;
      end;
    SM_HIDEEVENT:
      begin
        EventMan.DelEventById(msg.Recog);
      end;

      //Item ??
      SM_ADDITEM:
      begin
        ClientGetAddItem(body);
      end;
    SM_COUNTERITEMCHANGE:
      begin
        if not BoDealEnd then
          dealactiontime := GetTickCount;  // 交换时-重叠物品时会收到信息
        ChangeItemCount(msg.Recog, msg.Param, msg.Tag, DecodeString(body));
      end;
    SM_UPGRADEITEM_RESULT:
      begin
        UpgradeItemResult(msg.Recog, msg.Param, DecodeString(body));
      end;
    SM_UPGRADEITEM_RESULTT:
      begin
        UpgradeItemResultt(msg.Recog, msg.Param, DecodeString(body));
      end;
    SM_BAGITEMS:
      begin
        ClientGetBagItmes(body);
      end;
    SM_UPDATEITEM:
      begin
        ClientGetUpdateItem(body);
      end;
    SM_DELITEM:
      begin
        ClientGetDelItem(body, msg.Tag);
      end;
    SM_DELITEMS:
      begin
        ClientGetDelItems(body);
      end;

    SM_DROPITEM_SUCCESS:
      begin
        DelDropItem(DecodeString(body), msg.Recog);
      end;
    SM_DROPITEM_FAIL:
      begin
        ClientGetDropItemFail(DecodeString(body), msg.Recog);
      end;

    SM_ITEMSHOW:
      begin
        ClientGetShowItem(msg.Recog, msg.param{x}, msg.Tag{y}, msg.Series{looks}, DecodeString(body));
      end;
    SM_ITEMHIDE:
      begin
        ClientGetHideItem(msg.Recog, msg.param, msg.Tag);
      end;

    SM_OPENDOOR_OK: //门被人打开
      begin
        Map.OpenDoor(msg.param, msg.tag);
            //开门声...
      end;

    SM_OPENDOOR_LOCK: //我要打开的门被锁上了。
      begin
        DScreen.AddSysMsg('门锁着.');
      end;
    SM_CLOSEDOOR:
      begin
        Map.CloseDoor(msg.param, msg.tag);
      end;

    SM_CANCLOSE_OK:
      begin
//               DScreen.AddChatBoardString ('Receive=> SM_CANCLOSE_OK:', clYellow, clRed);
        if (GetTickCount - LatestStruckTime > 1) and (GetTickCount - LatestMagicTime > 1) and (GetTickCount - LatestHitTime > 1) or (Myself.Death) then
        begin
          AppLogOut;//
        end
        else
          DScreen.AddChatBoardString('在战斗的时候你不能退出游戏', clYellow, clRed);
      end;

    SM_CANCLOSE_FAIL:
      begin
//               DScreen.AddChatBoardString ('Receive=> SM_CANCLOSE_FAIL:', clYellow, clRed);
        DScreen.AddChatBoardString('在战斗的时候你不能退出游戏', clYellow, clRed);
      end;

    SM_TAKEON_OK:
      begin
        Myself.Feature := msg.Recog;
        Myself.FeatureChanged;
            // 2003/03/15 物品库存扩张
        if WaitingUseItem.Index in [0..U_TRANS] then       //8->12
          UseItems[WaitingUseItem.Index] := WaitingUseItem.Item;
        //g_DuraWarning[WaitingUseItem.Index].TAKEON_OK := True;
        WaitingUseItem.Item.S.Name := '';
      end;
    SM_CREATEGROUPREQ:
      begin
        str := DecodeString(body);
//        DScreen.AddChatBoardString ('SM_CREATEGROUPREQ: SendUderID=> '+str, clYellow, clRed);
        if not BoMsgDlgTimeCheck then
        begin
          BoMsgDlgTimeCheck := True;
          FrmDlg.MsgDlgClickTime := GetTickCount + 30000;
          huafeitime := FrmDlg.MsgDlgClickTime;
          if mrYes = FrmDlg.DMessageDlg(str + '邀请您加入队伍，是否同意？', [mbYes, mbNo]) then
          begin
            FrmMain.SendClientMessage2(CM_CREATEGROUPREQ_OK, 0, 0, 0, 0, str);
//        DScreen.AddChatBoardString ('CM_CREATEGROUPREQ_OK', clYellow, clRed);
          end
          else
          begin
              if GetTickCount > huafeitime then
               FrmMain.SendClientMessage2(CM_CHAOSHI1_FAIL, 0, 0, 0, 0, str)
              else
               FrmMain.SendClientMessage2(CM_CREATEGROUPREQ_FAIL, 0, 0, 0, 0, str);
          end;
          BoMsgDlgTimeCheck := False;
          FrmDlg.MsgDlgClickTime := GetTickCount;
          huafeitime :=   GetTickCount;
        end;
      end;

    SM_ADDGROUPMEMBERREQ:
      begin
        str := DecodeString(body);
//        DScreen.AddChatBoardString ('SM_ADDGROUPMEMBERREQ: SendUderID=> '+str, clYellow, clRed);
        if not BoMsgDlgTimeCheck then
        begin
          BoMsgDlgTimeCheck := True;
          FrmDlg.MsgDlgClickTime := GetTickCount + 30000;
          huafeitime := FrmDlg.MsgDlgClickTime;
          if mrYes = FrmDlg.DMessageDlg(str + '邀请您加入队伍，是否同意？', [mbYes, mbNo]) then
          begin
            FrmMain.SendClientMessage2(CM_ADDGROUPMEMBERREQ_OK, 0, 0, 0, 0, str);
//        DScreen.AddChatBoardString ('CM_ADDGROUPMEMBERREQ_OK', clYellow, clRed);
          end
          else
          begin
              if GetTickCount > huafeitime then
               FrmMain.SendClientMessage2(CM_CHAOSHI2_FAIL, 0, 0, 0, 0, str)
              else
            FrmMain.SendClientMessage2(CM_ADDGROUPMEMBERREQ_FAIL, 0, 0, 0, 0, str);
//        DScreen.AddChatBoardString ('CM_ADDGROUPMEMBERREQ_FAIL', clYellow, clRed);
          end;
          BoMsgDlgTimeCheck := False;
          FrmDlg.MsgDlgClickTime := GetTickCount;
          huafeitime :=   GetTickCount;
        end;
      end;

    SM_LM_DELETE_REQ:
      begin
        str := DecodeString(body);
//        DScreen.AddChatBoardString ('SM_LM_DELETE_REQ: SendUderID=> '+str, clYellow, clRed);
        if not BoMsgDlgTimeCheck then
        begin
          BoMsgDlgTimeCheck := True;
          FrmDlg.MsgDlgClickTime := GetTickCount + 30000;
          if mrYes = FrmDlg.DMessageDlg(str + '确定解除恋人关系？\一旦确定须要缴纳150,0000万金币手续费用，继续？', [mbYes, mbNo]) then
          begin
            FrmMain.SendClientMessage2(CM_LM_DELETE_REQ_OK, RsState_Lover, 0, 0, 0, str);
//        DScreen.AddChatBoardString ('CM_LM_DELETE_REQ_OK', clYellow, clRed);
          end
          else
          begin
            FrmMain.SendClientMessage2(CM_LM_DELETE_REQ_FAIL, RsState_Lover, 0, 0, 0, str);
//        DScreen.AddChatBoardString ('CM_LM_DELETE_REQ_FAIL', clYellow, clRed);
          end;
          BoMsgDlgTimeCheck := False;
          FrmDlg.MsgDlgClickTime := GetTickCount;
        end;
      end;

    SM_TAKEON_FAIL:
      begin
        AddItemBag(WaitingUseItem.Item);
        WaitingUseItem.Item.S.Name := '';
      end;
    SM_TAKEOFF_OK:
      begin
        Myself.Feature := msg.Recog;
        Myself.FeatureChanged;
        WaitingUseItem.Item.S.Name := '';
      end;
    SM_TAKEOFF_FAIL:
      begin
        if WaitingUseItem.Index < 0 then
        begin
          n := -(WaitingUseItem.Index + 1);
          UseItems[n] := WaitingUseItem.Item;
        end;
        WaitingUseItem.Item.S.Name := '';
      end;
    SM_EXCHGTAKEON_OK:
      ;
    SM_EXCHGTAKEON_FAIL:
      ;

    SM_SENDUSEITEMS:
      begin
        ClientGetSenduseItems(body);
      end;
    SM_WEIGHTCHANGED:
      begin
        if (msg.Recog + msg.Param + msg.Tag) = (((msg.Series xor $aa21) xor $1F35) xor $3A5F) then
        begin
          Myself.Abil.Weight := msg.Recog;
          Myself.Abil.WearWeight := msg.Param;
          Myself.Abil.HandWeight := msg.Tag;
        end
        else
        begin
          Myself.Abil.Weight := 127;
          Myself.Abil.WearWeight := 127;
          Myself.Abil.HandWeight := 127;
        end;
        ChangeWalkHitValues(Myself.Abil.Level, Myself.HitSpeed, Myself.Abil.Weight + Myself.Abil.MaxWeight + Myself.Abil.WearWeight + Myself.Abil.MaxWearWeight + Myself.Abil.HandWeight + Myself.Abil.MaxHandWeight, RUN_STRUCK_DELAY);
      end;
    SM_GOLDCHANGED:
      begin
        SoundUtil.PlaySound(s_money);
        if msg.Recog > Myself.Gold then
        begin
          DScreen.AddSysMsg(IntToStr(msg.Recog - Myself.Gold) + '金币增加.');
        end;
        Myself.Gold := msg.Recog;
      end;
    SM_POTCASHCHANGED:
      begin
        Myself.PlayCash := msg.Recog;
      end;
      SM_GAMEPOINTCHANGED:
         begin
//           if msg.Recog > Myself.GamePoint then
//           begin
//             DScreen.AddSysMsg('获得 ' + GetGoldStr(msg.Recog - Myself.GamePoint) + ' 荣誉值.');
//           end;
           Myself.GamePoint := msg.Recog;
         end;
    SM_CREDITPOINT:
      begin
//        if msg.Recog > Myself.m_btCreditPoint then
//        begin
//          DScreen.AddSysMsg('获得 ' + GetGoldStr(msg.Recog - Myself.m_btCreditPoint) + ' 声望值.');
//        end;
        Myself.m_btCreditPoint := msg.Recog;
      end;
    SM_FEATURECHANGED: //翅膀修改
      begin
        //PlayScene.SendMsg(msg.Ident, msg.Recog, 0, 0, 0, MakeLong(msg.Param, msg.Tag), 0, 0, '');
        str := DecodeString(body);
        PlayScene.SendMsg(msg.Ident, msg.Recog, 0, 0, 0, MakeLong(msg.Param, msg.Tag), msg.series, StrToIntDef(str, 0), '');
      end;
    SM_CHARSTATUSCHANGED:
      begin
        PlayScene.SendMsg(msg.Ident, msg.Recog, 0, 0, 0, MakeLong(msg.Param, msg.Tag), msg.Series, 0, '');
      end;
    SM_CLEAROBJECTS:
      begin
            //PlayScene.CleanObjects;
        MapMoving := TRUE; //地图移动中
      end;

    SM_EAT_OK:
      begin
//      DScreen.AddChatBoardString ('SM_EAT_OK: EatingItem.S.Name=> '+ EatingItem.S.Name, clYellow, clRed);
        if EatingItem.S.StdMode <> 7 then
          EatingItem.S.Name := ''; // 如果不是绳子。
        if (EatingItem.S.StdMode = 7) and (EatingItem.Dura = 1) then
        begin
          EatingItem.S.Name := '';
        end;
        if (MovingItem.Item.S.StdMode = 7) and (MovingItem.Item.Dura = 1) then
        begin
          MovingItem.Item.S.Name := '';
          ItemMoving := FALSE;
//               FrmDlg.CancelItemMoving;
        end;
        ArrangeItembag;
// 消耗腰带物品时 自动填充 2006/03/22------------------------- //自动放药
        if StBeltAutoFill then
        begin
          if not g_bozdfy then Exit; // jingdian add 20220117
          if ItemArr[BtInDex].S.Name = '' then
          begin
            i := GetSameItemFromBag(EatingItem);
//      DScreen.AddChatBoardString ('i := GetSameItemFromBag(EatingItem)    i=> '+IntToStr(i), clYellow, clRed);
            if i <> -100 then
            begin
//      DScreen.AddChatBoardString ('ItemArr[i].S.Name=> '+ ItemArr[i].S.Name  +'     '+IntToStr(i), clYellow, clRed);
              if ItemArr[i].S.Name <> '' then
              begin
                ItemArr[BtInDex] := ItemArr[i];
                ItemArr[i].S.Name := '';
              end;
            end;
          end;
          StBeltAutoFill := False;
        end;
//---------------------------------------------------------------------
      end;
    SM_EAT_FAIL:
      begin
//      DScreen.AddChatBoardString ('SM_EAT_FAIL: EatingItem.S.Name=> '+ EatingItem.S.Name, clYellow, clRed);
        StBeltAutoFill := False;
        if EatingItem.S.StdMode <> 7 then
          AddItemBag(EatingItem); // 如果不是绳子。
        EatingItem.S.Name := '';
      end;

    SM_ADDMAGIC:
      begin
        if body <> '' then
          ClientGetAddMagic(body);
      end;
    SM_SENDMYMAGIC:
      begin
        if body <> '' then
          ClientGetMyMagics(msg.Recog, body);
      end;
    SM_DELMAGIC:
      begin
        ClientGetDelMagic(msg.Recog);
      end;
    SM_MAGIC_LVEXP:
      begin
        ClientGetMagicLvExp(msg.Recog{magid}, msg.Param{lv}, MakeLong(msg.Tag, msg.Series));
      end;
    SM_SOUND:
      begin
        ClientGetSound(msg.Param);
      end;

    SM_NOVICEHEIP:
      begin
        FrmDlg.DHelpDlg.Visible := TRUE;
      end;
    SM_DURACHANGE:
      begin
        ClientGetDuraChange(msg.Param{useitem index}, msg.Recog, MakeLong(msg.Tag, msg.Series));
      end;

    SM_MERCHANTSAY:
      begin
        ClientGetMerchantSay(msg.Recog, msg.Param, DecodeString(body));
      end;
    SM_MERCHANTDLGCLOSE:
      begin
//      DScreen.AddChatBoardString ('SM_MERCHANTDLGCLOSE: msg.Param=> '+IntToStr(msg.Param), clYellow, clRed);
//            FrmDlg.CloseMDlg();
        if msg.Param = 0 then
          FrmDlg.CloseMDlg()
        else
          FrmDlg.CloseMDlg2(); //@@@@
      end;
    SM_SENDGOODSLIST:
      begin
        ClientGetSendGoodsList(msg.Recog, msg.Param, body);
      end;
    SM_DECOITEM_LIST:
      begin
//      DScreen.AddChatBoardString ('SM_DECOITEM_LIST: msg.Recog=> '+IntToStr(msg.Recog), clYellow, clRed);
//      DScreen.AddChatBoardString ('SM_DECOITEM_LIST: msg.Param=> '+IntToStr(msg.Param), clYellow, clRed);
        ClientGetDecorationList(msg.Recog, msg.Param, body);
      end;
    SM_DECOITEM_LISTSHOW: //2004/08/05 庄园装饰
      begin
//      DScreen.AddChatBoardString ('SM_DECOITEM_LISTSHOW: msg.Recog=> '+IntToStr(msg.Recog), clYellow, clRed);
//      DScreen.AddChatBoardString ('SM_DECOITEM_LISTSHOW: msg.Param=> '+IntToStr(msg.Param), clYellow, clRed);
        CurMerchant := msg.Recog;
        FrmDlg.ShowGADecorateDlg;
      end;
    SM_SENDUSERMAKEDRUGITEMLIST:
      begin
        ClientGetSendMakeDrugList(msg.Recog, body);
      end;
    SM_SENDUSERMAKEITEMLIST:
      begin
        ClientGetSendMakeItemList(msg.Recog, body);
      end;
    SM_SENDUSERSELL:
      begin
        ClientGetSendUserSell(msg.Recog);
      end;
    SM_SENDUSERREPAIR:
      begin
        ClientGetSendUserRepair(msg.Recog);
      end;
    SM_SENDBUYPRICE:
      begin
        if SellDlgItem.S.Name <> '' then
        begin
          if msg.Recog > 0 then
          begin
            if SellDlgItem.S.OverlapItem > 0 then
              SellPriceStr := IntToStr(msg.Recog * SellDlgItem.Dura) + '金币'
            else
              SellPriceStr := IntToStr(msg.Recog) + '金币';
          end
          else
            SellPriceStr := '????金币';
        end;
      end;
    SM_USERSELLITEM_OK:
      begin
        FrmDlg.LastestClickTime := GetTickCount;
        Myself.Gold := msg.Recog;
        SellDlgItemSellWait.S.Name := '';
      end;

    SM_USERSELLITEM_FAIL:
      begin
        FrmDlg.LastestClickTime := GetTickCount;
        AddItemBag(SellDlgItemSellWait);
        SellDlgItemSellWait.S.Name := '';
        FrmDlg.DMessageDlg('你不能出售该物品', [mbOk]);
      end;

    SM_USERSELLCOUNTITEM_OK:
      begin
        FrmDlg.LastestClickTime := GetTickCount;
        Myself.Gold := msg.Recog;
        SellItemProg(msg.Param, msg.Tag);
        SellDlgItemSellWait.S.Name := '';
      end;

    SM_USERSELLCOUNTITEM_FAIL:
      begin
        FrmDlg.LastestClickTime := GetTickCount;
        AddItemBag(SellDlgItemSellWait);
        SellDlgItemSellWait.S.Name := '';
        FrmDlg.DMessageDlg('你不能出售该物品', [mbOk]);
      end;
    SM_SENDREPAIRCOST:
      begin
        if SellDlgItem.S.Name <> '' then
        begin
          if msg.Recog >= 0 then
            SellPriceStr := IntToStr(msg.Recog) + '金币'
          else
            SellPriceStr := '????金币';
        end;
      end;
    SM_USERREPAIRITEM_OK:
      begin
        if SellDlgItemSellWait.S.Name <> '' then
        begin
          FrmDlg.LastestClickTime := GetTickCount;
          Myself.Gold := msg.Recog;
          SellDlgItemSellWait.Dura := msg.Param;
          SellDlgItemSellWait.DuraMax := msg.Tag;
          AddItemBag(SellDlgItemSellWait);
          SellDlgItemSellWait.S.Name := '';
        end;
      end;
    SM_USERREPAIRITEM_FAIL:
      begin
        FrmDlg.LastestClickTime := GetTickCount;
        AddItemBag(SellDlgItemSellWait);
        SellDlgItemSellWait.S.Name := '';
        FrmDlg.DMessageDlg('你不能修理这个物品', [mbOk]);
      end;
    SM_STORAGE_OK, SM_STORAGE_FULL, SM_STORAGE_FAIL:
      begin
        FrmDlg.LastestClickTime := GetTickCount;
        if msg.Ident <> SM_STORAGE_OK then
        begin
          if msg.Ident = SM_STORAGE_FULL then
            FrmDlg.DMessageDlg('你的个人仓库已满，你不能再寄存任何物品。', [mbOk])
          else
            FrmDlg.DMessageDlg('你不能寄存。', [mbOk]);
          AddItemBag(SellDlgItemSellWait);
        end;
        SellDlgItemSellWait.S.Name := '';
      end;
    SM_SAVEITEMLIST:
      begin
        ClientGetSaveItemList(msg.Recog, msg.tag, msg.series, msg.Param, body);
      end;
    SM_TAKEBACKSTORAGEITEM_OK, SM_TAKEBACKSTORAGEITEM_FAIL, SM_TAKEBACKSTORAGEITEM_FULLBAG:
      begin
        FrmDlg.LastestClickTime := GetTickCount;
        if msg.Ident <> SM_TAKEBACKSTORAGEITEM_OK then
        begin
          if msg.Ident = SM_TAKEBACKSTORAGEITEM_FULLBAG then
            FrmDlg.DMessageDlg('你不能再携带更多东西了。', [mbOk])
          else
            FrmDlg.DMessageDlg('你不能取回', [mbOk]);
        end
        else
          FrmDlg.DelStorageItem(msg.Recog, msg.Param); //itemserverindex
      end;

    SM_BUYITEM_SUCCESS:
      begin
        FrmDlg.LastestClickTime := GetTickCount;
        Myself.Gold := msg.Recog;
        FrmDlg.SoldOutGoods(MakeLong(msg.Param, msg.Tag)); //从已售商品菜单中扣除
      end;
    SM_BUYITEM_FAIL:
      begin
        FrmDlg.LastestClickTime := GetTickCount;
        case msg.Recog of
          1:
            FrmDlg.DMessageDlg('物品被卖出。', [mbOk]);
          2:
            FrmDlg.DMessageDlg('没有更多物品可以携带了', [mbOk]);
          3:
            FrmDlg.DMessageDlg('金币不足。', [mbOk]);
        end;
      end;
    SM_MAKEDRUG_SUCCESS:
      begin
        FrmDlg.LastestClickTime := GetTickCount;
        Myself.Gold := msg.Recog;
        FrmDlg.DMessageDlg('物品已被正确打造', [mbOk]);
      end;
    SM_MAKEDRUG_FAIL:
      begin
        FrmDlg.LastestClickTime := GetTickCount;
        case msg.Recog of
          1:
            FrmDlg.DMessageDlg('发生了错误', [mbOk]);
          2:
            FrmDlg.DMessageDlg('没有更多的项目可以进行', [mbOk]);
          3:
            FrmDlg.DMessageDlg('钱是不够的', [mbOk]);
          4:
            FrmDlg.DMessageDlg('你缺乏所必需的物品。', [mbOk]);
          5:
            FrmDlg.DMessageDlg('失败，使宝石。', [mbOk]);
          6:
            FrmDlg.DMessageDlg('该矿石具有纯度低度', [mbOk]);
        end;
      end;

    SM_SENDDETAILGOODSLIST:
      begin
        ClientGetSendDetailGoodsList(msg.Recog, msg.Param, msg.Tag, body);
      end;

    SM_TEST:
      begin
        Inc(TestReceiveCount);
      end;

    SM_SENDNOTICE:
      begin
        ClientGetSendNotice(body);
      end;

    SM_GROUPMODECHANGED: //我在服务器上的组设置已更改。
      begin
        if msg.Param > 0 then
          AllowGroup := TRUE
        else
          AllowGroup := FALSE;
        changegroupmodetime := GetTickCount;
      end;
    SM_CREATEGROUP_OK:
      begin
        changegroupmodetime := GetTickCount;
        AllowGroup := TRUE;
            // 2003/03/04 组队时显示自己的HP
        if g_bozuduihp then
        MySelf.BoOpenHealth := TRUE
        else
        MySelf.BoOpenHealth := FALSE;
            {GroupMembers.Add (Myself.UserName);
            GroupMembers.Add (DecodeString(body));}
      end;
    SM_CREATEGROUP_FAIL:
      begin
        str := DecodeString(body);
        changegroupmodetime := GetTickCount;
        case msg.Recog of
          -1:
            DScreen.AddChatBoardString('已经加入编组。', clWhite, clBlack);
          -2:
            DScreen.AddChatBoardString('这个被加进编组的名字是不正确的。', clWhite, clBlack);
          -3:
            DScreen.AddChatBoardString('你想加入编组的这位用户已经是其他组的成员了。', clWhite, clBlack);
          -4:
            DScreen.AddChatBoardString('对方不允许编组。', clWhite, clBlack);
          -5:
            DScreen.AddChatBoardString(str + '现在正忙，请稍后再尝试邀请', clWhite, GetRGB(249));
        end;
      end;
    SM_GROUPADDMEM_OK:
      begin
        changegroupmodetime := GetTickCount;
            //GroupMembers.Add (DecodeString(body));
      end;
    SM_GROUPADDMEM_FAIL:
      begin
        changegroupmodetime := GetTickCount;
        case msg.Recog of
          -1:
            DScreen.AddChatBoardString('编组尚未成立或者你还不够等级创建。', clWhite, clBlack);
          -2:
            DScreen.AddChatBoardString('这个被加进编组的名字是不正确的。', clWhite, clBlack);
          -3:
            DScreen.AddChatBoardString('已经加入编组。', clWhite, clBlack);
          -4:
            DScreen.AddChatBoardString('对方不允许编组。', clWhite, clBlack);
          -5:
             DScreen.AddChatBoardString('成员上限已经达到。', clWhite, clBlack);
        end;
      end;
    SM_GROUPDELMEM_OK:
      begin
        changegroupmodetime := GetTickCount;
            {data := DecodeString (body);
            for i:=0 to GroupMembers.Count-1 do begin
               if GroupMembers[i] = data then begin
                  GroupMembers.Delete (i);
                  break;
               end;
            end; }
      end;
    SM_GROUPDELMEM_FAIL:
      begin
        changegroupmodetime := GetTickCount;
        case msg.Recog of
          -1:
            DScreen.AddChatBoardString('编组尚未成立或者你还不够等级创建。', clWhite, clBlack);
          -2:
            DScreen.AddChatBoardString('这个被加进编组的名字是不正确的。', clWhite, clBlack);
          -3:
            FrmDlg.DMessageDlg('该名字不在编组中。', [mbOk]);
        end;
      end;
    SM_GROUPCANCEL:
      begin
            // 2003/03/04 解除组时不输出HP
        MySelf.BoOpenHealth := FALSE;
        GroupMembers.Clear;
        try
          for i := 0 to GroupIdList.Count - 1 do
          begin
            actor := PlayScene.FindActor(integer(GroupIdList[i]));
            if actor <> nil then
              actor.BoOpenHealth := False;
          end;
          GroupIdList.Clear;  // MonOpenHp
        except
        end;
      end;
    SM_GROUPMEMBERS:
      begin
          // 2003/03/04 解除组时不输出HP
        if g_bozuduihp then
        begin
        MySelf.BoOpenHealth := TRUE;
        ClientGetGroupMembers(DecodeString(body));
        end
        else
        ClientGetGroupMembers(DecodeString(body));
      end;



    SM_OPENGUILDDLG:
      begin
        querymsgtime := GetTickCount;
        ClientGetOpenGuildDlg(body);
      end;

    SM_SENDGUILDMEMBERLIST:
      begin
        querymsgtime := GetTickCount;
        ClientGetSendGuildMemberList(body);
      end;

    SM_OPENGUILDDLG_FAIL:
      begin
        querymsgtime := GetTickCount;
        FrmDlg.DMessageDlg('你目前没有加入任何行会。', [mbOk]);
      end;

    SM_DEALTRY_FAIL:
      begin
        querymsgtime := GetTickCount;
        FrmDlg.DMessageDlg('交易被取消。\要正确交易你必须和对方面对面。', [mbOk]);
      end;
    SM_DEALMENU:
      begin
        querymsgtime := GetTickCount;
        DealWho := DecodeString(body);
        FrmDlg.OpenDealDlg(1);
      end;
    SM_GUILDAGITDEALMENU:
      begin
        querymsgtime := GetTickCount;
        DealWho := DecodeString(body);
        FrmDlg.OpenDealDlg(2);
      end;
    SM_DEALCANCEL:
      begin
        FrmDlg.CancelItemMoving;
        MoveDealItemToBag;

        if DealGold > 0 then
        begin
          Myself.Gold := Myself.GOld + DealGold;
          DealGold := 0;
        end;
        FrmDlg.CloseDealDlg;

//            if DealDlgItem.S.OverlapItem > 0 then FrmDlg.CancelItemMoving;
        FrmDlg.CancelItemMoving;
        if FrmDlg.DCountDlgCancel.Visible then
        begin
          FrmDlg.DCountDlg.DialogResult := mrCancel;
          FrmDlg.DCountDlg.Visible := FALSE;
        end;
      end;

    SM_DEALADDITEM_OK:
      begin
        dealactiontime := GetTickCount;
        if DealDlgItem.S.Name <> '' then
        begin
          ResultDealItem(DealDlgItem, msg.Recog, msg.Param);  //Deal Dlg 追加
          DealDlgItem.S.Name := '';
        end;
      end;
    SM_DEALADDITEM_FAIL:
      begin
        dealactiontime := GetTickCount;
        if DealDlgItem.S.Name <> '' then
        begin
          AddItemBag(DealDlgItem);  //添加到背包
          DealDlgItem.S.Name := '';
        end;
      end;
    SM_DEALDELITEM_OK:
      begin
        dealactiontime := GetTickCount;
        if DealDlgItem.S.Name <> '' then
        begin
               //AddItemBag (DealDlgItem);  //添加到背包
          DealDlgItem.S.Name := '';
        end;
      end;
    SM_DEALDELITEM_FAIL:
      begin
        dealactiontime := GetTickCount;
        if DealDlgItem.S.Name <> '' then
        begin
          DelCountItemBag(DealDlgItem.S.Name, DealDlgItem.MakeIndex, DealDlgItem.Dura);
          AddDealItem(DealDlgItem);
          if (MovingItem.Item.MakeIndex = DealDlgItem.MakeIndex) and (MovingItem.Item.S.Name = DealDlgItem.S.Name) then
          begin
            ItemMoving := FALSE;
            MovingItem.Item.S.Name := '';
          end;
          DealDlgItem.S.Name := '';
        end;
        FrmDlg.CancelItemMoving;
      end;
    SM_DEALREMOTEADDITEM:
      begin
        ClientGetDealRemoteAddItem(body);
        SoundUtil.PlaySound(s_deal_additem);
      end;
    SM_DEALREMOTEDELITEM:
      begin
        ClientGetDealRemoteDelItem(body);
        SoundUtil.PlaySound(s_deal_delitem);
      end;

    SM_DEALCHGGOLD_OK:
      begin
        DealGold := msg.Recog;
        Myself.Gold := MakeLong(msg.param, msg.tag);
        dealactiontime := GetTickCount;
      end;
    SM_DEALCHGGOLD_FAIL:
      begin
        DealGold := msg.Recog;
        Myself.Gold := MakeLong(msg.param, msg.tag);
        dealactiontime := GetTickCount;
      end;
    SM_DEALREMOTECHGGOLD:
      begin
        DealRemoteGold := msg.Recog;
        SoundUtil.PlaySound(s_money);  //对方变钱时会发出声音。
      end;
    SM_DEALSUCCESS:
      begin
        FrmDlg.CloseDealDlg;
      end;

    SM_SENDUSERSTORAGEITEM:  //显示保存窗口
      begin
        ClientGetSendUserStorage(msg.Recog);
      end;
    //改变攻击模式
    SM_ATTACKMODE:
      begin
         ClientGetAttackMode( msg.Param );
      end;
    SM_READMINIMAP_OK:
      begin
        querymsgtime := GetTickCount;
        ClientGetReadMiniMap(msg.Param);
      end;

    SM_READMINIMAP_FAIL:
      begin
        querymsgtime := GetTickCount;
        DScreen.AddChatBoardString('没有可用的地图。', clWhite, clRed);
        BoDrawMiniMap := False;
      end;

    SM_CHANGEGUILDNAME:
      begin
        ClientGetChangeGuildName(DecodeString(body));
      end;

    SM_SENDUSERSTATE:
      begin
        ClientGetSendUserState(body);
      end;
    SM_Server_Config:;

    SM_GUILDADDMEMBER_OK:
      begin
        SendGuildMemberList;
      end;
    SM_GUILDADDMEMBER_FAIL:
      begin
        case msg.Recog of
          1:
            FrmDlg.DMessageDlg('你没有权利使用这个命令', [mbOk]);
          2:
            FrmDlg.DMessageDlg('想加入进来的成员应该来面对掌门人', [mbOk]);
          3:
            FrmDlg.DMessageDlg('对方已经加入我们的行会', [mbOk]);
          4:
            FrmDlg.DMessageDlg('对方已经加入其他行会', [mbOk]);
          5:
            FrmDlg.DMessageDlg('对方不允许加入行会', [mbOk]);
        end;
      end;
    SM_GUILDDELMEMBER_OK:
      begin
        SendGuildMemberList;
      end;
    SM_GUILDDELMEMBER_FAIL:
      begin
        case msg.Recog of
          1:
            FrmDlg.DMessageDlg('你没有权利使用这个命令', [mbOk]);
          2:
            FrmDlg.DMessageDlg('此人非本行会成员', [mbOk]);
          3:
            FrmDlg.DMessageDlg('行会掌门人不能开除自己', [mbOk]);
          4:
            FrmDlg.DMessageDlg('不能使用命令', [mbOk]);
        end;
      end;

    SM_GUILDRANKUPDATE_FAIL:
      begin
        case msg.Recog of
          -2:
            FrmDlg.DMessageDlg('掌门人位置不能为空', [mbOk]);
          -3:
            FrmDlg.DMessageDlg('新的行会掌门人已经被传位', [mbOk]);
          -4:
            FrmDlg.DMessageDlg('一个行会最多只能有二个掌门人', [mbOk]);
          -5:
            FrmDlg.DMessageDlg('掌门人位置不能为空', [mbOk]);
          -6:
            FrmDlg.DMessageDlg('不能添加成员/删除成员', [mbOk]);
          -7:
            FrmDlg.DMessageDlg('职位重复或者出错', [mbOk]);
        end;
      end;

    SM_GUILDMAKEALLY_OK, SM_GUILDMAKEALLY_FAIL:
      begin
        case msg.Recog of
          -1:
            FrmDlg.DMessageDlg('你没有权利', [mbOk]);
          -2:
            FrmDlg.DMessageDlg('联盟失败', [mbOk]);
          -3:
            FrmDlg.DMessageDlg('你应该面对你想要结盟的行会掌门人', [mbOk]);
          -4:
            FrmDlg.DMessageDlg('对方行会掌门人不允许结盟', [mbOk]);
        end;
      end;
    SM_GUILDBREAKALLY_OK, SM_GUILDBREAKALLY_FAIL:
      begin
        case msg.Recog of
          -1:
            FrmDlg.DMessageDlg('解除结盟', [mbOk]);
          -2:
            FrmDlg.DMessageDlg('此行会不是您行会的结盟行会', [mbOk]);
          -3:
            FrmDlg.DMessageDlg('没有此行会', [mbOk]);
        end;
      end;

    SM_BUILDGUILD_OK:
      begin
        FrmDlg.LastestClickTime := GetTickCount;
        FrmDlg.DMessageDlg('行会建立成功', [mbOk]);
      end;

    SM_BUILDGUILD_FAIL:
      begin
        FrmDlg.LastestClickTime := GetTickCount;
        case msg.Recog of
          -1:
            FrmDlg.DMessageDlg('已经加入行会', [mbOk]);
          -2:
            FrmDlg.DMessageDlg('缺少创建费用', [mbOk]);
          -3:
            FrmDlg.DMessageDlg('你没有准备好需要的全部物品', [mbOk]);
        end;
      end;
    SM_MENU_OK:
      begin
        FrmDlg.LastestClickTime := GetTickCount;
        if body <> '' then
          FrmDlg.DMessageDlg(DecodeString(body), [mbOk]);
      end;


    SM_ALIVEREQ:
      begin
      FrmDlg.LastestClickTime := GetTickCount;
        if body <> '' then
        begin
          if mrOk = FrmDlg.{DMessageDlg}DSimpleMessageDlg(DecodeString(body), [mbOk, mbCancel]) then
          begin

            SendClientMessage(CM_ALIVE_OK, 0, 0, 0, 0);
          end;
        end;
      end;
    SM_DLGMSG:
      begin
        if body <> '' then
          FrmDlg.DMessageDlg(DecodeString(body), [mbOk]);
      end;

      // 2003/04/15 朋友，注意
      SM_USER_INFO:
      begin
        if body <> '' then
          ClientGetUserInfo(msg, body);
      end;

    SM_FRIEND_INFO:
      begin
        if body <> '' then
          ClientGetFriendInfo(msg, body);
      end;
    SM_FRIEND_DELETE:
      begin
        if body <> '' then
          ClientGetDelFriend(msg, body);
      end;
    SM_FRIEND_RESULT:
      begin
        if body <> '' then
          ClientGetFriendResult(msg, body);
      end;
      // 2003/04/15 朋友，注意
    SM_TAG_ALARM: // 新信息到达
      begin
            // if body <> '' then ClientGetTagAlarm (msg ,body);
        ClientGetTagAlarm(msg, body);
      end;
    SM_TAG_LIST:  // 笔记清单
      begin
        if body <> '' then
          ClientGetTagList(msg, body);
      end;
    SM_TAG_INFO:  // 备注信息
      begin
        if body <> '' then
          ClientGetTagInfo(msg, body);
      end;
    SM_TAG_REJECT_LIST:   // 拒绝列表
      begin
        if body <> '' then
          ClientGetTagRejectList(msg, body);
      end;
    SM_TAG_REJECT_ADD:    // 拒绝登记
      begin
        if body <> '' then
          ClientGetTagRejectAdd(msg, body);
      end;
    SM_TAG_REJECT_DELETE: // 删除拒绝
      begin
        if body <> '' then
          ClientGetTagRejectDelete(msg, body);
      end;
    SM_TAG_RESULT:        // 笔记结果
      begin
        if body <> '' then
          ClientGetTagResult(msg, body);
      end;
    SM_LM_OPTION:       // 更改恋人祭祀选项
      begin
        ClientGetLMOptionChange(msg);
      end;
    SM_LM_REQUEST:      // 恋人祭祀登记要求
      begin
        ClientGetLMRequest(msg, body);
      end;
    SM_LM_LIST:       // 恋人祭祀列表
      begin
        ClientGetLMList(msg, body);
      end;
    SM_LM_RESULT:      // 恋人祭祀结果
      begin
        ClientGetLMREsult(msg, body);
      end;
    SM_LM_DELETE:     // 删除恋人祭祀
      begin
        ClientGetLMDelete(msg, body);
      end;

    SM_MARKET_LIST:  //寄售清单
      begin
        g_Market.OnMsgWriteData(msg, body);
        FrmDlg.ShowItemMarketDlg; // 寄售 ItemMarket
      end;
    SM_MARKET_RESULT: // 寄售结果
      begin
//            DScreen.AddSysMsg ('SM_MARKET_RESULT R:'+ intToStr(msg.Recog));
//            DScreen.AddSysMsg ('SM_MARKET_RESULT P:'+ intToStr(msg.param));
//            DScreen.AddSysMsg ('SM_MARKET_RESULT T:'+ intToStr(msg.Tag));

        case msg.Param of // Market System..
          UMResult_Success:
            ;    // 0   ;     // 成功
          UMResult_Fail:
            ;    // 1   ;     // 失败
          UMResult_ReadFail:
            ;    // 2   ;     // 读取失败
          UMResult_WriteFail:
            ;    // 3   ;     // 保存失败
          UMResult_ReadyToSell:      // 4   ;     // 销售可能
            begin
              ClientGetSendUserMaketSell(msg.Recog);
            end;
          UMResult_OverSellCount:   // 5   ;     // 销售项囊路量超过
            FrmDlg.DMessageDlg('上架物品数量超限.', [mbOk]);
          UMResult_LessMoney:       // 6   ;     // 金币不足
            begin
              FrmDlg.LastestClickTime := GetTickCount;
              if SellDlgItemSellWait.S.Name <> '' then
              begin
                AddItemBag(SellDlgItemSellWait);
              end;
              SellDlgItemSellWait.S.Name := '';
            end;
          UMResult_LessLevel:
            ;    // 7   ;     // 级别不够
          UMResult_MaxBagItemCount:
            ; // 8   ;     // 包裹已满
          UMResult_NoItem:
            ;    // 9   ;     // 这个项目
          UMResult_DontSell:         // 10  ;     // 销售不可
            begin
              FrmDlg.LastestClickTime := GetTickCount;
              AddItemBag(SellDlgItemSellWait);
              SellDlgItemSellWait.S.Name := '';
              FrmDlg.DMessageDlg('这个物品不能上架。', [mbOk]);
            end;
          UMResult_DontBuy:
            ; // 11  ;     // 购买不可
          UMResult_DontGetMoney:
            ; // 12  ;     // 价格最大值
          UMResult_MarketNotReady:
            ; // 13  ;     // 委托系统本身不可用
          UMResult_LessTrustMoney:   // 14  ;     // 委托金额不足1000 前相比已大
            begin
              FrmDlg.LastestClickTime := GetTickCount;
              if SellDlgItemSellWait.S.Name <> '' then
              begin
                AddItemBag(SellDlgItemSellWait);
              end;
              SellDlgItemSellWait.S.Name := '';
            end;

          UMResult_MaxTrustMoney:
            ; // 15  ;     // 委托金额太大
          UMResult_CancelFail:
            ; // 16  ;     // 委托取消失败
          UMResult_OverMoney:
            ; // 17  ;     // 所有金额超过最大值的语感
          UMResult_SellOK:           // 18  ;     // 销售就好了
            begin
//      DScreen.AddChatBoardString ('UMResult_SellOK:', clYellow, clRed);
              FrmDlg.DSellDlg.Visible := FALSE;
              FrmDlg.LastestClickTime := GetTickCount;
//                     Myself.Gold := msg.Recog;
//                     SellItemProg ( msg.Param, msg.Tag );
              SellDlgItemSellWait.S.Name := '';
              DScreen.AddChatBoardString(SellDlgItemSellWait.S.Name + ' 上架成功', clLime, clBlack);
            end;
          UMResult_BuyOK:
            ; // 19  ;     // 购得非常完美
          UMResult_CancelOK:
            ; // 20  ;     // 取消销售很好
          UMResult_GetPayOK:
            ; // 21  ;     // 销售金额就好了
        else


        end;
      end;

    SM_GUILDAGITLIST:
      begin
        ClientGetJangwonList(msg.Recog, msg.Param, body);
      end;
    SM_GABOARD_LIST: //庄园布告栏
      begin
        ClientGetGABoardList(msg.Param, msg.Recog, msg.Tag, body);
      end;
    SM_GABOARD_READ: //庄园布告栏
      begin
        ClientGetGABoardRead(body);
      end;
    SM_GABOARD_NOTICE_OK:
      begin
        FrmDlg.SendGABoardNoticeOk;
      end;
    SM_GABOARD_NOTICE_FAIL:
      begin
        DScreen.AddChatBoardString('只有授权行会管理员才可以编辑', clWhite, clRed);
      end;

    SM_DONATE_OK:
      begin
        FrmDlg.LastestClickTime := GetTickCount;
      end;

    SM_DONATE_FAIL:
      begin
        FrmDlg.LastestClickTime := GetTickCount;
      end;

    SM_NEXTTIME_PASSWORD:
      begin
        if FrmDlg.DEdChat.PasswordChar = #0 then
          FrmDlg.DEdChat.PasswordChar := '*';
        BoOneTimePassword := TRUE;
      end;
         
//      SM_CHANGEATTATCKMODE:
//         begin  //改变攻击模式
//            g_sAttackMode := DecodeString (body);
//         end;

    SM_PLAYDICE:
      begin
        body2 := Copy(body, UpInt(sizeof(TMessageBodyWL) * 4 / 3) + 1, Length(body));
        DecodeBuffer(body, @wl, sizeof(TMessageBodyWL));
        str := DecodeString(body2);
        FrmDlg.RunDice := msg.Param;

        FrmDlg.DiceType := 1;
        FrmDlg.DiceArr[0].DiceResult := lobyte(loword(wl.lparam1));
        FrmDlg.DiceArr[1].DiceResult := hibyte(loword(wl.lparam1));
        FrmDlg.DiceArr[2].DiceResult := lobyte(hiword(wl.lparam1));
        FrmDlg.DiceArr[3].DiceResult := hibyte(hiword(wl.lparam1));
        FrmDlg.DiceArr[4].DiceResult := lobyte(loword(wl.lparam2));
        FrmDlg.DiceArr[5].DiceResult := hibyte(loword(wl.lparam2));
        FrmDlg.DiceArr[6].DiceResult := lobyte(hiword(wl.lparam2));
        FrmDlg.DiceArr[7].DiceResult := hibyte(hiword(wl.lparam2));
        FrmDlg.DiceArr[8].DiceResult := lobyte(loword(wl.lTag1));
        FrmDlg.DiceArr[9].DiceResult := hibyte(loword(wl.lTag1));
        FrmDlg.DialogSize := 0;

        FrmDlg.DMessageDlg('', []);

        FrmMain.SendMerchantDlgSelect(msg.Recog, str);
      end;

    SM_SHELLEXECUTE: begin
        with frmWebBrowser do begin
          if not Showing then begin
            if pos('http://',body)=0 then
            body:='http://'+body;
            Open(body);
          end
        end;
      end;

    SM_PLAYROCK:
      begin
        body2 := Copy(body, UpInt(sizeof(TMessageBodyWL) * 4 / 3) + 1, Length(body));
        DecodeBuffer(body, @wl, sizeof(TMessageBodyWL));
        str := DecodeString(body2);

        FrmDlg.RunDice := msg.Param;
        FrmDlg.DiceType := 2;
        FrmDlg.DiceArr[0].DiceResult := lobyte(loword(wl.lparam1));
//      DScreen.AddChatBoardString ('SM_PLAYDICE: DiceResult=> '+InttoStr(FrmDlg.DiceArr[0].DiceResult), clYellow, clRed);
//            FrmDlg.DiceArr[1].DiceResult := hibyte(loword(wl.lparam1));
        FrmDlg.DialogSize := 0;

        FrmDlg.DMessageDlg('', []);
        FrmMain.SendMerchantDlgSelect(msg.Recog, str);
      end;
    SM_SERVERUNBIND: ClientGetServerUnBind(Body); //解包消息
    SM_MIRCONFIG:
      begin
        DecodeBuffer(DecodeString(body), @MirConfig, sizeof(TMirConfig));
        g_boMirNg := MirConfig.boMirNg;
        if not g_boMirNg then
         CloseNgInfo;
        g_boMirDark :=  MirConfig.g_boMirDark;
        if (not g_boMirDark) and (DarkLevel in [1..3]) then
          ViewFog := not g_boMirDark
        else if (not g_boMirDark) and (DarkLevel = 0) then
          ViewFog :=  (not DarkLevel = 0)
        else
          ViewFog := not g_boMirDark;
        g_boMirShowHp := MirConfig.g_boMirShowHp;
        g_boMirShowNumber := MirConfig.g_boMirShowNumber;
        bo摆摊 := MirConfig.bo摆摊;
        FrmDlg.DBotMaster1.Visible := bo摆摊;
        boHelp := MirConfig.g_boHelp;
        FrmDlg.DBotHelp.Visible := boHelp;

        
        g_boHostpot := MirConfig.g_boHostpot;
        FrmDlg.DBotHostpot.Visible := g_boHostpot;
        g_boQuestions := MirConfig.g_boQuestions;
        FrmDlg.DBotQuestions.Visible := g_boQuestions;

        g_boChinese := MirConfig.g_boChinese;
        g_boWhisperWin := MirConfig.g_boWhisperWin;

        g_boRelationWin := MirConfig.g_boRelationWin;

        if g_boWhisperWin then begin
          FrmDlg.DBotWhisper.Visible := g_boWhisperWin;
        end else begin
          FrmDlg.DBotWhisper.Visible := g_boWhisperWin;
          if FrmDlg.DWhisperDlg.Visible then
            FrmDlg.DWhisperDlg.Visible := g_boWhisperWin;
        end;

        if g_boRelationWin then begin
          FrmDlg.DBotFriend.Visible := g_boRelationWin;
        end else begin
          FrmDlg.DBotFriend.Visible := g_boRelationWin;
          if FrmDlg.DFriendDlg.Visible then
            FrmDlg.DFriendDlg.Visible := g_boRelationWin;
        end;


        g_boMirShop := MirConfig.g_boMirShop;
        g_bofuguHP :=  MirConfig.g_bofuguHP;
        g_bozuduihp := MirConfig.g_bozuduihp;
        if g_boMirShop then begin
          FrmDlg.DBotShop.Visible := g_boMirShop;
        end else begin
          FrmDlg.DBotShop.Visible := g_boMirShop;
          if FrmDlg.DCashShopDlg.Visible then
            FrmDlg.DCashShopDlg.Visible := g_boMirShop;
        end;

        if g_boChinese then begin
          FrmDlg.DBotLogout.SetImgIndex(WProgUse, 143);
//          FrmDlg.DBotExit.SetImgIndex(WProgUse, 138);
        end else begin
          FrmDlg.DBotLogout.SetImgIndex(WProgUse, 136);
//          FrmDlg.DBotExit.SetImgIndex(WProgUse, 138);
        end;

        g_boHostpotWeb := MirConfig.g_boHostpotWeb;
        g_boQuestionsWeb := MirConfig.g_boQuestionsWeb;
        g_bopaobusudu := MirConfig.g_bopaobusudu;
        g_MAGICSPEED := MirConfig.g_MAGICSPEED;
        g_ATTACKSPEED := MirConfig.g_ATTACKSPEED;

        g_bo免助跑 := MirConfig.g_bo免助跑;
        g_bo稳如泰山 := MirConfig.g_bo稳如泰山;
        g_bo绝对泰山 := MirConfig.g_bo绝对泰山;
        g_bo刀刀刺杀 := MirConfig.g_bo刀刀刺杀;
        g_bo战斗退出 := MirConfig.g_bo战斗退出;
        if FrmDlg.DWGameConfig.Visible then
          FrmDlg.DWGameConfig.Visible := g_boMirNg;

        g_bo技能备注 :=  MirConfig.g_bo技能备注;

        g_bo物品窗口 := MirConfig.g_bo物品窗口;
        g_bo主界面 := MirConfig.g_bo主界面;

        with FrmDlg do
        begin
          if not g_bo物品窗口 then
          begin
   //物品包裹栏
            DItemBag.SetImgIndex(WProgUse, 3);
            DItemBag.Left := 0;
            DItemBag.Top := 0;
            DItemGrid.Left := 20;
            DItemGrid.Top := 13;
            DItemGrid.Width := 286;
            DItemGrid.Height := 162;
   //黄金、修理物品、关闭包裹按钮
            DGold.SetImgIndex(WProgUse, 29);
            DGold.Left := 10;
            DGold.Top := 190;
            DRepairItem.SetImgIndex(WProgUse, 26);
            DRepairItem.Left := 254;
            DRepairItem.Top := 183;
            DRepairItem.Width := 48;
            DRepairItem.Height := 22;
            DClosebag.SetImgIndex(WProgUse, 371);
            DCloseBag.Left := 309;
            DCloseBag.Top := 203;
            DCloseBag.Width := 14;
            DCloseBag.Height := 20;
          end
          else
          begin//==============  以下是新包裹
   //新物品包裹栏
            DItemBag.SetImgIndex(WProgUse, 41);
            DItemBag.Left := 0;
            DItemBag.Top := 0;
            DItemGrid.Left := 29;
            DItemGrid.Top := 41;
            DItemGrid.Width := 286;
            DItemGrid.Height := 162;
   //新黄金、修理物品、关闭包裹按钮
            DGold.SetImgIndex(WProgUse, 29);
            DGold.Left := 18;
            DGold.Top := 218;
            DRepairItem.SetImgIndex(WProgUse, 42);
            DRepairItem.Left := 232;
            DRepairItem.Top := 206;
            DRepairItem.Width := 48;
            DRepairItem.Height := 22;
            DClosebag.SetImgIndex(WProgUse, 371);
            DCloseBag.Left := 337;
            DCloseBag.Top := 59;
            DCloseBag.Width := 14;
            DCloseBag.Height := 20;
          end;

          RefusePublicChat.Visible := g_bo主界面;
          RefuseCRY.Visible := g_bo主界面;
          RefuseWHISPER.Visible := g_bo主界面;
          Refuseguild.Visible := g_bo主界面;
          AutoCRY.Visible := g_bo主界面;
          g_bo锁定人物 := MirConfig.g_bo锁定人物;
          g_bo锁定怪物 := MirConfig.g_bo锁定怪物;
          g_bo极品蓝字 := MirConfig.g_bo极品蓝字;
          g_bo自动换符 := MirConfig.g_bo自动换符;
          g_bo自动换毒 := MirConfig.g_bo自动换毒;
          g_bo地图雷达 := MirConfig.g_bo地图雷达;
          g_bo悬浮信息 := MirConfig.g_bo悬浮信息;
          g_bo人物四格 := MirConfig.g_bo人物四格;
          g_bo大地图开关 := MirConfig.g_bo大地图开关;
          g_bo小地图迷宫入口显示 := MirConfig.g_bo小地图迷宫入口显示;
          g_bosjcd := MirConfig.g_bosjcd;     //jingdian add 20220117 双击穿戴
          g_bozdfy := MirConfig.g_bozdfy;      //jingdian add 20220117 自动放药
          g_Deatheject := MirConfig.g_Deatheject;
          g_bochksigedu  := MirConfig.g_bochksigedu; //20221010界面选择
          ClientChangeUi;
        end;
      end;
      SM_Master: begin
        with FrmDlg do
        begin
         if msg.recog = 11 then
         begin
         ToggleShowMasterDlg;
         if DLoveDlg.Visible then
          DLoveDlg.Visible := false;
         end
         else
         begin
         ToggleShowLoveDlg;
         if DMasterDlg.Visible then
           DMasterDlg.Visible := false;
         end;

         CloseMDlg;
        end;

      end;
      SM_OFFERITEM, SM_SPECOFFERITEM: if body <> '' then ClientGetShopItems(body, msg.param);

      SM_BUGITEMFAIL:
         begin
            case msg.Recog of
               00: FrmDlg.DMessageDlg('[失败]: 非法物品名', [mbOk]);
               -1: FrmDlg.DMessageDlg('[失败]: 不存在你想购买的物品', [mbOk]);
               -2: FrmDlg.DMessageDlg('[失败]: 请先进行元宝冲值', [mbOk]);
               -3: FrmDlg.DMessageDlg('[失败]: 你帐号中的元宝数不够', [mbOk]);
               -4: FrmDlg.DMessageDlg('[失败]：你无法携带更多的物品', [mbOk]);
               -5: FrmDlg.DMessageDlg('[失败]：购买物品不在商城中', [mbOk]);
               -6: FrmDlg.DMessageDlg('[失败]: 您的购买速度过快', [mbOk]);
            else
               FrmDlg.DMessageDlg('[失败]: 你无法购买', [mbOk]);
            end;
         end;
      SM_PRESENDITEMFAIL:
         begin
            if msg.tag = 0 then begin
               case msg.Recog of
                  01: FrmDlg.DMessageDlg('[成功]: 对方已经收到你的礼物', [mbOk]);
                  00: FrmDlg.DMessageDlg('[失败]: 非法的物品名称', [mbOk]);
                  -1: FrmDlg.DMessageDlg('[失败]: 抱歉, 服务器不存在你想购买赠送的物品', [mbOk]);
                  -2: FrmDlg.DMessageDlg('[失败]: 请先进行元宝冲值', [mbOk]);
                  -3: FrmDlg.DMessageDlg('[失败]: 你帐号中的元宝数不够', [mbOk]);
                  -4: FrmDlg.DMessageDlg('[失败]：赠送人无法携带更多的物品', [mbOk]);
                  -5: FrmDlg.DMessageDlg('[失败]：你想购买物品不在商城中', [mbOk]);
                  -6: FrmDlg.DMessageDlg('[失败]: 您的购买速度过快', [mbOk]);
                  -7: FrmDlg.DMessageDlg('[失败]: 赠送人不存在或不在线', [mbOk]);
                  -8: FrmDlg.DMessageDlg('[失败]: 赠送人不能是自己', [mbOk]);
                  -9: FrmDlg.DMessageDlg('[失败]: 服务器未开启赠送功能', [mbOk]);
               else
                  FrmDlg.DMessageDlg('[失败]: 你无法购买', [mbOk]);
               end;
            end else begin
               case msg.Recog of
                  01: FrmDlg.DMessageDlg('[成功]: 对方已经收到你的礼物', [mbOk]);
                  00: FrmDlg.DMessageDlg('[失败]: 非法的物品名称', [mbOk]);
                  -1: FrmDlg.DMessageDlg('[失败]: 抱歉, 服务器不存在你想购买赠送的物品', [mbOk]);
                  -2: FrmDlg.DMessageDlg('[失败]: 你没有金币', [mbOk]);
                  -3: FrmDlg.DMessageDlg('[失败]: 你帐的金币数不够', [mbOk]);
                  -4: FrmDlg.DMessageDlg('[失败]：赠送人无法携带更多的物品', [mbOk]);
                  -5: FrmDlg.DMessageDlg('[失败]：你想购买物品不在商城中', [mbOk]);
                  -6: FrmDlg.DMessageDlg('[失败]: 您的购买速度过快', [mbOk]);
                  -7: FrmDlg.DMessageDlg('[失败]: 赠送人不存在或不在线', [mbOk]);
                  -8: FrmDlg.DMessageDlg('[失败]: 赠送人不能是自己', [mbOk]);
                  -9: FrmDlg.DMessageDlg('[失败]: 服务器未开启赠送功能', [mbOk]);
               else
                  FrmDlg.DMessageDlg('[失败]: 你无法购买', [mbOk]);
               end;
            end;
         end;

      SM_RufuseMaster: begin
         g_bo拒绝拜师 := boolean(msg.recog);
        case msg.Param of
          30: begin
        if g_bo拒绝拜师 then
          DScreen.AddChatBoardString('[允许拜师]', clRed, clWhite)
        else
          DScreen.AddChatBoardString('[拒绝拜师]', clRed, clWhite);
          end;
          33: begin
        if g_bo拒绝拜师 then
          DScreen.AddChatBoardString('[允许收徒]', clRed, clWhite)
        else
          DScreen.AddChatBoardString('[拒绝收徒]', clRed, clWhite);
        end;
        end;
      end;
      SM_PING: ClientGetPing();


  else
    begin
      DScreen.AddSysMsg(IntToStr(msg.Ident) + ' : ' + body);
    end;
  end;

  if Pos('#', datablock) > 0 then
    DScreen.AddSysMsg(datablock);
end;


procedure TFrmMain.ClientChangeUi;
var
  d: TAsphyreLockableTexture;
begin
  with FrmDlg do
  begin
    if g_bo人物四格 then
    begin
      g_nMagicCount := 6;
      d := WProgUse.Images[92];  //惑怕
      if d <> nil then
      begin
        DStateWin.SetImgIndex(WProgUse, 92);
        DStateWin.Left := g_FScreenWidth - d.Width;
        DStateWin.Top := 0;
      end;

      DSWBujuk.Left := 38 + 4;
      DSWBujuk.Top := 52 + 202;
      DSWBujuk.Width := 34;
      DSWBujuk.Height := 31;
      DSWBujuk.Visible := True;

      DSWBelt.Left := 38 + 46;
      DSWBelt.Top := 52 + 202;
      DSWBelt.Width := 34;
      DSWBelt.Height := 31;
      DSWBelt.Visible := True;

      DSWBoots.Left := 38 + 88;
      DSWBoots.Top := 52 + 202;
      DSWBoots.Width := 34;
      DSWBoots.Height := 31;
      DSWBoots.Visible := True;

      DSWCharm.Left := 38 + 130;
      DSWCharm.Top := 52 + 202;
      DSWCharm.Width := 34;
      DSWCharm.Height := 31;
      DSWCharm.Visible := True;

      //DStMag6.Visible := TRUE;
      PageChanged;
      d := WProgUse.Images[92];  //惑怕
      if d <> nil then
      begin
        DUserState1.SetImgIndex(WProgUse, 92);
        DUserState1.Left := g_FScreenWidth - d.Width - d.Width;
        DUserState1.Top := 0;
      end;

      DBujukUS1.Left := 38 + 4;
      DBujukUS1.Top := 52 + 202;
      DBujukUS1.Width := 34;
      DBujukUS1.Height := 31;
      DBujukUS1.Visible := True;

      DBeltUS1.Left := 38 + 46;
      DBeltUS1.Top := 52 + 202;
      DBeltUS1.Width := 34;
      DBeltUS1.Height := 31;
      DBeltUS1.Visible := True;

      DBootsUS1.Left := 38 + 88;
      DBootsUS1.Top := 52 + 202;
      DBootsUS1.Width := 34;
      DBootsUS1.Height := 31;
      DBootsUS1.Visible := True;

      DCharmUS1.Left := 38 + 130;
      DCharmUS1.Top := 52 + 202;
      DCharmUS1.Width := 34;
      DCharmUS1.Height := 31;
      DCharmUS1.Visible := True;
    end
    else
    begin
      g_nMagicCount := 5;
      d := WProgUse.Images[370];  //惑怕
      if d <> nil then
      begin
        DStateWin.SetImgIndex(WProgUse, 370);
        DStateWin.Left := g_FScreenWidth - d.Width;
        DStateWin.Top := 0;
      end;

      DSWBujuk.Left := 38 + 4;
      DSWBujuk.Top := 52 + 202;
      DSWBujuk.Width := 34;
      DSWBujuk.Height := 31;
      DSWBujuk.Visible := False;

      DSWBelt.Left := 38 + 46;
      DSWBelt.Top := 52 + 202;
      DSWBelt.Width := 34;
      DSWBelt.Height := 31;
      DSWBelt.Visible := False;

      DSWBoots.Left := 38 + 88;
      DSWBoots.Top := 52 + 202;
      DSWBoots.Width := 34;
      DSWBoots.Height := 31;
      DSWBoots.Visible := False;

      DSWCharm.Left := 38 + 130;
      DSWCharm.Top := 52 + 202;
      DSWCharm.Width := 34;
      DSWCharm.Height := 31;
      DSWCharm.Visible := False;

      DStMag6.Visible := False;

      d := WProgUse.Images[370];  //惑怕
      if d <> nil then
      begin
        DUserState1.SetImgIndex(WProgUse, 370);
        DUserState1.Left := g_FScreenWidth - d.Width - d.Width;
        DUserState1.Top := 0;
      end;

      DBujukUS1.Left := 38 + 4;
      DBujukUS1.Top := 52 + 202;
      DBujukUS1.Width := 34;
      DBujukUS1.Height := 31;
      DBujukUS1.Visible := False;

      DBeltUS1.Left := 38 + 46;
      DBeltUS1.Top := 52 + 202;
      DBeltUS1.Width := 34;
      DBeltUS1.Height := 31;
      DBeltUS1.Visible := False;

      DBootsUS1.Left := 38 + 88;
      DBootsUS1.Top := 52 + 202;
      DBootsUS1.Width := 34;
      DBootsUS1.Height := 31;
      DBootsUS1.Visible := False;

      DCharmUS1.Left := 38 + 130;
      DCharmUS1.Top := 52 + 202;
      DCharmUS1.Width := 34;
      DCharmUS1.Height := 31;
      DCharmUS1.Visible := False;
    end;
  end;
end;

procedure TFrmMain.ClientGetPasswdSuccess(body: string);
var
  str, runaddr, runport, uid, certifystr: string;
begin
  str := DecodeString(body);
  str := GetValidStr3(str, runaddr, ['/']);
  str := GetValidStr3(str, runport, ['/']);
  str := GetValidStr3(str, certifystr, ['/']);
  Certification := Str_ToInt(certifystr, 0);

  if not BoOneClick then
  begin
    CSocket.Active := FALSE;  //关闭连接到登录的socket
    FrmDlg.DSelServerDlg.Visible := FALSE;
    WaitAndPass(500); //0.5秒内等待
    ConnectionStep := cnsSelChr;

//    Application.MessageBox( PChar(runaddr+'/'+runport+'/'+certifystr), PChar('Check'), IDOK);
    with CSocket do
    begin
      SelChrAddr := runaddr;
      SelChrPort := Str_ToInt(runport, 0);
      Address := SelChrAddr;
      Port := SelChrPort;
      Active := TRUE;
    end;
//    Application.MessageBox( PChar('Activated'), PChar('Check'), IDOK);
  end
  else
  begin
    FrmDlg.DSelServerDlg.Visible := FALSE;
    SelChrAddr := runaddr;
    SelChrPort := Str_ToInt(runport, 0);

//    Application.MessageBox( PChar(runaddr+'/'+runport+'/'+certifystr), PChar('CheckOneClick'), IDOK);
    if CSocket.Socket.Connected then
      CSocket.Socket.SendText('$S' + runaddr + '/' + runport + '%');
    WaitAndPass(500); //0.5秒内等待
    ConnectionStep := cnsSelChr;
    LoginScene.OpenLoginDoor;
    SelChrWaitTimer.Enabled := TRUE;
//    Application.MessageBox( PChar('Activated'), PChar('CheckOneClick'), IDOK);
  end;
  FLoginIDLock := true;
end;

procedure TFrmMain.ClientGetSelectServer;
var
  sname: string;
begin
  LoginScene.HideLoginBox;
  FrmDlg.ShowSelectServerDlg;
end;

procedure TFrmMain.ClientGetNeedUpdateAccount(body: string);
var
  ue: TUserEntryInfo;
begin
  DecodeBuffer(body, @ue, sizeof(TUserEntryInfo));
  LoginScene.UpdateAccountInfos(ue);
end;

procedure TFrmMain.ClientGetReceiveChrs(body: string);
var
  i, select: integer;
  str, uname, sjob, shair, slevel, ssex: string;
begin
  SelectChrScene.ClearChrs;
  str := DecodeString(body);
  for i := 0 to 2 do
  begin
    str := GetValidStr3(str, uname, ['/']);
    str := GetValidStr3(str, sjob, ['/']);
    str := GetValidStr3(str, shair, ['/']);
    str := GetValidStr3(str, slevel, ['/']);
    str := GetValidStr3(str, ssex, ['/']);
    select := 0;
    if (uname <> '') and (slevel <> '') and (ssex <> '') then
    begin
      if uname[1] = '*' then
      begin
        select := i;
        uname := Copy(uname, 2, Length(uname) - 1);
      end;
      SelectChrScene.AddChr(uname, Str_ToInt(sjob, 0), Str_ToInt(shair, 0), Str_ToInt(slevel, 0), Str_ToInt(ssex, 0));
    end;
    with SelectChrScene do
    begin
      if select = 0 then
      begin
        ChrArr[0].FreezeState := FALSE;
        ChrArr[0].Selected := TRUE;
        ChrArr[1].FreezeState := TRUE;
        ChrArr[1].Selected := FALSE;
      end
      else if select = 1 then
      begin
        ChrArr[0].FreezeState := TRUE;
        ChrArr[0].Selected := FALSE;
        ChrArr[1].FreezeState := FALSE;
        ChrArr[1].Selected := TRUE;
      end
      else if select = 2 then
      begin
        ChrArr[0].FreezeState := TRUE;
        ChrArr[0].Selected := FALSE;
        ChrArr[1].FreezeState := TRUE;
        ChrArr[1].Selected := FALSE;
      end;

    end;
  end;
end;

procedure TFrmMain.ClientGetStartPlay(body: string);
var
  str, addr, sport: string;
begin
  str := DecodeString(body);
  sport := GetValidStr3(str, addr, ['/']);

  if not BoOneClick then
  begin
    CSocket.Active := FALSE;  //关闭连接到登录的socket
    WaitAndPass(500); //0.5秒内等待

    ConnectionStep := cnsPlay;
    with CSocket do
    begin
      Address := addr;
      Port := Str_ToInt(sport, 0);
      Active := TRUE;
    end;
  end
  else
  begin
    SocStr := '';
    BufferStr := '';
    if CSocket.Socket.Connected then
      CSocket.Socket.SendText('$R' + addr + '/' + sport + '%');

    ConnectionStep := cnsPlay;
    ClearBag;  //重置背包
    DScreen.ClearChatBoard; //重置聊天窗口
    DScreen.ChangeScene(stLoginNotice);

    WaitAndPass(500); //0.5秒内等待
    SendRunLogin;
  end;
end;

procedure TFrmMain.ClientGetReconnect(body: string);
var
  str, addr, sport: string;
begin
  str := DecodeString(body);
  sport := GetValidStr3(str, addr, ['/']);

  if not BoOneClick then
  begin
//    if BoBagLoaded then
//      Savebags('.\Data\' + ServerName + '.' + CharName + '.itm', @ItemArr);
//
//    BoBagLoaded := FALSE;

    BoServerChanging := TRUE;
    CSocket.Active := FALSE;  //关闭连接到登录的socket

    WaitAndPass(500); //0.5秒内等待

    ConnectionStep := cnsPlay;
    with CSocket do
    begin
      Address := addr;
      Port := Str_ToInt(sport, 0);
      Active := TRUE;
    end;

  end
  else
  begin
//    if BoBagLoaded then
//      Savebags('.\Data\' + ServerName + '.' + CharName + '.itm', @ItemArr);
//
//    BoBagLoaded := FALSE;

    SocStr := '';
    BufferStr := '';
    BoServerChanging := TRUE;

    if CSocket.Socket.Connected then   //发送连接结束信号。
      CSocket.Socket.SendText('$C' + addr + '/' + sport + '%');

    WaitAndPass(500); //0.5秒内等待
    if CSocket.Socket.Connected then   //重新加入..
      CSocket.Socket.SendText('$R' + addr + '/' + sport + '%');

    ConnectionStep := cnsPlay;
    ClearBag;  //重置背包
    DScreen.ClearChatBoard; //重置聊天窗口
    DScreen.ChangeScene(stLoginNotice);

    WaitAndPass(300); //0.5秒内等待
    ChangeServerClearGameVariables;

    SendRunLogin;
  end;
end;

procedure TFrmMain.ClientGetMapDescription(body: string);
var
  data: string;
begin
  body := DecodeString(body);
  body := GetValidStr3(body, data, [#13]);
  MapTitle := data; //地图名称....
  g_MapDesc := GetMapDescList(MapTitle);
  TempMapTitle := data; //2019-02-19
end;

procedure TFrmMain.ClientGetAdjustBonus(bonus: integer; body: string);
var
  str1, str2, str3: string;
begin
  BonusPoint := bonus;
  body := GetValidStr3(body, str1, ['/']);
  str3 := GetValidStr3(body, str2, ['/']);
  DecodeBuffer(str1, @BonusTick, sizeof(TNakedAbility));
  DecodeBuffer(str2, @BonusAbil, sizeof(TNakedAbility));
  DecodeBuffer(str3, @NakedAbil, sizeof(TNakedAbility));
  FillChar(BonusAbilChg, sizeof(TNakedAbility), #0);
end;

procedure TFrmMain.ClientGetAddItem(body: string);
var
  cu: TClientItem;
begin
  if body <> '' then
  begin
    DecodeBuffer(body, @cu, sizeof(TClientItem));
    AddItemBag(cu);
    DScreen.AddSysMsg(cu.S.Name + ' 被发现.');
  end;
  g_boRefreshBagItem := false;
end;

procedure TFrmMain.ClientGetUpdateItem(body: string);
var
  i: integer;
  cu: TClientItem;
begin
  if body <> '' then
  begin
    DecodeBuffer(body, @cu, sizeof(TClientItem));
    UpdateItemBag(cu);
      // 2003/03/15 内容扩展
    for i := 0 to 12 do
    begin    // 8 -> 12
      if (UseItems[i].S.Name = cu.S.Name) and (UseItems[i].MakeIndex = cu.MakeIndex) then
      begin
        UseItems[i] := cu;
      end;
    end;
  end;
end;
function dellStallItem(ci: TClientItem): Boolean;
var
  i                 : Integer;
begin
  Result := False;
  if MySelf = nil then Exit;
  for i := 0 to 10 - 1 do begin
    if mySelf.m_StallMgr.mBlock.Items[i].s.Name <> '' then begin
      if mySelf.m_StallMgr.mBlock.Items[i].MakeIndex = ci.MakeIndex then begin
        mySelf.m_StallMgr.mBlock.Items[i].S.Name := '';
       // mySelf.m_StallMgr.mBlock.Items[i].S.Stock := 0;
        Result := True;
        Exit;
      end;
    end;
  end;
end;
procedure TFrmMain.ClientGetDelItem(body: string; flag: integer);
var
  i: integer;
  cu: TClientItem;
begin

  if body <> '' then
  begin
    if flag = 1 then
    begin
      DecodeBuffer(body, @DelTempItem, sizeof(TClientItem));
    end
    else
    begin
      DecodeBuffer(body, @cu, sizeof(TClientItem));
      DelItemBag(cu.S.Name, cu.MakeIndex);
      dellStallItem(cu);
         // 2003/03/15 内容扩展
      for i := 0 to 12 do
      begin   // 8 -> 12
        if (UseItems[i].S.Name = cu.S.Name) and (UseItems[i].MakeIndex = cu.MakeIndex) then
        begin
          UseItems[i].S.Name := '';
        end;
      end;
    end;
  end;
end;

procedure TFrmMain.ClientGetDelItems(body: string);
var
  i, iindex: integer;
  str, iname: string;
  cu: TClientItem;
begin
  body := DecodeString(body);
  while body <> '' do
  begin
    body := GetValidStr3(body, iname, ['/']);
    body := GetValidStr3(body, str, ['/']);
    if (iname <> '') and (str <> '') then
    begin
      iindex := Str_ToInt(str, 0);
      DelItemBag(iname, iindex);
         // 2003/03/15 内容扩展
      for i := 0 to 12 do
      begin   // 8->12
        if (UseItems[i].S.Name = iname) and (UseItems[i].MakeIndex = iindex) then
        begin
          UseItems[i].S.Name := '';
        end;
      end;
    end
    else
      break;
  end;
end;

procedure TFrmMain.ClientGetBagItmes(body: string);
var
  str: string;
  cu: TClientItem;
  ItemSaveArr: array[0..MAXBAGITEMCL - 1] of TClientItem;

  function CompareItemArr: Boolean;
  var
    i, j: integer;
    flag: Boolean;
  begin
    flag := TRUE;
    for i := 0 to MAXBAGITEMCL - 1 do
    begin
      if ItemSaveArr[i].S.Name <> '' then
      begin
        flag := FALSE;
        for j := 0 to MAXBAGITEMCL - 1 do
        begin
          if (ItemArr[j].S.Name = ItemSaveArr[i].S.Name) and (ItemArr[j].MakeIndex = ItemSaveArr[i].MakeIndex) then
          begin
            if (ItemArr[j].Dura = ItemSaveArr[i].Dura) and (ItemArr[j].DuraMax = ItemSaveArr[i].DuraMax) then
            begin
              flag := TRUE;
            end;
            break;
          end;
        end;
        if not flag then
          break;
      end;
    end;
    if flag then
    begin
      for i := 0 to MAXBAGITEMCL - 1 do
      begin
        if ItemArr[i].S.Name <> '' then
        begin
          flag := FALSE;
          for j := 0 to MAXBAGITEMCL - 1 do
          begin
            if (ItemArr[i].S.Name = ItemSaveArr[j].S.Name) and (ItemArr[i].MakeIndex = ItemSaveArr[j].MakeIndex) then
            begin
              if (ItemArr[i].Dura = ItemSaveArr[j].Dura) and (ItemArr[i].DuraMax = ItemSaveArr[j].DuraMax) then
              begin
                flag := TRUE;
              end;
              break;
            end;
          end;
          if not flag then
            break;
        end;
      end;
    end;
    Result := flag;
  end;

begin
   //ClearBag;
  FillChar(ItemArr, sizeof(TClientItem) * MAXBAGITEMCL, #0);
  while TRUE do
  begin
    if body = '' then
      break;
    body := GetValidStr3(body, str, ['/']);
    DecodeBuffer(str, @cu, sizeof(TClientItem));
    AddItemBag(cu);
  end;
  FillChar(ItemSaveArr, sizeof(TClientItem) * MAXBAGITEMCL, #0);
//  Loadbags('.\Data\' + ServerName + '.' + CharName + '.itm', @ItemSaveArr);
  if CompareItemArr then
  begin
    Move(ItemSaveArr, ItemArr, sizeof(TClientItem) * MAXBAGITEMCL);
  end;
  ArrangeItembag;
//  BoBagLoaded := TRUE;
  g_boRefreshBagItem := false;
end;

procedure TFrmMain.ClientGetDropItemFail(iname: string; sindex: integer);
var
  pc: PTClientItem;
begin
  pc := GetDropItem(iname, sindex);
  if pc <> nil then
  begin
    AddItemBag(pc^);
    DelDropItem(iname, sindex);
  end;
end;

procedure TFrmMain.ClientGetShowItem(itemid, x, y, looks: integer; body: string);
var
  i: integer;
  pd: PTDropItem;
  itmname, sDeco: string;
  pCItemRule: pTCItemRule;
begin
  for i := 0 to DropedItemList.Count - 1 do
  begin
    if PTDropItem(DropedItemList[i]).id = itemid then
      exit;
  end;
  new(pd);
  pd.Id := itemid;
  pd.X := x;
  pd.Y := y;
  pd.Looks := looks;
  sDeco := '0';
  if body <> '' then
  begin
    body := GetValidStr3(body, itmname, ['/']);
    body := GetValidStr3(body, sDeco, ['/']);
  end;
  pd.Name := itmname;
  if Str_ToInt(sDeco, 0) = 0 then
    pd.BoDeco := False
  else
    pd.BoDeco := True;
  pd.FlashTime := GetTickCount - Random(3000);
  pd.BoFlash := FALSE;
  pCItemRule := GetFiltrateItem(itmname);
  if pCItemRule <> nil then
  begin
    pd.boItemHiht := pCItemRule.rare;
    pd.boPickUp := pCItemRule.pick;
    pd.boShowName := pCItemRule.Show;
  end;
  DropedItemList.Add(pd);
end;

procedure TFrmMain.ClientGetHideItem(itemid, x, y: integer);
var
  i: integer;
  pd: PTDropItem;
begin
  for i := 0 to DropedItemList.Count - 1 do
  begin
    if PTDropItem(DropedItemList[i]).id = itemid then
    begin
      Dispose(PTDropItem(DropedItemList[i]));
      DropedItemlist.Delete(i);
      break;
    end;
  end;
end;

procedure TFrmMain.ClientGetSenduseItems(body: string);
var
  index, i: integer;
  str, data, TempHint: string;
  cu: TClientItem;
begin
   // 2003/03/15 新武功
  FillChar(UseItems, sizeof(UseItems), #0);      // 9->13
  while TRUE do
  begin
    if body = '' then
      break;
    body := GetValidStr3(body, str, ['/']);
    body := GetValidStr3(body, data, ['/']);
    index := Str_ToInt(str, -1);
      // 2003/03/15 物品库存扩张
    if index in [0..U_TRANS] then
    begin    // 8->12
      DecodeBuffer(data, @cu, sizeof(TClientItem));
      UseItems[index] := cu;
    end;
  end;

  if (g_bofuguHP) or (g_NgConfigInfo.boDuraWarning) and (MySelf <> nil) and not MySelf.Death then
  begin
    for i := High(UseItems) downto Low(UseItems) do
    begin
      if (UseItems[i].S.name <> '') then
      begin
        if UseItems[i].S.StdMode in [7, 25] then
          Continue;
        if (UseItems[i].Dura < 2500) and (UseItems[i].S.StdMode in [0..50,52,54]) then
        begin
          if GetDuraHint1(i, UseItems[i]) then
          begin
            case g_DuraWarning[i].DuraCount of
              1:
                TempHint := '你的[' + UseItems[i].S.Name + ']持久已到2，请及时修理或更换！';
              2:
                TempHint := '你的[' + UseItems[i].S.Name + ']持久已到1，请及时修理或更换！';
              3:
                TempHint := '你的[' + UseItems[i].S.Name + ']持久已到底限，请及时修理或更换！';
            end;
            DScreen.AddChatBoardString(TempHint, GetRGB(255), clBlue);
          end;
        end;
      end;
    end;
    g_MapDuraWarning := False;
  end;
  end;

procedure TFrmMain.ClientGetAddMagic(body: string);
var
  pcm: PTClientMagic;
begin
  new(pcm);
  DecodeBuffer(body, @(pcm^), sizeof(TClientMagic));
  MagicList.Add(pcm);
end;

procedure TFrmMain.ClientGetDelMagic(magid: integer);
var
  i: integer;
begin
  for i := MagicList.Count - 1 downto 0 do
  begin
    if PTClientMagic(MagicList[i]).Def.MagicId = magid then
    begin
      Dispose(PTClientMagic(MagicList[i]));
      MagicList.Delete(i);
      break;
    end;
  end;
end;

procedure TFrmMain.ClientGetMyMagics(checksum: integer; body: string);
var
  i, mdelay: integer;
  data: string;
  pcm: PTClientMagic;
begin
  for i := 0 to MagicList.Count - 1 do
    Dispose(PTClientMagic(MagicList[i]));
  MagicList.Clear;
  mdelay := 0;
  while TRUE do
  begin
    if body = '' then
      break;
    body := GetValidStr3(body, data, ['/']);
    if data <> '' then
    begin
      new(pcm);
      DecodeBuffer(data, @(pcm^), sizeof(TClientMagic));
      MagicList.Add(pcm);
      mdelay := mdelay + pcm.Def.DelayTime;
    end
    else
      break;
  end;

  if (checksum xor $4BBC2255) xor $773F1A34 <> mdelay then
  begin
    for i := 0 to MagicList.Count - 1 do
      PTClientMagic(MagicList[i]).Def.DelayTime := 1000;
  end;

end;

procedure TFrmMain.ClientGetMagicLvExp(magid, maglv, magtrain: integer);
var
  i: integer;
begin
  for i := MagicList.Count - 1 downto 0 do
  begin
    if PTClientMagic(MagicList[i]).Def.MagicId = magid then
    begin
      PTClientMagic(MagicList[i]).level := maglv;
      PTClientMagic(MagicList[i]).CurTrain := magtrain;
      break;
    end;
  end;
end;

procedure TFrmMain.ClientGetSound(soundid: integer);
begin
  SilenceSound;
  if soundid <> 0 then
  begin
    PlaySound(soundid);
  end
end;

procedure TFrmMain.ClientGetDuraChange(uidx, newdura, newduramax: integer);
begin
   // 2003/03/15 物品库存扩张
  if uidx in [0..U_TRANS] then
  begin     // 8->12
    if UseItems[uidx].S.Name <> '' then
    begin
      UseItems[uidx].Dura := newdura;
      UseItems[uidx].DuraMax := newduramax;
      g_DuraWarning[uidx].TAKEON_OK := false;
      g_DuraWarning[uidx].Dura_Ok := True;
    end;
  end;
end;

procedure TFrmMain.ClientGetMerchantSay(merchant, face: integer; saying: string);
var
  npcname: string;
begin
  MDlgX := Myself.XX;
  MDlgY := Myself.YY;
  if CurMerchant <> merchant then
  begin
    CurMerchant := merchant;
    FrmDlg.ResetMenuDlg;
    FrmDlg.CloseMDlg;
  end;

  saying := GetValidStr3(saying, npcname, ['/']);
  FrmDlg.ShowMDlg(face, npcname, saying);
end;

procedure TFrmMain.ClientGetSendGoodsList(merchant, count: integer; body: string);
var
  i: integer;
  data, gname, gsub, gprice, gstock: string;
  pcg: PTClientGoods;
begin
  FrmDlg.ResetMenuDlg;

  CurMerchant := merchant;
  with FrmDlg do
  begin
      //deocde body received from server
    body := DecodeString(body);
    while body <> '' do
    begin
      body := GetValidStr3(body, gname, ['/']);
      body := GetValidStr3(body, gsub, ['/']);
      body := GetValidStr3(body, gprice, ['/']);
      body := GetValidStr3(body, gstock, ['/']);
      if (gname <> '') and (gprice <> '') and (gstock <> '') then
      begin
        new(pcg);
        pcg.Name := gname;
        pcg.SubMenu := Str_ToInt(gsub, 0);
        pcg.Price := Str_ToInt(gprice, 0);
        pcg.Stock := Str_ToInt(gstock, 0);
        pcg.Grade := -1;
        MenuList.Add(pcg);
      end
      else
        break;
    end;
    FrmDlg.ShowShopMenuDlg;
    FrmDlg.CurDetailItem := '';
  end;
end;

procedure TFrmMain.ClientGetDecorationList(merchant, count: integer; body: string);
var
  i: integer;
  data, sname, simgindex, sprice, scase: string;
  pcd: PTClientGADecoration;
begin

  with FrmDlg do
  begin
    for i := 0 to GADecorationList.Count - 1 do
      Dispose(PTClientGADecoration(GADecorationList[i]));
    GADecorationList.Clear;
  end;

//   CurMerchant := merchant;
   //捞抚/锅龋/啊拜/辆幅
  with FrmDlg do
  begin
      //deocde body received from server
    body := DecodeString(body);
    while body <> '' do
    begin
      body := GetValidStr3(body, sname, ['/']);
      body := GetValidStr3(body, simgindex, ['/']);
      body := GetValidStr3(body, sprice, ['/']);
      body := GetValidStr3(body, scase, ['/']);
//         body := GetValidStr3 (body, sprice, ['/']);
//      DScreen.AddChatBoardString (sname+'/'+stemp1+'/'+simgindex+'/'+stemp2, clYellow, clRed);
//         if (sname <> '') and (sprice <> '') and (simgindex <> '') then begin
      if (sname <> '') and (simgindex <> '') then
      begin
        new(pcd);
        pcd.Num := Str_ToInt(simgindex, 0);
        pcd.Name := sname;
        pcd.Price := Str_ToInt(sprice, 0);
        pcd.ImgIndex := Str_ToInt(simgindex, 0);
        pcd.CaseNum := Str_ToInt(scase, 0);

        GADecorationList.Add(pcd);
      end
      else
        break;
    end;
//      FrmDlg.ShowGADecorateDlg;
  end;
end;

procedure TFrmMain.ClientGetJangwonList(Page, count: integer; body: string);
var //收到庄园清单
//   i: integer;
  SNum, SGuildname, SCaptainname1, SCaptainname2, SSellprice, SSellstate: string;
  pcj: PTClientJangwon;
begin
  FrmDlg.ResetMenuDlg;

   //deocde body received from server
  body := DecodeString(body);
  while body <> '' do
  begin
    body := GetValidStr3(body, SNum, ['/']);
    body := GetValidStr3(body, SGuildname, ['/']);
    body := GetValidStr3(body, SCaptainname1, ['/']);
    body := GetValidStr3(body, SCaptainname2, ['/']);
    body := GetValidStr3(body, SSellprice, ['/']);
    body := GetValidStr3(body, SSellstate, ['/']);
    if (SCaptainname1 <> '') and (SSellprice <> '') and (SSellstate <> '') then
    begin
      new(pcj);
      pcj.Num := Str_ToInt(SNum, 0);
      pcj.GuildName := SGuildname;
      pcj.CaptaineName1 := SCaptainname1;
      pcj.CaptaineName2 := SCaptainname2;
      pcj.SellPrice := Str_ToInt(SSellprice, 0);
      pcj.SellState := SSellstate;
      FrmDlg.JangwonList.Add(pcj);
//  DScreen.AddChatBoardString (SNum +'/'+ SGuildname +'/'+ SCaptainname +'/'+ SSellprice +'/'+ SSellstate, clYellow, clRed);
    end
    else
      break;
  end;
  if Page = 1 then
    FrmDlg.MenuTop := 0
  else if Page = 2 then
    FrmDlg.MenuTop := 10;
  FrmDlg.ShowJangwonDlg; // 寄售 ItemMarket

end;

procedure TFrmMain.ClientGetGABoardList(ListNum, Page, MaxPage: integer; body: string);
var //收到庄园公告牌清单
  i: integer;
  SGuildname, SWriteUser, SIndexType1, SIndexType2, SIndexType3, SIndexType4, STitleMsg, LineData: string;
  pcb: PTClientGABoard;
begin
   //deocde body received from server
  body := DecodeString(body);

  body := GetValidStr3(body, SGuildname, ['/']);
  body := GetValidStr3(body, SWriteUser, ['/']);
  body := GetValidStr3(body, SIndexType1, ['/']);
  body := GetValidStr3(body, SIndexType2, ['/']);
  body := GetValidStr3(body, SIndexType3, ['/']);
  body := GetValidStr3(body, SIndexType4, ['/']);
  body := GetValidStr3(body, STitleMsg, ['/']);

  FrmDlg.GABoard_MaxPage := MaxPage;
  FrmDlg.GABoard_CurPage := Page;

  if ListNum = 1 then
  begin
    FrmDlg.ResetMenuDlg;
    FrmDlg.GABoard_GuildName := SGuildname;
  end;

  if STitleMsg <> '' then
  begin
    new(pcb);
    pcb.WrigteUser := SWriteUser;
    pcb.IndexType1 := StrToInt(SIndexType1);
    pcb.IndexType2 := StrToInt(SIndexType2);
    pcb.IndexType3 := StrToInt(SIndexType3);
    pcb.IndexType4 := StrToInt(SIndexType4);

    STitleMsg := GetValidStr3(SQLSafeToStr(STitleMsg), LineData, [#13]);
    FrmDlg.GABoard_Notice.Add(LineData);
    pcb.TitleMsg := LineData;
    pcb.ReplyCount := 0;
    if pcb.IndexType2 > 0 then
      Inc(pcb.ReplyCount);
    if pcb.IndexType3 > 0 then
      Inc(pcb.ReplyCount);
    if pcb.IndexType4 > 0 then
      Inc(pcb.ReplyCount);

    FrmDlg.GABoardList.Add(pcb);
  end;

//   if FrmDlg.DGABoardListDlg.Visible then FrmDlg.DGABoardListDlg.Visible := False;
  if ListNum = 100 then
    FrmDlg.ShowGABoardListDlg;

end;

procedure TFrmMain.ClientGetGABoardRead(body: string);
var
  SWriteUser, STitleMsg, SIndexType1, SIndexType2, SIndexType3, SIndexType4, LineData: string;
begin

  body := DecodeString(body);

  body := GetValidStr3(body, SIndexType1, ['/']);
  body := GetValidStr3(body, SIndexType2, ['/']);
  body := GetValidStr3(body, SIndexType3, ['/']);
  body := GetValidStr3(body, SIndexType4, ['/']);
  body := GetValidStr3(body, SWriteUser, ['/']);
  body := GetValidStr3(body, STitleMsg, ['/']);

  FrmDlg.GABoard_IndexType1 := StrToInt(SIndexType1);
  FrmDlg.GABoard_IndexType2 := StrToInt(SIndexType2);
  FrmDlg.GABoard_IndexType3 := StrToInt(SIndexType3);
  FrmDlg.GABoard_IndexType4 := StrToInt(SIndexType4);

  FrmDlg.GABoard_UserName := SWriteUser;
  FrmDlg.GABoard_TxtBody := STitleMsg;

//DScreen.AddChatBoardString (SIndexType1 +'/'+ SIndexType2 +'/'+ SIndexType3 +'/'+ SIndexType4 +'/'+
//                            SWriteUser +'/'+ STitleMsg , clYellow, clRed);

  FrmDlg.GABoard_Notice.Clear;
//   STitleMsg := GetValidStr3 (SQLSafeToStr(STitleMsg), LineData, [#13]);
//   FrmDlg.GABoard_Notice.Add (SQLSafeToStr(STitleMsg));

  while TRUE do
  begin
    if STitleMsg = '' then
    begin
//    DScreen.AddChatBoardString ('STitleMsg=> '+STitleMsg, clYellow, clRed);
//    DScreen.AddChatBoardString ('LineData=> '+LineData, clYellow, clRed);
      break;
    end;
    STitleMsg := GetValidStr3(SQLSafeToStr(STitleMsg), LineData, [#13]);
    FrmDlg.GABoard_Notice.Add(LineData);
  end;

  FrmDlg.ShowGABoardReadDlg;

end;

procedure TFrmMain.ClientGetSendMakeDrugList(merchant: integer; body: string);
var
  i: integer;
  data, gname, gsub, gprice, gstock: string;
  pcg: PTClientGoods;
begin
  FrmDlg.ResetMenuDlg;

  CurMerchant := merchant;
  with FrmDlg do
  begin
      //clear shop menu list
      //deocde body received from server
    body := DecodeString(body);
    while body <> '' do
    begin
      body := GetValidStr3(body, gname, ['/']);
      body := GetValidStr3(body, gsub, ['/']);
      body := GetValidStr3(body, gprice, ['/']);
      body := GetValidStr3(body, gstock, ['/']);
      if (gname <> '') and (gprice <> '') and (gstock <> '') then
      begin
        new(pcg);
        pcg.Name := gname;
        pcg.SubMenu := Str_ToInt(gsub, 0);
        pcg.Price := Str_ToInt(gprice, 0);
        pcg.Stock := Str_ToInt(gstock, 0);
        pcg.Grade := -1;
        MenuList.Add(pcg);
      end
      else
        break;
    end;
    FrmDlg.ShowShopMenuDlg;
    FrmDlg.CurDetailItem := '';
    FrmDlg.BoMakeDrugMenu := TRUE;
  end;
end;

procedure TFrmMain.ClientGetSendMakeItemList(merchant: integer; body: string);
var
  i: integer;
  data, gname, gsub, gprice, gstock: string;
  pcg: PTClientGoods;
begin
  FrmDlg.ResetMenuDlg;

  CurMerchant := merchant;
  with FrmDlg do
  begin
      //clear shop menu list
      //deocde body received from server
    body := DecodeString(body);
    while body <> '' do
    begin
      body := GetValidStr3(body, gname, ['/']);
      body := GetValidStr3(body, gsub, ['/']);
      body := GetValidStr3(body, gprice, ['/']);
      body := GetValidStr3(body, gstock, ['/']);
      if (gname <> '') and (gprice <> '') and (gstock <> '') then
      begin
        new(pcg);
        pcg.Name := gname;
        pcg.SubMenu := Str_ToInt(gsub, 0);
        pcg.Price := Str_ToInt(gprice, 0);
        pcg.Stock := Str_ToInt(gstock, 0);
        pcg.Grade := -1;
        MenuList.Add(pcg);
      end
      else
        break;
    end;
    FrmDlg.ShowShopMenuDlg;
    FrmDlg.CurDetailItem := '';
    FrmDlg.BoMakeItemMenu := True;
  end;
end;

procedure TFrmMain.ClientGetSendUserSell(merchant: integer);
begin
  FrmDlg.CloseDSellDlg;
  CurMerchant := merchant;
  FrmDlg.SpotDlgMode := dmSell;
  FrmDlg.ShowShopSellDlg;
end;

procedure TFrmMain.ClientGetSendUserRepair(merchant: integer);
begin
  FrmDlg.CloseDSellDlg;
  CurMerchant := merchant;
  FrmDlg.SpotDlgMode := dmRepair;
  FrmDlg.ShowShopSellDlg;
end;

procedure TFrmMain.ClientGetSendUserStorage(merchant: integer);
begin
  FrmDlg.CloseDSellDlg;
  CurMerchant := merchant;
  FrmDlg.SpotDlgMode := dmStorage;
  FrmDlg.ShowShopSellDlg;
end;

procedure TFrmMain.ClientGetSendUserMaketSell(merchant: integer);
begin
  FrmDlg.CloseDSellDlg;
  CurMerchant := merchant;
  FrmDlg.SpotDlgMode := dmMaketSell;
  FrmDlg.ShowShopSellDlg;
end;

procedure TFrmMain.ClientGetSaveItemList(merchant, Currentpage, maxpage, bStorageType: integer; bodystr: string);
var
  i: integer;
  data: string;
  pc: PTClientItem;
  pcg: PTClientGoods;
begin
  FrmDlg.ResetMenuDlg;

//   DScreen.AddSysMsg (IntToStr(CurrentPage) + ' , ' + IntToStr(maxpage) );

  if Currentpage = 0 then
  begin
    for i := 0 to SaveItemList.Count - 1 do
      Dispose(PTClientItem(SaveItemList[i]));
    SaveItemList.Clear;
  end;

  while TRUE do
  begin
    if bodystr = '' then
      break;
    bodystr := GetValidStr3(bodystr, data, ['/']);
    if data <> '' then
    begin
      new(pc);
      DecodeBuffer(data, @(pc^), sizeof(TClientItem));
      SaveItemList.Add(pc);
    end
    else
      break;
  end;

  CurMerchant := merchant;
  with FrmDlg do
  begin
      //deocde body received from server
    for i := 0 to SaveItemList.Count - 1 do
    begin
      new(pcg);
      pcg.Name := PTClientItem(SaveItemList[i]).S.Name;
      pcg.SubMenu := 0;
      pcg.Price := PTClientItem(SaveItemList[i]).MakeIndex;
      pcg.Stock := Round(PTClientItem(SaveItemList[i]).Dura / 1000);
      pcg.Grade := Round(PTClientItem(SaveItemList[i]).DuraMax / 1000);
      MenuList.Add(pcg);
    end;
    if Currentpage = maxpage then
    begin
      FrmDlg.ShowShopMenuDlg(bStorageType);
      FrmDlg.BoStorageMenu := TRUE;
    end;
  end;
end;

procedure TFrmMain.ClientGetSendDetailGoodsList(merchant, count, topline: integer; bodystr: string);
var
  i: integer;
  body, data, gname, gprice, gstock, ggrade: string;
  pcg: PTClientGoods;
  pc: PTClientItem;
begin
  FrmDlg.ResetMenuDlg;

  CurMerchant := merchant;

  bodystr := DecodeString(bodystr);
  while TRUE do
  begin
    if bodystr = '' then
      break;
    bodystr := GetValidStr3(bodystr, data, ['/']);
    if data <> '' then
    begin
      new(pc);
      DecodeBuffer(data, @(pc^), sizeof(TClientItem));
      MenuItemList.Add(pc);
    end
    else
      break;
  end;

  with FrmDlg do
  begin
      //clear shop menu list
    for i := 0 to MenuItemList.Count - 1 do
    begin
      new(pcg);
      pcg.Name := PTClientItem(MenuItemList[i]).S.Name;
      pcg.SubMenu := 0;
      pcg.Price := PTClientItem(MenuItemList[i]).DuraMax;
      pcg.Stock := PTClientItem(MenuItemList[i]).MakeIndex;
      pcg.Grade := Round(PTClientItem(MenuItemList[i]).Dura / 1000);
      MenuList.Add(pcg);
    end;
    FrmDlg.ShowShopMenuDlg;
    FrmDlg.BoDetailMenu := TRUE;
    FrmDlg.MenuTopLine := topline;
  end;
end;

procedure TFrmMain.ClientGetSendNotice(body: string);
var
  data, msgstr: string;
begin
  DoFastFadeOut := FALSE;
  msgstr := '';
  body := DecodeString(body);
  while TRUE do
  begin
    if body = '' then
      break;
    body := GetValidStr3(body, data, [#27]);
    msgstr := msgstr + data + '\';
  end;
  FrmDlg.DialogSize := 2;
  gAutoRun := False;
  if FrmDlg.DMessageDlg(msgstr, [mbOk]) = mrOk then
  begin
    SendClientMessage(CM_LOGINNOTICEOK, 0, 0, 0, 0);
  end;
end;

procedure TFrmMain.ClientGetGroupMembers(bodystr: string);
var
  memb: string;
  actor: TActor;
  i: integer;
begin
  GroupMembers.Clear;

  try
    for i := 0 to GroupIdList.Count - 1 do
    begin
      actor := PlayScene.FindActor(integer(GroupIdList[i]));
      if actor <> nil then
        actor.BoOpenHealth := False;
    end;
    GroupIdList.Clear; // MonOpenHp
  except
  end;

  while TRUE do
  begin
    if bodystr = '' then
      break;
    bodystr := GetValidStr3(bodystr, memb, ['/']);
    if memb <> '' then
      GroupMembers.Add(memb)
    else
      break;
  end;
end;

procedure TFrmMain.ClientGetOpenGuildDlg(bodystr: string);
var
  str, data, linestr, s1: string;
  pstep: integer;
begin
  str := DecodeString(bodystr);
  str := GetValidStr3(str, FrmDlg.Guild, [#13]);
  str := GetValidStr3(str, FrmDlg.GuildFlag, [#13]);
  str := GetValidStr3(str, data, [#13]);
  if data = '1' then
    FrmDlg.GuildCommanderMode := TRUE
  else
    FrmDlg.GuildCommanderMode := FALSE;

  FrmDlg.GuildStrs.Clear;
  FrmDlg.GuildNotice.Clear;
  pstep := 0;
  while TRUE do
  begin
    if str = '' then
      break;
    str := GetValidStr3(str, data, [#13]);
    if data = '<Notice>' then
    begin
      FrmDlg.GuildStrs.AddObject(char(7) + '公告', TObject(clWhite));
      FrmDlg.GuildStrs.Add(' ');
      pstep := 1;
      continue;
    end;
    if data = '<KillGuilds>' then
    begin
      FrmDlg.GuildStrs.Add(' ');
      FrmDlg.GuildStrs.AddObject(char(7) + '敌对行会', TObject(clWhite));
      FrmDlg.GuildStrs.Add(' ');
      pstep := 2;
      linestr := '';
      continue;
    end;
    if data = '<AllyGuilds>' then
    begin
      if linestr <> '' then
        FrmDlg.GuildStrs.Add(linestr);
      linestr := '';
      FrmDlg.GuildStrs.Add(' ');
      FrmDlg.GuildStrs.AddObject(char(7) + '联盟行会', TObject(clWhite));
      FrmDlg.GuildStrs.Add(' ');
      pstep := 3;
      continue;
    end;

    if pstep = 1 then
      FrmDlg.GuildNotice.Add(data);

    if data <> '' then
    begin
      if data[1] = '<' then
      begin
        ArrestStringEx(data, '<', '>', s1);
        if s1 <> '' then
        begin
          FrmDlg.GuildStrs.Add(' ');
          FrmDlg.GuildStrs.AddObject(char(7) + s1, TObject(clWhite));
          FrmDlg.GuildStrs.Add(' ');
          continue;
        end;
      end;
    end;
    if (pstep = 2) or (pstep = 3) then
    begin
      if Length(linestr) > 80 then
      begin
        FrmDlg.GuildStrs.Add(linestr);
        linestr := '';
        linestr := linestr + fmstr(data, 18);
      end
      else
      begin
        linestr := linestr + fmstr(data, 18);
      end;
      continue;
    end;

    FrmDlg.GuildStrs.Add(data);
  end;

  if linestr <> '' then
    FrmDlg.GuildStrs.Add(linestr);

  FrmDlg.ShowGuildDlg;
end;

procedure TFrmMain.ClientGetSendGuildMemberList(body: string);
var
  str, data, rankname, members: string;
  rank: integer;
begin
  str := DecodeString(body);
  FrmDlg.GuildStrs.Clear;
  FrmDlg.GuildMembers.Clear;
  rank := 0;
  while TRUE do
  begin
    if str = '' then
      break;
    str := GetValidStr3(str, data, ['/']);
    if data <> '' then
    begin
      if data[1] = '#' then
      begin
        rank := Str_ToInt(Copy(data, 2, Length(data) - 1), 0);
        continue;
      end;
      if data[1] = '*' then
      begin
        if members <> '' then
          FrmDlg.GuildStrs.Add(members);
        rankname := Copy(data, 2, Length(data) - 1);
        members := '';
        FrmDlg.GuildStrs.Add(' ');
        if FrmDlg.GuildCommanderMode then
          FrmDlg.GuildStrs.AddObject(fmStr('(' + IntToStr(rank) + ')', 3) + '<' + rankname + '>', TObject(clWhite))
        else
          FrmDlg.GuildStrs.AddObject('<' + rankname + '>', TObject(clWhite));
        FrmDlg.GuildMembers.Add('#' + IntToStr(rank) + ' <' + rankname + '>');
        continue;
      end;

      if Length(members) > 80 then
      begin
        FrmDlg.GuildStrs.Add(members);
        members := '';
      end;

      members := members + FmStr(data, 18);
      FrmDlg.GuildMembers.Add(data);
    end;
  end;
  if members <> '' then
    FrmDlg.GuildStrs.Add(members);

end;

procedure TFrmMain.MinTimerTimer(Sender: TObject); //原为1000毫秒执行一次
var                                                //现改为500毫秒执行一次
  i: integer;                                      //不影响整体性能 2019-02-19
  timertime: longword;
  
  TempType: TSafeZone; //2019-02-19
begin



  with PlayScene do
    for i := 0 to ActorList.Count - 1 do
    begin
      if IsGroupMember(TActor(ActorList[i]).UserName) then //检测对象是否队员
      begin
        TActor(ActorList[i]).Grouped := TRUE;
      end
      else
        TActor(ActorList[i]).Grouped := FALSE;
    end;
  for i := FreeActorList.Count - 1 downto 0 do //释放对象资源
  begin
    if GetTickCount - TActor(FreeActorList[i]).DeleteTime > 60000 then
    begin
      TActor(FreeActorList[i]).Free;
      FreeActorList.Delete(i);
    end;
  end;

  if MySelf <> nil then begin //每500毫秒执行一次 2019-02-19
    for I := 0 to High(SafeZoneFromM2) do begin
      TempType := SafeZoneFromM2[i]; //取出
      
      if (CompareText(TempMapTitle, TempType.sMapName) = 0)  then begin //前地Dc主地DΡ
        if (Abs(myself.XX - TempType.nX) < TempType.nRange)
          and (Abs(myself.YY - TempType.nY) < TempType.nRange) then begin
          MapTitle := TempType.sMapName2; //城名字
          Break;
          end else //不在范围内，则地图名字不变。
          MapTitle := TempMapTitle;
      end;
    end;
  if (ConnectionStep = cnsPlay) and (GetTickCount - g_dwSendGetPinTick > 1000 * 2) then begin
    g_dwSendGetPinTick := GetTickCount;
    g_dwReceiveGetPinTick := 0;
    SendGetPing();
  end;


  end;
  if g_boAutoTalk then
  begin
    if (GetTickCount - g_nAutoTalkTimer) > 60000 then   //自动喊话的时间设置
    begin
      SendSay(g_sAutoTalkStr);
      g_nAutoTalkTimer := GetTickCount;
    end;
  end;
  ShowDuraWarning;
end;

procedure TFrmMain.SendGetPing;
var
  Msg: TDefaultMessage;
begin
  Msg := MakeDefaultMsg(CM_PING,0,0,0,0);
  SendSocket(EncodeMessage(Msg));
end;

procedure TFrmMain.ClientGetPing;
begin
  g_dwReceiveGetPinTick := GetTickCount;
  g_nPing := g_dwReceiveGetPinTick -  g_dwSendGetPinTick;
end;

procedure TFrmMain.CheckHackTimerTimer(Sender: TObject);
//const
//   busy: boolean = FALSE;
//检测隐藏工具
  function CheckHideToolz(sCaption: string): Boolean;
  const
    SE_Shell_TrayWnd_NAME = 'Shell_TrayWnd';
    SE_TrayNotifyWnd_NAME = 'TrayNotifyWnd';
    SE_SysPager_NAME = 'SysPager';
    SE_ToolbarWindow32_NAME = 'ToolbarWindow32';
  var
    ToolBarHnd: Cardinal;
    hProc: HWND;
    dwPID: DWORD;
    lpCommon: Pointer;
    btnInfo: TTBBUTTON;
    dwBytes: NativeUInt;
    TrayIconCaption: array[0..512] of char;
    i, nBtnCount: Integer;
  begin
    Result := False;
    ToolBarHnd := FindWindowEx(0, 0, SE_Shell_TrayWnd_NAME, nil);
    ToolBarHnd := FindWindowEx(ToolBarHnd, 0, SE_TrayNotifyWnd_NAME, nil);
    ToolBarHnd := FindWindowEx(ToolBarHnd, 0, SE_SysPager_NAME, nil);
    ToolBarHnd := FindWindowEx(ToolBarHnd, 0, SE_ToolbarWindow32_NAME, nil);
    if ToolBarHnd = 0 then
    begin
      Result := True;
      Exit;
    end;
    GetWindowThreadProcessId(ToolBarHnd, @dwPID);
    hProc := OpenProcess(PROCESS_VM_OPERATION or PROCESS_VM_READ or PROCESS_VM_WRITE, false, dwPID);
    lpCommon := VirtualAllocEx(hProc, nil, 4096, MEM_RESERVE or MEM_COMMIT, PAGE_READWRITE);
    nBtnCount := SendMessage(ToolBarHnd, TB_BUTTONCOUNT, 0, 0);
    for i := 0 to nBtnCount do
    begin

      ZeroMemory(@btnInfo, sizeof(btnInfo));
      WriteProcessMemory(hProc, lpCommon, @btnInfo, sizeof(btnInfo), dwBytes);
      SendMessage(ToolBarHnd, TB_GETBUTTON, i, LPARAM(lpCommon));
      ReadProcessMemory(hProc, lpCommon, @btnInfo, sizeof(btnInfo), dwBytes);
      SendMessage(ToolBarHnd, TB_GETBUTTONTEXT, btnInfo.idCommand, LPARAM(LPARAM(lpCommon) + sizeof(btnInfo)));
      ReadProcessMemory(hProc, Pointer(LPARAM(lpCommon) + Sizeof(btnInfo)), @TrayIconCaption, 512, dwBytes);
      OutputDebugString(TrayIconCaption);
      if SameText(TrayIconCaption, sCaption) then
      begin
        Result := True;
        Break;
      end;
    end;
    VirtualFreeEx(hProc, lpCommon, 0, MEM_RELEASE);
    CloseHandle(hProc);
  end;

//检测调试
  function IsSlefRemoteDebuggerPresent(): Boolean;
  var
    Func_Addr: Pointer;
    hModule: Cardinal;
    pDebugBool: PBool;
  begin
    result := False;
    hModule := GetModuleHandle(kernel32);
    if hModule = INVALID_HANDLE_VALUE then
      Exit;
    Func_addr := GetProcAddress(hModule, 'CheckRemoteDebuggerPresent');
    if (Func_addr <> nil) then
    begin
      asm
        lea     eax, pDebugBool
        push    eax
        push    $ffffffff
        call    Func_addr
        cmp     dword ptr[pDebugBool], 0
        jne     @IsDebug
        jmp     @exit

@IsDebug:
        mov     @result, 1

@exit:
      end;
    end;
  end;

//检测是否被HOOK
  function IsSlefApiHook(): Boolean;
  const
    wsock32  = 'wsock32.dll';
  var
    PNum: Pointer;
    lpBuffer: pByte;
    lpNumberOfBytesRead: NativeUInt;
    DllHandle: Cardinal;
  begin
    DllHandle := LoadLibrary(wsock32);
    lpBuffer := AllocMem(4);
    try
      PNum := GetProcAddress(DllHandle, 'recv');
      ReadProcessMemory(GetCurrentProcess(), pnum, lpBuffer, 4, lpNumberOfBytesRead);
      if (IntToHex(lpBuffer^, 4) = '008B') or (IntToHex(lpBuffer^, 4) = '0055') then
        Result := False
      else
        Result := True;
    finally
      FreeMem(lpBuffer);
    end;
  end;
var
  Filename: string;
  msg: TDefaultMessage;
//   ahour, amin, asec, amsec: word;
//   tcount, timertime: longword;
begin
  Filename := ExtractFileName(Application.Exename);
  if CheckHideToolz(Filename) or IsSlefRemoteDebuggerPresent or IsSlefApiHook then
  begin
    msg := MakeDefaultMsg(CM_CHECKHACK, 0, 0, 0, 0);
    SendSocket(EncodeMessage(msg));
    CSocket.Close;
    FrmDlg.DMessageDlg('你正在使用非法外挂，请关闭外挂后再进入游戏.', [mbOk]);   //经典关闭可能的外挂误报  20220302
    FrmMain.Close;
  end;
end;

procedure TFrmMain.CheckMapView;
var P:TPoint;
    ARect:TRect;
begin
  g_ShowMiniMapXY:=False;
  if BoDrawMiniMap and (ViewMiniMapStyle>0) then
     begin
        P.X := g_MouseX;
        P.Y := g_MouseY;
        ARect:=Rect(g_FScreenWidth-g_MinMapWidth,0,g_FScreenWidth,g_MinMapWidth);
        g_ShowMiniMapXY:=types.PtInRect(ARect, P);
     end;
end;

function TFrmMain.CheckPtInMinMap(X, Y: Integer): Boolean;
var Pt:TPoint;
    ARect:TRect;
begin
  if ViewMiniMapStyle>0 then
     begin
        Pt:=Point(X,Y);
        ARect:=Rect(g_FScreenWidth-g_MinMapWidth,0,g_FScreenWidth,g_MinMapWidth);
        Result:=types.PtInRect(ARect,Pt);
     end
     else
     Result:=False;
end;

(**
const
   busy: boolean = FALSE;
var
   ahour, amin, asec, amsec: word;
   timertime, tcount: longword;
begin
   if busy then exit;
   busy := TRUE;
   DecodeTime (Time, ahour, amin, asec, amsec);
   timertime := amin * 1000 * 60 + asec * 1000 + amsec;
   tcount := GetTickCount;

   //DScreen.AddSysMsg (IntToStr(tcount - FirstClientGetTime) + ' ' +
   //                   IntToStr(timertime - FirstClientTimerTime) + ' ' +
   //                   IntToStr(abs(tcount - FirstClientGetTime) - abs(timertime - FirstClientTimerTime)));

   if FirstClientTimerTime = 0 then begin
      FirstClientTimerTime := timertime;
      FirstClientGetTime := tcount;
   end else begin
      if (abs(timertime - LatestClientTimerTime) > 2000) or
         (timertime < LatestClientGetTime)
      then begin
         FirstClientTimerTime := timertime;
         FirstClientGetTime := tcount;
      end;
      if abs(abs(tcount - FirstClientGetTime) - abs(timertime - FirstClientTimerTime)) > 2000 then begin
         Inc (TimeFakeDetectSum);
         if TimeFakeDetectSum > 10 then begin
            //矫埃 炼累...
            SendSpeedHackUser;
            FrmDlg.DMessageDlg ('作为黑客程序使用者被记录在案。\' +
                             '使用这种程序是违法的。\' +
                             '而且请注意，你可能会受到类似帐户查封等惩罚。\' +
                             '[询问] mir2master@wemade.com\' +
                             '程序将被终止。', [mbOk]);
            FrmMain.Close;
         end;
      end else
         TimeFakeDetectSum := 0;
      LatestClientTimerTime := timertime;
      LatestClientGetTime := tcount;
   end;
   busy := FALSE;
end;
//**)

procedure TFrmMain.ClientGetDealRemoteAddItem(body: string);
var
  ci: TClientItem;
begin
  if body <> '' then
  begin
    DecodeBuffer(body, @ci, sizeof(TClientItem));
    AddDealRemoteItem(ci);
  end;
end;

procedure TFrmMain.ClientGetDealRemoteDelItem(body: string);
var
  ci: TClientItem;
begin
  if body <> '' then
  begin
    DecodeBuffer(body, @ci, sizeof(TClientItem));
    DelDealRemoteItem(ci);
  end;
end;

procedure TFrmMain.ClientGetReadMiniMap(mapindex: integer);
begin
  if mapindex >= 1 then
  begin
    BoDrawMiniMap := True;
      if BoWantMiniMap then
      begin
//         if PrevVMMStyle < 1 then
//            PrevVMMStyle := 1;
//         ViewMiniMapStyle := PrevVMMStyle;
      end;
    MiniMapIndex := mapindex - 1;
  end;
end;

procedure TFrmMain.ClientGetChangeGuildName(body: string);
var
  str: string;
begin
  str := GetValidStr3(body, GuildName, ['/']);
  GuildRankName := Trim(str);
end;

procedure TFrmMain.ClientGetSendUserState(body: string);
var
  ustate: TUserStateInfo;
begin
  DecodeBuffer(body, @ustate, sizeof(TUserStateInfo));
  ustate.NameColor := GetRGB(ustate.NameColor);
  FrmDlg.OpenUserState(ustate);
end;

procedure TFrmMain.SendTimeTimerTimer(Sender: TObject);
var
  tcount: longword;
begin
//   tcount := GetTickCount;
//   SendClientMessage (CM_CLIENT_CHECKTIME, tcount, Loword(LatestClientGetTime), Hiword(LatestClientGetTime), 0);
//   LastestClientGetTime := tcount;
end;

function TFrmMain.IsMyMember(name: string): Boolean;
var
  i: integer;
begin
  Result := false;
   // 在朋友中搜索
  for i := FriendMembers.Count - 1 downto 0 do
  begin
    if PTFriend(FriendMembers[i]).CharID = name then
    begin
      Result := true;
      Exit;
    end;
  end;

   // Black List 搜索
  for i := BlackMembers.Count - 1 downto 0 do
  begin
    if PTFriend(BlackMembers[i]).CharID = name then
    begin
      Result := true;
      Exit;
    end;
  end;

end;

// 2003/04/15 朋友，注意
procedure TFrmMain.ClientGetDelFriend(msg: TDefaultMessage; body: string);
var
  i: integer;
  str: string;
  keep: boolean;
begin
  str := DecodeString(body);
  keep := TRUE;
   // 在朋友中搜索
  for i := FriendMembers.Count - 1 downto 0 do
  begin
    if PTFriend(FriendMembers[i]).CharID = str then
    begin
      Dispose(PTFriend(FriendMembers[i]));
      FriendMembers.Delete(i);
      keep := FALSE;
      break;
    end;
  end;

   // 在朋友中搜索
   // Black List 搜索
  for i := BlackMembers.Count - 1 downto 0 do
  begin
    if PTFriend(BlackMembers[i]).CharID = str then
    begin
      Dispose(PTFriend(BlackMembers[i]));
      BlackMembers.Delete(i);
      keep := FALSE;
      break;
    end;
  end;


   // Block List搜索
  if keep then
  begin
    for i := BlockLists.Count - 1 downto 0 do
    begin
      if BlockLists[i] = str then
      begin
        BlockLists.Delete(i);
        keep := FALSE;
        break;
      end;
    end;
  end;

  RecalcOnlinUserCount;

end;

procedure TFrmMain.RecalcOnlinUserCount;
var
  i: integer;
begin
  ConnectFriend := 0;
  for i := 0 to FriendMembers.Count - 1 do
  begin
    if PTFriend(FriendMembers[i]).Status >= 4 then
      inc(ConnectFriend);
  end;

  ConnectBlack := 0;
  for i := 0 to BlackMembers.Count - 1 do
  begin
    if PTFriend(BlackMembers[i]).Status >= 4 then
      inc(ConnectBlack);
  end;

end;

procedure TFrmMain.ClientGetUserInfo(msg: TDefaultMessage; body: string);
var
  i, j: integer;
  str, fname, fmapinfo: string;
  fstatus: integer;
  keep: boolean;
  fr: PTFriend;
begin
//   DScreen.AddSysMsg('SM_USER_INFO(BODY):'+body);
  str := DecodeString(body);
//   DScreen.AddSysMsg('SM_USER_INFO:'+str);

  fstatus := msg.param;
  fmapinfo := GetValidStr3(str, fname, ['/']);

   // 从朋友那里检查
  for i := FriendMembers.Count - 1 downto 0 do
  begin
    if PTFriend(FriendMembers[i]).CharID = fname then
    begin
      PTFriend(FriendMembers[i]).Status := fstatus;
      break;
    end;
  end;

   // 关系不好的检查
  for i := BlackMembers.Count - 1 downto 0 do
  begin
    if PTFriend(BlackMembers[i]).CharID = fname then
    begin
      PTFriend(BlackMembers[i]).Status := fstatus;
      break;
    end;
  end;

  RecalcOnlinUserCount;
end;

procedure TFrmMain.ClientFriendSort(var datalist: TList; firstname: string);
var
  i, j: integer;
  firstpt, temppt: pointer;
begin
    // 当有不止一只狗时，它就变成了一种。
  if (datalist = nil) or (datalist.count < 2) then
    Exit;

  firstpt := nil;

    // 我删除了我必须放入的第一件事。
  if (firstname <> '') then
  begin
    for i := 0 to datalist.count - 1 do
    begin
      if (PTFriend(datalist[i]).CharID = firstname) then
      begin
        firstpt := datalist[i];
        datalist.Delete(i);
        break;
      end;
    end;
  end;

    // 如果数字大于 2
  if datalist.count >= 2 then
  begin
    for i := 0 to datalist.count - 2 do
    begin
      for j := i + 1 to datalist.count - 1 do
      begin
        if PTFriend(datalist[i]).CharID > PTFriend(datalist[j]).CharID then
        begin
          temppt := datalist[i];
          datalist[i] := datalist[j];
          datalist[j] := temppt;
        end;
      end;
    end;
  end;

    // 一开始都会放进去
  if firstpt <> nil then
  begin
    datalist.Insert(0, firstpt);
  end;

end;

procedure TFrmMain.ClientGetFriendInfo(msg: TDefaultMessage; body: string);
var
  i, j: integer;
  str, fname, fmemo: string;
  ftype, fstatus: integer;
  keep: boolean;
  fr: PTFriend;
begin
//   DScreen.AddSysMsg('SM_FRIEND_INFO(BODY):'+body);
  str := DecodeString(body);
//   DScreen.AddSysMsg('SM_FRIEND_INFO:'+str);

   //str := GetValidStr3 (str, ftype, [' ']);
   //str := GetValidStr3 (str, fstatus, [' ']);
  ftype := msg.param;
  fstatus := msg.tag;
  fmemo := GetValidStr3(str, fname, ['/']);

  i := ftype;
  case i of
    RT_FRIENDS:
      begin
        keep := TRUE;
            // 在朋友中搜索
        for i := FriendMembers.Count - 1 downto 0 do
        begin
          if PTFriend(FriendMembers[i]).CharID = fname then
          begin
            PTFriend(FriendMembers[i]).Status := fstatus;
            PTFriend(FriendMembers[i]).Memo := fmemo;
            keep := FALSE;
            break;
          end;
        end;
        if keep then
        begin
          new(fr);
          fr.CharID := fname;
          fr.Status := fstatus;
          fr.Memo := fmemo;
          FriendMembers.Add(fr);
        end;

        ClientFriendSort(FriendMembers, flover.GetName(RsState_Lover));
      end;
    RT_BLACKLIST:
      begin
        keep := TRUE;
            // 在朋友中搜索
        for i := BlackMembers.Count - 1 downto 0 do
        begin
          if PTFriend(BlackMembers[i]).CharID = fname then
          begin
            PTFriend(BlackMembers[i]).Status := fstatus;
            PTFriend(BlackMembers[i]).Memo := fmemo;
            keep := FALSE;
            break;
          end;
        end;
        if keep then
        begin
          new(fr);
          fr.CharID := fname;
          fr.Status := fstatus;
          fr.Memo := fmemo;
          BlackMembers.Add(fr);
        end;

        ClientFriendSort(BlackMembers, '');
      end;
    RT_LOVERS:
      begin
      end;
    RT_MASTER:
      begin
      end;
    RT_DISCIPLE:
      begin
      end;
  end;

  RecalcOnlinUserCount
end;

procedure TFrmMain.ClientGetFriendResult(msg: TDefaultMessage; body: string);
var
  i: integer;
  str, fcmd, ferr, fname: string;
  keep: boolean;
  fr: PTFriend;
begin
  str := DecodeString(body);
  ferr := GetValidStr3(str, fcmd, [' ']);
  i := StrToInt(ferr);
  case i of
    CR_FAIL:
      DScreen.AddChatBoardString('请求的操作失败，原因是未知的错误。', clWhite, clRed);
    CR_DONTFINDUSER:
      DScreen.AddChatBoardString('字符名称不能被发现。', clWhite, clRed);
    CR_DONTADD:
      DScreen.AddChatBoardString('增加失败。', clWhite, clRed);
    CR_DONTDELETE:
      DScreen.AddChatBoardString('删除失败。', clWhite, clRed);
    CR_DONTUPDATE:
      DScreen.AddChatBoardString('修改失败。', clWhite, clRed);
    CR_DONTACCESS:
      DScreen.AddChatBoardString('信息是不可访问。', clWhite, clRed);
    CR_LISTISMAX:
      DScreen.AddChatBoardString('最大允许的人数已经超过。', clWhite, clRed);
    CR_LISTISMIN:
      DScreen.AddChatBoardString('最小允许的人数已经达到。', clWhite, clRed);
  end;
end;

procedure TFrmMain.ClientGetTagAlarm(msg: TDefaultMessage; body: string);
var
  notreadcount: integer;
begin
//     DScreen.AddSysMsg('SM_TAG_ARLARM:');
  notreadcount := msg.Param;
  if (notreadcount > 0) then
  begin
    DScreen.AddChatBoardString('你收到了新邮件！', clWhite, clRed);
    MailAlarm := true;
  end;

end;

procedure TFrmMain.RecalcNotReadCount;
var
  i: integer;
begin
     // 刷新未读个数
  NotReadMailCount := 0;
  for i := 0 to MailLists.Count - 1 do
  begin
    if (pTMail(MailLists[i]).Status = 0) then
      inc(NotReadMailCount);
  end;

end;

procedure TFrmMain.ClientGetTagList(msg: TDefaultMessage; body: string);
var
  i: integer;
  str: string;
  MailStr: string;
  StateStr: string;
  DateStr: string;
  SenderStr: string;
  TotalCount: integer;
  PageCount: integer;
  pMail: pTMail;
begin
  str := DecodeString(body);
//   DScreen.AddSysMsg('SM_TAG_LIST:'+str);

  PageCount := msg.Param;
  TotalCount := msg.Tag;

  pMail := nil;
  for i := 0 to TotalCount - 1 do
  begin
    str := GetValidStr3(str, MailStr, ['/']);
    MailStr := GetValidStr3(MailStr, StateStr, [':']);
    MailStr := GetValidStr3(MailStr, DateStr, [':']);
    MailStr := GetValidStr3(MailStr, SenderStr, [':']);

    new(pMail);

    pMail^.Sender := SenderStr;
    pMail^.Date := DateStr;
    pMail^.Mail := MailStr;
    pMail^.Status := Str_ToInt(StateStr, 0);

    MailLists.Insert(0, pMail);
  end;

  RecalcNotReadCount;
end;

procedure TFrmMain.ClientGetTagInfo(msg: TDefaultMessage; body: string);
var
  str: string;
  i: integer;
  Status: integer;
begin
  str := DecodeString(body);
  Status := msg.Param;

//   DScreen.AddSysMsg('SM_TAG_INFO:'+str + IntToStr(Status));
  for i := 0 to MailLists.Count - 1 do
  begin
    if pTMail(MailLists[i]).Date = str then
    begin
      // 删除时删除
      if Status = 3 then
      begin
        dispose(MailLists[i]);
        MailLists.Delete(i);
      end
      else
        pTMail(MailLists[i]).Status := Status;

      break;
    end;
  end;
  RecalcNotReadCount;
end;

procedure TFrmMain.ClientGetTagRejectList(msg: TDefaultMessage; body: string);
var
  i: integer;
  str: string;
  RejectStr: string;
  RejectCount: Integer;
begin

  str := DecodeString(body);
//   DScreen.AddSysMsg('SM_TAG_REJECT_LIST:'+str);

  RejectCount := msg.Param;

  for i := 0 to RejectCount - 1 do
  begin
    str := GetValidStr3(str, RejectStr, ['/']);
    BlockLists.Add(RejectStr);
  end;

end;

procedure TFrmMain.ClientGetTagRejectAdd(msg: TDefaultMessage; body: string);
var
  str: string;
begin
  str := DecodeString(body);
//   DScreen.AddSysMsg('SM_TAG_REJECT_ADD:'+str);

  BlockLists.Add(str);

end;

procedure TFrmMain.ClientGetTagRejectDelete(msg: TDefaultMessage; body: string);
var
  str: string;
  i: integer;
begin
  str := DecodeString(body);
//   DScreen.AddSysMsg('SM_TAG_REJECT_DELETE:'+str);

  for i := 0 to BlockLists.Count - 1 do
  begin
    if (BlockLists[i] = str) then
    begin
      BlockLists.Delete(i);
      break;
    end;
  end
end;

procedure TFrmMain.ClientGetTagResult(msg: TDefaultMessage; body: string);
begin

end;

procedure TFrmMain.ClientGetLMList(msg: TDefaultMessage; body: string);
var
  _state: integer;
  _level: integer;
  _Sex: integer;
  _Date: string;
  _ServerDate: string;
  _Name: string;
  _MapInfo: string;
  count, i: integer;
  str: string;
  infostr: string;
  temp: string;
begin
  str := DecodeString(body);
  count := msg.Param;
//     DScreen.AddSysmsg ('SM_LM_LIST:'+intToStr(count)+','+str);
//  DScreen.AddChatBoardString ('SM_LM_LIST:'+intToStr(count)+','+str, clWhite, clGreen);
  for i := 0 to count - 1 do begin
    str := GetValidStr3(str, infostr, ['/']);
    if infostr <> '' then begin
      infostr := GetValidStr3(infostr, temp, [':']);
      _state := Str_ToInt(temp, 0);
      infostr := GetValidStr3(infostr, _Name, [':']);
      infostr := GetValidStr3(infostr, temp, [':']);
      _level := Str_ToInt(temp, 1);
      infostr := GetValidStr3(infostr, temp, [':']);
      _Sex := Str_ToInt(temp, 0);
      infostr := GetValidStr3(infostr, _Date, [':']);
      infostr := GetValidStr3(infostr, _ServerDate, [':']);
      infostr := GetValidStr3(infostr, _MapInfo, [':']);

      case _state of
        RsState_Lover :
        begin
//          DScreen.AddChatBoardString (_Name+' '+_MapInfo+'', clWhite, clGreen);
          fLover.Add(MySelf.UserName, _Name, _state, _level, _Sex, _Date, _ServerDate, _MapInfo);
          ClientFriendSort(FriendMembers, flover.GetName(RsState_Lover));
        end;
        RsState_Master :
        begin
//          DScreen.AddChatBoardString (_Name+' '+_MapInfo+'', clWhite, clGreen);
          fMaster.Add(MySelf.UserName, _Name, _state, _level, _Sex, _Date, _ServerDate, _MapInfo);
//          ClientFriendSort(FriendMembers, fMaster.GetName(RsState_Master));


        end;
        RsState_Pupil :
        begin
//          DScreen.AddChatBoardString (_Name+' '+_MapInfo+'', clWhite, clGreen);
          fPupil.Add(MySelf.UserName, _Name, _state, _level, _Sex, _Date, _ServerDate, _MapInfo);
//          ClientFriendSort(FriendMembers, fPupil.GetName(RsState_Pupil));

        end;
      end;

//            if _MapInfo <> '' then
//            begin
//                DScreen.AddChatBoardString (_Name+'丛捞 '+_MapInfo+'俊 拌绞聪促.', clWhite, clGreen);
//            end;
    end;
  end;
end;

procedure TFrmMain.ClientGetLMOptionChange(msg: TDefaultMessage);
var
  optiontype, enable: integer;
begin
  optiontype := msg.Param;
  enable := msg.Tag;
  case optiontype of
    1:
      begin
        fLover.SetEnable(rsState_Lover, enable);
//        if enable = 1 then
//          DScreen.AddChatBoardString('[允许结婚]', clRed, clWhite)
//        else
//          DScreen.AddChatBoardString('[拒绝结婚]', clRed, clWhite);
      end;
  end;
     // DScreen.AddSysmsg ('SM_LM_OPTION:'+IntToStr( optiontype) + ','+ IntToStr( enable));

end;

procedure TFrmMain.ClientGetLMRequest(msg: TDefaultMessage; body: string);
var
  str: string;
  ReqType: integer;
  ReqSeq: integer;
begin
  str := DecodeString(body);
  ReqType := msg.Param;
  ReqSeq := msg.Tag;

  case ReqType of
    RsState_Lover:
      begin
        case ReqSeq of
          RsReq_WhoWantJoin:
            begin
              if mrYes = FrmDlg.DMessageDlg(str + ' 正在向你发送结婚请求。\请问你愿意和他(她)结为合法夫妻吗？', [mbYes, mbNo]) then
                SendLMRequest(ReqType, RsReq_AloowJoin)
              else
                SendLMRequest(ReqType, RsReq_DenyJoin);

            end;
        end;
      end;
    RsState_Master:
      begin
        case ReqSeq of
          RsReq_WhoWantJoin:
            begin
              if mrYes = FrmDlg.DMessageDlg('提示：['+str+'] 请求与你成为师徒关系！\一旦师徒关系建立，强制脱离将支付100,000金币费用！\你确定要建立师徒关系吗？', [mbYes, mbNo]) then
                SendLMRequest(RsState_Pupil, RsReq_AloowJoin)
              else
                SendLMRequest(RsState_Pupil, RsReq_DenyJoin);
            end;
          50: begin
            FrmDlg.DMessageDlg('提示：['+str+'] 不允许收徒！', [mbYes]);
          end;
        end;
      end;
    RsState_Pupil:
      begin
        case ReqSeq of
          RsReq_WhoWantJoin:
            begin
              if mrYes = FrmDlg.DMessageDlg('提示：['+str+'] 请求与你成为师徒关系！\一旦师徒关系建立，强制脱离将支付100,000金币费用！\你确定要建立师徒关系吗？', [mbYes, mbNo]) then
                SendLMRequest(RsState_Master, RsReq_AloowJoin)
              else
                SendLMRequest(RsState_Master, RsReq_DenyJoin);
            end;
          50: begin
            FrmDlg.DMessageDlg('提示：['+str+'] 不允许拜师！', [mbYes]);
          end;
        end;
      end;
  end;

//   DScreen.AddSysmsg ('SM_LM_REQUEST:'+IntToStr( msg.param) + ','+IntToStr( msg.Tag) + ','+ str);
end;

procedure TFrmMain.ClientGetLMResult(msg: TDefaultMessage; body: string);
var
  str: string;
  reqtype: integer;
  errcode: integer;
  sName, sMinLevel, sMaxLevel: string;
begin
  str := DecodeString(body);
  reqtype := msg.Param;
  errcode := msg.Tag;

  case reqtype of
    RsState_Lover:
      begin
        case errcode of
          RsError_SuccessJoin: //= 1;         // 参加成功了 ( 曼啊茄荤恩率)
            begin
//                FrmDlg.DMessageDlg (str+'丛苞 楷牢捞 登菌嚼聪促.', [mbYes]);
              FrmDlg.AddFriend(str, false);
              PlaySound(154);
            end;
          RsError_SuccessJoined: //= 2;         // 参加成功了 ( 曼啊等 荤恩率)
            begin
//                FrmDlg.DMessageDlg (str+'丛捞 背力甫 倾遏窍咯 楷牢捞 登菌嚼聪促.', [mbYes]);
              FrmDlg.AddFriend(str, false);
              PlaySound(154);
            end;
          RsError_DontJoin: //= 3;         // 曼啊且 荐 绝促
//            FrmDlg.JustMessageDlg (str+' 决定是否要结婚吗？', [mbOK]);
            FrmDlg.DMessageDlg(str + '决定是否要结婚吗？', [mbOK]);
          RsError_DontLeave: //= 4;         // 栋朝荐 绝促.
            FrmDlg.DMessageDlg(str + '你破坏不了我们的关系。', [mbOK]);
          RsError_RejectMe: //= 5;         // 芭何惑怕捞促
            FrmDlg.DMessageDlg('您目前没有允许情侣关系。\请点击选择允许情侣关系按钮。', [mbOK]);
          RsError_RejectOther: //= 6;         // 芭何惑怕捞促
            FrmDlg.DMessageDlg(str + '目前未允许情侣关系。', [mbOK]);
          RsError_LessLevelMe: //= 7;         // 唱狼饭骇捞 撤促
            FrmDlg.DMessageDlg('只有22级或更高的等级才可以邀请情侣关系。', [mbOK]);
          RsError_LessLevelOther: //= 8;         // 惑措规狼饭骇捞 撤促
            FrmDlg.DMessageDlg(str + '必须22级或以上才可以接婚。', [mbOK]);
          RsError_EqualSex: //= 9;         // 己喊捞 鞍促
            FrmDlg.DMessageDlg('两个相同性别不允许情侣关系。', [mbOK]);
          RsError_FullUser: //= 10;        // 曼咯牢盔捞 啊垫谩促
            FrmDlg.DMessageDlg(str + '已经结婚，因此无法再次结婚', [mbOK]);
          RsError_CancelJoin: //= 11;        // 曼啊秒家
            DScreen.AddChatBoardString('求婚被拒绝。', clGreen, clWhite);
          RsError_DenyJoin: //= 12;        // 曼啊甫 芭例窃
            FrmDlg.DMessageDlg(str + '拒绝了你的求婚。', [mbOK]);
          RsError_DontDelete: //= 13;        // 呕硼矫懦荐 绝促.
            FrmDlg.DMessageDlg(str + '摧毁不了我们的关系。', [mbOK]);
          RsError_SuccessDelete: //= 14;        // 呕硼矫淖澜
            begin
              PlaySound(155);
              FrmDlg.DMessageDlg('[提示]：你 与 ['+str+'] 的婚姻已被宣布解散！', [mbOK]);
            end;
          RsError_NotRelationShip: //= 15;        // 背力惑怕啊 酒聪促.
            FrmDlg.DMessageDlg('你目前已经是已婚人士了.', [mbOK]);
        end;
      end;
    RsState_Master:
      begin
        case errcode of
          RsError_LessLevelMe:begin
            str := GetValidStr3(str, sMinLevel, ['/']);
            str := GetValidStr3(str, sMaxLevel, ['/']);

            FrmDlg.DMessageDlg('提示：只有 ['+sMinLevel+'] 级到 ['+sMaxLevel+'] 级才可以拜师！', [mbOK]);
          end;
          RsError_LessLevelOther:begin
            str := GetValidStr3(str, sName, ['/']);
            FrmDlg.DMessageDlg('提示：['+sName+'] 要作为师傅，必须在 ['+str+'] 级或者 ['+str+'] 级以上！', [mbOK]);
          end;
          RsError_FullUser:
            FrmDlg.DMessageDlg('提示：['+str+'] 收的徒弟数量已经满了，不能再收徒了！', [mbOK]);
          RsError_SuccessDelete:
            begin
              PlaySound(155);
              FrmDlg.DMessageDlg('提示：你已经和 ['+str+'] 脱离师徒关系！', [mbOK]);
            end;
          RsError_CancelJoin:
            DScreen.AddChatBoardString('提示：建立师徒关系的邀请已经取消了！', clGreen, clWhite);
          RsError_DenyJoin:
            FrmDlg.DMessageDlg('提示：['+str+'] 拒绝了您建立师徒关系的请求！', [mbOK]); //提示这个么
          RsError_RelationShip:
            FrmDlg.DMessageDlg('提示：['+str+'] 已经是你的师傅，请不要重复请求拜师！', [mbOK]);
        end;
      end;
    RsState_Pupil:
      begin
        case errcode of
          RsError_LessLevelMe:
            FrmDlg.DMessageDlg('提示：只有 ['+str+'] 级或 ['+str+'] 级以上的才可以收徒！', [mbOK]);
          RsError_LessLevelOther:begin
            str := GetValidStr3(str, sName, ['/']);
            str := GetValidStr3(str, sMinLevel, ['/']);
            str := GetValidStr3(str, sMaxLevel, ['/']);
            FrmDlg.DMessageDlg('提示：['+sName+'] 要作为徒弟，必须在 ['+sMinLevel+'] 级到 ['+sMaxLevel+'] 级！', [mbOK]);
          end;
          RsError_FullUser:
            FrmDlg.DMessageDlg('提示：['+str+'] 已经拜师，不能重复拜师！', [mbOK]);
          RsError_SuccessDelete:
            begin
              PlaySound(155);
              FrmDlg.DMessageDlg('提示： [' + str + '] 已经和你脱离师徒关系！', [mbOK]);
            end;
          RsError_CancelJoin:
            DScreen.AddChatBoardString('提示：建立师徒关系的邀请已经取消了！', clGreen, clWhite);
          RsError_DenyJoin:
            FrmDlg.DMessageDlg('提示：['+str+'] 拒绝了您建立师徒关系的请求！', [mbOK]);
          RsError_RelationShip:
            FrmDlg.DMessageDlg('提示：['+str+'] 已经是你的徒弟，请不要重复请求收徒！', [mbOK]);
        end;
      end;
  end;

     // DScreen.AddSysmsg ('SM_LM_RESULT:'+IntToStr( msg.param) + ','+IntToStr( msg.Tag) + ','+ str);
end;

procedure TFrmMain.ClientGetLMDelete(msg: TDefaultMessage; body: string);
var
  str: string;
  ReqType: integer;
begin
  str := DecodeString(body);
  ReqType := msg.Param;
  case ReqType of
    RsState_Lover: fLover.Delete(str);
    RsState_Master: fMaster.Delete(str);
    RsState_Pupil: fPupil.Delete(str);
  end;;
end;

procedure TFrmMain.SendAddFriend(data: string; FriendType: integer);
var
  msg: TDefaultMessage;
begin
//   DScreen.AddSysMsg('CM_FRIEND_ADD:'+data);
   // TO DO , FRIEND = 1 (wparam ) , BLACKLIST = 8
  msg := MakeDefaultMsg(CM_FRIEND_ADD, 0, FriendType, 0, 0);
  SendSocket(EncodeMessage(msg) + EncodeString(data));
end;

procedure TFrmMain.SendAddReject(data: string);
var
  msg: TDefaultMessage;
begin
//   DScreen.AddSysMsg('CM_TAG_REJECT_ADD:'+data);
  msg := MakeDefaultMsg(CM_TAG_REJECT_ADD, 0, 0, 0, 0);
  SendSocket(EncodeMessage(msg) + EncodeString(data));
end;

procedure TFrmMain.SendDelReject(data: string);
var
  msg: TDefaultMessage;
begin
//   DScreen.AddSysMsg('CM_TAG_REJECT_DELETE:'+data);
  msg := MakeDefaultMsg(CM_TAG_REJECT_DELETE, 0, 0, 0, 0);
  SendSocket(EncodeMessage(msg) + EncodeString(data));
end;

procedure TFrmMain.SendLMOptionChange(OptionType: integer; Enable: integer);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_LM_OPTION, OptionType, Enable, 0, 0);
  SendSocket(EncodeMessage(msg));
end;

procedure TFrmMain.SendLMRequest(ReqType: integer; ReqSeq: integer);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_LM_REQUEST, ReqType, ReqSeq, 0, 0);
  SendSocket(EncodeMessage(msg));
end;

procedure TFrmMain.SendRufuseMaster(ReqType: integer; ReqSeq: integer);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_RufuseMaster, 0, 0, 0, 0);
  SendSocket(EncodeMessage(msg));
end;

procedure TFrmMain.SendLMSeparate(ReqType: integer; data: string);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_LM_DELETE, ReqType, 0, 0, 0);
  SendSocket(EncodeMessage(msg) + EncodeString(data));
end;

procedure TFrmMain.SendDeath(targetid: Integer);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_DEATH_FALL, targetid, 0, 0, 0);
  SendSocket(EncodeMessage(msg));
end;

procedure TFrmMain.SendDelFriend(data: string);
var
  msg: TDefaultMessage;
begin
//   DScreen.AddSysMsg('CM_FRIEND_DELETE:'+data);
  msg := MakeDefaultMsg(CM_FRIEND_DELETE, 0, 0, 0, 0);
  SendSocket(EncodeMessage(msg) + EncodeString(data));
end;

procedure TFrmMain.SendMail(data: string);
var
  msg: TDefaultMessage;
begin
  if frmDlg.BoMemoJangwon then
  begin
    msg := MakeDefaultMsg(CM_GUILDAGIT_TAG_ADD, 0, 0, 0, 0);
    frmDlg.BoMemoJangwon := False;
  end
  else
    msg := MakeDefaultMsg(CM_TAG_ADD, 0, 0, 0, 0);
  SendSocket(EncodeMessage(msg) + EncodeString(data));
end;

procedure TFrmMain.SendReadingMail(data: string);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_TAG_SETINFO, 0, 1, 0, 0);
  SendSocket(EncodeMessage(msg) + EncodeString(data));
end;

procedure TFrmMain.SendDelMail(data: string);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_TAG_DELETE, 0, 0, 0, 0);
  SendSocket(EncodeMessage(msg) + EncodeString(data));
end;

procedure TFrmMain.SendLockMail(data: string);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_TAG_SETINFO, 0, 2, 0, 0);
  SendSocket(EncodeMessage(msg) + EncodeString(data));
end;

procedure TFrmMain.SendUnLockMail(data: string);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_TAG_SETINFO, 0, 3, 0, 0);
  SendSocket(EncodeMessage(msg) + EncodeString(data));
end;

procedure TFrmMain.SendMailList;
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_TAG_LIST, 0, 0, 0, 0);
  SendSocket(EncodeMessage(msg));
end;

procedure TFrmMain.SendRejectList;
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_TAG_REJECT_LIST, 0, 0, 0, 0);
  SendSocket(EncodeMessage(msg));
end;

procedure TFrmMain.SendUpdateFriend(data: string);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(CM_FRIEND_EDIT, 0, 0, 0, 0);
  SendSocket(EncodeMessage(msg) + EncodeString(data));
end;

procedure TFrmMain.DelitemProg;
begin
  DelItemBag(DelTempItem.S.Name, DelTempItem.MakeIndex);
end;

procedure TFrmMain.RunEffectTimerTimer(Sender: TObject);
var
  tx, ty, n, kx, ky, i: integer;
  bofly: Boolean;
begin

  tx := Myself.XX;
  ty := Myself.YY;

  Randomize;
  RunEffectTimer.Tag := RunEffectTimer.Tag + 1;
  n := random(4);
  kx := random(5) + 1;
  ky := random(4) + 1;
  if RunEffectTimer.Tag > 1000000 then
    RunEffectTimer.Tag := 1000;

  if EffectNum = 1 then
  begin
    case random(5) of
      0:
        RunEffectTimer.Interval := 400;
      1:
        RunEffectTimer.Interval := 600;
      2:
        RunEffectTimer.Interval := 800;
      3:
        RunEffectTimer.Interval := 1000;
      4:
        RunEffectTimer.Interval := 1500;
    end;

    case n of
      0:
        if Map.CanMove(tx + kx, ty - ky) then
          PlayScene.NewMagic(nil, MAGIC_DUN_THUNDER, MAGIC_DUN_THUNDER, tx + kx, ty - ky, tx + kx, ty - ky, 0, mtThunder, FALSE, 30, bofly);
      1:
        if Map.CanMove(tx - kx, ty + ky) then
          PlayScene.NewMagic(nil, MAGIC_DUN_THUNDER, MAGIC_DUN_THUNDER, tx - kx, ty + ky, tx - kx, ty + ky, 0, mtThunder, FALSE, 30, bofly);
      2:
        if Map.CanMove(tx - kx, ty - ky) then
          PlayScene.NewMagic(nil, MAGIC_DUN_THUNDER, MAGIC_DUN_THUNDER, tx - kx, ty - ky, tx - kx, ty - ky, 0, mtThunder, FALSE, 30, bofly);
      3:
        if Map.CanMove(tx + kx, ty + ky) then
          PlayScene.NewMagic(nil, MAGIC_DUN_THUNDER, MAGIC_DUN_THUNDER, tx + kx, ty + ky, tx + kx, ty + ky, 0, mtThunder, FALSE, 30, bofly);
    end;
    PlaySound(8301);

  end
  else if EffectNum = 2 then
  begin
    case random(RunEffectTimer.Tag) mod 5 of
      0:
        RunEffectTimer.Interval := 1000;
      1:
        RunEffectTimer.Interval := 1500;
      2:
        RunEffectTimer.Interval := 2000;
      3:
        RunEffectTimer.Interval := 2500;
      4:
        RunEffectTimer.Interval := 3000;
    end;

    case n of
      0:
        if Map.CanMove(tx + kx, ty - ky) then
        begin
          PlayScene.NewMagic(nil, MAGIC_DUN_FIRE1, MAGIC_DUN_FIRE1, tx + kx, ty - ky, tx + kx, ty - ky, 0, mtThunder, FALSE, 30, bofly);
          PlayScene.NewMagic(nil, MAGIC_DUN_FIRE2, MAGIC_DUN_FIRE2, tx + kx, ty - ky, tx + kx, ty - ky, 0, mtThunder, FALSE, 30, bofly);
        end;
      1:
        if Map.CanMove(tx - kx, ty + ky) then
        begin
          PlayScene.NewMagic(nil, MAGIC_DUN_FIRE1, MAGIC_DUN_FIRE1, tx - kx, ty + ky, tx - kx, ty + ky, 0, mtThunder, FALSE, 30, bofly);
          PlayScene.NewMagic(nil, MAGIC_DUN_FIRE2, MAGIC_DUN_FIRE2, tx - kx, ty + ky, tx - kx, ty + ky, 0, mtThunder, FALSE, 30, bofly);
        end;
      2:
        if Map.CanMove(tx - kx, ty - ky) then
        begin
          PlayScene.NewMagic(nil, MAGIC_DUN_FIRE1, MAGIC_DUN_FIRE1, tx - kx, ty - ky, tx - kx, ty - ky, 0, mtThunder, FALSE, 30, bofly);
          PlayScene.NewMagic(nil, MAGIC_DUN_FIRE2, MAGIC_DUN_FIRE2, tx - kx, ty - ky, tx - kx, ty - ky, 0, mtThunder, FALSE, 30, bofly);
        end;
      3:
        if Map.CanMove(tx + kx, ty + ky) then
        begin
          PlayScene.NewMagic(nil, MAGIC_DUN_FIRE1, MAGIC_DUN_FIRE1, tx + kx, ty + ky, tx + kx, ty + ky, 0, mtThunder, FALSE, 30, bofly);
          PlayScene.NewMagic(nil, MAGIC_DUN_FIRE2, MAGIC_DUN_FIRE2, tx + kx, ty + ky, tx + kx, ty + ky, 0, mtThunder, FALSE, 30, bofly);
        end;
    end;
    PlaySound(8302);
  end;

end;

procedure TFrmMain.RunTimerTimer(Sender: TObject);
begin
  if GetTickCount - FCheckLibTime > CHECK_FREE_TEXTURE_INTERVAL then
  begin
    LibManager.FreeMemory;
    FontManager.FreeIdleMemory;
    FCheckLibTime := GetTickCount;
  end;
end;

procedure TFrmMain.MainCancelItemMoving;
begin
  FrmDlg.CancelItemMoving;
end;

procedure TFrmMain.FormKeyUp(Sender: TObject; var Key: Word; Shift: TShiftState);
var
  TempStr: string;
begin
  if ConnectionStep = cnsPlay then begin
    if Key = VK_CONTROL then boWhisperLen := False;
    if (ssCtrl in Shift) then boWhisperLen := False;
    if (ssShift in Shift) then
    begin
      if g_NgConfigInfo.boNotNeedShift then
        if not g_boShiftUp then
        begin
          g_boShiftUp := True;
          exit;
        end;
    end;
    case Key of
      VK_SHIFT:
        begin
          if g_NgConfigInfo.boNotNeedShift then
            if not g_boShiftUp then
            begin
              g_boShiftOff := not g_boShiftOff;
              if g_boShiftOff then
                TempStr := '自动Shift开'
              else
                TempStr := '自动Shift关';
              DScreen.AddChatBoardString(TempStr, clWhite, clBlue);
              g_boShiftUp := True;
            end;
        end;
      VK_TAB:
      begin
          FrmDlg.DBotMiniMapClick(nil, 0, 0);
        if ViewMiniMapStyle=2 then
           g_MinMapWidth:=200
           else
           g_MinMapWidth:=120;
          CheckMapView;
      end;

      VK_UP:
        if (ssCtrl in Shift) and FrmDlg.DEdChat.Visible then begin
          if g_SendSayListIdx > 0 then
            Dec(g_SendSayListIdx);
          if g_SendSayListIdx < g_SendSayList.count then
            FrmDlg.DEdChat.Text := g_SendSayList[g_SendSayListIdx];
          Key := 0;
        end;
      VK_DOWN:
        if (ssCtrl in Shift) and FrmDlg.DEdChat.Visible then begin
          if g_SendSayListIdx < g_SendSayList.count - 1 then
            Inc(g_SendSayListIdx);
          if g_SendSayListIdx < g_SendSayList.count then
            FrmDlg.DEdChat.Text := g_SendSayList[g_SendSayListIdx];
          Key := 0;
        end;
    end;
    case Key of              //ESC
      VK_ESCAPE:
        begin
          if not g_boMirNg then
            SendPickup;
          TabClickTime := GetTickCount;
        end;
    end;
  end;
end;

procedure TFrmMain.FormShow(Sender: TObject);
begin
//  ShowWindow(application.Handle, SW_HIDE);
end;

procedure TFrmMain.AppOnIdle(Sender: TObject; var Done: Boolean);
var
  CanDraw: Boolean;
  t, t2: DWORD;
  LagCount: Integer;
  I: Integer;
begin
  Done := TRUE;
  if (not NativeAsphyreConnect.Init()) then
    Exit;
  if (Assigned(g_GameDevice)) and (g_GameDevice.IsAtFault()) then
  begin
    if (not FailureHandled) then
      HandleConnectFailure();
    FailureHandled := True;
    Exit;
  end;
  if (not Assigned(g_GameDevice)) or (not g_GameDevice.Connect()) then
    Exit;

  if not g_LogoHide then
  begin
    Sleep(1500);
    ImageLogo.Visible := False;
    Color := clBlack;
    g_LogoHide := True;
    if not DoFadeOut and not DoFadeIn then begin
      DoFadeIn := True;
      FadeIndex := 0;
    end;
    Exit;
  end;

  if GetTickCount - g_ProcOnIdleTick >= 5 then
  begin
    if MySelf <> nil then begin
      PlayScene.ProcessObecjts;      //这个是处理所有OBJ事件 一切物体和魔法效果的
    end;
    ProcessActionMessages;
    ProcessKeyMessages;
    g_ProcOnIdleTick := GetTickCount;
  end;

  if GetTickCount - g_ProcOnDrawTick >= 5 then
  begin
    DScreen.BeginDrawScreen(g_GameDevice, g_GameCanvas);
//    if DScreen.CurrentScene = PlayScene then begin
//      g_GameDevice.RenderTo(PlayScene.DrawObjects, 0, True, PlayScene.ObjSurface);
//      g_GameDevice.RenderTo(PlayScene.LightSurface, 0, True, PlayScene.LigSurface);
//    end;

    g_GameCanvas.ResetStates;
    g_GameDevice.Render(RenderEvent, 0);
    g_GameCanvas.Flush;
    g_ProcOnDrawTick := GetTickCount;
  end;
  Sleep(1);
end;

procedure TfrmMain.FullScreen(boFull: Boolean);
begin
  if g_boFullScreen <> boFull then begin

    application.ProcessMessages;
    g_boFullScreen := boFull;
    if g_boFullScreen then begin
      DisplayChange(False);
      
      BorderStyle := bsNone;
      BorderIcons := [];

      ClientWidth := g_GameDevice.SwapChains.Items[0].Width;
      ClientHeight := g_GameDevice.SwapChains.Items[0].Height;
      WindowState := wsMaximized;

      m_Point.X := 0;
      m_Point.Y := 0;
    end else begin
      DisplayChange(True);

      BorderStyle := bsSingle;
      FormStyle := fsNormal;
      WindowState := wsNormal;
      ClientWidth := g_GameDevice.SwapChains.Items[0].Width;
      ClientHeight := g_GameDevice.SwapChains.Items[0].Height;
      BorderIcons := [biSystemMenu, biMinimize];
      Left := (Screen.width - ClientWidth) div 2;
      Top := (Screen.Height - ClientHeight) div 2 - 40;
      SetWindowPos(handle, HWND_NOTOPMOST, left, top, width, height, SWP_SHOWWINDOW);
    end;
    Tag := 0;
  end;

end;

procedure TfrmMain.OnAsphyreCreate(Sender: TObject; Param: Pointer;
  var Handled: Boolean);
begin
  g_GameDevice := Factory.CreateDevice();
  g_GameCanvas := Factory.CreateCanvas();
  FontManager.OnGetTextExtent := DoGetTextExtent;
end;

procedure TfrmMain.OnAsphyreDestroy(Sender: TObject; Param: Pointer;
  var Handled: Boolean);
begin
  FreeAndNilEx(g_GameCanvas);
  FreeAndNilEx(g_GameDevice);
end;

procedure TfrmMain.OnDeviceInit(Sender: TObject; Param: Pointer;
  var Handled: Boolean);
begin
  g_DisplaySize := Point2px(g_FScreenWidth, g_FScreenHeight);
  g_GameDevice.SwapChains.RemoveAll;
  g_GameDevice.SwapChains.Add(Self.Handle, g_DisplaySize, 0, False,
    TAsphyrePixelFormat.apf_A8R8G8B8);

  if g_boFullScreen then begin
//    DisplayChange(False);
    BorderStyle := bsNone;
    BorderIcons := [];
    if (Screen.MonitorCount > 1) then
    begin
      Left := Screen.Monitors[MonitorsID].Left;
      Top := Screen.Monitors[MonitorsID].Top;
      Width := Screen.Monitors[MonitorsID].Width;
      Height := Screen.Monitors[MonitorsID].Height;
    end else begin
      Left := 0;
      Top := 0;
    end;

    WindowState := wsMaximized;
    ClientWidth := g_FScreenWidth;
    ClientHeight := g_FScreenHeight;
//    DisplayChange(False);
  end else begin
    FrmMain.BorderStyle := bsSingle;
    ClientWidth := g_FScreenWidth;
    ClientHeight := g_FScreenHeight;
  end;
end;

procedure TfrmMain.OnDeviceCreate(Sender: TObject; Param: Pointer;
  var Handled: Boolean);
begin
  if BoFirstTime then
  begin
    LoadWMImagesLib();
    InitWMImagesLib();
    DScreen.Initialize;
    LoginScene.Initialize;
    PlayScene.Initialize;
    FrmDlg.Initialize;
    LoadLightImages();
    BoFirstTime := False;

    if g_boFullScreen then begin
      m_Point.X := 0;
      m_Point.Y := 0;
    end;
    g_boForceMapDraw := True;
    MinTimer.Enabled := True;
    CSocket.Active := TRUE;
  end;
end;

procedure TfrmMain.OnDeviceDestroy(Sender: TObject; Param: Pointer;
  var Handled: Boolean);
begin
  FontManager.Finalize;
  UnLoadLightImages();

  if not BoFirstTime and not FAppTerminated then
  begin
    DScreen.Finalize;
    PlayScene.Finalize;
    UnLoadWMImagesLib;
    BoFirstTime := True;
  end;
end;

procedure TfrmMain.OnDeviceReset(Sender: TObject; Param: Pointer;
  var Handled: Boolean);
begin
end;

procedure TfrmMain.OnDeviceLost(Sender: TObject; Param: Pointer;
  var Handled: Boolean);
begin
end;


procedure TfrmMain.RenderEvent(Sender: TObject);
var
  d, ATexture: TAsphyreLockableTexture;
  p: TPoint;
  h: THandle;
  b: Boolean;
  Actor: TActor;
  I: Integer;
begin
  if DScreen.CurrentScene = PlayScene then begin
    if PlayScene.ObjSurface.BeginDrawTo then
    try
      PlayScene.PlayScene(g_GameCanvas);
      g_GameCanvas.Draw(0, 0, PlayScene.ObjSurface);
    finally
      PlayScene.ObjSurface.EndDrawTo;
    end;

    if PlayScene.LigSurface.BeginDrawTo then
    try
      PlayScene.LightSurface(g_GameCanvas);
      g_GameCanvas.Draw(0, 0, PlayScene.LigSurface);
    finally
      PlayScene.LigSurface.EndDrawTo;
    end;
  end;

  DScreen.DrawScreen(g_GameCanvas);
  g_DWinMan.DirectPaint(g_GameCanvas);
  DScreen.DrawScreenTop(g_GameCanvas);
  DScreen.DrawHint(g_GameCanvas);
{$ifdef debug}
  if (DefDControl <> nil)  and (DefDControl.Visible) then
  begin
    with DefDControl do
    begin
      g_GameCanvas.FrameRect(Bounds(SurfaceX(Left), SurfaceY(Top), Width, Height), clLime);
    end;
  end;
{$endif}

  if ItemMoving then begin
    if (MovingItem.Item.S.Name <> '金币') then
      d := WBagItem.Images[MovingItem.Item.S.Looks]
    else
      d := WBagItem.Images[115]; //金钱形状
    if d <> nil then begin
      GetCursorPos(p);
      p.X := p.X - m_Point.X;
      p.Y := p.Y - m_Point.Y;
      g_GameCanvas.Draw(p.x - (d.ClientRect.Right div 2), p.y - (d.ClientRect.Bottom div 2), d.ClientRect, d, TRUE);

      if (MovingItem.Item.S.OverlapItem > 0) and (MovingItem.Item.S.Name <> '金币') then begin
        g_GameCanvas.TextOut(p.x + 9, p.y + 3, clYellow, IntToStr(MovingItem.Item.Dura));
      end;
    end;
  end;

  if DoFadeOut then begin
    if FadeIndex < 1 then FadeIndex := 1;

    MakeDark(g_GameCanvas, FadeIndex);
    if FadeIndex <= 1 then
      DoFadeOut := False
    else
      Dec(FadeIndex, 2);
  end else if DoFadeIn then begin
    if FadeIndex > 29 then
      FadeIndex := 29;

    MakeDark(g_GameCanvas, FadeIndex);
    if FadeIndex >= 29 then
      DoFadeIn := False
    else
      Inc(FadeIndex, 1);
  end else if DoFastFadeOut then begin
    if FadeIndex < 1 then
      FadeIndex := 1;
    MakeDark(g_GameCanvas, FadeIndex);
    if FadeIndex > 1 then
      Dec(FadeIndex, 4);
  end;

  if (not g_boMirDark) and (not ViewFog) then begin
   case DayBright of
    0:        //早上
      if DScreen.CurrentScene = PlayScene then
      begin
        if BackSoundLoopTime + 150000 < GetTickcount then
        begin
          if Random(2) = 1 then
          begin
            PlaySound(153);
//      DScreen.AddChatBoardString ('PlaySound 111 '+InttoStr(GetTickcount), clYellow, clRed);
            BackSoundLoopTime := GetTickcount;
          end
        end;
        if BackSoundLoopTime + 90000 < GetTickcount then
        begin
          if Random(20) = 3 then
          begin
            PlaySound(153);
//      DScreen.AddChatBoardString ('PlaySound 222 '+InttoStr(GetTickcount), clYellow, clRed);
            BackSoundLoopTime := GetTickcount;
          end;
        end;
        if BackSoundLoopTime + 50000 < GetTickcount then
        begin
          if Random(3000) in [12, 23] then
          begin
            PlaySound(153);
            BackSoundLoopTime := GetTickcount;
//         DScreen.AddChatBoardString ('PlaySound 333 '+InttoStr(GetTickcount), clYellow, clRed);
          end;
        end;
      end;
    1:          //白天
      if DScreen.CurrentScene = PlayScene then
      begin
        if BackSoundLoopTime + 150000 < GetTickcount then
        begin
          if Random(2) = 1 then
          begin
            PlaySound(153);
//      DScreen.AddChatBoardString ('PlaySound 111 '+InttoStr(GetTickcount), clYellow, clRed);
            BackSoundLoopTime := GetTickcount;
          end
        end;
        if BackSoundLoopTime + 90000 < GetTickcount then
        begin
          if Random(20) = 3 then
          begin
            PlaySound(153);
//      DScreen.AddChatBoardString ('PlaySound 222 '+InttoStr(GetTickcount), clYellow, clRed);
            BackSoundLoopTime := GetTickcount;
          end;
        end;
        if BackSoundLoopTime + 50000 < GetTickcount then
        begin
          if Random(3000) in [12, 23] then
          begin
            PlaySound(153);
            BackSoundLoopTime := GetTickcount;
//         DScreen.AddChatBoardString ('PlaySound 333 '+InttoStr(GetTickcount), clYellow, clRed);
          end;
        end;
      end;
    2:             //傍晚
      if DScreen.CurrentScene = PlayScene then
      begin
        if BackSoundLoopTime + 150000 < GetTickcount then
        begin
          if Random(2) = 1 then
          begin
            PlaySound(153);
//      DScreen.AddChatBoardString ('PlaySound 111 '+InttoStr(GetTickcount), clYellow, clRed);
            BackSoundLoopTime := GetTickcount;
          end
        end;
        if BackSoundLoopTime + 90000 < GetTickcount then
        begin
          if Random(20) = 3 then
          begin
            PlaySound(153);
//      DScreen.AddChatBoardString ('PlaySound 222 '+InttoStr(GetTickcount), clYellow, clRed);
            BackSoundLoopTime := GetTickcount;
          end;
        end;
        if BackSoundLoopTime + 50000 < GetTickcount then
        begin
          if Random(3000) in [12, 23] then
          begin
            PlaySound(153);
            BackSoundLoopTime := GetTickcount;
//         DScreen.AddChatBoardString ('PlaySound 333 '+InttoStr(GetTickcount), clYellow, clRed);
          end;
        end;
      end;
   end;
  end;
end;

procedure TfrmMain.HandleConnectFailure();
begin
end;

procedure TfrmMain.DoGetTextHeight(const Text: String; Font: TFont;
  var Value: Integer);
var
  ASize: TSize;
begin
  DoGetTextExtent(Text, Font, ASize);
  Value := ASize.cy;
end;

procedure TfrmMain.DoGetTextWidth(const Text: String; Font: TFont;
  var Value: Integer);
var
  ASize: TSize;
begin
  DoGetTextExtent(Text, Font, ASize);
  Value := ASize.cx;
end;

procedure TfrmMain.DoGetTextExtent(const Text: string; Font: TFont;
  var Value: TSize);
begin
  Canvas.Font.Assign(Font);
  Value.cx := 0;
  Value.cy := 0;
  Windows.GetTextExtentPoint32(Canvas.Handle, Text, Length(Text), Value);
end;

procedure TFrmMain.DisplayChange(boReset: Boolean);
var
  nWidth, nHeight: Integer;
begin
  if boReset then begin
    if FboDisplayChange then begin
      FormStyle := fsNormal;
      FIDDraw := nil;
      if FDDrawHandle > 0 then
        FreeLibrary(FDDrawHandle);
      FDDrawHandle := 0;
      FboDisplayChange := False;
      UnRegisterHotKey(Handle, FHotKeyId);
    end;
  end else begin
    if not FboDisplayChange then begin
      FormStyle := fsStayOnTop;
      nWidth := g_FScreenWidth;
      nHeight := g_FScreenHeight;

      FIDDraw := nil;
      if FDDrawHandle > 0 then
        FreeLibrary(FDDrawHandle);
      FDDrawHandle := LoadLibrary('DDraw.dll');

      if DD_OK = TDirectDrawCreate(GetProcAddress(FDDrawHandle, 'DirectDrawCreate'))(nil, FIDDraw, nil) then begin
        if DD_OK = FIDDraw.SetDisplayMode(nWidth, nHeight, 32) then begin          // WIN10 16改32
          FboDisplayChange := True;
          FHotKeyId := GlobalAddAtom('361ClientKey') - $C000;
          RegisterHotKey(Handle, FHotKeyId, MOD_ALT, VK_TAB);
        end;
      end;
    end;
  end;
end;

procedure TfrmMain.WMMove(var Message: TWMMove);
begin
  m_Point := ClientOrigin;
  inherited;
end;

procedure TfrmMain.WMHotKey(var Msg: Tmessage);
begin
  if (Msg.LparamLo = MOD_ALT) and (Msg.LParamHi = VK_TAB) then begin
    PostMessage(FrmMain.Handle, WM_SYSCOMMAND, SC_MINIMIZE, 0);
  end;
end;

procedure TFrmMain.FormCloseQuery(Sender: TObject; var CanClose: Boolean);
VAR
ini: TIniFile;
begin
  CanClose := FALSE;
  if g_bo战斗退出 then
  begin
    if ConnectionStep = cnsPlay then  begin
      if mrOk = FrmDlg.DMessageDlg('您确定要关闭传奇吗？', [mbOk, mbCancel]) then
    begin
       SaveNgInfo;
       Application.Terminate;
       CanClose := True;
    end;
    end else begin
       CanClose := True;
    end;
  end;
    if not g_bo战斗退出 then
  begin
    if (GetTickCount - LatestStruckTime > 10000) and
       (GetTickCount - LatestMagicTime > 10000) and
       (GetTickCount - LatestHitTime > 10000)
    or (Myself.Death) then
    begin
       if ConnectionStep = cnsPlay then  begin
        if mrOk = FrmDlg.DMessageDlg('您确定要关闭传奇吗？', [mbOk, mbCancel]) then
       begin
         SaveNgInfo;
         Application.Terminate;
         CanClose := True;
       end;
       end else begin
         CanClose := True;
       end;
    end
    else
      DScreen.AddChatBoardString('在战斗的时候你不能退出游戏', clYellow, clRed);



  end;
end;

procedure TFrmMain.TurnDuFu(pcm: PTClientMagic);
var
  s: TClientItem;
  Str,str1: string;
  i,index: Integer;
  RedDu, LimeDu, HuFu: Boolean;
begin
  RedDu := False;
  LimeDu := False;
  HuFu := False;
  //检查包裹里有什么毒
  if WaitingUseItem.Item.S.Name <> '' then Exit;
for I := 6 to MAXBAGITEMCL - 1 do
begin
  if (ItemArr[i].S.StdMode = 25) and (ItemArr[i].S.Name <> '') then
  begin
    if ItemArr[i].S.Shape = 1 then
    begin
      if g_bo自动换毒 then
        LimeDu := True
    end
    else if ItemArr[i].S.Shape = 2 then
    begin
      if g_bo自动换毒 then
        RedDu := True
    end
    else if ItemArr[i].S.Shape = 5 then
      if g_bo自动换符 then
        HuFu := True;
  end;
end;
  if g_bo人物四格 and g_bochksigedu then
  begin
     case pcm.Def.MagicId of
      6: index:=U_CHARM;
 //       6: index:=U_BUJUK;
        else index := U_BUJUK;
      end;
  end else

    if g_bo人物四格 and not g_bochksigedu then
  begin
     case pcm.Def.MagicId of
//      6: index:=U_CHARM;
        6: index:=U_BUJUK;
        else index := U_BUJUK;
      end;
  end else

    index:=U_ARMRINGL;
  s := UseItems[Index];
  if not LimeDu and not RedDu and not HuFu then Exit;
  //if not g_NgConfigInfo.boAutoHld then  Exit;
  if (pcm.Def.MagicId = 6) or (pcm.Def.MagicId = 38) then begin
    Str := '药';
    if (LimeDu) and (RedDu) and (g_NgConfigInfo.boAutoHld) then begin //如果2种毒都存在
      if g_nDuwhich=0 then begin
        str1:='黄';
        g_nDuwhich:=1;
      end else if g_NgConfigInfo.boAutoHld  then begin
        str1:='灰';
        g_nDuwhich:=0;
      end
    end else begin
      if (LimeDu) and (g_NgConfigInfo.boAutoHld) then begin
        str1:='灰';
        g_nDuwhich:=0;
      end else if (RedDu) and (g_NgConfigInfo.boAutoHld) then begin
        str1:='黄';
        g_nDuwhich:=1;
      end;
    end;

       if (LimeDu) and (g_NgConfigInfo.boAutoJld) then begin
        str1:='灰';
        g_nDuwhich:=0;
      end;

      if (RedDu) and (not g_NgConfigInfo.boAutoJld) and (not g_NgConfigInfo.boAutoHld) then begin
        str1:='黄';
        g_nDuwhich:=1;
      end;



    if (s.s.StdMode = 25) and (Pos(Str1, s.s.Name) > 0) then Exit; //如果是相同的毒或符就退出

    WaitingUseItem.Index := index;
    for i := 6 to MAXBAGITEMCL - 1 do begin
      if (ItemArr[i].S.StdMode = 25) and (str1 <> '') and (Pos(Str, ItemArr[i].S.Name) > 0)and (Pos(Str1, ItemArr[i].S.Name) > 0) then begin
        SendTakeOnItem(WaitingUseItem.Index ,ItemArr[i].MakeIndex, ItemArr[i].S.Name);
        WaitingUseItem.Item := ItemArr[i];
        ItemArr[i].S.Name := '';
        ArrangeItembag;
        Exit;
      end;
    end;
  end else if (pcm.Def.MagicId in [13, 14, 15, 16, 17, 18, 19, 30, 36, 41, 46, 49]) then begin
    if (s.s.StdMode = 25) and (s.S.Shape = 5) and (s.S.Name <> '') or not g_bo自动换符 then Exit;

    WaitingUseItem.Index := index;
    for i := 6 to MAXBAGITEMCL - 1 do begin
      if (ItemArr[i].s.StdMode = 25) and (ItemArr[i].s.Shape = 5) and (ItemArr[i].s.Name <> '') then begin
        SendTakeOnItem(WaitingUseItem.Index, ItemArr[i].MakeIndex, ItemArr[i].s.Name);
        WaitingUseItem.Item := ItemArr[i];
        ItemArr[i].s.Name := '';
        ArrangeItembag;
        Exit;
      end;
    end;
  end;
end;

procedure TFrmMain.ClientGetServerUnBind(Body: string);
var
  i: integer;
  data: string;
  pcm: pTUnbindInfo;
begin
  if g_UnbindItemList.Count > 0 then //20080629
    for i := 0 to g_UnbindItemList.Count - 1 do
      if pTUnbindInfo(g_UnbindItemList[i]) <> nil then
        Dispose(pTUnbindInfo(g_UnbindItemList[i]));
  g_UnbindItemList.Clear;
  while TRUE do begin
    if Body = '' then
      break;
    Body := GetValidStr3(Body, data, ['/']);
    if data <> '' then begin
      new(pcm);
      DecodeBuffer(data, @(pcm^), sizeof(TUnbindInfo));
      g_UnbindItemList.Add(pcm);
    end
    else
      break;
  end;
end;

procedure TFrmMain.ClientGetAttackMode( mode: byte);
begin
   MySelf.AttackMode := mode;
end;


procedure TfrmMain.CreateParams(var Params: TCreateParams);
  //随机取密码
  function RandomGetPass(): string;
  var
    s, s1: string;
    I, i0: Byte;
  begin
    s := '123456789ABCDEFGHIJKLMNPQRSTUVWXYZ';
    s1 := '';
    Randomize(); //随机种子
    for i := 0 to 8 do begin
      i0 := random(35);
      s1 := s1 + copy(s, i0, 1);
    end;
    Result := s1;
  end;
begin
  inherited CreateParams(Params);
  strpcopy(pchar(@Params.WinClassName), RandomGetPass);
  Params.WndParent := 0; 
  //Params.WinClassName:=mssss;
end;

procedure TfrmMain.ClientGetShopItems(body: string; Int: Integer);
var
  i: Integer;
  data: string;
  pSi: pTShopItem;
begin
  g_btSellType := Int;
  while True do begin
    if body = '' then Break;
    body := GetValidStr3(body, data, ['/']);
    if data <> '' then begin
      New(pSi);
      DecodeBuffer(data, @(pSi^), SizeOf(TShopItem));
      g_ShopListArr[pSi.btclass].Add(pSi);
    end else
      Break;
  end;
end;

end.


unit FState;

interface

uses
  Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,
  StdCtrls, Grids, Grobal2, clFunc, hUtil32, MapUnit, SoundUtil, comobj, DWinCtl,
  AbstractCanvas, AbstractTextures, AsphyreTextureFonts, AsphyreTypes,
  RelationShip, MaketSystem, StallSystem, CnHashTable, Clipbrd, uGameEngine, uCommon;

const
  BOTTOMBOARD = 1;
  BOTTOMBOARD1024 = 2;
  VIEWCHATLINE = 9;
  MAXSTATEPAGE = 4;
  LISTLINEHEIGHT = 13;
  LISTLINEHEIGHT2 = 14;
  MAKETLINEHEIGHT = 19;
  REPLYIMGPOS = 20;
  MAXMENU = 10;
  DECOMAXMENU = 12;
  RING_OF_UNKNOWN = 130;
  BRACELET_OF_UNKNOWN = 131;
  HELMET_OF_UNKNOWN = 132;
  UPITEMSUCCESSOFFSET = 633;

  MAX_FRIEND_COUNT = 20;
  VIEW_FRIEND = 1;
  VIEW_MAILSEND = 2;
  VIEW_MAILREAD = 3;
  VIEW_MEMO = 4;
  AdjustAbilHints: array[0..8] of string = ('攻击力 ', '魔法(魔法师)', '道术(道士)', '防御 ', '魔法防御', '生命值 ', '魔法值', '准确 ', '敏捷 ');
  MAX_GC_ITEMS = 7;

const
  g_sGameConfigPage1=331;
  g_sGameConfigPage2=332;
  g_ptItems_Type: Integer = 0;
type
  TSpotDlgMode = (dmSell, dmRepair, dmStorage, dmMaketSell);

  TClickPoint = record
    rc: TRect;
    RStr: string;
  end;

  PTClickPoint = ^TClickPoint;

  TDiceInfo = record
    DiceResult: integer;
    DiceCurrent: integer;
    DiceLeft, DiceTop: integer;
    DiceCount: integer;
    DiceLimit: integer;
    DiceTime: longword;
  end;

  TClickSLPoint = record
     rc: TRect;
     RStr: string;  //里面有唯一标实
     SStr: string;  //真正内容
  end;
  pTClickSLPoint = ^TClickSLPoint;

  TFrmDlg = class(TForm)
    DBackground: TDWindow;
    DAdjustAbility: TDWindow;
    DPlusDC: TDButton;
    DPlusMC: TDButton;
    DPlusSC: TDButton;
    DPlusAC: TDButton;
    DPlusMAC: TDButton;
    DPlusHP: TDButton;
    DPlusMP: TDButton;
    DPlusHit: TDButton;
    DPlusSpeed: TDButton;
    DMinusDC: TDButton;
    DMinusMC: TDButton;
    DMinusSC: TDButton;
    DMinusAC: TDButton;
    DMinusMAC: TDButton;
    DMinusMP: TDButton;
    DMinusHP: TDButton;
    DMinusHit: TDButton;
    DMinusSpeed: TDButton;
    DAdjustAbilClose: TDButton;
    DAdjustAbilOk: TDButton;
    DBlockListDlg: TDWindow;
    DBlockListClose: TDButton;
    DBLPgUp: TDButton;
    DBLPgDn: TDButton;
    DBLDel: TDButton;
    DBLAdd: TDButton;
    DBottom: TDWindow;
    DChgPw: TDWindow;
    DChgpwOk: TDButton;
    DChgpwCancel: TDButton;
    DCountDlg: TDWindow;
    DCountDlgClose: TDButton;
    DCountDlgMax: TDButton;
    DCountDlgOk: TDButton;
    DCountDlgCancel: TDButton;
    DDealDlg: TDWindow;
    DDGrid: TDGrid;
    DDealOk: TDButton;
    DDealClose: TDButton;
    DDGold: TDButton;
    DDealJangwon: TDWindow;
    DDealRemoteDlg: TDWindow;
    DDRGrid: TDGrid;
    DDRGold: TDButton;
    DFriendDlg: TDWindow;
    DGABoardDlg: TDWindow;
    DGABoardClose: TDButton;
    DGABoardCancel: TDButton;
    DGABoardOk2: TDButton;
    DGABoardReply: TDButton;
    DGABoardDel: TDButton;
    DGABoardMemo: TDButton;
    DGABoardListDlg: TDWindow;
    DGABoardListClose: TDButton;
    DGABoardListNext: TDButton;
    DGABoardListRefresh: TDButton;
    DGABoardListPrev: TDButton;
    DGABoardOk: TDButton;
    DGABoardWrite: TDButton;
    DGABoardNotice: TDButton;
    DGADecorateDlg: TDWindow;
    DGADecorateListNext: TDButton;
    DGADecorateListPrev: TDButton;
    DGADecorateBuy: TDButton;
    DGADecorateCancel: TDButton;
    DGADecorateClose: TDButton;
    DGroupDlg: TDWindow;
    DGrpAllowGroup: TDButton;
    DGrpDlgClose: TDButton;
    DGrpCreate: TDButton;
    DGrpAddMem: TDButton;
    DGrpDelMem: TDButton;
    DGuildDlg: TDWindow;
    DGDHome: TDButton;
    DGDList: TDButton;
    DGDChat: TDButton;
    DGDAddMem: TDButton;
    DGDDelMem: TDButton;
    DGDEditNotice: TDButton;
    DGDEditGrade: TDButton;
    DGDAlly: TDButton;
    DGDBreakAlly: TDButton;
    DGDWar: TDButton;
    DGDCancelWar: TDButton;
    DGDUp: TDButton;
    DGDDown: TDButton;
    DGDClose: TDButton;
    DGuildEditNotice: TDWindow;
    DGEClose: TDButton;
    DGEOk: TDButton;
    DItemBag: TDWindow;
    DGold: TDButton;
    DRepairItem: TDButton;
    DCloseBag: TDButton;
    DItemGrid: TDGrid;
    DItemMarketDlg: TDWindow;
    DItemBuy: TDButton;
    DItemCancel: TDButton;
    DItemFind: TDButton;
    DItemMarketClose: TDButton;
    DItemSellCancel: TDButton;
    DItemListPrev: TDButton;
    DItemListRefresh: TDButton;
    DItemListNext: TDButton;
    DMGold: TDButton;
    DMarketMemo: TDButton;
    DJangwonListDlg: TDWindow;
    DJangwonClose: TDButton;
    DJangListNext: TDButton;
    DJangMemo: TDButton;
    DJangListPrev: TDButton;
    DKeySelDlg: TDWindow;
    DKsIcon: TDButton;
    DKsF1: TDButton;
    DKsF2: TDButton;
    DKsF3: TDButton;
    DKsF4: TDButton;
    DKsNone: TDButton;
    DKsOk: TDButton;
    DKsF5: TDButton;
    DKsF6: TDButton;
    DKsF7: TDButton;
    DKsF8: TDButton;
    DKsConF1: TDButton;
    DKsConF5: TDButton;
    DKsConF2: TDButton;
    DKsConF6: TDButton;
    DKsConF3: TDButton;
    DKsConF7: TDButton;
    DKsConF4: TDButton;
    DKsConF8: TDButton;
    DLogIn: TDWindow;
    DMailDlg: TDWindow;
    DMailOK: TDButton;
    DMailClose: TDButton;
    DMailListDlg: TDWindow;
    DMailListClose: TDButton;
    DMailListPgUp: TDButton;
    DMailListPgDn: TDButton;
    DMLBlock: TDButton;
    DMLLock: TDButton;
    DMLDel: TDButton;
    DMLRead: TDButton;
    DMLReply: TDButton;
    DMakeItemDlg: TDWindow;
    DMakeItemDlgOk: TDButton;
    DMakeItemDlgCancel: TDButton;
    DMakeItemDlgClose: TDButton;
    DMakeitemGrid: TDGrid;
    DMasterDlg: TDWindow;
    DMasterClose: TDButton;
    DMaster3: TDButton;
    DMaster2: TDButton;
    DMaster1: TDButton;
    DMemo: TDWindow;
    DMemoClose: TDButton;
    DMemoB1: TDButton;
    DMemoB2: TDButton;
    DMenuDlg: TDWindow;
    DMenuPrev: TDButton;
    DMenuNext: TDButton;
    DMenuBuy: TDButton;
    DMenuClose: TDButton;
    DMerchantDlg: TDWindow;
    DMerchantDlgClose: TDButton;
    DMsgDlg: TDWindow;
    DNewAccount: TDWindow;
    DNewAccountOk: TDButton;
    DNewAccountClose: TDButton;
    DNewAccountCancel: TDButton;
    DSelectChr: TDWindow;
    DscStart: TDButton;
    DscNewChr: TDButton;
    DscEraseChr: TDButton;
    DscCredits: TDButton;
    DscExit: TDButton;
    DscSelect1: TDButton;
    DscSelect2: TDButton;
    DSellDlg: TDWindow;
    DSellDlgOk: TDButton;
    DSellDlgClose: TDButton;
    DSellDlgSpot: TDButton;
    DSellDlgStHold: TDButton;
    DSellDlgBtnHold: TDButton;
    DSelServerDlg: TDWindow;
    DSSrvClose: TDButton;
    DSServer1: TDButton;
    DSServer2: TDButton;
    DSServer3: TDButton;
    DSServer4: TDButton;
    DSServer5: TDButton;
    DSServer6: TDButton;
    DEngServer1: TDButton;
    DSServer8: TDButton;
    DSServer7: TDButton;
    DStateWin: TDWindow;
    DPrevState: TDButton;
    DCloseState: TDButton;
    DNextState: TDButton;
    DSWNecklace: TDButton;
    DSWLight: TDButton;
    DSWArmRingR: TDButton;
    DSWArmRingL: TDButton;
    DSWRingR: TDButton;
    DSWRingL: TDButton;
    DSWWeapon: TDButton;
    DSWDress: TDButton;
    DSWHelmet: TDButton;
    DStMag1: TDButton;
    DStMag2: TDButton;
    DStMag3: TDButton;
    DStMag4: TDButton;
    DStMag5: TDButton;
    DStPageUp: TDButton;
    DStPageDown: TDButton;
    DSWBujuk: TDButton;
    DSWBelt: TDButton;
    DSWBoots: TDButton;
    DSWCharm: TDButton;
    DHeartImg: TDButton;
    DUserState1: TDWindow;
    DCloseUS1: TDButton;
    DWeaponUS1: TDButton;
    DHelmetUS1: TDButton;
    DNecklaceUS1: TDButton;
    DDressUS1: TDButton;
    DLightUS1: TDButton;
    DArmringRUS1: TDButton;
    DRingRUS1: TDButton;
    DArmringLUS1: TDButton;
    DRingLUS1: TDButton;
    DBujukUS1: TDButton;
    DBeltUS1: TDButton;
    DBootsUS1: TDButton;
    DCharmUS1: TDButton;
    DHeartImgUS: TDButton;
    DCreateChr: TDWindow;
    DMsgSimpleDlg: TDWindow;
    DMsgSimpleDlgOk: TDButton;
    DMsgSimpleDlgCancel: TDButton;
    DWHeroStore: TDWindow;
    DGridStore: TDGrid;
    DBStoreClose: TDButton;
    DButton1: TDButton;
    DWUserStall: TDWindow;
    DGridUserStall: TDGrid;
    DBUserStallBuy: TDButton;
    DBUserStallClose: TDButton;
    DWStoreItemPrice: TDWindow;
    DBStoreItemPriceOk: TDButton;
    DBStoreItemPriceCancel: TDButton;
    DBStorePriceClose: TDButton;
    DEdit13: TDMemo;
    RefusePublicChat: TDButton;
    RefuseCRY: TDButton;
    RefuseWHISPER: TDButton;
    Refuseguild: TDButton;
    AutoCRY: TDButton;
    DWGameConfig: TDWindow;
    DBGCClose: TDButton;
    DBGCActivePage1: TDButton;
    DBGCActivePage2: TDButton;
    DBGCActivePage3: TDButton;
    DBGCActivePage4: TDButton;
    DBGCActivePage5: TDButton;
    DBGCActivePage6: TDButton;
    DBGCActivePage7: TDButton;
    DCheckBoxHideShiti: TDCheckBox;
    DCheckSdoNameShow: TDCheckBox;
    DCheckSdoDuraWarning: TDCheckBox;
    DCheckSdoAvoidShift: TDCheckBox;
    DCheckSdoExpFiltrate: TDCheckBox;
    DCheckSdoMapDesc: TDCheckBox;
    DCheckMyHp: TDCheckBox;
    DBIUP: TDButton;
    DBIDown: TDButton;
    DxEditSpecialHP: TDEdit;
    DxEditSpecialHPTime: TDEdit;
    DxEditRanHP: TDEdit;
    DxEditRanHPTime: TDEdit;
    DCheckSpecial: TDCheckBox;
    DCheckRanProtect: TDCheckBox;
    DCheckPttly: TDCheckBox;
    DCheckPtmfy: TDCheckBox;
    DEditPtHp: TDEdit;
    DEditPtHpTime: TDEdit;
    DEditPtMp: TDEdit;
    DEditPtMpTime: TDEdit;
    DCheckSdoAutoFireHit: TDCheckBox;
    DCheckSdoAutoShield: TDCheckBox;
    DCheckSdoAutoHide: TDCheckBox;
    DCheckSdoAutoMagic: TDCheckBox;
    DCheckSdoAutoMagicTime: TDEdit;
    DMoveButton_items: TDMoveButton;
    DUpDown_config: TDUpDown;
    DxEdit_Items: TDEdit;
    DCheckBox_AllPickup: TDCheckBox;
    DWindowItem: TDWindow;
    DButtonDefaultConfig: TDButton;
    DStMag6: TDButton;
    DLoveDlg: TDWindow;
    DLoveClose: TDButton;
    DLover1: TDButton;
    DLover2: TDButton;
    DLover3: TDButton;
    DHelpDlg: TDWindow;
    DHelpDlgClose: TDButton;
    DHelpDlgLeft: TDButton;
    DHelpDlgCentre: TDButton;
    DHelpDlgRight: TDButton;
    DBotHelp: TDButton;
    DBotHostpot: TDButton;
    DBotQuestions: TDButton;
    DWndWeb: TDWindow;
    DWndWebClose: TDButton;
    DBelt1: TDButton;
    DBelt2: TDButton;
    DBelt3: TDButton;
    DBelt4: TDButton;
    DBelt5: TDButton;
    DBelt6: TDButton;
    DBotExit: TDButton;
    DBotFriend: TDButton;
    DBotGroup: TDButton;
    DBotGuild: TDButton;
    DBotLogout: TDButton;
    DBotMaster: TDButton;
    DBotMaster1: TDButton;
    DBotMemo: TDButton;
    DBotMiniMap: TDButton;
    DBotPlusAbil: TDButton;
    DBotTrade: TDButton;
    DMyBag: TDButton;
    DMyMagic: TDButton;
    DMyState: TDButton;
    DOption: TDButton;
    DEdChat: TDEdit;
    DEditID: TDEdit;
    DEditPass: TDEdit;
    DLoginChgPw: TDButton;
    DLoginClose: TDButton;
    DLoginNew: TDButton;
    DLoginOk: TDButton;
    DHint: TDHint;
    DEdDlgEdit: TDEdit;
    DMsgDlgCancel: TDButton;
    DMsgDlgNo: TDButton;
    DMsgDlgOk: TDButton;
    DMsgDlgYes: TDButton;
    DEditChrName: TDEdit;
    DccClose: TDButton;
    DccFemale: TDButton;
    DccLeftHair: TDButton;
    DccMale: TDButton;
    DccMonk: TDButton;
    DccOk: TDButton;
    DccReserved: TDButton;
    DccRightHair: TDButton;
    DccWarrior: TDButton;
    DccWizzard: TDButton;
    DEditStoreItemPrice: TDEdit;
    DEditStoreName: TDEdit;
    DBStoreBuy: TDButton;
    DBStoreCancel: TDButton;
    DBStorePage1: TDButton;
    DBStorePage2: TDButton;
    DEdtSdoExpFiltrate: TDEdit;
    DComboBox_Items: TDComboBox;
    DListBox_Items: TDListBox;
    DCBRenewBookNowBook: TDComboBox;
    DLBRenewBookNowBook: TDListBox;
    DWindow1: TDWindow;
    DCBPractice: TDComboBox;
    DLBPractice: TDListBox;
    DSdoMemo: TDMemo;
    DBotWhisper: TDButton;
    DWhisperDlg: TDWindow;
    DEdtWhisper: TDEdit;
    DCheckWhisper: TDCheckBox;
    DWhisperClose: TDButton;
    DWhisperUP: TDButton;
    DWhisperBar: TDMoveButton;
    DWhisperDown: TDButton;
    DFrdAdd: TDButton;
    DFrdBlackList: TDButton;
    DFrdClose: TDButton;
    DFrdDel: TDButton;
    DFrdFriend: TDButton;
    DFrdMail: TDButton;
    DFrdMemo: TDButton;
    DFrdPgDn: TDButton;
    DFrdPgUp: TDButton;
    DFrdWhisper: TDButton;
    DFrdMaster: TDButton;
    DCashShopDlg: TDWindow;
    DButtonType1: TDButton;
    DButtonType2: TDButton;
    DButtonType3: TDButton;
    DButtonType4: TDButton;
    DButtonType5: TDButton;
    DCashShopDlgClose: TDButton;
    DGridShop2: TDGrid;
    DGridShop1: TDGrid;
    DButtonShopEffect: TDButton;
    DCashItemListPrev: TDButton;
    DCashItemListNext: TDButton;
    DCashItemBuy: TDButton;
    DCashItemGift: TDButton;
    DCashItemClose: TDButton;
    DBotShop: TDButton;
    DCheckSdoAutoHld: TDCheckBox;
    DCheckSdoAutoJld: TDCheckBox;
    DCheckSdoAutoLongHit: TDCheckBox;
    DCheckBoxTrans: TDCheckBox;
    ButTrans: TDButton;
    UserButTrans: TDButton;
    DWindowSaveItem: TDWindow;
    DGridSaveItem: TDGrid;
    procedure DBottomInRealArea(Sender: TObject; X, Y: Integer; var IsRealArea: Boolean);
    procedure DBottomDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DMyStateDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DOptionClick(Sender: TObject);
    procedure DItemBagDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DRepairItemDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DRepairItemInRealArea(Sender: TObject; X, Y: Integer; var IsRealArea: Boolean);
    procedure DStateWinDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure FormCreate(Sender: TObject);
    procedure DPrevStateDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DLoginNewDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DscSelect1DirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DccCloseDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DItemGridGridSelect(Sender: TObject; X, Y: integer; ACol, ARow: Integer; Shift: TShiftState);
    procedure DItemGridGridPaint(Sender: TObject; ACol, ARow: Integer; Rect: TRect; State: TGridDrawState; dsurface: TAsphyreCanvas);
    procedure DItemGridDblClick(Sender: TObject);
    procedure DMsgDlgOkDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DMsgDlgDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DMsgDlgKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);
    procedure DCloseBagDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DBackgroundBackgroundClick(Sender: TObject);
    procedure DItemGridGridMouseMove(Sender: TObject; X, Y: integer; ACol, ARow: Integer; Shift: TShiftState);
    procedure DBelt1DirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure FormDestroy(Sender: TObject);
    procedure DBelt1DblClick(Sender: TObject);
    procedure SwapBujuk(idx: integer);
    procedure DLoginCloseClick(Sender: TObject; X, Y: Integer);
    procedure DLoginOkClick(Sender: TObject; X, Y: Integer);
    procedure DLoginNewClick(Sender: TObject; X, Y: Integer);
    procedure DLoginChgPwClick(Sender: TObject; X, Y: Integer);
    procedure DNewAccountOkClick(Sender: TObject; X, Y: Integer);
    procedure DNewAccountCloseClick(Sender: TObject; X, Y: Integer);
    procedure DccCloseClick(Sender: TObject; X, Y: Integer);
    procedure DChgpwOkClick(Sender: TObject; X, Y: Integer);
    procedure DscSelect1Click(Sender: TObject; X, Y: Integer);
    procedure DCloseStateClick(Sender: TObject; X, Y: Integer);
    procedure DPrevStateClick(Sender: TObject; X, Y: Integer);
    procedure DNextStateClick(Sender: TObject; X, Y: Integer);
    procedure DSWWeaponClick(Sender: TObject; X, Y: Integer);
    procedure DMsgDlgOkClick(Sender: TObject; X, Y: Integer);
    procedure DCloseBagClick(Sender: TObject; X, Y: Integer);
    procedure DBelt1Click(Sender: TObject; X, Y: Integer);
    procedure DMyStateClick(Sender: TObject; X, Y: Integer);
    procedure DStateWinClick(Sender: TObject; X, Y: Integer);
    procedure DSWWeaponMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DBelt1MouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DMerchantDlgDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DMerchantDlgCloseClick(Sender: TObject; X, Y: Integer);
    procedure DMerchantDlgClick(Sender: TObject; X, Y: Integer);
    procedure DMerchantDlgMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure DMerchantDlgMouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure DMenuCloseClick(Sender: TObject; X, Y: Integer);
    procedure DMenuDlgDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DMenuDlgClick(Sender: TObject; X, Y: Integer);
    procedure DSellDlgDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DSellDlgCloseClick(Sender: TObject; X, Y: Integer);
    procedure DSellDlgSpotClick(Sender: TObject; X, Y: Integer);
    procedure DSellDlgSpotDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DSellDlgSpotMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DSellDlgOkClick(Sender: TObject; X, Y: Integer);
    procedure DMenuBuyClick(Sender: TObject; X, Y: Integer);
    procedure DMenuPrevClick(Sender: TObject; X, Y: Integer);
    procedure DMenuNextClick(Sender: TObject; X, Y: Integer);
    procedure DGoldClick(Sender: TObject; X, Y: Integer);
    procedure DSWLightDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DBackgroundMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure DLoginNewClickSound(Sender: TObject; Clicksound: TClickSound);
    procedure DStMag1DirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DStMag1Click(Sender: TObject; X, Y: Integer);
    procedure DKsIconDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DKsF1DirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DKsOkClick(Sender: TObject; X, Y: Integer);
    procedure DKsF1Click(Sender: TObject; X, Y: Integer);
    procedure DKeySelDlgDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DBotGroupDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DGrpAllowGroupDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DGrpDlgCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBotGroupClick(Sender: TObject; X, Y: Integer);
    procedure DGrpAllowGroupClick(Sender: TObject; X, Y: Integer);
    procedure DGrpCreateClick(Sender: TObject; X, Y: Integer);
    procedure DGroupDlgDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DGrpAddMemClick(Sender: TObject; X, Y: Integer);
    procedure DGrpDelMemClick(Sender: TObject; X, Y: Integer);
    procedure DBotLogoutClick(Sender: TObject; X, Y: Integer);
    procedure DBotExitClick(Sender: TObject; X, Y: Integer);
    procedure DStPageUpClick(Sender: TObject; X, Y: Integer);
    procedure DBottomMouse(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure DDealOkClick(Sender: TObject; X, Y: Integer);
    procedure DDealCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBotTradeClick(Sender: TObject; X, Y: Integer);
    procedure DDealRemoteDlgDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DDealDlgDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DDGridGridSelect(Sender: TObject; X, Y: integer; ACol, ARow: Integer; Shift: TShiftState);
    procedure DDGridGridPaint(Sender: TObject; ACol, ARow: Integer; Rect: TRect; State: TGridDrawState; dsurface: TAsphyreCanvas);
    procedure DDGridGridMouseMove(Sender: TObject; X, Y: integer; ACol, ARow: Integer; Shift: TShiftState);
    procedure DDRGridGridPaint(Sender: TObject; ACol, ARow: Integer; Rect: TRect; State: TGridDrawState; dsurface: TAsphyreCanvas);
    procedure DDRGridGridMouseMove(Sender: TObject; X, Y: integer; ACol, ARow: Integer; Shift: TShiftState);
    procedure DSServer1Click(Sender: TObject; X, Y: Integer);
    procedure DSSrvCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBotMiniMapClick(Sender: TObject; X, Y: Integer);
    procedure DMenuDlgMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DUserState1DirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DUserState1MouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DWeaponUS1MouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DCloseUS1Click(Sender: TObject; X, Y: Integer);
    procedure DNecklaceUS1DirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DBotGuildClick(Sender: TObject; X, Y: Integer);
    procedure DGuildDlgDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DGDUpClick(Sender: TObject; X, Y: Integer);
    procedure DGDDownClick(Sender: TObject; X, Y: Integer);
    procedure DGDCloseClick(Sender: TObject; X, Y: Integer);
    procedure DGDHomeClick(Sender: TObject; X, Y: Integer);
    procedure DGDListClick(Sender: TObject; X, Y: Integer);
    procedure DGDAddMemClick(Sender: TObject; X, Y: Integer);
    procedure DGDDelMemClick(Sender: TObject; X, Y: Integer);
    procedure DGDEditNoticeClick(Sender: TObject; X, Y: Integer);
    procedure DGDEditGradeClick(Sender: TObject; X, Y: Integer);
    procedure DGECloseClick(Sender: TObject; X, Y: Integer);
    procedure DGEOkClick(Sender: TObject; X, Y: Integer);
    procedure DGuildEditNoticeDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DGDChatClick(Sender: TObject; X, Y: Integer);
    procedure DGoldDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DNewAccountDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DAdjustAbilCloseClick(Sender: TObject; X, Y: Integer);
    procedure DAdjustAbilityDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DBotPlusAbilClick(Sender: TObject; X, Y: Integer);
    procedure DPlusDCClick(Sender: TObject; X, Y: Integer);
    procedure DMinusDCClick(Sender: TObject; X, Y: Integer);
    procedure DAdjustAbilOkClick(Sender: TObject; X, Y: Integer);
    procedure DBotPlusAbilDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DAdjustAbilityMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DUserState1MouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure DEngServer1Click(Sender: TObject; X, Y: Integer);
    procedure DGDAllyClick(Sender: TObject; X, Y: Integer);
    procedure DGDBreakAllyClick(Sender: TObject; X, Y: Integer);
    procedure DSelServerDlgDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DSServer1DirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DBotFriendClick(Sender: TObject; X, Y: Integer);
    procedure DBotFriendDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DBotFriendMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DFriendDlgDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DFrdPgUpClick(Sender: TObject; X, Y: Integer);
    procedure DFrdPgUpDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DFrdFriendClick(Sender: TObject; X, Y: Integer);
    procedure DFrdBlackListClick(Sender: TObject; X, Y: Integer);
    procedure DFrdAddMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DFrdDelMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DFrdMemoMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DFrdMailMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DFrdWhisperMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DFrdCloseClick(Sender: TObject; X, Y: Integer);
    procedure DFrdFriendDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DFrdBlackListDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DMailListDlgDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DMailListCloseClick(Sender: TObject; X, Y: Integer);
    procedure DMailListPgUpClick(Sender: TObject; X, Y: Integer);
    procedure DMLReplyMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DMLReadMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DMLDelMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DMLLockMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DMLBlockMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DMailListDlgClick(Sender: TObject; X, Y: Integer);
    procedure DFriendDlgClick(Sender: TObject; X, Y: Integer);
    procedure DBlockListCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBLPgUpClick(Sender: TObject; X, Y: Integer);
    procedure DBlockListDlgDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DBlockListDlgClick(Sender: TObject; X, Y: Integer);
    procedure DBLAddMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DBLDelMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DMLBlockClick(Sender: TObject; X, Y: Integer);
    procedure DBotMemoMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DBotMemoClick(Sender: TObject; X, Y: Integer);
    procedure DFrdAddClick(Sender: TObject; X, Y: Integer);
    procedure DMLReadClick(Sender: TObject; X, Y: Integer);
    procedure DFrdMailClick(Sender: TObject; X, Y: Integer);
    procedure DMemoDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DFrdMemoClick(Sender: TObject; X, Y: Integer);
    procedure DMemoCloseClick(Sender: TObject; X, Y: Integer);
    procedure DFrdDelClick(Sender: TObject; X, Y: Integer);
    procedure DFrdWhisperClick(Sender: TObject; X, Y: Integer);
    procedure DMemoB1DirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DMemoB2DirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DMemoB1Click(Sender: TObject; X, Y: Integer);
    procedure DBLAddClick(Sender: TObject; X, Y: Integer);
    procedure DBLDelClick(Sender: TObject; X, Y: Integer);
    procedure DMLReplyClick(Sender: TObject; X, Y: Integer);
    procedure DMLDelClick(Sender: TObject; X, Y: Integer);
    procedure DMLLockClick(Sender: TObject; X, Y: Integer);
    procedure DFriendDlgDblClick(Sender: TObject);
    procedure DMailListDlgDblClick(Sender: TObject);
    procedure DBotMemoDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DFriendDlgMouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure DMailListDlgMouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure DFrdPgUpMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DFrdPgDnMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DMailListPgUpMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DMailListPgDnMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DBLPgUpMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DBLPgDnMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DFriendDlgMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DMailListDlgMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DMailDlgMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DBlockListDlgMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DMemoMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DMakeItemDlgOkDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DCountDlgDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DCountDlgKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);
    procedure DCountDlgOkDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DCountDlgOkClick(Sender: TObject; X, Y: Integer);
    procedure DCountDlgCloseClick(Sender: TObject; X, Y: Integer);
    procedure DMakeItemDlgDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DMakeitemGridGridPaint(Sender: TObject; ACol, ARow: Integer; Rect: TRect; State: TGridDrawState; dsurface: TAsphyreCanvas);
    procedure DMakeitemGridGridMouseMove(Sender: TObject; X, Y: integer; ACol, ARow: Integer; Shift: TShiftState);
    procedure DMakeitemGridGridSelect(Sender: TObject; X, Y: integer; ACol, ARow: Integer; Shift: TShiftState);
    procedure DMakeItemDlgOkClick(Sender: TObject; X, Y: Integer);
    procedure DItemMarketDlgDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DItemMarketDlgClick(Sender: TObject; X, Y: Integer);
    procedure DItemMarketDlgMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DItemListPrevClick(Sender: TObject; X, Y: Integer);
    procedure DItemListNextClick(Sender: TObject; X, Y: Integer);
    procedure DItemBuyClick(Sender: TObject; X, Y: Integer);
    procedure DItemMarketCloseClick(Sender: TObject; X, Y: Integer);
    procedure DMGoldDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DItemMarketDlgKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);
    procedure DItemListRefreshClick(Sender: TObject; X, Y: Integer);
    procedure DItemSellCancelClick(Sender: TObject; X, Y: Integer);
    procedure DItemFindClick(Sender: TObject; X, Y: Integer);
    procedure DItemSellCancelMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DItemCancelMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DItemBagClick(Sender: TObject; X, Y: Integer);
    procedure DMemoClick(Sender: TObject; X, Y: Integer);
    procedure DMailDlgClick(Sender: TObject; X, Y: Integer);
    procedure DItemMarketDlgMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure DJangwonListDlgClick(Sender: TObject; X, Y: Integer);
    procedure DJangwonListDlgDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DJangwonCloseClick(Sender: TObject; X, Y: Integer);
    procedure DJangListPrevClick(Sender: TObject; X, Y: Integer);
    procedure DJangListNextClick(Sender: TObject; X, Y: Integer);
    procedure DJangMemoClick(Sender: TObject; X, Y: Integer);
    procedure DDealJangwonDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DGABoardListDlgDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DGABoardListCloseClick(Sender: TObject; X, Y: Integer);
    procedure DGABoardOkClick(Sender: TObject; X, Y: Integer);
    procedure DGABoardListDlgDblClick(Sender: TObject);
    procedure DGABoardListDlgMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure DGABoardDlgDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DGABoardCloseClick(Sender: TObject; X, Y: Integer);
    procedure DGABoardOk2Click(Sender: TObject; X, Y: Integer);
    procedure DGABoardWriteClick(Sender: TObject; X, Y: Integer);
    procedure DGABoardNoticeClick(Sender: TObject; X, Y: Integer);
    procedure DGABoardReplyClick(Sender: TObject; X, Y: Integer);
    procedure DGABoardDlgKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);
    procedure DGABoardListNextClick(Sender: TObject; X, Y: Integer);
    procedure DGABoardListPrevClick(Sender: TObject; X, Y: Integer);
    procedure DGABoardListRefreshClick(Sender: TObject; X, Y: Integer);
    procedure DGABoardMemoClick(Sender: TObject; X, Y: Integer);
    procedure DGABoardDelClick(Sender: TObject; X, Y: Integer);
    procedure DGADecorateDlgDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DGADecorateCloseClick(Sender: TObject; X, Y: Integer);
    procedure DGADecorateBuyClick(Sender: TObject; X, Y: Integer);
    procedure DGADecorateCancelClick(Sender: TObject; X, Y: Integer);
    procedure DGADecorateDlgClick(Sender: TObject; X, Y: Integer);
    procedure DGADecorateDlgKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);
    procedure DGADecorateListNextClick(Sender: TObject; X, Y: Integer);
    procedure DGADecorateListPrevClick(Sender: TObject; X, Y: Integer);
    procedure DMasterDlgClick(Sender: TObject; X, Y: Integer);
    procedure DMasterDlgDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DMasterDlgMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DLover1Click(Sender: TObject; X, Y: Integer);
    procedure DLover1MouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DLover2Click(Sender: TObject; X, Y: Integer);
    procedure DLover2MouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DLover3Click(Sender: TObject; X, Y: Integer);
    procedure DLover3MouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DMasterCloseClick(Sender: TObject; X, Y: Integer);
    procedure DHeartImgDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DHeartImgUSDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DBotMasterClick(Sender: TObject; X, Y: Integer);
    procedure DMarketMemoClick(Sender: TObject; X, Y: Integer);
    procedure DMemoKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);
    procedure DSkillBarOnDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DChFriendDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DChGroupClick(Sender: TObject; X, Y: Integer);
    procedure DChFriendClick(Sender: TObject; X, Y: Integer);
    procedure DChMemoClick(Sender: TObject; X, Y: Integer);
    procedure DSellDlgBtnHoldClick(Sender: TObject; X, Y: Integer);
    procedure DSellDlgStHoldDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DSelectChrClick(Sender: TObject; X, Y: Integer);
    procedure DSellDlgBtnHoldMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DGrpAllowGroupMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DGroupDlgMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DBotMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DRepairItemClick(Sender: TObject; X, Y: Integer);
    procedure DMyStateMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DMaster3Click(Sender: TObject; X, Y: Integer);
    procedure DMaster3MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DMaster1Click(Sender: TObject; X, Y: Integer);
    procedure DMaster1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DMsgSimpleDlgDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DMsgSimpleDlgKeyDown(Sender: TObject; var Key: Word;
      Shift: TShiftState);
    procedure DMsgSimpleDlgOkClick(Sender: TObject; X, Y: Integer);
    procedure DRefreshPotCashDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DBotGroupMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DWStoreItemPriceDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBStorePage1Click(Sender: TObject; X, Y: Integer);
    procedure DBStorePage1DirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DBStorePriceCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBStoreItemPriceOkClick(Sender: TObject; X, Y: Integer);
    procedure DBStoreItemPriceCancelClick(Sender: TObject; X, Y: Integer);
    procedure DWHeroStoreMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DWHeroStoreDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DBStoreCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBStoreBuyDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DBStoreBuyClick(Sender: TObject; X, Y: Integer);
    procedure DBStoreCancelClick(Sender: TObject; X, Y: Integer);
    procedure DGridStoreGridMouseMove(Sender: TObject; X, Y, ACol,
      ARow: Integer; Shift: TShiftState);
    procedure DGridStoreGridPaint(Sender: TObject; ACol, ARow: Integer;
      Rect: TRect; State: TGridDrawState; dsurface: TAsphyreCanvas);
    procedure DGridStoreGridSelect(Sender: TObject; X, Y, ACol, ARow: Integer;
      Shift: TShiftState);
    procedure DWUserStallDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DBUserStallBuyClick(Sender: TObject; X, Y: Integer);
    procedure DBUserStallBuyDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DBotMaster1Click(Sender: TObject; X, Y: Integer);
    procedure DBStoreCancelDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DBUserStallCloseClick(Sender: TObject; X, Y: Integer);
    procedure DGridUserStallGridMouseMove(Sender: TObject; X, Y, ACol, ARow:
        Integer; Shift: TShiftState);
    procedure DGridUserStallGridPaint(Sender: TObject; ACol, ARow: Integer; Rect:
        TRect; State: TGridDrawState; dsurface: TAsphyreCanvas);
    procedure DGridUserStallGridSelect(Sender: TObject; X, Y, ACol, ARow: Integer;
        Shift: TShiftState);
    procedure RefusePublicChatClick(Sender: TObject; X, Y: Integer);
    procedure RefusePublicChatDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure RefusePublicChatMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure RefuseCRYClick(Sender: TObject; X, Y: Integer);
    procedure RefuseWHISPERClick(Sender: TObject; X, Y: Integer);
    procedure RefuseguildClick(Sender: TObject; X, Y: Integer);
    procedure AutoCRYClick(Sender: TObject; X, Y: Integer);
    procedure DWGameConfigDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DBGCCloseDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DBGCCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBGCActivePage1DirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DBGCActivePage1Click(Sender: TObject; X, Y: Integer);
    procedure DCheckBoxHideShitiDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBIUPDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure Db_MoveButtonDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DMoveButton_itemsDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBIDownMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DBIDownMouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DBIUPMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DBIUPMouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DComboBox_ItemsChange(Sender: TObject);
    procedure DxEdit_ItemsChange(Sender: TObject; sText: string);
    procedure DCheckPttlyChange(Sender: TObject);
    procedure DCheckPtmfyChange(Sender: TObject);
    procedure DCheckSdoAutoFireHitChange(Sender: TObject);
    procedure DCheckSdoAutoShieldChange(Sender: TObject);
    procedure DCheckSdoAutoHideChange(Sender: TObject);
    procedure DCheckSdoAutoHldChange(Sender: TObject);
    procedure DCheckSdoAutoJldChange(Sender: TObject);
    procedure DCheckSdoAutoLongHitChange(Sender: TObject);
    procedure DWGameConfigVisible(Sender: TObject; boVisible: Boolean);
    procedure DComboBoxAutoMagicListChange(Sender: TObject);
    procedure DListBox_ItemsChange(Sender: TObject);
    procedure DWindowItemDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DWindowItemMouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DCheckBox_AllPickupChange(Sender: TObject);
    procedure DCheckSdoNameShowMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DWGameConfigMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DButtonDefaultConfigDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DButtonDefaultConfigClick(Sender: TObject; X, Y: Integer);
    procedure DSdoMemoEndDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DStMag1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DStateWinMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DItemBagMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DLoveDlgDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DMasterCloseDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DLoveCloseClick(Sender: TObject; X, Y: Integer);
    procedure DMaster2MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DMaster2Click(Sender: TObject; X, Y: Integer);
    procedure DPopUpEditsPopIndex(Sender, DControl: TDControl;
      ItemIndex: Integer; UserName: string);
    procedure DBotHelpClick(Sender: TObject; X, Y: Integer);
    procedure DHelpDlgLeftDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DHelpDlgCloseDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DHelpDlgLeftClick(Sender: TObject; X, Y: Integer);
    procedure DHelpDlgDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DHelpDlgCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBotHostpotClick(Sender: TObject; X, Y: Integer);
    procedure DWndWebDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DWndWebInRealArea(Sender: TObject; X, Y: Integer;
      var IsRealArea: Boolean);
    procedure DWndWebVisible(Sender: TObject; boVisible: Boolean);
    procedure DBotQuestionsClick(Sender: TObject; X, Y: Integer);
    procedure DWndWebCloseClick(Sender: TObject; X, Y: Integer);
    procedure DEditIDKeyPress(Sender: TObject; var Key: Char);
    procedure DEditIDMouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DEditPassKeyPress(Sender: TObject; var Key: Char);
    procedure DEditStoreItemPriceKeyPress(Sender: TObject; var Key: Char);
    procedure DCheckSdoNameShowClick(Sender: TObject; X, Y: Integer);
    procedure DCheckBoxHideShitiClick(Sender: TObject; X, Y: Integer);
    procedure DCheckSdoDuraWarningClick(Sender: TObject; X, Y: Integer);
    procedure DCheckSdoAvoidShiftClick(Sender: TObject; X, Y: Integer);
    procedure DCheckMyHpClick(Sender: TObject; X, Y: Integer);
    procedure DCheckSdoMapDescClick(Sender: TObject; X, Y: Integer);
    procedure DCheckSdoExpFiltrateClick(Sender: TObject; X, Y: Integer);


    procedure DxEdit_Items_Search_OnTextChanged(Sender: TObject; sText: string);
    procedure DListBox_ItemsOnChangeSelect(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DCheckSdoAutoMagicClick(Sender: TObject; X, Y: Integer);
    procedure DLBPracticeClick(Sender: TObject; X, Y: Integer);
    procedure DCheckSpecialClick(Sender: TObject; X, Y: Integer);
    procedure DCheckRanProtectClick(Sender: TObject; X, Y: Integer);
    procedure DCheckSpecialDirectPaint(Sender: TObject;
      DSurface: TAsphyreCanvas);
    procedure DCheckSdoAutoMagicTimeLeave(Sender: TObject);
    procedure DEditPtMpTimeLeave(Sender: TObject);
    procedure DEditPtMpLeave(Sender: TObject);
    procedure DEditPtHpTimeLeave(Sender: TObject);
    procedure DEditPtHpLeave(Sender: TObject);
    procedure DxEditRanHPTimeLeave(Sender: TObject);
    procedure DxEditRanHPLeave(Sender: TObject);
    procedure DxEditSpecialHPTimeLeave(Sender: TObject);
    procedure DxEditSpecialHPLeave(Sender: TObject);
    procedure DWhisperDlgDirectPaint(Sender: TObject; DSurface: TAsphyreCanvas);
    procedure DBotWhisperClick(Sender: TObject; X, Y: Integer);
    procedure DWhisperCloseClick(Sender: TObject; X, Y: Integer);
    procedure DCheckWhisperDirectPaint(Sender: TObject;
      DSurface: TAsphyreCanvas);
    procedure DWhisperDlgMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DWhisperDlgMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DWhisperDlgMouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DWhisperDownMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DWhisperUPMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DMenuDlgInRealArea(Sender: TObject; X, Y: Integer;
      var IsRealArea: Boolean);
    procedure DCashShopDlgDirectPaint(Sender: TObject;
      DSurface: TAsphyreCanvas);
    procedure DCashShopDlgMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DButtonType1Click(Sender: TObject; X, Y: Integer);
    procedure DButtonType1DirectPaint(Sender: TObject;
      DSurface: TAsphyreCanvas);
    procedure DCashShopDlgCloseClick(Sender: TObject; X, Y: Integer);
    procedure DButtonShopEffectDirectPaint(Sender: TObject;
      DSurface: TAsphyreCanvas);
    procedure DGridShop1GridPaint(Sender: TObject; ACol, ARow: Integer;
      Rect: TRect; State: TGridDrawState; DSurface: TAsphyreCanvas);
    procedure DGridShop1GridSelect(Sender: TObject; X, Y, ACol, ARow: Integer;
      Shift: TShiftState);
    procedure DGridShop2GridPaint(Sender: TObject; ACol, ARow: Integer;
      Rect: TRect; State: TGridDrawState; DSurface: TAsphyreCanvas);
    procedure DGridShop2GridSelect(Sender: TObject; X, Y, ACol, ARow: Integer;
      Shift: TShiftState);
    procedure DCashItemListPrevClick(Sender: TObject; X, Y: Integer);
    procedure DCashItemListNextClick(Sender: TObject; X, Y: Integer);
    procedure DCashItemBuyClick(Sender: TObject; X, Y: Integer);
    procedure DCashItemGiftClick(Sender: TObject; X, Y: Integer);
    procedure DBotShopClick(Sender: TObject; X, Y: Integer);
    procedure DEdtSdoExpFiltrateTextChanged(Sender: TObject; sText: string);
    procedure DCheckSdoAutoMagicTimeTextChanged(Sender: TObject; sText: string);
    procedure DEditPtMpTimeTextChanged(Sender: TObject; sText: string);
    procedure DxEditRanHPTimeTextChanged(Sender: TObject; sText: string);
    procedure DEditPtMpTextChanged(Sender: TObject; sText: string);
    procedure DxEditRanHPTextChanged(Sender: TObject; sText: string);
    procedure DEditPtHpTimeTextChanged(Sender: TObject; sText: string);
    procedure DxEditSpecialHPTimeTextChanged(Sender: TObject; sText: string);
    procedure DEditPtHpTextChanged(Sender: TObject; sText: string);
    procedure DxEditSpecialHPTextChanged(Sender: TObject; sText: string);
    procedure DCheckBox_AllPickupClick(Sender: TObject; X, Y: Integer);
    procedure DCheckSdoAutoFireHitClick(Sender: TObject; X, Y: Integer);
    procedure DCheckSdoAutoShieldClick(Sender: TObject; X, Y: Integer);
    procedure DCheckSdoAutoHideClick(Sender: TObject; X, Y: Integer);
    procedure DCheckSdoAutoHldClick(Sender: TObject; X, Y: Integer);
    procedure DCheckSdoAutoJldClick(Sender: TObject; X, Y: Integer);
    procedure DCheckSdoAutoLongHitClick(Sender: TObject; X, Y: Integer);
    procedure DCBRenewBookNowBookTextChanged(Sender: TObject; sText: string);
    procedure DCBRenewBookNowBookClick(Sender: TObject; X, Y: Integer);
    procedure DCheckPttlyClick(Sender: TObject; X, Y: Integer);
    procedure DCheckPtmfyClick(Sender: TObject; X, Y: Integer);
    procedure DDGoldClick(Sender: TObject; X, Y: Integer);
    procedure DWGameConfigClick(Sender: TObject; X, Y: Integer);
    procedure DCheckBoxTransDirectPaint(Sender: TObject;
      DSurface: TAsphyreCanvas);
    procedure DCheckBoxTransClick(Sender: TObject; X, Y: Integer);
    procedure DWindowSaveItemDirectPaint(Sender: TObject;
      DSurface: TAsphyreCanvas);
    procedure DGridSaveItemGridPaint(Sender: TObject; ACol, ARow: Integer;
      Rect: TRect; State: TGridDrawState; DSurface: TAsphyreCanvas);
    procedure DGridSaveItemGridSelect(Sender: TObject; X, Y, ACol,
      ARow: Integer; Shift: TShiftState);
    procedure DGridSaveItemGridMouseMove(Sender: TObject; X, Y, ACol,
      ARow: Integer; Shift: TShiftState);
    procedure DGridSaveItemDblClick(Sender: TObject);
  private
    //私聊系统
    WhisperPoints: TList;
    WhisperAddPoints: Boolean;
    WhisperMoveed: integer;
    WhisperSelect: integer;
    WhisperTop: Integer;

    EditTemp: TEdit;
    DlgTemp: TList;
    magcur, magtop: integer;
//    EdDlgEdit: TEdit;
    EdCountEdit: TEdit;
    ItemSearchEdit: TEdit;
    Memo: TMemo;
    // 2003/04/15 模备, 率瘤
    edCharID: TEdit;
    memoMail: TMemo;
    ViewDlgEdit: Boolean;
    msglx, msgly: integer;
    MagKeyIcon, MagKeyCurKey: integer;
    MagKeyMagName: string;
    BackupMemoMail: string;
    StrMemoMail: string;
    MagicPage: integer;
    // 2003/04/15 模备, 率瘤
    MemoCharID: string;
    MemoCharID2: string;
    MemoDate: string;
    FriendPage: integer;
    BlackListPage: integer;
    MailPage: integer;
    BlockPage: integer;
    CurrentMail: integer;
    CurrentFriend: integer;
    CurrentBlack: integer;
    CurrentBlock: integer;
    ViewFriends: boolean;
    ViewRelation: byte;
    ViewWindowNo: integer;
    ViewWindowData: integer;
    FriendDlgDblClicked: Boolean;
    MailListDlgDblClicked: Boolean;
    BlinkTime: longword;
    BlinkCount: integer;  //0..9荤捞甫 馆汗
    UpDownStart:boolean;
    UpDownTick:longword;
    SelectIndex: Integer;
    procedure RestoreHideControls;
    procedure DealItemReturnBag(mitem: TClientItem);
    procedure DealZeroGold;
    //-

    procedure EdChatKeyDown (Sender: TObject; var Key: Word; Shift: TShiftState);
    //-
  public
    MenuTop: integer;
    StatePage: integer;
    MsgText: string;
    DialogSize: integer;
    RunDice: integer;
    DiceType: Byte;
    BoDrawOk: Boolean;
    BoDrawDice: Boolean;
    DiceArr: array[0..9] of TDiceInfo;
    MerchantName: string;
    MerchantFace: integer;
    MDlgStr: string;
    MDlgPoints: TList;
    RequireAddPoints: Boolean;
    SelectMenuStr: string;
    LastestClickTime: longword;
    MsgDlgClickTime: longword;
    SpotDlgMode: TSpotDlgMode;
    MenuList: TList; //list of PTClientGoods
    JangwonList: TList; //厘盔 府胶飘 PTClientJangwon
    GABoardList: TList; //厘盔 霸矫魄 府胶飘
    GADecorationList: TList; //厘盔 操固扁 府胶飘
    MenuIndex: integer;
    CurDetailItem: string;
    MenuTopLine: integer;
    BoStorageMove: Boolean;
    BoDetailMenu: Boolean;
    BoStorageMenu: Boolean;
    BoNoDisplayMaxDura: Boolean;
    BoMakeDrugMenu: Boolean;
    BoFirstShowOnServerSel: Boolean;
    // 酒捞袍 诀弊饭捞靛
    BoUpItemEffect: Boolean;
    CurUpItemEffect: integer;
    UpItemOffset: integer;
    UpItemMaxFrame: integer;
    upeffecttime: longword;

    // 般摹扁
    Total: integer;
    NameMakeItem: string[14];

    // 力炼
    BoMakeItemMenu: Boolean;
    // 困殴魄概
    MItemSellState: Byte;
    BoInRect: Boolean;
    // 厘盔 率瘤
    BoMemoJangwon: Boolean;
    NAHelps: TStringList;
    NewAccountTitle: string;
    DlgEditText: string;
    UserState1: TUserStateInfo;
    Guild: string;
    GuildFlag: string;
    GuildCommanderMode: Boolean;
    GuildStrs: TStringList;
    GuildStrs2: TStringList;
    GuildNotice: TStringList;
    GuildMembers: TStringList;
    GuildTopLine: integer;
    GuildEditHint: string;
    GuildChats: TStringList;
    BoGuildChat: Boolean;
    GABoard_GuildName: string;
    GABoard_UserName: string[14];
    GABoard_TxtBody: string;
    GABoard_Edit     : string;
    GABoard_Notice: TStringList;
    GABoard_MaxPage: integer;
    GABoard_CurPage: integer;
    GABoard_BoNotice: integer;
    GABoard_BoWrite: Byte;
    GABoard_BoReply: Byte;
    GABoard_IndexType1: integer;
    GABoard_IndexType2: integer;
    GABoard_IndexType3: integer;
    GABoard_IndexType4: integer;
    GABoard_X, GABoard_Y: integer;

    m_nShopPage: Integer;
    m_nShopClass: Integer;

    m_dwShopEffectTick: LongWord;
    m_nShopShowMaxFrame: Integer;
    m_nShopShowEffectFrame: Integer;
    m_nShopShowCurrentFrame: Integer;
    m_nShopItemIndex: Integer;
    m_nShopItemIndex2: Integer;

    DWhisperInfoList: TStringList;

    m_dwBlinkTime: LongWord;
    m_boViewBlink: Boolean;
    m_FilterItemCheck:array[0..2,0..7] of TDCheckBox;
    m_ComboBox_ItemsIdx:integer;
    //password
//    DxEditStoreName: TDEdit;           //名字
//    D1xEditStoreItemPrice:TDEdit;//价格
   procedure OnFilterItemCheckDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure PageChanged;
    procedure Initialize;
    procedure OpenMyStatus;
    procedure OpenUserState(ustate: TUserStateInfo);
    procedure OpenItemBag;
    procedure ViewBottomBox(visible: Boolean);
    procedure CancelItemMoving;
    procedure DropMovingItem;
    procedure OpenAdjustAbility;
    procedure HideAllControls;
    procedure ShowSelectServerDlg;
    function DMessageDlg(msgstr: string; DlgButtons: TMsgDlgButtons): TModalResult;
    function DSimpleMessageDlg (msgstr: string; DlgButtons: TMsgDlgButtons): TModalResult;
    function OnlyMessageDlg(msgstr: string; DlgButtons: TMsgDlgButtons): TModalResult;
    function DCountMsgDlg(msgstr: string; DlgButtons: TMsgDlgButtons): TModalResult;
    function MakeItemDlgShow(msgstr: string): TModalResult;
    procedure ShowMDlg(face: integer; mname, msgstr: string);
    procedure ShowGuildDlg;
    procedure ShowGuildEditNotice;
    procedure ShowGuildEditGrade;
    procedure ResetMenuDlg;
    procedure ShowShopMenuDlg(bStorageType: Byte = 0);
    procedure ShowItemMarketDlg;
    procedure ShowJangwonDlg;
    procedure ShowGADecorateDlg;
    procedure ShowGABoardListDlg;
    procedure ShowGABoardReadDlg;
    procedure SendGABoardOkProg;
    procedure SendGABoardNoticeOk;
    procedure ShowShopSellDlg;
    procedure CloseDSellDlg;
    procedure CloseMDlg;
    procedure CloseMDlg2;
    procedure CloseItemMarketDlg;
    procedure SafeCloseDlg;
    procedure ToggleShowGroupDlg;
    // 2003/04/15 模备, 率瘤
    procedure ToggleShowFriendsDlg;
    procedure ToggleShowMailListDlg;
    procedure ToggleShowBlockListDlg;
    procedure ToggleShowMemoDlg;
    procedure ToggleShowMasterDlg;
    procedure ToggleShowLoveDlg;
    procedure ShowEditMail;
    procedure AddFriend(FriendName: string; ShowMessage: Boolean);
    procedure OpenDealDlg(DealCase: Byte);
    procedure CloseDealDlg;
    procedure SetChatFocus;
    function DecoItemDesc(Dura: word; var str: string): string;
    procedure SoldOutGoods(itemserverindex: integer);
    procedure DelStorageItem(itemserverindex: integer; remain: word);
    procedure GetMouseItemInfo(var iname, line1, line2, line3, line4, line5: string; var useable: boolean; bowear: Boolean);
    procedure SetMagicKeyDlg(icon: integer; magname: string; var curkey: word);
    procedure AddGuildChat(str: string);
    function ConvertEscChar(str: string): string;
    procedure UpgradeItemEffect(wResult: word);
    procedure DGABoardReplyVisibleOk(Index, ReplyCount: Integer; dsurface: TAsphyreCanvas);
    //-
    procedure EdChatKeyPress(Sender: TObject; var Key: Char);
    procedure AddWhisper(Str: string);
    procedure AutoWhisper(str: string);
    function IsBlockNameList(str: string):Boolean;
  end;

var
  FrmDlg: TFrmDlg;
  g_nMagicCount: Integer = 5;
  nHelpType: Integer = -1;
  bWindowsType: Integer = -1;

implementation

uses
  ClMain, MShare, Actor,Imm, ngshare, MagicShar, shellapi, frmWebBroser, FwEB;

{$R *.DFM}

{
   ##  MovingItem.Index
      1~n : 啊规芒狼 酒捞袍 鉴辑
      -1~-8 : 厘馒芒俊辑狼 酒捞袍 鉴辑
      -97 : 背券芒狼 捣
      -98 : 捣
      -99 : 迫扁 芒俊辑狼 酒捞袍 鉴辑
      -20~29: 背券芒俊辑狼 酒捞袍 鉴辑
}
const
  HERO_MIIDX_OFFSET = 5000;
  SAVE_MIIDX_OFFSET = HERO_MIIDX_OFFSET + 500;
  STALL_MIIDX_OFFSET = HERO_MIIDX_OFFSET + 500 + 50;
  DETECT_MIIDX_OFFSET = HERO_MIIDX_OFFSET + 500 + 50 + 10 + 1;
function IsDetectItem(idx: Integer): Boolean;
begin
  Result := idx = DETECT_MIIDX_OFFSET;
end;
function IsStallItem(idx: Integer): Boolean;
begin
  Result := (idx >= STALL_MIIDX_OFFSET) and (idx < STALL_MIIDX_OFFSET + 10);
end;
function CanAddStallItem(): Boolean;
var
  i                 : Integer;
begin
  Result := False;
  if MySelf = nil then Exit;
  for i := 0 to 10 - 1 do begin
    if mySelf.m_StallMgr.mBlock.Items[i].s.Name = '' then begin
      Result := True;
      Break;
    end;
  end;
end;
function AddStallItem(ci: TClientItem): Boolean;
var
  i                 : Integer;
begin
  Result := False;
  if MySelf = nil then Exit;
  for i := 0 to 10 - 1 do begin
    if mySelf.m_StallMgr.mBlock.Items[i].s.Name <> '' then begin
      if mySelf.m_StallMgr.mBlock.Items[i].MakeIndex = ci.MakeIndex then begin
        mySelf.m_StallMgr.mBlock.Items[i] := ci;
        Result := True;
        Exit;
      end;
    end;
  end;

  for i := 0 to 10 - 1 do begin
    if mySelf.m_StallMgr.mBlock.Items[i].s.Name = '' then begin
      mySelf.m_StallMgr.mBlock.Items[i] := ci;
      Result := True;
      Break;
    end;
  end;
end;
function UpdateBagStallItem(cu: TClientItem; ststus: Byte): Boolean;
var
  i                 : Integer;
begin
  Result := False;
  for i := MAXBAGITEMCL - 1 downto 6 do begin
    if (ItemArr[i].s.Name = cu.s.Name) and (ItemArr[i].MakeIndex = cu.MakeIndex) then begin
      ItemArr[i].s.Stock := ststus; //零时用
      Result := True;
      Break;
    end;
  end;
end;

procedure TFrmDlg.FormCreate(Sender: TObject);
var i,j:integer;
begin
  SelectIndex := -1;
  StatePage := 0;
  DlgTemp := TList.Create;
  DialogSize := 1; //扁夯 农扁
  RunDice := 0;
  DiceType := 1;
  BoDrawDice := FALSE;
  BoDrawOk := False;
  magcur := 0;
  magtop := 0;
  MDlgPoints := TList.Create;
  SelectMenuStr := '';
  MenuList := TList.Create;
  JangwonList := TList.Create;
  GABoardList := TList.Create;
  GADecorationList := TList.Create;
  MenuIndex := -1;
  MenuTopLine := 0;
  BoStorageMove := False;
  BoDetailMenu := FALSE;
  BoStorageMenu := FALSE;
  BoNoDisplayMaxDura := FALSE;
  BoMakeDrugMenu := FALSE;
  BoMakeItemMenu := FALSE;
  BoMemoJangwon := False;
  NameMakeItem := '';
  MagicPage := 0;
   // 2003/04/15 模备, 率瘤
  FriendPage := 0;
  BlackListPage := 0;
  MailPage := 0;
  BlockPage := 0;
  CurrentMail := -1;
  CurrentFriend := -1;
  CurrentBlack := -1;
  CurrentBlock := -1;
  ViewFriends := TRUE;
  ViewRelation := 0;
  ViewWindowNo := 0;
  ViewWindowData := 0;

  NAHelps := TStringList.Create;
  BlinkTime := GetTickCount;
  BlinkCount := 0;

  SellDlgItem.S.Name := '';
  Guild := '';
  GuildFlag := '';
  GuildCommanderMode := FALSE;
  GuildStrs := TStringList.Create;
  GuildStrs2 := TStringList.Create; //归诀侩
  GuildNotice := TStringList.Create;
  GABoard_Notice := TStringList.Create;
  GuildMembers := TStringList.Create;
  GuildChats := TStringList.Create;

  EditTemp := TEdit.Create(frmMain.Owner);
  with EditTemp do begin
    Parent := frmMain;
    Color := clBlack;
    Font.Color := clBlack;
    Font.Size := 9;
    MaxLength := 0;
    Height := 16;
    Ctl3D := False;
    BorderStyle := bsSingle;
    Visible := False;
  end;

//  EdDlgEdit := TEdit.Create(FrmMain.Owner);
//  with EdDlgEdit do
//  begin
//    Parent := FrmMain;
//    Color := clBlack;
//    Font.Color := clWhite;
//    Font.Size := 9;
//    MaxLength := 30;
//    Height := 13;
//    Ctl3d := FALSE;
//    BorderStyle := bsSingle;  {OnKeyPress := EdDlgEditKeyPress;}
//    Visible := FALSE;
//  end;

  EdCountEdit := TEdit.Create(FrmMain.Owner);
  with EdCountEdit do
  begin
    Parent := FrmMain;
    Color := clBlack;
    Font.Color := clWhite;
    Font.Size := 10;
    MaxLength := 20;
    Height := 16;
    Ctl3d := FALSE;
    BorderStyle := bsSingle;
    Visible := False;
  end;

  ItemSearchEdit := TEdit.Create(FrmMain.Owner);
  with ItemSearchEdit do
  begin
    Parent := FrmMain;
    Color := clBlack;
    Font.Color := clWhite;
    Font.Size := 10;
    MaxLength := 20;
    Height := 16;
    Ctl3d := FALSE;
    BorderStyle := bsSingle;
    Visible := False;
  end;

  Memo := TMemo.Create(FrmMain.Owner);
  with Memo do
  begin
    Parent := FrmMain;
    Color := clBlack;
    Font.Color := clWhite;
    Font.Size := 10;
    Ctl3d := FALSE;
    BorderStyle := bsSingle;  {OnKeyPress := EdDlgEditKeyPress;}
    Visible := FALSE;
  end;

   // 2003/04/15 模备, 率瘤
  edCharID := TEdit.Create(FrmMain.Owner);
  with edCharID do
  begin
    Parent := FrmMain;
    Color := clBlack;
    Font.Color := clWhite;
    Font.Size := 10;
    MaxLength := 14;
    Height := 16;
    Ctl3d := FALSE;
    BorderStyle := bsSingle;  {OnKeyPress := EdDlgEditKeyPress;}
    Visible := FALSE;
  end;

  memoMail := TMemo.Create(FrmMain.Owner);
  with memoMail do
  begin
    Parent := FrmMain;
    Color := clBlack;
    Font.Color := clWhite;
    Font.Size := 10;
    MaxLength := 80;
    Ctl3d := FALSE;
    BorderStyle := bsSingle;  {OnKeyPress := EdDlgEditKeyPress;}
    Visible := FALSE;
  end;
  m_dwBlinkTime := GetTickCount;
  m_boViewBlink := False;
  m_ComboBox_ItemsIdx:=0;
  DWhisperInfoList := TStringList.create;
  WhisperPoints := TList.create;
  WhisperMoveed:= -1;
  WhisperSelect:= -1;
  WhisperTop:= -1;

  m_nShopPage := 0;
  m_nShopClass := 0;
  m_nShopItemIndex := -1;
  m_nShopItemIndex2 := -1;
end;

procedure TFrmDlg.FormDestroy(Sender: TObject);
var
  I:Integer;
begin
  for I := 0 to WhisperPoints.Count - 1 do begin
    if pTClickSLPoint(WhisperPoints[I]) <> nil then
      Dispose(pTClickSLPoint(WhisperPoints[i]))
  end;
  FreeAndNil(WhisperPoints);

  DlgTemp.Free;
  MDlgPoints.Free;  //埃窜洒..
  MenuList.Free;
  JangwonList.Free;
  GABoardList.Free;
  GADecorationList.Free;
  NAHelps.Free;
  GuildStrs.Free;
  GuildStrs2.Free;
  GuildNotice.Free;
  GABoard_Notice.Free;
  GuildMembers.Free;
  GuildChats.Free;
end;

procedure TFrmDlg.HideAllControls;
var
  i: integer;
  c: TControl;
begin
  DlgTemp.Clear;
  with FrmMain do
    for i := 0 to ControlCount - 1 do
    begin
      c := Controls[i];
      if c is TEdit then
        if (c.Visible) and (c <> DEdDlgEdit) then
        begin
          DlgTemp.Add(c);
          c.Visible := FALSE;
        end;
    end;
end;

procedure TFrmDlg.RestoreHideControls;
var
  i: integer;
  c: TControl;
begin
  for i := 0 to DlgTemp.Count - 1 do
  begin
    TControl(DlgTemp[i]).Visible := TRUE;
  end;
end;

procedure TFrmDlg.Initialize;  //霸烙阑 府胶配绢且锭付促 龋免凳
var
  i,j, dsrvtop, dsrvheight: integer;
  lx, ly: integer;
  d: TAsphyreLockableTexture;
begin
  g_DWinMan.ClearAll;

  DBackground.Left := 0;
  DBackground.Top := 0;
  DBackground.Width := g_FScreenWidth;
  DBackground.Height := g_FScreenHeight;
  DBackground.Background := TRUE;
  g_DWinMan.AddDControl(DBackground, TRUE);

   {-----------------------------------------------------------}

  DHint.Items.Clear;
  DHint.Items.Add('   剪切  ');
  DHint.Items.Add('   复制  ');
  DHint.Items.Add('   粘贴  ');
  DHint.Items.Add('   删除  ');
//  DHint.Items.Add('   全 选  ');
  DHint.Width := 80;
  DHint.Height := 20 * DHint.Items.Count + 6;

   //消息对话框
//  d := WProgUse.Images[360];
//  if d <> nil then
//  begin
    DMsgDlg.SetImgIndex(WProgUse, 360);
    DMsgDlg.Left := (g_FScreenWidth - 452) div 2;
    DMsgDlg.Top := (g_FScreenHeight - 179) div 2;
//  end;
  DMsgDlgOk.SetImgIndex(WProgUse, 361);
  DMsgDlgYes.SetImgIndex(WProgUse, 363);
  DMsgDlgCancel.SetImgIndex(WProgUse, 365);
  DMsgDlgNo.SetImgIndex(WProgUse, 367);
  DMsgDlgOk.Top := 126;
  DMsgDlgYes.Top := 126;
  DMsgDlgCancel.Top := 126;
  DMsgDlgNo.Top := 126;
  with DEdDlgEdit do begin
    Color := clBlack;
    Font.Color := clWhite;
    Font.Size := 10;
    MaxLength := 30;
    Height := 16;
    Ctl3d := FALSE;
    BorderStyle := bsSingle;
    Visible := FALSE;
  end;
   {-----------------------------------------------------------}

   // 登陆账号窗口
//  d := WProgUse.Images[660]; //背景
//  if d <> nil then
//  begin
    DCountDlg.SetImgIndex(WProgUse, 660);
    DCountDlg.Left := (g_FScreenWidth - 308) div 2;
    DCountDlg.Top := (g_FScreenHeight - 181) div 2;
//  end;
  DCountDlgMax.SetImgIndex(WProgUse, 662);
  DCountDlgOk.SetImgIndex(WProgUse, 663);
  DCountDlgCancel.SetImgIndex(WProgUse, 664);
  DCountDlgClose.SetImgIndex(WProgUse, 64);

   {-----------------------------------------------------------}
  //服务器选择窗口
//  d := WProgUse.Images[661];
//  if d <> nil then
//  begin
    DMakeItemDlg.SetImgIndex(WProgUse, 661);
    DMakeItemDlg.Left := (g_FScreenWidth - 268) div 2;
    DMakeItemDlg.Top := (g_FScreenHeight - 148) div 2;
//  end;

  DMakeitemGrid.Left := 16;
  DMakeitemGrid.Top := 13;
  DMakeitemGrid.Width := 240; //286;
  DMakeitemGrid.Height := 40; //80;

  lx := 163; //234;
  ly := 109; //141;

  DMakeItemDlgCancel.SetImgIndex(WProgUse, 674);  //664
  DMakeItemDlgCancel.Left := lx;
  DMakeItemDlgCancel.Top := ly;
  DMakeItemDlgCancel.Visible := True;
  lx := lx - 70;

  DMakeItemDlgOk.SetImgIndex(WProgUse, 691);  //663
  DMakeItemDlgOk.Left := lx;
  DMakeItemDlgOk.Top := ly;
  DMakeItemDlgOk.Visible := True;

  DMakeItemDlgClose.SetImgIndex(WProgUse, 64);
  DMakeItemDlgClose.Left := 246; //319;
  DMakeItemDlgClose.Top := 0;
  DMakeItemDlgClose.Visible := True;

  DMakeItemDlg.Floating := True;

   {-----------------------------------------------------------}
   //登陆对话框
//  d := WProgUse.Images[60];
//  if d <> nil then
//  begin
    DLogIn.SetImgIndex(WProgUse, 60);
    DLogIn.Left := (g_FScreenWidth - 296) div 2;
    DLogIn.Top := (g_FScreenHeight - 254) div 2;
//  end;
  DLoginNew.SetImgIndex(WProgUse, 61);
  DLoginNew.Left := 25;
  DLoginNew.Top := 207;
  DLoginOk.SetImgIndex(WProgUse, 62);
  DLoginOk.Left := 169;
  DLoginOk.Top := 164;
  DLoginChgPw.SetImgIndex(WProgUse, 53);
  DLoginChgPw.Left := 130;
  DLoginChgPw.Top := 207;
  DLoginClose.SetImgIndex(WProgUse, 64);
  DLoginClose.Left := 252;
  DLoginClose.Top := 28;

  DEditID.Left := 125-26;
  DEditID.Top := 75+17;
  DEditID.Width := 137;
  DEditID.Height := 12;
  DEditID.FMiniCaret := 4;


  DEditPass.Left := 125-26;
  DEditPass.Top := 107+17;
  DEditPass.Width := 137;
  DEditPass.Height := 12;
  DEditPass.FMiniCaret := 4;
   {-----------------------------------------------------------}


  DEngServer1.Visible := FALSE;

  DSServer1.Visible := FALSE;
  DSServer2.Visible := FALSE;
  DSServer3.Visible := FALSE;
  DSServer4.Visible := FALSE;
  DSServer5.Visible := FALSE;
  DSServer6.Visible := FALSE;
  DSServer7.Visible := FALSE;
  DSServer8.Visible := FALSE;

  if ServerCount >= 1 then
    DSServer1.Visible := TRUE;
  if ServerCount >= 2 then
    DSServer2.Visible := TRUE;
  if ServerCount >= 3 then
    DSServer3.Visible := TRUE;
  if ServerCount >= 4 then
    DSServer4.Visible := TRUE;
  if ServerCount >= 5 then
    DSServer5.Visible := TRUE;
  if ServerCount >= 6 then
    DSServer6.Visible := TRUE;
  if ServerCount >= 7 then
    DSServer7.Visible := TRUE;
  if ServerCount >= 8 then
    DSServer8.Visible := TRUE;

  if ServerCount <= 8 then
  begin
    dsrvheight := 42; //42;
    dsrvtop := 235 - (dsrvheight * ServerCount) div 2;

//    d := WProgUse.Images[256];  //2];
//    if d <> nil then
//    begin
      DSelServerDlg.SetImgIndex(WProgUse, 256);
      DSelServerDlg.Left := (g_FScreenWidth - 308) div 2;
      DSelServerDlg.Top := (g_FScreenHeight - 450) div 2;
//    end;
    DSSrvClose.SetImgIndex(WProgUse, 64);
    DSSrvClose.Left := 244;
    DSSrvClose.Top := 30;

    DSServer1.SetImgIndex(WProgUse2, 2); //82);
    DSServer1.Left := 63;
    DSServer1.Top := dsrvtop + 0 * dsrvheight; //102;

    DSServer2.SetImgIndex(WProgUse2, 2); //82);
    DSServer2.Left := 63;
    DSServer2.Top := dsrvtop + 1 * dsrvheight; //102;

    DSServer3.SetImgIndex(WProgUse2, 2); //82);
    DSServer3.Left := 63;
    DSServer3.Top := dsrvtop + 2 * dsrvheight; //102;

    DSServer4.SetImgIndex(WProgUse2, 2); //82);
    DSServer4.Left := 63;
    DSServer4.Top := dsrvtop + 3 * dsrvheight; //102;

    DSServer5.SetImgIndex(WProgUse2, 2); //82);
    DSServer5.Left := 63;
    DSServer5.Top := dsrvtop + 4 * dsrvheight; //102;

    DSServer6.SetImgIndex(WProgUse2, 2); //82);
    DSServer6.Left := 63;
    DSServer6.Top := dsrvtop + 5 * dsrvheight; //102;

    DSServer7.SetImgIndex(WProgUse2, 2); //82);
    DSServer7.Left := 63;
    DSServer7.Top := dsrvtop + 6 * dsrvheight; //102;

    DSServer8.SetImgIndex(WProgUse2, 2); //82);
    DSServer8.Left := 63;
    DSServer8.Top := dsrvtop + 7 * dsrvheight; //102;
  end;

  if (ServerCount > 8) and (ServerCount <= 16) then
  begin
    dsrvheight := 42;
    dsrvtop := 235 - (dsrvheight * 16{ServerCount}  div 2) div 2;

    d := WProgUse2.Images[4];
    if d <> nil then
    begin
      DSelServerDlg.SetImgIndex(WProgUse2, 4);
      DSelServerDlg.Left := (g_FScreenWidth - d.Width) div 2;
      DSelServerDlg.Top := (g_FScreenHeight - d.Height) div 2;
    end;
    DSSrvClose.SetImgIndex(WProgUse, 64);
    DSSrvClose.Left := 348;
    DSSrvClose.Top := 31;

    DSServer1.SetImgIndex(WProgUse2, 2); //82);
    DSServer1.Left := 25;
    DSServer1.Top := dsrvtop + 0 * dsrvheight; //102;

    DSServer2.SetImgIndex(WProgUse2, 2); //82);
    DSServer2.Left := 25;
    DSServer2.Top := dsrvtop + 1 * dsrvheight; //102;

    DSServer3.SetImgIndex(WProgUse2, 2); //82);
    DSServer3.Left := 25;
    DSServer3.Top := dsrvtop + 2 * dsrvheight; //102;

    DSServer4.SetImgIndex(WProgUse2, 2); //82);
    DSServer4.Left := 25;
    DSServer4.Top := dsrvtop + 3 * dsrvheight; //102;

    DSServer5.SetImgIndex(WProgUse2, 2); //82);
    DSServer5.Left := 25;
    DSServer5.Top := dsrvtop + 4 * dsrvheight; //102;

    DSServer6.SetImgIndex(WProgUse2, 2); //82);
    DSServer6.Left := 25;
    DSServer6.Top := dsrvtop + 5 * dsrvheight; //102;

    DSServer7.SetImgIndex(WProgUse2, 2); //82);
    DSServer7.Left := 25;
    DSServer7.Top := dsrvtop + 6 * dsrvheight; //102;

    DSServer8.SetImgIndex(WProgUse2, 2); //82);
    DSServer8.Left := 25;
    DSServer8.Top := dsrvtop + 7 * dsrvheight; //102;

  end;

  if (ServerCount > 16) then
  begin // and (ServerCount <= 24) then begin
    dsrvheight := 42;
    dsrvtop := 235 - (dsrvheight * 8) div 2;

    d := WProgUse2.Images[5];
    if d <> nil then
    begin
      DSelServerDlg.SetImgIndex(WProgUse2, 5);
      DSelServerDlg.Left := (g_FScreenWidth - d.Width) div 2;
      DSelServerDlg.Top := (g_FScreenHeight - d.Height) div 2;
    end;
    DSSrvClose.SetImgIndex(WProgUse, 64);
    DSSrvClose.Left := 527;
    DSSrvClose.Top := 35;

    DSServer1.SetImgIndex(WProgUse2, 2); //82);
    DSServer1.Left := 25;
    DSServer1.Top := dsrvtop + 0 * dsrvheight; //102;

    DSServer2.SetImgIndex(WProgUse2, 2); //82);
    DSServer2.Left := 25;
    DSServer2.Top := dsrvtop + 1 * dsrvheight; //102;

    DSServer3.SetImgIndex(WProgUse2, 2); //82);
    DSServer3.Left := 25;
    DSServer3.Top := dsrvtop + 2 * dsrvheight; //102;

    DSServer4.SetImgIndex(WProgUse2, 2); //82);
    DSServer4.Left := 25;
    DSServer4.Top := dsrvtop + 3 * dsrvheight; //102;

    DSServer5.SetImgIndex(WProgUse2, 2); //82);
    DSServer5.Left := 25;
    DSServer5.Top := dsrvtop + 4 * dsrvheight; //102;

    DSServer6.SetImgIndex(WProgUse2, 2); //82);
    DSServer6.Left := 25;
    DSServer6.Top := dsrvtop + 5 * dsrvheight; //102;

    DSServer7.SetImgIndex(WProgUse2, 2); //82);
    DSServer7.Left := 25;
    DSServer7.Top := dsrvtop + 6 * dsrvheight; //102;

    DSServer8.SetImgIndex(WProgUse2, 2); //82);
    DSServer8.Left := 25;
    DSServer8.Top := dsrvtop + 7 * dsrvheight; //102;

  end;



   {-----------------------------------------------------------}

   //新建账号窗口
  d := WProgUse.Images[63];
//  if d <> nil then
//  begin
    DNewAccount.SetImgIndex(WProgUse, 63);
    DNewAccount.Left := (g_FScreenWidth - 640) div 2;
    DNewAccount.Top := (g_FScreenHeight - 473) div 2;
//  end;
  DNewAccountOk.SetImgIndex(WProgUse, 62);
  DNewAccountOk.Left := 160;
  DNewAccountOk.Top := 417;
  DNewAccountCancel.SetImgIndex(WProgUse, 52);
  DNewAccountCancel.Left := 446;
  DNewAccountCancel.Top := 419;
  DNewAccountClose.SetImgIndex(WProgUse, 64);
  DNewAccountClose.Left := 587;
  DNewAccountClose.Top := 33;
   {-----------------------------------------------------------}
   //LOGO窗口
//   DLOGO.Left := 0;
//   DLOGO.Top := 0;
//   DLOGO.Width := 800;
//   DLOGO.Height := 600;
   {-----------------------------------------------------------}

   //修改密码窗口
//  d := WProgUse.Images[50];
//  if d <> nil then
//  begin
    DChgPw.SetImgIndex(WProgUse, 50);
    DChgPw.Left := (g_FScreenWidth - 420) div 2;
    DChgPw.Top := (g_FScreenHeight - 299) div 2;
//  end;
  DChgpwOk.SetImgIndex(WProgUse, 81);
  DChgPwOk.Left := 181;
  DChgPwOk.Top := 253;
  DChgpwCancel.SetImgIndex(WProgUse, 52);
  DChgPwCancel.Left := 276;
  DChgPwCancel.Top := 252;

   {-----------------------------------------------------------}

   //选择角色窗口
  DSelectChr.Left := 0;
  DSelectChr.Top := 0;
  DSelectChr.Width := g_FScreenWidth;
  DSelectChr.Height := g_FScreenHeight;
  DscSelect1.SetImgIndex(WProgUse, 66);
  DscSelect2.SetImgIndex(WProgUse, 67);
  DscStart.SetImgIndex(WProgUse, 68);
  DscNewChr.SetImgIndex(WProgUse, 69);
  DscEraseChr.SetImgIndex(WProgUse, 70);
  DscCredits.SetImgIndex(WProgUse, 71);
  DscExit.SetImgIndex(WProgUse, 72);

  DscSelect1.Left := (g_FScreenWidth - DEFSCREENWIDTH) div 2 + 133;
  DscSelect1.Top := (g_FScreenHeight - DEFSCREENHEIGHT) div 2 + 453;
  DscSelect2.Left := (g_FScreenWidth - DEFSCREENWIDTH) div 2 + 685;
  DscSelect2.Top := (g_FScreenHeight - DEFSCREENHEIGHT) div 2 + 454;
  DscStart.Left := (g_FScreenWidth - DEFSCREENWIDTH) div 2 + 385;
  DscStart.Top := (g_FScreenHeight - DEFSCREENHEIGHT) div 2 + 456;
  DscNewChr.Left := (g_FScreenWidth - DEFSCREENWIDTH) div 2 + 348;
  DscNewChr.Top := (g_FScreenHeight - DEFSCREENHEIGHT) div 2 + 486;
  DscEraseChr.Left := (g_FScreenWidth - DEFSCREENWIDTH) div 2 + 347;
  DscEraseChr.Top := (g_FScreenHeight - DEFSCREENHEIGHT) div 2 + 506;
  DscCredits.Left := (g_FScreenWidth - DEFSCREENWIDTH) div 2 + 362;
  DscCredits.Top := (g_FScreenHeight - DEFSCREENHEIGHT) div 2 + 527;
  DscExit.Left := (g_FScreenWidth - DEFSCREENWIDTH) div 2 + 379;
  DscExit.Top := (g_FScreenHeight - DEFSCREENHEIGHT) div 2 + 547;

   {-----------------------------------------------------------}

   //创建角色窗口

   //创建角色窗口
//  d := WProgUse.Images[73];
//  if d <> nil then
//  begin
    DCreateChr.SetImgIndex(WProgUse, 73);
    DCreateChr.Left := (g_FScreenWidth - 300) div 2;
    DCreateChr.Top := (g_FScreenHeight - 417) div 2;
//  end;
  DccWarrior.SetImgIndex(WProgUse, 74);
  DccWizzard.SetImgIndex(WProgUse, 75);
  DccMonk.SetImgIndex(WProgUse, 76);
   //DccReserved.SetImgIndex (WProgUse.Images[76], TRUE);
  DccMale.SetImgIndex(WProgUse, 77);
  DccFemale.SetImgIndex(WProgUse, 78);
  DccLeftHair.SetImgIndex(WProgUse, 79);
  DccRightHair.SetImgIndex(WProgUse, 80);
  DccOk.SetImgIndex(WProgUse, 62);
  DccClose.SetImgIndex(WProgUse, 64);
  DccWarrior.Left := 48;
  DccWarrior.Top := 157;
  DccWizzard.Left := 93;
  DccWizzard.Top := 157;
  DccMonk.Left := 138;
  DccMonk.Top := 157;
      //DccReserved.Left := 183;
      //DccReserved.Top := 157;
  DccMale.Left := 93;
  DccMale.Top := 231;
  DccFemale.Left := 138;
  DccFemale.Top := 231;
  DccLeftHair.Left := 76;
  DccLeftHair.Top := 308;
  DccRightHair.Left := 170;
  DccRightHair.Top := 308;
  DccClose.Left := 248;
  DccClose.Top := 31;
  DccOk.Left := 102;
  DccOk.Top := 359;

  with DEditChrName do begin
    Height := 16;
    Width := 136;
    Left := 72;
    Top := 108;
    MaxLength := 14;
  end;
   {-----------------------------------------------------------}
   //人物状态窗口
//  d := WProgUse.Images[370];  //惑怕
//  if d <> nil then
//  begin
    DStateWin.SetImgIndex(WProgUse, 370);
    DStateWin.Left := g_FScreenWidth - 232;
    DStateWin.Top := 0;
//  end;
  DSWNecklace.Left := 38 + 130;
  DSWNecklace.Top := 52 + 35;
  DSWNecklace.Width := 34;
  DSWNecklace.Height := 31;
  DSWHelmet.Left := 38 + 77;
  DSWHelmet.Top := 52 + 41;
  DSWHelmet.Width := 18;
  DSWHelmet.Height := 18;
  DSWLight.Left := 38 + 130;
  DSWLight.Top := 52 + 73;
  DSWLight.Width := 34;
  DSWLight.Height := 31;
  DSWArmRingR.Left := 38 + 4;
  DSWArmRingR.Top := 52 + 124;
  DSWArmRingR.Width := 34;
  DSWArmRingR.Height := 31;
  DSWArmRingL.Left := 38 + 130;
  DSWArmRingL.Top := 52 + 124;
  DSWArmRingL.Width := 34;
  DSWArmRingL.Height := 31;
  DSWRingR.Left := 38 + 4;
  DSWRingR.Top := 52 + 163;
  DSWRingR.Width := 34;
  DSWRingR.Height := 31;
  DSWRingL.Left := 38 + 130;
  DSWRingL.Top := 52 + 163;
  DSWRingL.Width := 34;
  DSWRingL.Height := 31;
  DSWWeapon.Left := 38 + 9;
  DSWWeapon.Top := 52 + 28;
  DSWWeapon.Width := 47;
  DSWWeapon.Height := 87;
  DSWDress.Left := 38 + 58;
  DSWDress.Top := 52 + 70;
  DSWDress.Width := 53;
  DSWDress.Height := 112;
      // 2003/03/15 酒捞袍 牢亥配府 犬厘
  DSWBujuk.Left := 38 + 4;
  DSWBujuk.Top := 52 + 202;
  DSWBujuk.Width := 34;
  DSWBujuk.Height := 31;
  DSWBelt.Left := 38 + 46;
  DSWBelt.Top := 52 + 202;
  DSWBelt.Width := 34;
  DSWBelt.Height := 31;
  DSWBoots.Left := 38 + 88;
  DSWBoots.Top := 52 + 202;
  DSWBoots.Width := 34;
  DSWBoots.Height := 31;
  DSWCharm.Left := 38 + 130;
  DSWCharm.Top := 52 + 202;
  DSWCharm.Width := 34;
  DSWCharm.Height := 31;

  ButTrans.Left := 42;
  ButTrans.Top := 135;
  ButTrans.Width := 36;
  ButTrans.Height := 36;

  DCheckBoxTrans.SetImgIndex(WProgUse, 333);
  DCheckBoxTrans.Left := 80;
  DCheckBoxTrans.Top := 230;
  DCheckBoxTrans.Checked := True;
//------------------------------------------------ 技能解读框框设置
  DStMag1.Left := 38 + 8;//左   +1   -1   +就是向右 -就是向左
  DStMag1.Top := 52 + 5; //右   +1  -1   +是下 -是上
  DStMag1.Width := 30; //宽
  DStMag1.Height := 30;//高

  DStMag2.Left := 38 + 8;
  DStMag2.Top := 52 + 44;
  DStMag2.Width := 30;
  DStMag2.Height := 30;

  DStMag3.Left := 38 + 8;
  DStMag3.Top := 52 + 82;
  DStMag3.Width := 30;
  DStMag3.Height := 30;

  DStMag4.Left := 38 + 8;
  DStMag4.Top := 52 + 119;
  DStMag4.Width := 30;
  DStMag4.Height := 30;

  DStMag5.Left := 38 + 8;
  DStMag5.Top := 52 + 156;
  DStMag5.Width := 30;
  DStMag5.Height := 30;

  DStMag6.Left := 38 + 8;
  DStMag6.Top := 52 + 156 + 156 - 119;
  DStMag6.Width := 30;
  DStMag6.Height := 30;
//-----------------------------------------
  DStPageUp.SetImgIndex(WProgUse, 398);
  DStPageDown.SetImgIndex(WProgUse, 396);
  DStPageUp.Left := 213;
  DStPageUp.Top := 113;
  DStPageDown.Left := 213;
  DStPageDown.Top := 143;

  DCloseState.SetImgIndex(WProgUse, 371);
  DCloseState.Left := 8;
  DCloseState.Top := 39;
  DPrevState.SetImgIndex(WProgUse, 373);
  DNextState.SetImgIndex(WProgUse, 372);
  DPrevState.Left := 7;
  DPrevState.Top := 128;
  DNextState.Left := 7;
  DNextState.Top := 187;
  DHeartImg.SetImgIndex(WProgUse, 604);

   {-----------------------------------------------------------}

   //人物状态窗口(查看别人信息)
//  d := WProgUse.Images[370];  //惑怕
//  if d <> nil then
//  begin
    DUserState1.SetImgIndex(WProgUse, 370);
    DUserState1.Left := g_FScreenWidth - 232 - 232;
    DUserState1.Top := 0;
//  end;
  DNecklaceUS1.Left := 38 + 130;
  DNecklaceUS1.Top := 52 + 35;
  DNecklaceUS1.Width := 34;
  DNecklaceUS1.Height := 31;
  DHelmetUS1.Left := 38 + 77;
  DHelmetUS1.Top := 52 + 41;
  DHelmetUS1.Width := 18;
  DHelmetUS1.Height := 18;
  DLightUS1.Left := 38 + 130;
  DLightUS1.Top := 52 + 73;
  DLightUS1.Width := 34;
  DLightUS1.Height := 31;
  DArmRingRUS1.Left := 38 + 4;
  DArmRingRUS1.Top := 52 + 124;
  DArmRingRUS1.Width := 34;
  DArmRingRUS1.Height := 31;
  DArmRingLUS1.Left := 38 + 130;
  DArmRingLUS1.Top := 52 + 124;
  DArmRingLUS1.Width := 34;
  DArmRingLUS1.Height := 31;
  DRingRUS1.Left := 38 + 4;
  DRingRUS1.Top := 52 + 163;
  DRingRUS1.Width := 34;
  DRingRUS1.Height := 31;
  DRingLUS1.Left := 38 + 130;
  DRingLUS1.Top := 52 + 163;
  DRingLUS1.Width := 34;
  DRingLUS1.Height := 31;
  DWeaponUS1.Left := 38 + 9;
  DWeaponUS1.Top := 52 + 28;
  DWeaponUS1.Width := 47;
  DWeaponUS1.Height := 87;
  DDressUS1.Left := 38 + 58;
  DDressUS1.Top := 52 + 70;
  DDressUS1.Width := 53;
  DDressUS1.Height := 112;

      // 2003/03/15 酒捞袍 牢亥配府 犬厘
  DBujukUS1.Left := 38 + 4;
  DBujukUS1.Top := 52 + 202;
  DBujukUS1.Width := 34;
  DBujukUS1.Height := 31;
  DBeltUS1.Left := 38 + 46;
  DBeltUS1.Top := 52 + 202;
  DBeltUS1.Width := 34;
  DBeltUS1.Height := 31;
  DBootsUS1.Left := 38 + 88;
  DBootsUS1.Top := 52 + 202;
  DBootsUS1.Width := 34;
  DBootsUS1.Height := 31;
  DCharmUS1.Left := 38 + 130;
  DCharmUS1.Top := 52 + 202;
  DCharmUS1.Width := 34;
  DCharmUS1.Height := 31;
  UserButTrans.Left := 42;
  UserButTrans.Top := 135;
  UserButTrans.Width := 36;
  UserButTrans.Height := 36;
  DCloseUS1.SetImgIndex(WProgUse, 371);
  DCloseUS1.Left := 8;
  DCloseUS1.Top := 39;
  DHeartImgUS.SetImgIndex(WProgUse, 604);

  {-------------------------------------------------------------}
  if NOT g_bo物品窗口 then  BEGIN
   //物品包裹栏
  DItemBag.SetImgIndex(WProgUse, 3);
  DItemBag.Left := 0;
  DItemBag.Top := 0;
  DItemGrid.Left := 20;
  DItemGrid.Top := 13;
  DItemGrid.Width := 286;
  DItemGrid.Height := 162;
   //黄金、修理物品、关闭包裹按钮
  DGold.SetImgIndex(WProgUse, 29);
  DGold.Left := 10;
  DGold.Top := 190;
  DRepairItem.SetImgIndex(WProgUse, 26);
  DRepairItem.Left := 254;
  DRepairItem.Top := 183;
  DRepairItem.Width := 48;
  DRepairItem.Height := 22;
  DClosebag.SetImgIndex(WProgUse, 371);
  DCloseBag.Left := 309;
  DCloseBag.Top := 203;
  DCloseBag.Width := 14;
  DCloseBag.Height := 20;
  END ELSE BEGIN//==============  以下是新包裹
   //新物品包裹栏
  DItemBag.SetImgIndex(WProgUse, 41);
  DItemBag.Left := 0;
  DItemBag.Top := 0;
  DItemGrid.Left := 29;
  DItemGrid.Top := 41;
  DItemGrid.Width := 286;
  DItemGrid.Height := 162;
   //新黄金、修理物品、关闭包裹按钮
  DGold.SetImgIndex(WProgUse, 29);
  DGold.Left := 18;
  DGold.Top := 218;
  DRepairItem.SetImgIndex(WProgUse, 42);
  DRepairItem.Left := 232;
  DRepairItem.Top := 206;
  DRepairItem.Width := 48;
  DRepairItem.Height := 22;
  DClosebag.SetImgIndex(WProgUse, 371);
  DCloseBag.Left := 337;
  DCloseBag.Top := 59;
  DCloseBag.Width := 14;
  DCloseBag.Height := 20;
  END;


  BoUpItemEffect := FALSE;
   {-----------------------------------------------------------}

   //主控面板
  if g_bo主界面 then
  begin
  if g_FScreenWidth = 1024 then d := WProgUse.Images[BOTTOMBOARD1024]
  else d := WProgUse.Images[BOTTOMBOARD];
  if d <> nil then
  begin
    DBottom.Left := 0;
    DBottom.Top := g_FScreenHeight - 251;
    DBottom.Width := g_FScreenWidth;
    DBottom.Height := 251;
  end;
  end else begin
  if g_FScreenWidth = 1024 then d := WProgUse.Images[45]
  else d := WProgUse.Images[44];
  if d <> nil then
  begin
    DBottom.Left := 0;
    DBottom.Top := g_FScreenHeight - 251;
    DBottom.Width := g_FScreenWidth;
    DBottom.Height := 251;
  end;
  end;
  DBottom.FRightClick := True;

   {-----------------------------------------------------------}

   //底部状态栏的4个快捷按钮
  DMyState.SetImgIndex(WProgUse, 8);
  DMyState.Left := g_FScreenWidth-157;
  DMyState.Top := 61;
  DMyBag.SetImgIndex(WProgUse, 9);
  DMyBag.Left := g_FScreenWidth-118;
  DMyBag.Top := 41;
  DMyMagic.SetImgIndex(WProgUse, 10);
  DMyMagic.Left := g_FScreenWidth-78;
  DMyMagic.Top := 21;
  DOption.SetImgIndex(WProgUse, 11);
  DOption.Left := g_FScreenWidth-36;
  DOption.Top := 11;

   {-----------------------------------------------------------}

   //底部状态栏的小地图、交易、行会、组按钮
  DBotMiniMap.SetImgIndex(WProgUse, 130);
  DBotMiniMap.Left := 207;
  DBotMiniMap.Top := 104;
  DBotTrade.SetImgIndex(WProgUse, 132);
  DBotTrade.Left := 207 + 30; //560 - 30;
  DBotTrade.Top := 104;
  DBotGuild.SetImgIndex(WProgUse, 134);
  DBotGuild.Left := 207 + 30 * 2;
  DBotGuild.Top := 104;
  DBotGroup.SetImgIndex(WProgUse, 128);
  DBotGroup.Left := 207 + 30 * 3;
  DBotGroup.Top := 104;
  DBotGroup.FRightClick := True;
  DBotPlusAbil.SetImgIndex(WProgUse, 140); //加点
  DBotPlusAbil.Left := 207 + 30 * 6{4};
  DBotPlusAbil.Top := 104;
   // 2003/04/15 朋友, 敌人
  DBotFriend.SetImgIndex(WProgUse, 260); //朋友
  DBotFriend.Left := 207 + 30 * 6;
  DBotFriend.Top := 104;
  DBotMaster.SetImgIndex(WProgUse, 528); //夫妻
  DBotMaster.Left := 207 + 30 * 5;
  DBotMaster.Top := 104;
//-20191314
  DBotMaster1.SetImgIndex(WProgUse, 736); //摆摊
  DBotMaster1.Left := 207 + 30 * 4{6};
  DBotMaster1.Top := 104;
  DBotHelp.SetImgIndex(WProgUse, 313); //帮助素材
  DBotHelp.Left := 207 + 30 * 7;
  DBotHelp.Top := 104;
  DBotWhisper.SetImgIndex(WProgUse, 167); //私聊
  DBotWhisper.Left := 207 + 30 * 5;
  DBotWhisper.Top := 104;
  DBotShop.SetImgIndex(WProgUse, 147);
  DBotShop.Left := g_FScreenWidth-47;
  DBotShop.Top  := 204;


  DBotHostpot.SetImgIndex(WProgUse, 324); //摆摊
  DBotHostpot.Left := 171;
  DBotHostpot.Top := 60;
  DBotQuestions.SetImgIndex(WProgUse, 321); //摆摊
  DBotQuestions.Left := g_FScreenWidth - 200;
  DBotQuestions.Top := 60;
//-
  DBotMemo.SetImgIndex(WProgUse, 532); //邮件
  DBotMemo.Left := g_FScreenWidth-47;
  DBotMemo.Top := 204;
  DBotExit.SetImgIndex(WProgUse, 138);
  DBotExit.Left := g_FScreenWidth-240;
  DBotExit.Top := 104;
  DBotLogout.SetImgIndex(WProgUse, 136);
  DBotLogout.Left := g_FScreenWidth-270;
  DBotLogout.Top := 104;

//  d := WProgUse.Images[BOTTOMBOARD];
//  if d <> nil then begin
     DHelpDlg.SetImgIndex(WProgUse, 292);
     DHelpDlg.Left := 0;
     DHelpDlg.Top := 0;
//  end;
  DHelpDlgClose.SetImgIndex(WProgUse, 308);
  DHelpDlgClose.Left := (g_FScreenWidth-60) div 2;
  DHelpDlgClose.Top := (g_FScreenHeight-22) div 2;;

  DHelpDlgLeft.SetImgIndex(WProgUse, 295);
  DHelpDlgLeft.Left := 30;
  DHelpDlgLeft.Top := g_FScreenHeight-255;;
  DHelpDlgCentre.SetImgIndex(WProgUse, 298);
  DHelpDlgCentre.Left := (g_FScreenWidth-228) div 2;
  DHelpDlgCentre.Top := g_FScreenHeight-240;
  DHelpDlgRight.SetImgIndex(WProgUse, 301);
  DHelpDlgRight.Left := g_FScreenWidth-230;
  DHelpDlgRight.Top := g_FScreenHeight-275;;
   {-----------------------------------------------------------}

      //喊话信息快捷栏
   RefusePublicChat.SetImgIndex(WProgUse,280); //拒绝所有公聊信息
   RefusePublicChat.Left:=176;
   RefusePublicChat.Top:=120;
   RefusePublicChat.Visible :=  g_bo主界面;

   RefuseCRY.SetImgIndex(WProgUse,282);    //拒绝所有喊话信息
   RefuseCRY.Left:=176;
   RefuseCRY.Top:=140;
   RefuseCRY.Visible := g_bo主界面;

   RefuseWHISPER.SetImgIndex(WProgUse,284);   //拒绝所有私聊信息
   RefuseWHISPER.Left:=176;
   RefuseWHISPER.Top:=160;
   RefuseWHISPER.Visible := g_bo主界面;

   Refuseguild.SetImgIndex(WProgUse,286);  //拒绝行会聊天信息
   Refuseguild.Left:=176;
   Refuseguild.Top:=180;
   Refuseguild.Visible := g_bo主界面;

   AutoCRY.SetImgIndex(WProgUse,288);   //自动喊话开关
   AutoCRY.Left:=176;
   AutoCRY.Top:=200;
   AutoCRY.Visible := g_bo主界面;

   //吃药快捷栏
  DBelt1.Left := (g_FScreenWidth div 2)-115;
  DBelt1.Width := 32;
  DBelt1.Top := 59;
  DBelt1.Height := 29;
  DBelt2.Left := (g_FScreenWidth div 2)-72;
  DBelt2.Width := 32;
  DBelt2.Top := 59;
  DBelt2.Height := 29;
  DBelt3.Left := (g_FScreenWidth div 2)-29;
  DBelt3.Width := 32;
  DBelt3.Top := 59;
  DBelt3.Height := 29;
  DBelt4.Left := (g_FScreenWidth div 2)+15;
  DBelt4.Width := 32;
  DBelt4.Top := 59;
  DBelt4.Height := 29;
  DBelt5.Left := (g_FScreenWidth div 2)+59;
  DBelt5.Width := 32;
  DBelt5.Top := 59;
  DBelt5.Height := 29;
  DBelt6.Left := (g_FScreenWidth div 2)+103;
  DBelt6.Width := 32;
  DBelt6.Top := 59;
  DBelt6.Height := 29;
   {-----------------------------------------------------------}

   //商人对话框
//  d := WProgUse.Images[384];
//  if d <> nil then
//  begin
    DMerchantDlg.Left := 0;
    DMerchantDlg.Top := 0;
    DMerchantDlg.SetImgIndex(WProgUse, 384);
//  end;
  DMerchantDlgClose.Left := 399;
  DMerchantDlgClose.Top := 1;
  DMerchantDlgClose.SetImgIndex(WProgUse, 64);

   {-----------------------------------------------------------}

   //菜单对话框
//  d := WProgUse.Images[385];
//  if d <> nil then
//  begin
    DMenuDlg.Left := 138;
    DMenuDlg.Top := 163;
    DMenuDlg.SetImgIndex(WProgUse, 385);
//  end;
  DMenuPrev.Left := 43;
  DMenuPrev.Top := 175;
  DMenuPrev.SetImgIndex(WProgUse, 388);
  DMenuNext.Left := 90;
  DMenuNext.Top := 175;
  DMenuNext.SetImgIndex(WProgUse, 387);
  DMenuBuy.Left := 215;
  DMenuBuy.Top := 171;
  DMenuBuy.SetImgIndex(WProgUse, 386);
  DMenuClose.Left := 291;
  DMenuClose.Top := 0;
  DMenuClose.SetImgIndex(WProgUse, 64);

    DWindowSaveItem.Left := 0;
    DWindowSaveItem.Top := 176;
   // DWindowSaveItem.SetImgIndex(NewUI, 0);
    DWindowSaveItem.SetImgIndex(WProgUse, 802);
    DGridSaveItem.Left := 15;
    DGridSaveItem.Top := 13;
    DGridSaveItem.Width := 370;
    DGridSaveItem.Height := 262;
    DGridSaveItem.ColWidth := 31;
    DGridSaveItem.RowHeight := 31;
    DGridSaveItem.Coloffset := 1+5;//可视化仓库{@z底志托  @{l就行  1+1+1e太大了
    DGridSaveItem.Rowoffset := 1+1;//可视化仓库{@z底志托
   {-----------------------------------------------------------}

   //拍卖系统  //2004/01/15 ItemMarket..
//  d := WProgUse.Images[670];
//  if d <> nil then
//  begin
    DItemMarketDlg.Left := 0;
    DItemMarketDlg.Top := 90;
    DItemMarketDlg.SetImgIndex(WProgUse, 670);
//  end;

  DItemListPrev.Left := 216;
  DItemListPrev.Top := 355;
  DItemListPrev.SetImgIndex(WProgUse, 388);
  DItemListNext.Left := 303;
  DItemListNext.Top := 355;
  DItemListNext.SetImgIndex(WProgUse, 387);
  DItemListRefresh.Left := 259;
  DItemListRefresh.Top := 356;
  DItemListRefresh.SetImgIndex(WProgUse, 671);

  DItemBuy.Left := 330;
  DItemBuy.Top := 326; //418;
  DItemBuy.SetImgIndex(WProgUse, 672);
  DItemSellCancel.Left := 330;
  DItemSellCancel.Top := 326; //418;
  DItemSellCancel.SetImgIndex(WProgUse, 544);
  DItemCancel.Left := 396;
  DItemCancel.Top := 325; //418;
  DItemCancel.SetImgIndex(WProgUse, 674);
  DItemFind.Left := 145;
  DItemFind.Top := 327; //417;
  DItemFind.SetImgIndex(WProgUse, 676);
  DMarketMemo.Left := 305; //258;
  DMarketMemo.Top := 326;
  DMarketMemo.SetImgIndex(WProgUse, 681);

  DMGold.Visible := False;
//   DMGold.SetImgIndex (WProgUse, 29); //捣农扁 3俺 鞍澜
//   DMGold.Left := 465;
//   DMGold.Top  := 226;

  DItemMarketClose.Left := 447;
  DItemMarketClose.Top := 7;
  DItemMarketClose.SetImgIndex(WProgUse, 64);
   {-----------------------------------------------------------}

   //装饰品买？ //2004/06/18
//  d := WProgUse.Images[702];
//  if d <> nil then
//  begin
    DGADecorateDlg.Left := 0;
    DGADecorateDlg.Top := 55; //90;
    DGADecorateDlg.SetImgIndex(WProgUse, 702);
//  end;

  DGADecorateListPrev.Left := 150;
  DGADecorateListPrev.Top := 361;
  DGADecorateListPrev.SetImgIndex(WProgUse, 388);
  DGADecorateListNext.Left := 237;
  DGADecorateListNext.Top := 361;
  DGADecorateListNext.SetImgIndex(WProgUse, 387);

  DGADecorateBuy.Left := 211;
  DGADecorateBuy.Top := 304;
  DGADecorateBuy.SetImgIndex(WProgUse, 672);
  DGADecorateCancel.Left := 211;
  DGADecorateCancel.Top := 328;
  DGADecorateCancel.SetImgIndex(WProgUse, 674);
  DGADecorateClose.Left := 581; //410;
  DGADecorateClose.Top := 6;
  DGADecorateClose.SetImgIndex(WProgUse, 64);

   {-----------------------------------------------------------}

//  d := WProgUse.Images[680];
//  if d <> nil then
//  begin
    DJangwonListDlg.Left := 0;
    DJangwonListDlg.Top := 175;
    DJangwonListDlg.SetImgIndex(WProgUse, 680);
//  end;

  DJangListPrev.Left := 208; //152;
  DJangListPrev.Top := 199;
  DJangListPrev.SetImgIndex(WProgUse, 388);
  DJangListNext.Left := 298; //242;
  DJangListNext.Top := 199;
  DJangListNext.SetImgIndex(WProgUse, 387);
  DJangMemo.Left := 254; //197;
  DJangMemo.Top := 193;
  DJangMemo.SetImgIndex(WProgUse, 681);

  DMGold.Visible := False;
//   DMGold.SetImgIndex (WProgUse, 29); //捣农扁 3俺 鞍澜
//   DMGold.Left := 465;
//   DMGold.Top  := 226;

  DJangwonClose.Left := 522; //410;
  DJangwonClose.Top := 0;
  DJangwonClose.SetImgIndex(WProgUse, 64);

   {-----------------------------------------------------------}
   //庄园公告牌
//  d := WProgUse.Images[688];
//  if d <> nil then
//  begin
    DGABoardListDlg.Left := 0;
    DGABoardListDlg.Top := 175;
    DGABoardListDlg.SetImgIndex(WProgUse, 688);
//  end;

  DGABoardOk.Left := 344;
  DGABoardOk.Top := 262;
  DGABoardOk.SetImgIndex(WProgUse, 691);
  DGABoardWrite.Left := 275;
  DGABoardWrite.Top := 262;
  DGABoardWrite.SetImgIndex(WProgUse, 693);
  DGABoardNotice.Left := 206;
  DGABoardNotice.Top := 262;
  DGABoardNotice.SetImgIndex(WProgUse, 695);

  DGABoardListPrev.Left := 61;
  DGABoardListPrev.Top := 280;
  DGABoardListPrev.SetImgIndex(WProgUse, 388);
  DGABoardListNext.Left := 148;
  DGABoardListNext.Top := 280;
  DGABoardListNext.SetImgIndex(WProgUse, 387);
  DGABoardListRefresh.Left := 104;
  DGABoardListRefresh.Top := 281;
  DGABoardListRefresh.SetImgIndex(WProgUse, 671);

  DGABoardListClose.Left := 401;
  DGABoardListClose.Top := 6;
  DGABoardListClose.SetImgIndex(WProgUse, 64);

   {-----------------------------------------------------------}
   //庄园公告牌消息修改
//  d := WProgUse.Images[689];
//  if d <> nil then
//  begin
    DGABoardDlg.Left := 0;
    DGABoardDlg.Top := 175;
    DGABoardDlg.SetImgIndex(WProgUse, 689);
//  end;

  DGABoardDel.Left := 19;
  DGABoardDel.Top := 186;
  DGABoardDel.SetImgIndex(WProgUse, 697);
  DGABoardMemo.Left := 85;
  DGABoardMemo.Top := 186;
  DGABoardMemo.SetImgIndex(WProgUse, 681);

  DGABoardReply.Left := 109;
  DGABoardReply.Top := 186;
  DGABoardReply.SetImgIndex(WProgUse, 699);
  DGABoardOk2.Left := 175;
  DGABoardOk2.Top := 186;
  DGABoardOk2.SetImgIndex(WProgUse, 691);
  DGABoardCancel.Left := 241;
  DGABoardCancel.Top := 186;
  DGABoardCancel.SetImgIndex(WProgUse, 674);

  DGABoardClose.Left := 291;
  DGABoardClose.Top := 8;
  DGABoardClose.SetImgIndex(WProgUse, 64);

   {-----------------------------------------------------------}

   //出售对话框
//  d := WProgUse.Images[392];
//  if d <> nil then
//  begin
    DSellDlg.Left := 328;
    DSellDlg.Top := 163;
    DSellDlg.SetImgIndex(WProgUse, 392);
//  end;
  DSellDlgOk.Left := 85;
  DSellDlgOk.Top := 150;
  DSellDlgOk.SetImgIndex(WProgUse, 393);
  DSellDlgClose.Left := 115;
  DSellDlgClose.Top := 0;
  DSellDlgClose.SetImgIndex(WProgUse, 64);
  DSellDlgSpot.Left := 27;
  DSellDlgSpot.Top := 67;
  DSellDlgSpot.Width := 61;
  DSellDlgSpot.Height := 52;

   {-----------------------------------------------------------}

   //设置魔法快捷对话框
//  d := WProgUse.Images[620];
//  if d <> nil then
//  begin
    DKeySelDlg.Left := (g_FScreenWidth - 376) div 2;
    DKeySelDlg.Top := (g_FScreenHeight - 179) div 2;
    DKeySelDlg.SetImgIndex(WProgUse, 620);
//  end;
  DKsIcon.Left := 51;  //DMagIcon...
  DKsIcon.Top := 31;
  DKsF1.SetImgIndex(WProgUse, 232);
  DKsF1.Left := 25; //34; //-9
  DKsF1.Top := 78; //83; //-4
  DKsF2.SetImgIndex(WProgUse, 234);
  DKsF2.Left := 57; //66;
  DKsF2.Top := 78; //83;
  DKsF3.SetImgIndex(WProgUse, 236);
  DKsF3.Left := 89; //98;
  DKsF3.Top := 78; //83;
  DKsF4.SetImgIndex(WProgUse, 238);
  DKsF4.Left := 121; ////130;
  DKsF4.Top := 78;
  DKsF5.SetImgIndex(WProgUse, 240);
  DKsF5.Left := 160; //171; //-11
  DKsF5.Top := 78;
  DKsF6.SetImgIndex(WProgUse, 242);
  DKsF6.Left := 192; //203;
  DKsF6.Top := 78;
  DKsF7.SetImgIndex(WProgUse, 244);
  DKsF7.Left := 224; //235;
  DKsF7.Top := 78;
  DKsF8.SetImgIndex(WProgUse, 246);
  DKsF8.Left := 256; //267;
  DKsF8.Top := 78;
  DKsConF1.SetImgIndex(WProgUse, 626);
  DKsConF1.Left := 25;
  DKsConF1.Top := 120;
  DKsConF2.SetImgIndex(WProgUse, 628);
  DKsConF2.Left := 57;
  DKsConF2.Top := 120;
  DKsConF3.SetImgIndex(WProgUse, 630);
  DKsConF3.Left := 89;
  DKsConF3.Top := 120;
  DKsConF4.SetImgIndex(WProgUse, 632);
  DKsConF4.Left := 121;
  DKsConF4.Top := 120;
  DKsConF5.SetImgIndex(WProgUse, 634);
  DKsConF5.Left := 160;
  DKsConF5.Top := 120;
  DKsConF6.SetImgIndex(WProgUse, 636);
  DKsConF6.Left := 192;
  DKsConF6.Top := 120;
  DKsConF7.SetImgIndex(WProgUse, 638);
  DKsConF7.Left := 224;
  DKsConF7.Top := 120;
  DKsConF8.SetImgIndex(WProgUse, 640);
  DKsConF8.Left := 256;
  DKsConF8.Top := 120;
  DKsNone.SetImgIndex(WProgUse, 624);
  DKsNone.Left := 296; //299;//-2
  DKsNone.Top := 78; //83;//-4
  DKsOk.SetImgIndex(WProgUse, 621);
  DKsOk.Left := 296; //222;
  DKsOk.Top := 120; //131;

   {-----------------------------------------------------------}
   //组对话框
//  d := WProgUse.Images[120];
//  if d <> nil then
//  begin
    DGroupDlg.Left := (g_FScreenWidth - 276) div 2;
    DGroupDlg.Top := (g_FScreenHeight - 242) div 2;
    DGroupDlg.SetImgIndex(WProgUse, 120);
//  end;
  DGrpDlgClose.SetImgIndex(WProgUse, 64);
  DGrpDlgClose.Left := 260;
  DGrpDlgClose.Top := 0;
  DGrpAllowGroup.SetImgIndex(WProgUse, 122);
  DGrpAllowGroup.Left := 20;
  DGrpAllowGroup.Top := 18;
  DGrpCreate.SetImgIndex(WProgUse, 123);
  DGrpCreate.Left := 21 + 1;
  DGrpCreate.Top := 202 + 1;
  DGrpAddMem.SetImgIndex(WProgUse, 124);
  DGrpAddMem.Left := 96 + 1;
  DGrpAddMem.Top := 202 + 1;
  DGrpDelMem.SetImgIndex(WProgUse, 125);
  DGrpDelMem.Left := 171 + 1;
  DGrpDelMem.Top := 202 + 1;

   {-----------------------------------------------------------}
  //交易对话框
//  d := WProgUse.Images[389];  //卖出方
//  if d <> nil then
//  begin
    DDealDlg.Left := g_FScreenWidth - 236;
    DDealDlg.Top := 0;
    DDealDlg.SetImgIndex(WProgUse, 389);
//  end;
  DDGrid.Left := 21;
  DDGrid.Top := 56;
  DDGrid.Width := 36 * 5;
  DDGrid.Height := 33 * 2;
  DDealOk.SetImgIndex(WProgUse, 391);
  DDealOk.Left := 155;
  DDealOk.Top := 193 - 65;
  DDealClose.SetImgIndex(WProgUse, 64);
  DDealClose.Left := 220;
  DDealClose.Top := 42;
  DDGold.SetImgIndex(WProgUse, 28);
  DDGold.Left := 11;
  DDGold.Top := 202 - 65;
//  DDGold.OnbtnState := tdisable;

//  d := WProgUse.Images[390];  //买进方
//  if d <> nil then
//  begin
    DDealRemoteDlg.Left := DDealDlg.Left - 220;
    DDealRemoteDlg.Top := 0;
    DDealRemoteDlg.SetImgIndex(WProgUse, 390);
//  end;
  DDRGrid.Left := 21;
  DDRGrid.Top := 56;
  DDRGrid.Width := 36 * 5;
  DDRGrid.Height := 33 * 2;
  DDRGold.SetImgIndex(WProgUse, 28);
//  DDRGold.OnbtnState := tdisable;
  DDRGold.Left := 11;
  DDRGold.Top := 202 - 65;

   // 厘盔 芭贰 舅覆魄
//  d := WProgUse.Images[683];
//  if d <> nil then
//  begin
    DDealJangwon.Left := 388;
    DDealJangwon.Top := 138;
    DDealJangwon.SetImgIndex(WProgUse, 683);
//  end;

   {-----------------------------------------------------------}
   //行会主菜单
//  d := WProgUse.Images[180];
//  if d <> nil then
//  begin
    DGuildDlg.Left := 0;
    DGuildDlg.Top := 0;
    DGuildDlg.SetImgIndex(WProgUse, 180);
//  end;
  DGDClose.Left := 584;
  DGDClose.Top := 6;
  DGDClose.SetImgIndex(WProgUse, 64);
  DGDHome.Left := 13;
  DGDHome.Top := 411;
  DGDHome.SetImgIndex(WProgUse, 198);
  DGDList.Left := 13;
  DGDList.Top := 429;
  DGDList.SetImgIndex(WProgUse, 200);
  DGDChat.Left := 94;
  DGDChat.Top := 429;
  DGDChat.SetImgIndex(WProgUse, 190);
  DGDAddMem.Left := 243;
  DGDAddMem.Top := 411;
  DGDAddMem.SetImgIndex(WProgUse, 182);
  DGDDelMem.Left := 243;
  DGDDelMem.Top := 429;
  DGDDelMem.SetImgIndex(WProgUse, 192);
  DGDEditNotice.Left := 325;
  DGDEditNotice.Top := 411;
  DGDEditNotice.SetImgIndex(WProgUse, 196);
  DGDEditGrade.Left := 325;
  DGDEditGrade.Top := 429;
  DGDEditGrade.SetImgIndex(WProgUse, 194);
  DGDAlly.Left := 407;
  DGDAlly.Top := 411;
  DGDAlly.SetImgIndex(WProgUse, 184);
  DGDBreakAlly.Left := 407;
  DGDBreakAlly.Top := 429;
  DGDBreakAlly.SetImgIndex(WProgUse, 186);
  DGDWar.Left := 529;
  DGDWar.Top := 411;
  DGDWar.SetImgIndex(WProgUse, 202);
  DGDCancelWar.Left := 529;
  DGDCancelWar.Top := 429;
  DGDCancelWar.SetImgIndex(WProgUse, 188);

  DGDUp.Left := 595;
  DGDUp.Top := 239;
  DGDUp.SetImgIndex(WProgUse, 373);
  DGDDown.Left := 595;
  DGDDown.Top := 291;
  DGDDown.SetImgIndex(WProgUse, 372);

   //行会通告编辑框
  DGuildEditNotice.SetImgIndex(WProgUse, 204);
  DGEOk.SetImgIndex(WProgUse, 361);
  DGEOk.Left := 514;
  DGEOk.Top := 287;
  DGEClose.SetImgIndex(WProgUse, 64);
  DGEClose.Left := 584;
  DGEClose.Top := 6;

   {-----------------------------------------------------------}
   //属性调整对话框
  DAdjustAbility.SetImgIndex(WProgUse, 226);
  DAdjustAbilClose.SetImgIndex(WProgUse, 64);
  DAdjustAbilClose.Left := 316;
  DAdjustAbilClose.Top := 1;
  DAdjustAbilOk.SetImgIndex(WProgUse, 62);
  DAdjustAbilOk.Left := 220;
  DAdjustAbilOk.Top := 298;

  DPlusDC.SetImgIndex(WProgUse, 227);
  DPlusDC.Left := 217;
  DPlusDC.Top := 101;
  DPlusMC.SetImgIndex(WProgUse, 227);
  DPlusMC.Left := 217;
  DPlusMC.Top := 121;
  DPlusSC.SetImgIndex(WProgUse, 227);
  DPlusSC.Left := 217;
  DPlusSC.Top := 140;
  DPlusAC.SetImgIndex(WProgUse, 227);
  DPlusAC.Left := 217;
  DPlusAC.Top := 160;
  DPlusMAC.SetImgIndex(WProgUse, 227);
  DPlusMAC.Left := 217;
  DPlusMAC.Top := 181;
  DPlusHP.SetImgIndex(WProgUse, 227);
  DPlusHP.Left := 217;
  DPlusHP.Top := 201;
  DPlusMP.SetImgIndex(WProgUse, 227);
  DPlusMP.Left := 217;
  DPlusMP.Top := 220;
  DPlusHit.SetImgIndex(WProgUse, 227);
  DPlusHit.Left := 217;
  DPlusHit.Top := 240;
  DPlusSpeed.SetImgIndex(WProgUse, 227);
  DPlusSpeed.Left := 217;
  DPlusSpeed.Top := 261;

  DMinusDC.SetImgIndex(WProgUse, 228);
  DMinusDC.Left := 227;
  DMinusDC.Top := 101;
  DMinusMC.SetImgIndex(WProgUse, 228);
  DMinusMC.Left := 227;
  DMinusMC.Top := 121;
  DMinusSC.SetImgIndex(WProgUse, 228);
  DMinusSC.Left := 227;
  DMinusSC.Top := 140;
  DMinusAC.SetImgIndex(WProgUse, 228);
  DMinusAC.Left := 227;
  DMinusAC.Top := 160;
  DMinusMAC.SetImgIndex(WProgUse, 228);
  DMinusMAC.Left := 227;
  DMinusMAC.Top := 181;
  DMinusHP.SetImgIndex(WProgUse, 228);
  DMinusHP.Left := 227;
  DMinusHP.Top := 201;
  DMinusMP.SetImgIndex(WProgUse, 228);
  DMinusMP.Left := 227;
  DMinusMP.Top := 220;
  DMinusHit.SetImgIndex(WProgUse, 228);
  DMinusHit.Left := 227;
  DMinusHit.Top := 240;
  DMinusSpeed.SetImgIndex(WProgUse, 228);
  DMinusSpeed.Left := 227;
  DMinusSpeed.Top := 261;

   {-----------------------------------------------------------}
   // 2003/04/15 模备, 率瘤
   //好友
//  d := WProgUse.Images[266];
//  if d <> nil then
//  begin
    DFriendDlg.SetImgIndex(WProgUse, 266);
    DFriendDlg.Left := (g_FScreenWidth - 216) div 2;
    DFriendDlg.Top := (g_FScreenHeight - 283) div 2;
//  end;
  DFrdClose.SetImgIndex(WProgUse, 371);
  DFrdClose.Left := 193;
  DFrdClose.Top := 2;
  DFrdPgUp.SetImgIndex(WProgUse, 264);
  DFrdPgUp.Left := 167;
  DFrdPgUp.Top := 102;
  DFrdPgDn.SetImgIndex(WProgUse, 262);
  DFrdPgDn.Left := 167;
  DFrdPgDn.Top := 154;
  DFrdFriend.SetImgIndex(WProgUse, 267);
  DFrdFriend.Left := 17;
  DFrdFriend.Top := 20;
  DFrdMaster.SetImgIndex(WProgUse, 268);
  DFrdMaster.Left := 63;
  DFrdMaster.Top := 20;
  DFrdBlackList.SetImgIndex(WProgUse, 269);
  DFrdBlackList.Left := 109;
  DFrdBlackList.Top := 20;
  DFrdAdd.SetImgIndex(WProgUse, 271);
  DFrdAdd.Left := 31;
  DFrdAdd.Top := 231;
  DFrdDel.SetImgIndex(WProgUse, 270);
  DFrdDel.Left := 95;
  DFrdDel.Top := 231;
  DFrdMemo.SetImgIndex(WProgUse, 558);
  DFrdMemo.Left := 158;
  DFrdMemo.Top := 233;
  DFrdMail.SetImgIndex(WProgUse, 560);
  DFrdMail.Left := 192;
  DFrdMail.Top := 233;
  DFrdWhisper.SetImgIndex(WProgUse, 562);
  DFrdWhisper.Left := 226;
  DFrdWhisper.Top := 233;
   {-----------------------------------------------------------}
   //邮件 Mail
//  d := WProgUse.Images[536];
//  if d <> nil then
//  begin
    DMailListDlg.SetImgIndex(WProgUse, 536);
    DMailListDlg.Left := 512; //(SCREENWIDTH - d.Width) div 2;
    DMailListDlg.Top := 0; //(SCREENHEIGHT - d.Height) div 2;
//  end;
  DMailListClose.SetImgIndex(WProgUse, 371);
  DMailListClose.Left := 247;
  DMailListClose.Top := 5;
  DMailListPgUp.SetImgIndex(WProgUse, 373);
  DMailListPgUp.Left := 259;
  DMailListPgUp.Top := 102;
  DMailListPgDn.SetImgIndex(WProgUse, 372);
  DMailListPgDn.Left := 259;
  DMailListPgDn.Top := 154;
  DMLReply.SetImgIndex(WProgUse, 564);
  DMLReply.Left := 90;
  DMLReply.Top := 233;
  DMLRead.SetImgIndex(WProgUse, 566);
  DMLRead.Left := 124;
  DMLRead.Top := 233;
  DMLDel.SetImgIndex(WProgUse, 556);
  DMLDel.Left := 158;
  DMLDel.Top := 233;
  DMLLock.SetImgIndex(WProgUse, 568);
  DMLLock.Left := 192;
  DMLLock.Top := 233;
  DMLBlock.SetImgIndex(WProgUse, 570);
  DMLBlock.Left := 226;
  DMLBlock.Top := 233;
   {-----------------------------------------------------------}
   //Mail
//  d := WProgUse.Images[536];
//  if d <> nil then
//  begin
    DBlockListDlg.SetImgIndex(WProgUse, 536);
    DBlockListDlg.Left := 512; //(SCREENWIDTH - d.Width) div 2;
    DBlockListDlg.Top := 265; //(SCREENHEIGHT - d.Height) div 2;
//  end;
  DBlockListClose.SetImgIndex(WProgUse, 371);
  DBlockListClose.Left := 247;
  DBlockListClose.Top := 5;
  DBLPgUp.SetImgIndex(WProgUse, 373);
  DBLPgUp.Left := 259;
  DBLPgUp.Top := 102;
  DBLPgDn.SetImgIndex(WProgUse, 372);
  DBLPgDn.Left := 259;
  DBLPgDn.Top := 154;
  DBLAdd.SetImgIndex(WProgUse, 554);
  DBLAdd.Left := 192;
  DBLAdd.Top := 233;
  DBLDel.SetImgIndex(WProgUse, 556);
  DBLDel.Left := 226;
  DBLDel.Top := 233;
   {-----------------------------------------------------------}
   //发送邮件框
//  d := WProgUse.Images[537];
//  if d <> nil then
//  begin
    DMemo.SetImgIndex(WProgUse, 537);
    DMemo.Left := 290; //(SCREENWIDTH - d.Width) div 2;
    DMemo.Top := 0; //(SCREENHEIGHT - d.Height) div 2;
//  end;
  DMemoClose.SetImgIndex(WProgUse, 371);
  DMemoClose.Left := 205;
  DMemoClose.Top := 1;
  DMemoB1.SetImgIndex(WProgUse, 544);
  DMemoB1.Left := 58;
  DMemoB1.Top := 114;
  DMemoB2.SetImgIndex(WProgUse, 538);
  DMemoB2.Left := 126;
  DMemoB2.Top := 114;

   {-----------------------------------------------------------}
   //邮件框
//  d := WProgUse.Images[584];
//  if d <> nil then
//  begin
    DMasterDlg.SetImgIndex(WProgUse, 584);
    DMasterDlg.Left := 0; //(SCREENWIDTH - d.Width) div 2;
    DMasterDlg.Top := 0; //(SCREENHEIGHT - d.Height) div 2;
//  end;
  DMaster1.SetImgIndex(WProgUse, 590);
  DMaster1.Left := 25;
  DMaster1.Top := 290;
  DMaster2.SetImgIndex(WProgUse, 596);
  DMaster2.Left := 60;
  DMaster2.Top := 290;
  DMaster3.SetImgIndex(WProgUse, 592);
  DMaster3.Left := 95;
  DMaster3.Top := 290;
  DMasterClose.SetImgIndex(WProgUse, 585);
  DMasterClose.Left := 255;   //师徒的关闭图标位置
  DMasterClose.Top := 0;

//  d := WProgUse.Images[584];
//  if d <> nil then
//  begin
    DLoveDlg.SetImgIndex(WProgUse, 584);
    DLoveDlg.Left := 0; //(SCREENWIDTH - d.Width) div 2;
    DLoveDlg.Top := 0; //(SCREENHEIGHT - d.Height) div 2;
//  end;
  DLover1.SetImgIndex(WProgUse, 600);
  DLover1.Left := 25;
  DLover1.Top := 290;
  DLover2.SetImgIndex(WProgUse, 598);
  DLover2.Left := 60;
  DLover2.Top := 290;
  DLover3.SetImgIndex(WProgUse, 594);
  DLover3.Left := 90;
  DLover3.Top := 290;
  DLoveClose.SetImgIndex(WProgUse, 585);
  DLoveClose.Left := 255;  //师徒的关闭图标位置
  DLoveClose.Top := 0;


   // 小信息提示窗口
//  d := WProgUse.Images[710];
//  if d <> nil then begin
    DMsgSimpleDlg.SetImgIndex (WProgUse, 990);
    DMsgSimpleDlg.Left := (g_FScreenWidth - d.Width) div 2;
    DMsgSimpleDlg.Top := (g_FScreenHeight - d.Height) div 2;
//  end;
  DMsgSimpleDlgOk.SetImgIndex (WProgUse, 711);
  DMsgSimpleDlgCancel.SetImgIndex (WProgUse, 713);
  DMsgSimpleDlgOk.Top := 56;
  DMsgSimpleDlgCancel.Top := 56;
//-  卖价格
//    d := WProgUse.Images[731];
  //  if d <> nil then
//    begin
     DWStoreItemPrice.SetImgIndex(WProgUse, 731);
     DWStoreItemPrice.Left := (g_FScreenWidth - 324) div 2;
     DWStoreItemPrice.Top := ((g_FScreenHeight - 40) - DWStoreItemPrice.Height) div 2;
//    end;
////-
//  D1xEditStoreItemPrice:=TDEdit.Create(FrmMain.Owner);
  DEditStoreItemPrice.Left := 128;
  DEditStoreItemPrice.Top :=80;     //未写释放代码
//  with D1xEditStoreItemPrice do
//  begin
// //   OnKeyPress := EdChatKeyPress;
//    Parent := FrmMain;
//    Color := clBlack;
//    Font.Color := clWhite;
//    Font.Size := 10;
//    MaxLength := 30;
//    Height := 16;
//    width :=181;//121
//    Ctl3d := FALSE;
//    BorderStyle := bsNone;//bsSingle;  {OnKeyPress := EdDlgEditKeyPress;}
//    Visible := FALSE;
//  end;
//  with DxEditStoreItemPrice do
//  begin
//
//    BorderStyle := bsNone;
//    OnKeyPress := EdChatKeyPress;
//
//  end;

  DBStorePage1.SetImgIndex(WProgUse, 732);
  DBStorePage1.Left := 10;
  DBStorePage1.Top := 15;

  DBStorePage2.SetImgIndex(WProgUse, 732);
  DBStorePage2.Left := 110;
  DBStorePage2.Top := 15;
  DBStorePage2.PageActive := True;

  DBStorePriceClose.SetImgIndex(WProgUse, 371);
  DBStorePriceClose.Left := 302;
  DBStorePriceClose.Top := 1;

  DBStoreItemPriceOk.SetImgIndex(WProgUse, 754);
  DBStoreItemPriceOk.Left := 180;
  DBStoreItemPriceOk.Top := 106;

  DBStoreItemPriceCancel.SetImgIndex(WProgUse, 754);
  DBStoreItemPriceCancel.Left := 232;
  DBStoreItemPriceCancel.Top := 106;
  //-卖买预览

  d := WProgUse.Images[730];//爸爸
  DWHeroStore.SetImgIndex(WProgUse, 730);
  DWHeroStore.Left := 100;
  DWHeroStore.Top := 160;

  DEditStoreName.Left := 29;
  DEditStoreName.Top := 34;
  DEditStoreName.Width := 151+32;
  DEditStoreName.Height := 16;

  DWUserStall.SetImgIndex(WProgUse, 730);
  DWUserStall.Left := 100;
  DWUserStall.Top := 160;

  DEditStoreItemPrice.Left := 128;
  DEditStoreItemPrice.Top := 80;
  DEditStoreItemPrice.Width := 151;
  DEditStoreItemPrice.Height := 16;


//  DxEditStoreName:=TDEdit.Create(FrmMain.Owner);
//  DxEditStoreName.Left := DWHeroStore.Left+30;
//  DxEditStoreName.Top := DWHeroStore.Top+32;     //未写释放代码
//  with DxEditStoreName do
//  begin
//    Width := 54;
//    Height := 21 ;
//    DFColor := clWhite  ;
//    DFEnabledColor := 12964541   ;
//    DFMoveColor := 12964541  ;
//    DFDownColor := clWhite ;
//    DFBackColor := 8;
//    Caption := #24080#21495#26694  ;
//    DParent := DWHeroStore  ;
//    Visible := True   ;
//    Enabled := True ;
//    MouseFocus := True ;
//    KeyFocus := True  ;
//    Color := clBlack ;
//    Font.Charset := DEFAULT_CHARSET ;
//    Font.Color := clWhite   ;
//    Font.Height := -12   ;
//    Font.Name := #23435#20307   ;
//    Font.Style := []     ;
//    EditClass := deNone  ;
//    FrameColor := clSilver ;
//    boTransparent := True ;
//  end;
//   DEdit1.Left := DWHeroStore.Left+30;
//  DEdit1.Top := DWHeroStore.Top+32;     //未写释放代码
//  with DEdit1 do
//  begin
//    Width := 54;
//    Height := 21 ;
//    DFColor := clWhite  ;
//    DFEnabledColor := 12964541   ;
//    DFMoveColor := 12964541  ;
//    DFDownColor := clWhite ;
//    DFBackColor := 8;
//    Caption := #24080#21495#26694  ;
//    DParent := DWHeroStore  ;
//    Visible := True   ;
//    Enabled := True ;
//    MouseFocus := True ;
//    KeyFocus := True  ;
//    Color := clBlack ;
//    Font.Charset := DEFAULT_CHARSET ;
//    Font.Color := clWhite   ;
//    Font.Height := -12   ;
//    Font.Name := #23435#20307   ;
//    Font.Style := []     ;
//    EditClass := deNone  ;
//    FrameColor := clSilver ;
//    boTransparent := True ;
//  end;
//
//  with DxEditStoreName do
//  begin
// //   OnKeyPress := EdChatKeyPress;
//    Parent := FrmMain;
//    Color := clBlack;
//    Font.Color := clWhite;
//    Font.Size := 10;
//    MaxLength := 30;
//    Height := 16;
//    width :=181;//121
//    Ctl3d := FALSE;
//    BorderStyle := bsSingle;  {OnKeyPress := EdDlgEditKeyPress;}
//    Visible := FALSE;
//  end;

//  DxEditStoreName.Visible:=false;

  with DEdChat do begin
    OnKeyPress := PlayScene.EdChatKeyPress;
    MaxLength := 70;
    Font.Size := 9;
    FRightClick := True;

    Left := 210;
    Top := 234;
    Height := 12;
    Width := (g_FScreenWidth div 2 - 207) * 2;
    FCaretColor := clBlack;
    FMiniCaret := 2;
    FontSelColor := clWhite;
    m_InputHint := 'Ctrl+↑↓浏览历史记录';
  end;

  DGridStore.Left := 28;
  DGridStore.Top := 55;
  DGridStore.Width := 38 * 5 + 2;
  DGridStore.Height := 35 * 2 + 2;

  DBStoreBuy.SetImgIndex(WProgUse, 734);
  DBStoreBuy.Left := 47;
  DBStoreBuy.Top := 143;
  //DBStoreBuy.FFloating := True;

  DBStoreCancel.SetImgIndex(WProgUse, 734);
  DBStoreCancel.Left := 126;
  DBStoreCancel.Top := 143;
  //DBStoreCancel.FFloating := True;

  DBStoreClose.SetImgIndex(WProgUse, 371);
  DBStoreClose.Left := 239;
  DBStoreClose.Top := 1;
  //DBStoreClose.FFloating := True;

  DGridUserStall.Left := 28;
  DGridUserStall.Top := 55;
  DGridUserStall.Width := 38 * 5 + 2;
  DGridUserStall.Height := 35 * 2 + 2;

  DBUserStallBuy.SetImgIndex(WProgUse, 734);
  DBUserStallBuy.Left := 120;
  DBUserStallBuy.Top := 143;

  DBUserStallClose.SetImgIndex(WProgUse, 371);
  DBUserStallClose.Left := 239;
  DBUserStallClose.Top := 1;


  DWGameConfig.SetImgIndex(WProgUse, 330);
  DWGameConfig.Left := (g_FScreenWidth - 416) div 2;
  DWGameConfig.Top := (g_FScreenHeight - 261) div 2;

  DBGCClose.SetImgIndex(WProgUse, 341);
  DBGCClose.Left := 394;
  DBGCClose.Top := 1;

  DBGCActivePage1.SetImgIndex(WProgUse, g_sGameConfigPage1);
  DBGCActivePage1.Left := 10 + 48 * 0;
  DBGCActivePage1.Top := 15;
  DBGCActivePage1.PageActive := True;

  DBGCActivePage2.SetImgIndex(WProgUse, g_sGameConfigPage1);
  DBGCActivePage2.Left := 10 + 48 * 1;
  DBGCActivePage2.Top := 15;

  DBGCActivePage3.SetImgIndex(WProgUse, g_sGameConfigPage1);
  DBGCActivePage3.Left := 10 + 48 * 2;
  DBGCActivePage3.Top := 15;

  DBGCActivePage4.SetImgIndex(WProgUse, g_sGameConfigPage1);
  DBGCActivePage4.Left := 10 + 48 * 3;
  DBGCActivePage4.Top := 15;

  DBGCActivePage5.SetImgIndex(WProgUse, g_sGameConfigPage1);
  DBGCActivePage5.Left := 10 + 48 * 4;
  DBGCActivePage5.Top := 15;

  DBGCActivePage6.SetImgIndex(WProgUse, g_sGameConfigPage1);
  DBGCActivePage6.Left := 10 + 48 * 5;
  DBGCActivePage6.Top := 15;

  DBGCActivePage7.SetImgIndex(WProgUse, g_sGameConfigPage1);
  DBGCActivePage7.Left := 10 + 48 * 6;
  DBGCActivePage7.Top := 15;

  DCheckSdoNameShow.SetImgIndex(WProgUse, 333);
  DCheckSdoNameShow.Left := 37;
  DCheckSdoNameShow.Top := 73;

  DCheckBoxHideShiti.SetImgIndex(WProgUse, 333);
  DCheckBoxHideShiti.Left := 37;
  DCheckBoxHideShiti.Top := 97;

  DCheckSdoDuraWarning.SetImgIndex(WProgUse, 333);
  DCheckSdoDuraWarning.Left := 37;
  DCheckSdoDuraWarning.Top := 121;

  DCheckSdoAvoidShift.SetImgIndex(WProgUse, 333);
  DCheckSdoAvoidShift.Left := 37;
  DCheckSdoAvoidShift.Top := 145;

  DCheckSdoExpFiltrate.SetImgIndex(WProgUse, 333);
  DCheckSdoExpFiltrate.Left := 37;
  DCheckSdoExpFiltrate.Top := 169;

  DCheckMyHp.SetImgIndex(WProgUse, 333);
  DCheckMyHp.Left := 37;
  DCheckMyHp.Top := 193;

  DCheckSdoMapDesc.SetImgIndex(WProgUse, 333);
  DCheckSdoMapDesc.Left := 37;
  DCheckSdoMapDesc.Top := 217;

  DEdtSdoExpFiltrate.Left:=135;
  DEdtSdoExpFiltrate.Top:=168;
  DEdtSdoExpFiltrate.Width:=50;
  DEdtSdoExpFiltrate.Height:=19;
  DEdtSdoExpFiltrate.FrameColor := rgb(148,132,74);
  DWindowItem.Left := 20;
  DWindowItem.Top := 60;
  DWindowItem.Width := 355;
  DWindowItem.Height := 150;


  DBIUP.SetImgIndex(WProgUse, 336);
  DBIUP.Left := 384+1;
  DBIUP.Top := 38+1;

  DBIDown.SetImgIndex(WProgUse, 338);
  DBIDown.Left := 384+1;
  DBIDown.Top := 226;


  DMoveButton_items.SetImgIndex(WProgUse, 340);
  DMoveButton_items.Left := 384+1;
  DMoveButton_items.tag := DMoveButton_items.Left;
  DMoveButton_items.TypeRLeft := DMoveButton_items.Left;

  DMoveButton_items.Top := 39 + DBIUP.Height-1;
  DMoveButton_items.TypeRTop := DMoveButton_items.Top;

  DMoveButton_items.SlotLen := 175;
  DMoveButton_items.Max := 300;
  DMoveButton_items.LeftToRight := False;


  DSdoMemo.Left:=15; // 内挂便签光标的位置调整
  DSdoMemo.Top:=37;
  DSdoMemo.Width:=370;
  DSdoMemo.Height:=207;

  DUpDown_config.SetImgIndex(WProgUse, 335);
  DUpDown_config.UpButton.SetImgIndex(WProgUse, 336);
  DUpDown_config.DownButton.SetImgIndex(WProgUse, 338);
  DUpDown_config.MoveButton.SetImgIndex(WProgUse, 340);
  DUpDown_config.Left:=384;
  DUpDown_config.Top:=38;
  DUpDown_config.width:=16;
  DUpDown_config.Height:=205;
  DUpDown_config.Visible := false;

//
//  DListBox_Items.Items.Clear;
//  DListBox_Items.Items.Add('随机传送卷');
//  DListBox_Items.Items.Add('地牢逃脱卷');
//  DListBox_Items.Items.Add('回城卷');
//  DListBox_Items.Items.Add('行会回城卷');

//  DListBox_Items.SetImgIndex(WProgUse, 344);
//  DListBox_Items.Width := 83;
//  DListBox_Items.Height :=19;
//  DListBox_Items.Left:=87;
//  DListBox_Items.Top:=170;
//  DListBox_Items.ImageWidth:=80;
//  DListBox_Items.Visible:=false;
//  DListBox_Items.FrameColor := rgb(148,132,74);


   // 物品过滤
  DListBox_Items.Items.Clear;
  DListBox_Items.Items.Add('(全部分类)');
  DListBox_Items.Items.Add('其他类');
  DListBox_Items.Items.Add('药品类');
  DListBox_Items.Items.Add('服装类');
  DListBox_Items.Items.Add('武器类');
  DListBox_Items.Items.Add('首饰类');



  DListBox_Items.Width := 82;
  DListBox_Items.Height := 19 * DListBox_Items.Items.Count + 1;
  DListBox_Items.FOnChangeSelect := DListBox_ItemsOnChangeSelect;
//  DComboBox_Items.Item.Clear;
//  DComboBox_Items.Item.Add('(全部分类)');
//  DComboBox_Items.Item.Add('其他类');
//  DComboBox_Items.Item.Add('药品类');
//  DComboBox_Items.Item.Add('服装类');
//  DComboBox_Items.Item.Add('武器类');
//  DComboBox_Items.Item.Add('首饰类');
//  DComboBox_Items.ItemIndex:=0;
//  DComboBox_Items.SetImgIndex(WProgUse, 344);
//  DComboBox_Items.Width := 75;
//  DComboBox_Items.Height :=19;
//  DComboBox_Items.ImageWidth:=80;
//  DComboBox_Items.Visible:=false;
//  DComboBox_Items.Left := 27;
//  DComboBox_Items.Top := 215;
//  DComboBox_Items.FrameColor := rgb(148,132,74);


  DComboBox_Items.Width := 80;
  DComboBox_Items.Height := 17;
  DComboBox_Items.Caption := '';

  DListBox_Items.Left := 18;
  DListBox_Items.Top := 68 + 18 * 7;

  DComboBox_Items.Left := 21;
  DComboBox_Items.Top := 68 + 18 * 7 + 20 + 6;
  DComboBox_Items.Caption := DListBox_Items.Items[0];

  DxEdit_Items.Width := 122;
  DxEdit_Items.Height := 17;
  DxEdit_Items.Left := 113;
  DxEdit_Items.Top := 68 + 18 * 7 + 20 + 6;
  DxEdit_Items.m_InputHint := '[输入物品关键字查找]';
  DxEdit_Items.OnTextChanged := DxEdit_Items_Search_OnTextChanged;

  DButtonDefaultConfig.Left := 245;
  DButtonDefaultConfig.Top := 220;
  DButtonDefaultConfig.Width := 46;
  DButtonDefaultConfig.Height := 12;

  DCheckBox_AllPickup.Left:=305;
  DCheckBox_AllPickup.Top:=215;
  DCheckBox_AllPickup.SetImgIndex(WProgUse, 333);

 // DListBox_Items.UpDown.SetImgIndex();

  DLBRenewBookNowBook.Items.Clear;
  for i := Low(g_sRenewBooks) to High(g_sRenewBooks) do
    if g_sRenewBooks[i] <> '' then
      DLBRenewBookNowBook.Items.Add(g_sRenewBooks[i]);
  //DLBRenewBookNowBook.SetImgIndex(g_WMainImages, 911);
  DLBRenewBookNowBook.Width := 82;
  DLBRenewBookNowBook.Height := 15 * DLBRenewBookNowBook.Items.Count + 1;

  DCBRenewBookNowBook.Width := 80;
  DCBRenewBookNowBook.Height := 16;
  DCBRenewBookNowBook.Caption := DLBRenewBookNowBook.Items[0];

  DCBRenewBookNowBook.Left := 35 + 55;
  DCBRenewBookNowBook.Top := 70 + 24 * 2 + 48;
  DLBRenewBookNowBook.Left := 35 + 55 - 6;
  DLBRenewBookNowBook.Top := 70 + 24 * 2 + 48 + 18;

  DCBPractice.Caption := '';
  DCBPractice.Left := 158;
  DCBPractice.Top := 100;
  DCBPractice.Width := 100 - 4;
  DCBPractice.Height := 16;

  DLBPractice.Left := 158;
  DLBPractice.Top := 100 + 16;
  DLBPractice.Width := 100 - 4 + 2;

  DCheckSpecial.SetImgIndex(WProgUse, 333);
  DCheckSpecial.left:=37;
  DCheckSpecial.Top:=73;
  DCheckSpecial.Width:=20;
  DCheckSpecial.Height:=17;

  DCheckRanProtect.SetImgIndex(WProgUse, 333);
  DCheckRanProtect.left:=37;
  DCheckRanProtect.Top:=121;
  DCheckRanProtect.Width:=20;
  DCheckRanProtect.Height:=17;


  DxEditSpecialHP.Left := 87;
  DxEditSpecialHP.Top := 74;
  DxEditSpecialHP.Width := 49;
  DxEditSpecialHP.Height := 19;
  DxEditSpecialHP.FrameColor := rgb(148,132,74);

  DxEditSpecialHPTime.Left := 147;
  DxEditSpecialHPTime.Top := 74;
  DxEditSpecialHPTime.Width := 23;
  DxEditSpecialHPTime.Height := 19;
  DxEditSpecialHPTime.FrameColor := rgb(148,132,74);

  DxEditRanHP.Left := 87;
  DxEditRanHP.Top :=122;
  DxEditRanHP.Width := 49;
  DxEditRanHP.Height := 19;
  DxEditRanHP.FrameColor := rgb(148,132,74);

  DxEditRanHPTime.Left := 147;
  DxEditRanHPTime.Top := 122;
  DxEditRanHPTime.Width := 23;
  DxEditRanHPTime.Height := 19;
  DxEditRanHPTime.FrameColor := rgb(148,132,74);


  DCheckPttly.SetImgIndex(WProgUse, 333);
  DCheckPttly.Left:=45;
  DCheckPttly.Top:=77;

  DCheckPtmfy.SetImgIndex(WProgUse, 333);
  DCheckPtmfy.Left:=45;
  DCheckPtmfy.Top:=107;

  DEditPtHp.Left := 265;
  DEditPtHp.Top := 76;
  DEditPtHp.Width := 37;
  DEditPtHp.Height := 19;
  DEditPtHp.FrameColor := rgb(148,132,74);

  DEditPtHpTime.Left := 309;
  DEditPtHpTime.Top := 76;
  DEditPtHpTime.Width := 37;
  DEditPtHpTime.Height := 19;
  DEditPtHpTime.FrameColor := rgb(148,132,74);

  DEditPtMp.Left := 265;
  DEditPtMp.Top := 106;
  DEditPtMp.Width := 37;
  DEditPtMp.Height := 19;
  DEditPtMp.FrameColor := rgb(148,132,74);

  DEditPtMpTime.Left := 309;
  DEditPtMpTime.Top := 106;
  DEditPtMpTime.Width := 37;
  DEditPtMpTime.Height := 19;
  DEditPtMpTime.FrameColor := rgb(148,132,74);


  DCheckSdoAutoFireHit.SetImgIndex(WProgUse, 333);
  DCheckSdoAutoFireHit.Left:=40;
  DCheckSdoAutoFireHit.Top:=75;

  DCheckSdoAutoLongHit.SetImgIndex(WProgUse, 333);
  DCheckSdoAutoLongHit.Left:=40;
  DCheckSdoAutoLongHit.Top:=105;

  DCheckSdoAutoShield.SetImgIndex(WProgUse, 333);
  DCheckSdoAutoShield.Left:=40;
  DCheckSdoAutoShield.Top:=160;

  DCheckSdoAutoHide.SetImgIndex(WProgUse, 333);
  DCheckSdoAutoHide.Left:=40;
  DCheckSdoAutoHide.Top:=220;

  DCheckSdoAutoHld.SetImgIndex(WProgUse, 333);
  DCheckSdoAutoHld.Left:=120;
  DCheckSdoAutoHld.Top:=220;

  DCheckSdoAutoJld.SetImgIndex(WProgUse, 333);
  DCheckSdoAutoJld.Left:=210;
  DCheckSdoAutoJld.Top:=220;

//  DCheckSdoAutoJhd.SetImgIndex(WProgUse, 333);
//  DCheckSdoAutoJhd.Left:=270;
//  DCheckSdoAutoJhd.Top:=220;

  DCheckSdoAutoMagic.SetImgIndex(WProgUse, 333);
  DCheckSdoAutoMagic.Left:=155;
  DCheckSdoAutoMagic.Top:=75;

//  DComboBoxAutoMagicList.SetImgIndex(WProgUse, 344);
//  DComboBoxAutoMagicList.Left := 155;
//  DComboBoxAutoMagicList.Top := 96;
//  DComboBoxAutoMagicList.Width := 110;
//  DComboBoxAutoMagicList.Height := 18;
////  DComboBoxAutoMagicList.ImageWidth:=80;
//  DComboBoxAutoMagicList.FrameColor := rgb(148,132,74);

  DCheckSdoAutoMagicTime.Left := 230;
  DCheckSdoAutoMagicTime.Top := 75;
  DCheckSdoAutoMagicTime.Width := 20;
  DCheckSdoAutoMagicTime.Height := 19;
  DCheckSdoAutoMagicTime.FrameColor := rgb(148,132,74);


//  DListBox_Items.FOnChangeSelect := DListBox_ItemsOnChangeSelect;



//   d := WProgUse.Images[327];
//   if d <> nil then
//   begin
     DWndWeb.SetImgIndex(WProgUse, 327);
     DWndWeb.Left := (g_FScreenWidth - 486) div 2;
     DWndWeb.Top := (g_FScreenHeight - 506)  div 2;
//   end;
   DWndWebClose.SetImgIndex(WProgUse, 328);
   DWndWebClose.Left := 460;//彩虹精灵关闭键
   DWndWebClose.Top := 10;



  // 私聊
//  d := WProgUse.Images[164];
//  if d <> nil then begin
    DWhisperDlg.SetImgIndex(WProgUse, 164);
    DWhisperDlg.Left := (g_FScreenWidth - 400) div 2;
    DWhisperDlg.Top := (g_FScreenHeight - 261) div 2 - 10;
//  end;
  DWhisperDlg.Visible := False;
  DWhisperClose.SetImgIndex(WProgUse, 328);
  DWhisperClose.Left := 395;
  DWhisperClose.Top := 2;

  DCheckWhisper.SetImgIndex(WProgUse, 165);
  DCheckWhisper.Left := 18;
  DCheckWhisper.Top := 225;

  DEdtWhisper.Left := 92;
  DEdtWhisper.Top := 227;
  DEdtWhisper.Width := 286;
  DEdtWhisper.Height := 16;
  DEdtWhisper.Text := '';


  DWhisperUP.SetImgIndex(WProgUse, 336);
  DWhisperUP.Left := 365+1;
  DWhisperUP.Top := 43;

  DWhisperDown.SetImgIndex(WProgUse, 338);
  DWhisperDown.Left := 365+1;
  DWhisperDown.Top := 205;


  DWhisperBar.SetImgIndex(WProgUse, 340);
  DWhisperBar.Left := 365+1;
  DWhisperBar.tag := DWhisperBar.Left;
  DWhisperBar.TypeRLeft := DWhisperBar.Left;

  DWhisperBar.Top := 43 + DWhisperUP.Height-1;
  DWhisperBar.TypeRTop := DWhisperBar.Top;

  DWhisperBar.SlotLen := 148;
  DWhisperBar.Max := 300;
  DWhisperBar.LeftToRight := False;

  d := WProgUse.Images[760];
  if d <> nil then begin
    DCashShopDlg.SetImgIndex(WProgUse, 760);
    DCashShopDlg.Left := (g_FScreenWidth - d.Width) div 2;
    DCashShopDlg.Top := (g_FScreenHeight - d.Height) div 2;
  end;
  DCashShopDlgClose.Left := DCashShopDlg.Width - 22;
  DCashShopDlgClose.Top := 5;
  DCashShopDlgClose.SetImgIndex(WProgUse, 371);

  DButtonType1.SetImgIndex(WProgUse, 761);
  DButtonType1.Top := 14;
  DButtonType1.Left := 177;
  DButtonType1.Height := 16;
  DButtonType1.Width := 56;
  DButtonType1.PageActive := True;

  DButtonType2.SetImgIndex(WProgUse, 762);
  DButtonType2.Top := 14;
  DButtonType2.Left := 235;
  DButtonType2.Height := 16;
  DButtonType2.Width := 56;

  DButtonType3.SetImgIndex(WProgUse, 763);
  DButtonType3.Top := 14;
  DButtonType3.Left := 293;
  DButtonType3.Height := 16;
  DButtonType3.Width := 56;

  DButtonType4.SetImgIndex(WProgUse, 764);
  DButtonType4.Top := 14;
  DButtonType4.Left := 351;
  DButtonType4.Height := 16;
  DButtonType4.Width := 56;

  DButtonType5.SetImgIndex(WProgUse, 765);
  DButtonType5.Top := 14;
  DButtonType5.Left := 409;
  DButtonType5.Height := 16;
  DButtonType5.Width := 56;

  DCashItemListPrev.SetImgIndex(WProgUse, 388);
  DCashItemListPrev.Top := 349;
  DCashItemListPrev.Left := 197;

  DCashItemListNext.SetImgIndex(WProgUse, 387);
  DCashItemListNext.Top := 349;
  DCashItemListNext.Left := 287;

  DCashItemBuy.SetImgIndex(WProgUse, 766);
  DCashItemBuy.Top := 365;
  DCashItemBuy.Left := 329;

  DCashItemGift.SetImgIndex(WProgUse, 767);
  DCashItemGift.Top := 365;
  DCashItemGift.Left := 387;

  DCashItemClose.SetImgIndex(WProgUse, 768);
  DCashItemClose.Top := 365;
  DCashItemClose.Left := 445;

  DGridShop1.Left := 180;
  DGridShop1.Top := 58;
  DGridShop1.Width := 328;
  DGridShop1.Height := 266;

  DGridShop2.Left := 518;
  DGridShop2.Top := 66;
  DGridShop2.Width := 88;
  DGridShop2.Height := 320;

  DButtonShopEffect.Left := 20;
  DButtonShopEffect.Top := 35;
end;

{------------------------------------------------------------------------}



//打开/关闭我的属性对话框
procedure TFrmDlg.OpenMyStatus;
var
  str: string;
begin
  str := Copy(fLover.GetDisplay(0), length(STR_LOVER) + 1, 6);
  if str = '' then
    DHeartImg.Visible := False
  else
    DHeartImg.Visible := True;

  DStateWin.Visible := not DStateWin.Visible;
  PageChanged;
end;
//显示玩加信息对话框

procedure TFrmDlg.OpenUserState(ustate: TUserStateInfo);
begin
  UserState1 := ustate;
  if UserState1.bExistLover then
    DHeartImgUS.Visible := True
  else
    DHeartImgUS.Visible := False;
  DUserState1.Visible := TRUE;
end;

//显示/关闭物品对话框
procedure TFrmDlg.OpenItemBag;
begin
  DItemBag.Visible := not DItemBag.Visible;
  if DItemBag.Visible then
  begin
   if DWHeroStore.Visible then begin
      DItemBag.Visible :=True;
      DItemBag.Left := DWHeroStore.Width + 110;   // 坐标不对左右   就这样BLUE原始就这样
      DItemBag.Top := 60;                     //上下
   end;

   if DWUserStall.Visible then
   begin
      DItemBag.Visible :=True; //卖家
      DItemBag.Left := DWUserStall.Width + 110;   // 坐标不对左右   就这样BLUE原始就这样
      DItemBag.Top := 60;                     //上下
   end;

    ArrangeItemBag;
  end;
end;

//底部状态框
procedure TFrmDlg.ViewBottomBox(visible: Boolean);
begin
  DBottom.Visible := visible;
  DCheckBoxTrans.Checked := visible;
end;


// 取消物品移动 丢弃物品
procedure TFrmDlg.CancelItemMoving;
var
  idx, n: integer;
  TempItem: pTClientItem;
begin
  if ItemMoving then
  begin
    ItemMoving := FALSE;
    idx := MovingItem.Index;
    if not BoStorageMove or (bWindowsType <> 1) then
    begin
          if IsStallItem(idx) then //取回
          begin

            if (MovingItem.Item.S.Stock =44) or (MovingItem.Item.S.Stock = 45) then
             begin

             // MovingItem.Item.S.Stock:=0;

              // UpdateItemBag(MovingItem.Item);
              AddStallItem(MovingItem.Item);

              MovingItem.Item.S.Name:='';
            Exit;
             end;
          end;
    if idx < 0 then
    begin
      if idx = -99 then
      begin
        AddItemBag(MovingItem.Item);
        Exit;
      end;
      if (idx <= -20) and (idx > -30) then
      begin
        AddDealItem(MovingItem.Item);
      end
      else
      begin
        n := -(idx + 1);
            // 2003/03/15 酒捞袍 牢亥配府 犬厘
        if n in [0..U_TRANS] then
        begin    //8->12
          UseItems[n] := MovingItem.Item;
        end;
      end;
    end
    else if idx in [0..MAXBAGITEM - 1] then
    begin
      if (ItemArr[idx].S.Name = '') then
      begin
//               (MovingItem.Item.S.StdMode <= 3) then begin // 2004/02/23 器记, 澜侥, 胶农费 酒囱巴篮 啊规芒俊..
        ItemArr[idx] := MovingItem.Item;
      end
      else
      begin
        AddItemBag(MovingItem.Item);
      end;
    end;
    MovingItem.Item.S.Name := '';
    end
    else
    begin
      if idx <= SaveItemList.Count then
      begin
        TempItem := PTClientItem(SaveItemList[idx]);
        if TempItem <> nil then
        begin
          TempItem.s.Name := MovingItem.Item.S.Name;
        end;
      end;
      MovingItem.Item.S.Name := '';
      Exit;
    end;
  end;
  ArrangeItemBag;
end;

//把移动的物品放下(不询问)
procedure TFrmDlg.DropMovingItem;
begin
  if ItemMoving then
  begin
    ItemMoving := FALSE;
          if IsStallItem(MovingItem.Index) then //取回
          begin
            if (MovingItem.Item.S.Stock =44) or (MovingItem.Item.S.Stock = 45) then
            begin
            MovingItem.Item.S.Stock:=0;
            UpdateItemBag(MovingItem.Item);
            MovingItem.Item.S.Name:='';
            end;
          end;
    if MovingItem.Item.S.Name <> '' then
    begin
      FrmMain.SendDropItem(MovingItem.Item.S.Name, MovingItem.Item.MakeIndex);
      AddDropItem(MovingItem.Item);
      MovingItem.Item.S.Name := '';
    end;
  end;
end;
(*
//把移动的物品放下
procedure TFrmDlg.DropMovingItem;
var
   idx, DlopCount : integer;
   valstr : String;
   MsgResult : integer;
begin

   if ItemMoving then begin
      ItemMoving := FALSE;
      if MovingItem.Item.S.Name <> '' then begin
         if MovingItem.Item.S.OverlapItem > 0 then begin
            if DMakeItemDlg.Visible then begin
               DMessageDlg ('你确定要丢掉这个物品.', [mbOk]);
               ItemMoving := True;
               CancelItemMoving;
               Exit;
            end;

            DlopCount := 0;
            Total := MovingItem.Item.Dura;
            if Total = 1 then begin
               DlgEditText := '1';
               MsgResult := mrOk;
            end
            else MsgResult := DCountMsgDlg ('当前数量 ' + IntToStr(MovingItem.Item.Dura) +
                     ' 个.\你想丢掉了吗?', [mbOk, mbCancel, mbAbort]);
            ItemMoving := TRUE;
            if (MsgResult = mrCancel) then begin
               CancelItemMoving;
               Exit;
            end
            else if MsgResult = mrOk then begin

               GetValidStrVal (DlgEditText, valstr, [' ']);
               DlopCount := Str_ToInt (valstr, 0);

               if DlopCount <= 0 then DlopCount := 0;
               if DlopCount > MovingItem.Item.Dura then DlopCount := MovingItem.Item.Dura;
               if DlopCount = MovingItem.Item.Dura then begin
                  FrmMain.SendDropItem (MovingItem.Item.S.Name, MovingItem.Item.MakeIndex);
                  AddDropItem (MovingItem.Item);
                  MovingItem.Item.S.Name := '';
                  MovingItem.Item.Dura := 0;
               end
               else if (DlopCount > 0) then begin
                  FrmMain.SendDropCountItem( MovingItem.Item.S.Name, MovingItem.Item.MakeIndex, DlopCount );
               end;
               CancelItemMoving;
               Exit;
            end;
         end
         else begin

           if MovingItem.Item.S.StdMode <> 9 then begin
              if (MovingItem.Item.S.UniqueItem and $04) <> 0 then begin
                 if mrOk = DMessageDlg ('捞 酒捞袍篮 滚府搁 荤扼瘤绰 酒捞袍涝聪促.\沥富肺 酒捞袍阑 昏力窍矫摆嚼聪鳖?', [mbOk, mbCancel]) then
                    FrmMain.SendDropItem (MovingItem.Item.S.Name, MovingItem.Item.MakeIndex)//2004/01/15 ItemSafeGuard..
                 else begin
                    ItemMoving := TRUE;
                    CancelItemMoving;
                    Exit;
                 end;
              end
              else if mrOk = DMessageDlg ('你确定要丢掉这个物品？', [mbOk, mbCancel]) then
                 FrmMain.SendDropItem (MovingItem.Item.S.Name, MovingItem.Item.MakeIndex)//2004/01/15 ItemSafeGuard..
              else begin
                 ItemMoving := TRUE;
                 CancelItemMoving;
                 Exit;
              end;
           end
           else
              FrmMain.SendDropItem (MovingItem.Item.S.Name, MovingItem.Item.MakeIndex)//2004/01/15 ItemSafeGuard..
         end;

         AddDropItem (MovingItem.Item);
         MovingItem.Item.S.Name := '';
      end;
   end;

    {
   if ItemMoving then begin
      ItemMoving := FALSE;
      if MovingItem.Item.S.Name <> '' then begin
         FrmMain.SendDropItem (MovingItem.Item.S.Name, MovingItem.Item.MakeIndex);
         AddDropItem (MovingItem.Item);
         MovingItem.Item.S.Name := '';
      end;
   end;
    }
end;
*)

procedure TFrmDlg.OpenAdjustAbility;
begin
  DAdjustAbility.Left := 0;
  DAdjustAbility.Top := 0;
  SaveBonusPoint := BonusPoint;
  FillChar(BonusAbilChg, sizeof(TNakedAbility), #0);
  DAdjustAbility.Visible := TRUE;
end;

procedure TFrmDlg.DBackgroundBackgroundClick(Sender: TObject);
var
  dropgold: integer;
  valstr: string;
   n: Integer;
begin
  if ItemMoving then
  begin
    DBackground.WantReturn := TRUE;
    if MovingItem.Item.S.Name = '金币' then
    begin
      ItemMoving := FALSE;
      MovingItem.Item.S.Name := '';
         //倔付甫 滚副 扒瘤 拱绢夯促.
      DialogSize := 1;
      DMessageDlg('你想放下多少金币？', [mbOk, mbAbort]);

      GetValidStrVal(DlgEditText, valstr, [' ']);
      dropgold := Str_ToInt(valstr, 0);
         //
      FrmMain.SendDropGold(dropgold);
    end;
    if MovingItem.Index >= 0 then //酒捞袍 啊规俊辑 滚赴巴父..
      DropMovingItem
    else
    begin
      n := -(MovingItem.Index + 1);
         // 2003/03/15 COPARK 酒捞袍 牢亥配府 犬厘
      if n in [0..U_TRANS] then
      begin            // 8->12
        ItemClickSound(MovingItem.Item.S);
        UseItems[n] := MovingItem.Item;
        MovingItem.Item.S.Name := '';
        ItemMoving := FALSE;
      end;
    end;
  end;
end;

procedure TFrmDlg.DBackgroundMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  if ItemMoving then
  begin
    DBackground.WantReturn := TRUE;
  end;
end;

procedure TFrmDlg.DBottomMouse(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);

  function ExtractUserName(line: string): string;
  var
    uname: string;
  begin
    GetValidStr3(line, line, ['(', '!', '*', '/', ')', '-']);
    GetValidStr3(line, uname, [' ', '=', ':', '[']);
    if uname <> '' then
      if (uname[1] = '/') or (uname[1] = '(') or (uname[1] = ' ') or (uname[1] = '[') then
        uname := '';
    Result := uname;
  end;

  function ExtractUserName2(line: string): string;
  var
    uname, data: string;
  begin
    Result := line;
//    data := line;      //  括号恢复
//    data := GetValidStr3(data, uname, ['[']);
//    data := GetValidStr3(data, data, [']']);
//    Result := uname + data;
  end;

  function ExtractUserName3(line: string): string;
  var
    uname: string;
  begin
    GetValidStr3(line, line, ['(', '!', '*', '/', ')']);
    Result := line;
  end;

var
  n: integer;
  str: string;
  nWidth:Integer;
begin
  if g_FScreenWidth = 1024 then nWidth := 598
  else nWidth := 374;


  if (X >= 208) and (X <= (208 + nWidth)) and (Y >= g_FScreenHeight - 130) and (Y <= g_FScreenHeight - 130 + 12 * 9) then
  begin
    n := DScreen.ChatBoardTop + (Y - (g_FScreenHeight - 130)) div 12;
    if (n < DScreen.HornStrs.Count) then
    begin
      if not FrmDlg.DEdChat.Visible then
      begin
        FrmDlg.DEdChat.Visible := TRUE;
        FrmDlg.DEdChat.SetFocus;
      end;
      FrmDlg.DEdChat.Text := '/' + ExtractUserName(DScreen.HornStrs[n]) + ' ';
      FrmDlg.DEdChat.ChangeCurPos(AnsiTextLength(FrmDlg.DEdChat.Text), True);
      FrmDlg.DEdChat.SelLength := 0;
    end
    else
    begin
        if (n < DScreen.ChatStrs.Count) then
        begin
          if not FrmDlg.DEdChat.Visible then
          begin
            FrmDlg.DEdChat.Visible := TRUE;
            FrmDlg.DEdChat.SetFocus;
          end;
          if ssCtrl in Shift then
          FrmDlg.DEdChat.Text := ExtractUserName2(ExtractUserName3(DScreen.ChatStrs[n])) + ' '
          else
          FrmDlg.DEdChat.Text := '/' + ExtractUserName(ExtractUserName2(DScreen.ChatStrs[n])) + ' ';
          FrmDlg.DEdChat.ChangeCurPos(AnsiTextLength(FrmDlg.DEdChat.Text), True);
          FrmDlg.DEdChat.SelLength := 0;
        end
        else
          FrmDlg.DEdChat.Text := '';
    end;
  end;

  if DItemMarketDlg.Visible then begin
    if (X >= 206) and (X <= 208 + 380) and (Y >= g_FScreenHeight - 51) then
      SetChatFocus;
  end

end;

{------------------------------------------------------------------------}

////显示通用对话框
function TFrmDlg.DMessageDlg(msgstr: string; DlgButtons: TMsgDlgButtons): TModalResult;

  procedure DoRunDice;
  var
    dr: TAsphyreCanvas;
    i: integer;
    flag: Boolean;
  begin

    if (DiceType = 2) then
    begin
      if DiceArr[0].DiceCount < 20 then
      begin
        if GetTickCount - DiceArr[0].DiceTime > 250 then
        begin
//               if DiceArr[0].DiceCount mod 2 = 1 then DiceArr[0].DiceCurrent := 1 + Random(3)
          DiceArr[0].DiceCurrent := DiceArr[0].DiceCount mod 3;
          DiceArr[0].DiceTime := GetTickCount;
          Inc(DiceArr[0].DiceCount);
        end;
      end
      else
      begin
        DiceArr[0].DiceCurrent := DiceArr[0].DiceResult - 1;
        if GetTickCount - DiceArr[0].DiceTime > 3000 then
          DMsgDlg.Visible := FALSE;
      end;
    end
    else if RunDice = 1 then
    begin
      if DiceArr[0].DiceCount < 20 then
      begin
        if GetTickCount - DiceArr[0].DiceTime > 100 then
        begin
          if DiceArr[0].DiceCount mod 5 = 4 then
            DiceArr[0].DiceCurrent := 1 + Random(6)
          else
            DiceArr[0].DiceCurrent := 8 + DiceArr[0].DiceCount mod 5;
          DiceArr[0].DiceTime := GetTickCount;
          Inc(DiceArr[0].DiceCount);
        end;
      end
      else
      begin
        DiceArr[0].DiceCurrent := DiceArr[0].DiceResult;
        if GetTickCount - DiceArr[0].DiceTime > 3000 then
          DMsgDlg.Visible := FALSE;
      end;
    end
    else
    begin
      flag := TRUE;
      for i := 0 to RunDice - 1 do
      begin
        if DiceArr[i].DiceCount < DiceArr[i].DiceLimit then
        begin
          if GetTickCount - DiceArr[i].DiceTime > 100 then
          begin
            if DiceArr[i].DiceCount mod 5 = 4 then
              DiceArr[i].DiceCurrent := 1 + Random(6)
            else
              DiceArr[i].DiceCurrent := 8 + DiceArr[i].DiceCount mod 5;
            DiceArr[i].DiceTime := GetTickCount;
            Inc(DiceArr[i].DiceCount);
          end;
          flag := FALSE;
        end
        else
        begin
          DiceArr[i].DiceCurrent := DiceArr[i].DiceResult;
          if GetTickCount - DiceArr[i].DiceTime < 4000 then
            flag := FALSE;
        end;
      end;
      if flag then
        DMsgDlg.Visible := FALSE;
    end;
  end;

const
  XBase = 324;
var
  lx, ly, i, k: integer;
  d: TAsphyreLockableTexture;
begin
  lx := XBase;
  ly := 126;
  case DialogSize of
    0:  //小对话框
      begin
        d := WProgUse.Images[381];
        if d <> nil then
        begin
          DMsgDlg.SetImgIndex(WProgUse, 381);
          DMsgDlg.Left := (g_FScreenWidth - d.Width) div 2;
          DMsgDlg.Top := (g_FScreenHeight - d.Height) div 2;
          msglx := 39;
          msgly := 38;
          lx := 90; //d.Width div 2 - 38; //XBase;
          ly := 36; //56;
        end;
      end;
    1:  //大对话框（横）
      begin
        d := WProgUse.Images[360];
        if d <> nil then
        begin
          DMsgDlg.SetImgIndex(WProgUse, 360);
          DMsgDlg.Left := (g_FScreenWidth - d.Width) div 2;
          DMsgDlg.Top := (g_FScreenHeight - d.Height) div 2;
          msglx := 39;
          msgly := 38;
          lx := XBase;
          ly := 126;
        end;
      end;
    2:  //大对话框（竖）
      begin
        d := WProgUse.Images[380];
        if d <> nil then
        begin
          DMsgDlg.SetImgIndex(WProgUse, 380);
          DMsgDlg.Left := (g_FScreenWidth - d.Width) div 2;
          DMsgDlg.Top := (g_FScreenHeight - d.Height) div 2;
          msglx := 23;
          msgly := 20;
          lx := 90;
          ly := 305;
        end;
      end;
  end;
  DScreen.ClearHint(True);
  MsgText := msgstr;
  ViewDlgEdit := FALSE;
  DEdDlgEdit.Visible := FALSE;
  DMsgDlg.Floating := TRUE;   //编辑框不可见..
  DMsgDlgOk.Visible := FALSE;  //允许鼠标移动
  DMsgDlgYes.Visible := FALSE;
  DMsgDlgCancel.Visible := FALSE;
  DMsgDlgNo.Visible := FALSE;
  DMsgDlg.Left := (g_FScreenWidth - DMsgDlg.Width) div 2;
  DMsgDlg.Top := (g_FScreenHeight - DMsgDlg.Height) div 2;

  DEdDlgEdit.Text := '';

  for i := 0 to RunDice - 1 do
  begin
    DiceArr[i].DiceCount := 0;
    DiceArr[i].DiceLimit := 10 + Random(RunDice + 2) * 5;
    DiceArr[i].DiceCurrent := 1;
    DiceArr[i].DiceTime := GetTickCount;
  end;

  if mbCancel in DlgButtons then
  begin
    DMsgDlgCancel.Left := lx;
    DMsgDlgCancel.Top := ly;
    DMsgDlgCancel.Visible := TRUE;
    lx := lx - 110;
  end;
  if mbNo in DlgButtons then
  begin
    DMsgDlgNo.Left := lx;
    DMsgDlgNo.Top := ly;
    DMsgDlgNo.Visible := TRUE;
    lx := lx - 110;
  end;
  if mbYes in DlgButtons then
  begin
    DMsgDlgYes.Left := lx;
    DMsgDlgYes.Top := ly;
    DMsgDlgYes.Visible := TRUE;
    lx := lx - 110;
  end;
  if (mbOk in DlgButtons) or (lx = XBase) then
  begin
    DMsgDlgOk.Left := lx;
    DMsgDlgOk.Top := ly;
    DMsgDlgOk.Visible := TRUE;
    lx := lx - 110;
    SetDCapture(nil);
  end;
  HideAllControls;
  DMsgDlg.ShowModal;

  if mbAbort in DlgButtons then
  begin
    ViewDlgEdit := TRUE; //显示编辑框.
    DMsgDlg.Floating := FALSE;
    with DEdDlgEdit do
    begin
      Text := '';
      Width := DMsgDlg.Width - 70;
      Left := (DMsgDlg.Width - DEdDlgEdit.Width) div 2;
      Top := (DMsgDlg.Height - DEdDlgEdit.Height) div 2 - 10;
      DEdDlgEdit.MaxLength := MsgDlgMaxStr;
    end;
  end;
  Result := mrOk;
  k := 0;

  while TRUE do
  begin
    if not DMsgDlg.Visible then
      break;
      //FrmMain.DXTimerTimer (self, 0);
    frmMain.ProcOnIdle();
    Application.ProcessMessages; //接受消息
    Inc(k);
    if k = 5 then
    begin
      FrmMain.MsgProg;
      k := 0;
    end;

    if BoMsgDlgTimeCheck then
    begin
      if MsgDlgClickTime < GetTickCount then
      begin
        DMsgDlg.DialogResult := mrNo;
        BoMsgDlgTimeCheck := False;
        MsgDlgClickTime := GetTickCount;
        DMsgDlg.Visible := False;
        break;
      end;
    end;
    if RunDice > 0 then
    begin
      BoDrawDice := TRUE;
      for i := 0 to RunDice - 1 do
      begin
        DiceArr[i].DiceLeft := DMsgDlg.Width div 2 + 6 - (33 * RunDice) div 2 + 33 * i; // - 15;  //37
        DiceArr[i].DiceTop := DMsgDlg.Height div 2 - 14;  //25
      end;
      DoRunDice;
    end;
    if Application.Terminated then     //阻塞
      exit;
    Sleep(20);
  end;

  DEdDlgEdit.Visible := FALSE;
  RestoreHideControls;
  DlgEditText := DEdDlgEdit.Text;
  if FrmDlg.DEdChat.Visible then
    FrmDlg.DEdChat.SetFocus;
  ViewDlgEdit := FALSE;
  Result := DMsgDlg.DialogResult;
  DialogSize := 1; //扁夯惑怕
  RunDice := 0;
  BoDrawDice := FALSE;
  BoDrawOk := False;
end;

function TFrmDlg.DSimpleMessageDlg (msgstr: string; DlgButtons: TMsgDlgButtons): TModalResult;
const
  XBase = 384;
var
  I: Integer;
  lx, ly: integer;
  d: TAsphyreLockableTexture;
begin
  begin
    d := WProgUse.Images[710];
    if d <> nil then begin
      DMsgSimpleDlg.SetImgIndex(WProgUse, 710);
      DMsgSimpleDlg.Left := (g_FScreenWidth - d.Width) div 2;
      DMsgSimpleDlg.Top := (g_FScreenHeight - d.Height) div 2;
      msglx := 39;
      msgly := 38;
      lx := 220;
      ly := 96;
    end;
  end;
  MsgText := msgstr;
  ViewDlgEdit := FALSE;
  DMsgSimpleDlg.Floating := TRUE;
  DMsgSimpleDlgOk.Visible := False;
  DMsgSimpleDlgCancel.Visible := False;
  DMsgSimpleDlg.Left := (g_FScreenWidth - DMsgSimpleDlg.Width) div 2;
  DMsgSimpleDlg.Top := (g_FScreenHeight - DMsgSimpleDlg.Height) div 2;

  if MovingItem.Item.S.Name <> '' then
    FrmDlg.DMsgSimpleDlg.Top := 410;

  if (MySelf <> nil) and MySelf.Death then begin
    FrmDlg.DMsgSimpleDlg.Left := 0;
    FrmDlg.DMsgSimpleDlg.Top := 0;
  end;

  if mbCancel in DlgButtons then begin
    DMsgSimpleDlgCancel.Left := lx;
    DMsgSimpleDlgCancel.Top := ly;
    DMsgSimpleDlgCancel.Visible := True;
    lx := lx - 100;
  end;
  if (mbOK in DlgButtons) or (lx = XBase) then begin
    DMsgSimpleDlgOk.Left := lx;
    DMsgSimpleDlgOk.Top := ly;
    DMsgSimpleDlgOk.Visible := True;
    lx := lx - 100;
  end;
  HideAllControls;
  DMsgSimpleDlg.ShowModal;
  if mbAbort in DlgButtons then begin
    ViewDlgEdit := True;
    DMsgSimpleDlg.Floating := False;
    with DEdDlgEdit do begin
      Text := '';
      Width := DMsgDlg.Width - 70;
      Left := (DMsgDlg.Width - DEdDlgEdit.Width) div 2;
      Top := (DMsgDlg.Height - DEdDlgEdit.Height) div 2 - 10;
    end;
  end;
  Result := mrOk;

  while True do begin
    if not DMsgSimpleDlg.Visible then
      Break;

    FrmMain.ProcOnIdle();
    Application.ProcessMessages;
    if Application.Terminated then
      Exit;
    Sleep(20);
  end;

  DEdDlgEdit.Visible := False;
  RestoreHideControls;
  DlgEditText := DEdDlgEdit.Text;
  if FrmDlg.DEdChat.Visible then
    FrmDlg.DEdChat.SetFocus;
  ViewDlgEdit := False;
  Result := DMsgSimpleDlg.DialogResult;
end;

procedure TFrmDlg.OnFilterItemCheckDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
   k:integer;
begin
  k:=DMoveButton_items.Position;
  with Sender as TDCheckBox do
  begin
    if HiWord(TDCheckBox(Sender).Tag)+k>=DMoveButton_items.Tag then
       Exit;
    if WLib <> nil then begin
      d := nil;
      if Checked and Enabled then begin
        d := WLib.Images[FaceIndex + 1];
      end else begin
        d := WLib.Images[FaceIndex];
      end;
      if d <> nil then
      begin
        	dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
      end;
    end;
  end;
end;

function TFrmDlg.OnlyMessageDlg(msgstr: string; DlgButtons: TMsgDlgButtons): TModalResult;
const
  XBase = 329;
var
  lx, ly, i: integer;
  d: TAsphyreLockableTexture;
begin
  lx := XBase;
  ly := 126;
  case DialogSize of
    1:  //承绊 奴芭
      begin
        d := WProgUse.Images[360];
        if d <> nil then
        begin
          DMsgDlg.SetImgIndex(WProgUse, 360);
          DMsgDlg.Left := (g_FScreenWidth - d.Width) div 2;
          DMsgDlg.Top := (g_FScreenHeight - d.Height) div 2;
          msglx := 39;
          msgly := 38;
          lx := XBase;
          ly := 143;
        end;
      end;
  end;
  MsgText := msgstr;
  ViewDlgEdit := FALSE;
  DMsgDlg.Floating := TRUE;   //皋技瘤 冠胶啊 栋促丛..
  DMsgDlgOk.Visible := FALSE;
  DMsgDlgYes.Visible := FALSE;
  DMsgDlgCancel.Visible := FALSE;
  DMsgDlgNo.Visible := FALSE;
  DMsgDlg.Left := (g_FScreenWidth - DMsgDlg.Width) div 2;
  DMsgDlg.Top := (g_FScreenHeight - DMsgDlg.Height) div 2;

  if (mbOk in DlgButtons) or (lx = XBase) then
  begin
    DMsgDlgOk.Left := lx;
    DMsgDlgOk.Top := ly;
    DMsgDlgOk.Visible := TRUE;
    lx := lx - 110;
  end;
  HideAllControls;
  Result := mrOk;
  DMsgDlg.ShowModal;

  while TRUE do
  begin
    if not DMsgDlg.Visible then
      break;
      //FrmMain.DXTimerTimer (self, 0);
//      frmMain.AppOnIdle();
    Application.ProcessMessages;

{      if BoMsgDlgTimeCheck then begin
         if MsgDlgClickTime < GetTickCount then begin
            DMsgDlg.DialogResult := mrNo;
            BoMsgDlgTimeCheck := False;
            MsgDlgClickTime := GetTickCount;
            DMsgDlg.Visible := False;
            break;
         end;
      end;}
    if Application.Terminated then
      exit;
      Sleep(20);
  end;

  DEdDlgEdit.Visible := FALSE;
  RestoreHideControls;
  DlgEditText := DEdDlgEdit.Text;
  if FrmDlg.DEdChat.Visible then
    FrmDlg.DEdChat.SetFocus;
  ViewDlgEdit := FALSE;
  Result := DMsgDlg.DialogResult;
  DialogSize := 1; //扁夯惑怕
  RunDice := 0;
  BoDrawDice := FALSE;
end;

procedure TFrmDlg.DMsgDlgOkClick(Sender: TObject; X, Y: Integer);
begin
  if Sender = DMsgDlgOk then
    DMsgDlg.DialogResult := mrOk;
  if Sender = DMsgDlgYes then
    DMsgDlg.DialogResult := mrYes;
  if Sender = DMsgDlgCancel then
    DMsgDlg.DialogResult := mrCancel;
  if Sender = DMsgDlgNo then
    DMsgDlg.DialogResult := mrNo;

  if GameClose then
  begin
//      FrmMain.CloseNPMon;
    FrmMain.Close;
  end;

  BoMsgDlgTimeCheck := False;
  MsgDlgClickTime := GetTickCount;
  DMsgDlg.Visible := FALSE;
end;

procedure TFrmDlg.DMsgDlgKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);
begin
  if Key = 13 then
  begin
      //2003/02/11 OK/Cancel俊辑绰 浚磐甫 OK肺...
    if DMsgDlgOk.Visible and not (DMsgDlgYes.Visible {or DMsgDlgCancel.Visible}  or DMsgDlgNo.Visible) then
    begin
      DMsgDlg.DialogResult := mrOk;
      DMsgDlg.Visible := FALSE;
    end;
    if DMsgDlgYes.Visible and not (DMsgDlgOk.Visible or DMsgDlgCancel.Visible) then
    begin
      DMsgDlg.DialogResult := mrYes;
      DMsgDlg.Visible := FALSE;
    end;
  end;
  if Key = 27 then
  begin
    if DMsgDlgNo.Visible then
    begin
      DMsgDlg.DialogResult := mrNo;
      DMsgDlg.Visible := FALSE;
    end;
    if DMsgDlgCancel.Visible then
    begin
      DMsgDlg.DialogResult := mrCancel;
      DMsgDlg.Visible := FALSE;
    end;
  end;
end;

procedure TFrmDlg.DMsgDlgOkDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with Sender as TDButton do
  begin
    if not Downed then
      d := WLib.Images[FaceIndex]
    else
      d := WLib.Images[FaceIndex + 1];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
  end;
end;

procedure TFrmDlg.DMsgSimpleDlgDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  I: Integer;
  d: TAsphyreLockableTexture;
  ly: integer;
  str, data: string;
  nX,nY:Integer;
begin
   with Sender as TDWindow do begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
         dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

      ly := msgly;
      str := MsgText;
      while TRUE do begin
         if str = '' then break;
         str := GetValidStr3 (str, data, ['\']);
         if data = 'LoadingWait' then begin
           if data <> '' then
            dsurface.BoldTextOut (SurfaceX(Left+msglx), SurfaceY(Top+ly), clWhite, clBlack, '当前数据正在处理中. ');
            ly := ly + 14;
            dsurface.BoldTextOut (SurfaceX(Left+msglx), SurfaceY(Top+ly), clWhite, clBlack, inttostr(LoadingWaitTime)+'秒后可以连接. ');
         end else begin
         if data <> '' then
            dsurface.BoldTextOut (SurfaceX(Left+msglx), SurfaceY(Top+ly), clWhite, clBlack, data);
         ly := ly + 14;
         end
      end;
   end;
   if ViewDlgEdit then begin
      if not DEdDlgEdit.Visible then begin
         DEdDlgEdit.Visible := TRUE;
         DEdDlgEdit.SetFocus;
      end;
   end;
end;

procedure TFrmDlg.DMsgSimpleDlgKeyDown(Sender: TObject; var Key: Word;
  Shift: TShiftState);
begin
   if Key = 13 then begin
      if DMsgSimpleDlgOk.Visible then begin
         DMsgSimpleDlg.DialogResult := mrOk;
         DMsgSimpleDlg.Visible := FALSE;
      end;
   end;
   if Key = 27 then begin
      if DMsgSimpleDlgCancel.Visible then begin
         DMsgSimpleDlg.DialogResult := mrCancel;
         DMsgSimpleDlg.Visible := FALSE;
      end;
   end;
end;

procedure TFrmDlg.DMsgSimpleDlgOkClick(Sender: TObject; X, Y: Integer);
begin
  if Sender = DMsgSimpleDlgOk then DMsgSimpleDlg.DialogResult := mrOk;
  if Sender = DMsgSimpleDlgCancel then DMsgSimpleDlg.DialogResult := mrCancel;
  DMsgSimpleDlg.Visible := FALSE;
end;

procedure TFrmDlg.DMsgDlgDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d, dr: TAsphyreLockableTexture;
  ly, px, py, i: integer;
  str, data: string;
begin
  with Sender as TDWindow do
  begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
    if BoDrawDice then
    begin
      if DiceType = 1 then
      begin
        for i := 0 to RunDice - 1 do
        begin
          dr := WBagItem.GetCachedImage(376 + DiceArr[i].DiceCurrent - 1, px, py);
          if dr <> nil then
          begin
            dsurface.Draw(SurfaceX(Left) + DiceArr[i].DiceLeft + px - 14, SurfaceY(Top) + DiceArr[i].DiceTop + py + 38, dr.ClientRect, dr, TRUE);
          end;
        end;
      end
      else if DiceType = 2 then
      begin
        dr := WBagItem.GetCachedImage(887 + DiceArr[0].DiceCurrent, px, py);
        if dr <> nil then
        begin
          dsurface.Draw(SurfaceX(Left) + DiceArr[0].DiceLeft + px - 14, SurfaceY(Top) + DiceArr[0].DiceTop + py + 38, dr.ClientRect, dr, TRUE);
        end;
      end;
    end;
//      //SetBkMode (g_DXCanvas.Handle, TRANSPARENT);
    ly := msgly;
    str := MsgText;
    while TRUE do
    begin
      if str = '' then
        break;
      str := GetValidStr3(str, data, ['\']);
      if data <> '' then
        dsurface.TextOut(SurfaceX(Left + msglx), SurfaceY(Top + ly), clWhite, data);
      ly := ly + 14;
    end;
//      g_DXCanvas.//Release;
  end;
  if ViewDlgEdit then
  begin
    if not DEdDlgEdit.Visible then
    begin
      DEdDlgEdit.Visible := TRUE;
      DEdDlgEdit.SetFocus;
    end;
  end;
end;

{------------------------------------------------------------------------}

//肺弊牢 芒

procedure TFrmDlg.DLoginNewDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with Sender as TDButton do
  begin
    if TDButton(Sender).Downed then
    begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
    end;
  end;
end;
//注册帐号

procedure TFrmDlg.DLoginNewClick(Sender: TObject; X, Y: Integer);
var
  IE: variant;
begin
 LoginScene.NewClick;     // 登录器上注册
//   2003/03/18 下面是网页注册，如需网页注册，需屏蔽上面
//  if mrOk = FrmDlg.DMessageDlg('注册新用户功能已转向官方网站：http://www.mir778.com\ \点击“确定”按钮立即注册新用户。', [mbOk, mbCancel]) then
//  begin
//    IE := CreateOleObject('Internetexplorer.Application');
//    IE.Visible := true;
//    IE.Navigate('http://www.mir778.com');
//    FrmMain.CloseNPMon;
//    FrmMain.Close;
//  end;
end;

procedure TFrmDlg.DLoginOkClick(Sender: TObject; X, Y: Integer);
begin
  LoginScene.OkClick;
end;

procedure TFrmDlg.DLoginCloseClick(Sender: TObject; X, Y: Integer);
begin
//   FrmMain.CloseNPMon;
  FrmMain.Close;
end;
//修改密码

procedure TFrmDlg.DLBPracticeClick(Sender: TObject; X, Y: Integer);
begin
  g_NgConfigInfo.nAutoMagicID := DCBPractice.tag;
end;

procedure TFrmDlg.DListBox_ItemsChange(Sender: TObject);
begin
//  g_NgConfigInfo.sRanItemName := DListBox_Items.Item.Strings[DListBox_Items.ItemIndex];
end;

procedure TFrmDlg.DLoginChgPwClick(Sender: TObject; X, Y: Integer);
var
  IE: variant;
begin
   LoginScene.ChgPwClick;    // 登录器上修改密码，
//   2003/03/18 下面是修改密码跳转网页，
//  if mrOk = FrmDlg.DMessageDlg('密码服务功能已转向官方网站：http://www.mir778.com\ \点击“确定”按钮立即进入密码服务页面。', [mbOk, mbCancel]) then
//  begin
//    IE := CreateOleObject('Internetexplorer.Application');
//    IE.Visible := true;
//    IE.Navigate('http://www.mir778.com');
//    FrmMain.CloseNPMon;
//    FrmMain.Close;
//  end;
end;

procedure TFrmDlg.DLoginNewClickSound(Sender: TObject; Clicksound: TClickSound);
begin
  case Clicksound of
    csNorm:
      PlaySound(s_norm_button_click);
    csStone:
      PlaySound(s_rock_button_click);
    csGlass:
      PlaySound(s_glass_button_click);
  end;
end;

{------------------------------------------------------------------------}
//显示选择服务器对话框

procedure TFrmDlg.ShowSelectServerDlg;
begin
  DSelServerDlg.Visible := TRUE;
  BoFirstShowOnServerSel := TRUE;
end;

procedure TFrmDlg.DSelServerDlgDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with DSelServerDlg do
  begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
  end;
  if BoFirstShowOnServerSel then
  begin
    BoFirstShowOnServerSel := FALSE;

    if ServerCount >= 1 then
      DSServer1.Caption := ServerCaptionArr[0];
    if ServerCount >= 2 then
      DSServer2.Caption := ServerCaptionArr[1];
    if ServerCount >= 3 then
      DSServer3.Caption := ServerCaptionArr[2];
    if ServerCount >= 4 then
      DSServer4.Caption := ServerCaptionArr[3];
    if ServerCount >= 5 then
      DSServer5.Caption := ServerCaptionArr[4];
    if ServerCount >= 6 then
      DSServer6.Caption := ServerCaptionArr[5];
    if ServerCount >= 7 then
      DSServer7.Caption := ServerCaptionArr[6];
    if ServerCount >= 8 then
      DSServer8.Caption := ServerCaptionArr[7];
  end;

end;

procedure TFrmDlg.DSServer1Click(Sender: TObject; X, Y: Integer);
var
  svname: string;
begin
  svname := '';
  if TDButton(Sender).Tag = 0 then
    svname := ServerNameArr[0];
  if TDButton(Sender).Tag = 1 then
    svname := ServerNameArr[1];
  if TDButton(Sender).Tag = 2 then
    svname := ServerNameArr[2];
  if TDButton(Sender).Tag = 3 then
    svname := ServerNameArr[3];
  if TDButton(Sender).Tag = 4 then
    svname := ServerNameArr[4];
  if TDButton(Sender).Tag = 5 then
    svname := ServerNameArr[5];
  if TDButton(Sender).Tag = 6 then
    svname := ServerNameArr[6];
  if TDButton(Sender).Tag = 7 then
    svname := ServerNameArr[7];
  if TDButton(Sender).Tag = 8 then
    svname := ServerNameArr[8];

  if svname <> '' then
  begin
    if BO_FOR_TEST then
    begin
      svname := 'DragonServer';
    end;
    FrmMain.SendSelectServer(svname);
    DSelServerDlg.Visible := FALSE;
    ServerName := svname;
  end;
end;

procedure TFrmDlg.DEngServer1Click(Sender: TObject; X, Y: Integer);
var
  svname: string;
begin
  svname := 'DragonServer';

  if svname <> '' then
  begin
    if BO_FOR_TEST then
    begin
      svname := 'DragonServer';
    end;
    FrmMain.SendSelectServer(svname);
    DSelServerDlg.Visible := FALSE;
    ServerName := svname;
  end;
end;

procedure TFrmDlg.DSSrvCloseClick(Sender: TObject; X, Y: Integer);
begin
  DSelServerDlg.Visible := FALSE;
//   FrmMain.CloseNPMon;
  FrmMain.Close;
end;


{------------------------------------------------------------------------}

//新帐号
procedure TFrmDlg.DNewAccountOkClick(Sender: TObject; X, Y: Integer);
begin
  LoginScene.NewAccountOk;
end;

procedure TFrmDlg.DNewAccountCloseClick(Sender: TObject; X, Y: Integer);
begin
  LoginScene.NewAccountClose;
end;

procedure TFrmDlg.DNewAccountDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  i: integer;
begin
  with dsurface do
  begin
    with DNewAccount do
    begin
      d := DMenuDlg.WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
    end;

//      //SetBkMode (Handle, TRANSPARENT);
//      Font.Color := clSilver;
    for i := 0 to NAHelps.Count - 1 do
    begin
      TextOut((g_FScreenWidth - DEFSCREENWIDTH) div 2 + 79 + 386 + 10,
              (g_FScreenHeight - DEFSCREENHEIGHT) div 2 + 64 + 119 + 5 + i * 14, clSilver, NAHelps[i]);
    end;
    TextOut((g_FScreenWidth - DEFSCREENWIDTH) div 2 + 79 + 283, (g_FScreenHeight - DEFSCREENHEIGHT) div 2 + 64 + 57, clWhite, NewAccountTitle);
//      //Release;
  end;
end;



{------------------------------------------------------------------------}
////Chg pw 冠胶

procedure TFrmDlg.DChgpwOkClick(Sender: TObject; X, Y: Integer);
begin
  if Sender = DChgpwOk then
    LoginScene.ChgpwOk;
  if Sender = DChgpwCancel then
    LoginScene.ChgpwCancel;
end;




{------------------------------------------------------------------------}
//某腐磐 急琶

procedure TFrmDlg.DscSelect1DirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with Sender as TDButton do
  begin
    if Downed then
    begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(Left, Top, d.ClientRect, d, TRUE);
    end;
  end;
end;

procedure TFrmDlg.DscSelect1Click(Sender: TObject; X, Y: Integer);
begin
  if Sender = DscSelect1 then
    SelectChrScene.SelChrSelect1Click;
  if Sender = DscSelect2 then
    SelectChrScene.SelChrSelect2Click;
  if Sender = DscStart then
    SelectChrScene.SelChrStartClick;
  if Sender = DscNewChr then
    SelectChrScene.SelChrNewChrClick;
  if Sender = DscEraseChr then
    SelectChrScene.SelChrEraseChrClick;
  if Sender = DscCredits then
    SelectChrScene.SelChrCreditsClick;
  if Sender = DscExit then
    SelectChrScene.SelChrExitClick;
end;


{------------------------------------------------------------------------}
//新建人物职业选择

procedure TFrmDlg.DccCloseDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with Sender as TDButton do
  begin
    if Downed then
    begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
    end
    else
    begin
      d := nil;
      if Sender = DccWarrior then
      begin
        with SelectChrScene do
          if ChrArr[NewIndex].UserChr.Job = 0 then
            d := WLib.Images[55];
      end;
      if Sender = DccWizzard then
      begin
        with SelectChrScene do
          if ChrArr[NewIndex].UserChr.Job = 1 then
            d := WLib.Images[56];
      end;
      if Sender = DccMonk then
      begin
        with SelectChrScene do
          if ChrArr[NewIndex].UserChr.Job = 2 then
            d := WLib.Images[57];
      end;
      if Sender = DccMale then
      begin
        with SelectChrScene do
          if ChrArr[NewIndex].UserChr.Sex = 0 then
            d := WLib.Images[58];
      end;
      if Sender = DccFemale then
      begin
        with SelectChrScene do
          if ChrArr[NewIndex].UserChr.Sex = 1 then
            d := WLib.Images[59];
      end;
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
    end;
  end;
end;

procedure TFrmDlg.DccCloseClick(Sender: TObject; X, Y: Integer);
begin
  if Sender = DccClose then
    SelectChrScene.SelChrNewClose;
  if Sender = DccWarrior then
    SelectChrScene.SelChrNewJob(0);
  if Sender = DccWizzard then
    SelectChrScene.SelChrNewJob(1);
  if Sender = DccMonk then
    SelectChrScene.SelChrNewJob(2);
  if Sender = DccReserved then
    SelectChrScene.SelChrNewJob(3);
  if Sender = DccMale then
    SelectChrScene.SelChrNewSex(0);
  if Sender = DccFemale then
    SelectChrScene.SelChrNewSex(1);
//   if Sender = DccLeftHair then SelectChrScene.SelChrNewPrevHair;
//   if Sender = DccRightHair then SelectChrScene.SelChrNewNextHair;
  if Sender = DccOk then
    SelectChrScene.SelChrNewOk;
end;

{------------------------------------------------------------------------}

//人物信息栏绘画...

{------------------------------------------------------------------------}

procedure TFrmDlg.DStateWinDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  i, l, m, pgidx, magline, bbx, bby, mmx, idx, ax, ay, lx, trainlv, tx: integer;
  pm: PTClientMagic;
  d: TAsphyreLockableTexture;
  hcolor, old, keyimg, TempTop: integer;
  iname, d1, d2, d3, d4, d5: string;
  useable: Boolean;
  str: string;
  FColor: TColor;
begin
  if Myself = nil then
    exit;
  with DStateWin do
  begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

    case StatePage of
      0:
        begin //自己装备
          if (g_bo人物四格)and (not g_bochksigedu) then
          pgidx := 90
          else 
         if (g_bo人物四格) and (g_bochksigedu) then    
          pgidx := 804
          else
          pgidx := 376; //男4格
          if Myself <> nil then
            if Myself.Sex = 1 then
              if (g_bo人物四格)and (not g_bochksigedu) then
                pgidx := 91
                else
              if (g_bo人物四格) and (g_bochksigedu) then    
             pgidx := 805
             else
              pgidx := 377; //女4格
          bbx := Left + 38;
          bby := Top + 52;
          d := WProgUse.Images[pgidx];
          if d <> nil then
            dsurface.Draw(SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, FALSE);
          bbx := bbx - 7;
          bby := bby + 44;
          if UseItems[U_DRESS].S.Name <> '' then
          begin
            idx := UseItems[U_DRESS].S.Looks; //衣服 if Myself.Sex = 1 then idx := 80; //女衣服
            if idx >= 0 then
            begin
              d := WStateItem.GetCachedImage(idx, ax, ay);
              if d <> nil then
                dsurface.Draw(SurfaceX(bbx + ax), SurfaceY(bby + ay), d.ClientRect, d, TRUE);
            end;
          end;

          idx := 440 + Myself.Hair div 2; //发型
          if Myself.Sex = 1 then
            idx := 480 + Myself.Hair div 2;
          if idx > 0 then
          begin
            d := WProgUse.GetCachedImage(idx, ax, ay);
            if d <> nil then
              dsurface.Draw(SurfaceX(bbx + ax), SurfaceY(bby + ay), d.ClientRect, d, TRUE);
          end;

          if UseItems[U_WEAPON].S.Name <> '' then
          begin
            idx := UseItems[U_WEAPON].S.Looks;
            if idx >= 0 then
            begin
              d := WStateItem.GetCachedImage(idx, ax, ay);
              if d <> nil then
                dsurface.Draw(SurfaceX(bbx + ax), SurfaceY(bby + ay), d.ClientRect, d, TRUE);
            end;
            if idx = 923 then
            begin
              d := WStateItem.GetCachedImage(idx - 1, ax, ay);
              if d <> nil then
               dsurface.DrawBlend(SurfaceX(bbx + ax), SurfaceY(bby + ay), d, 1);
            end;
          end;
          if UseItems[U_HELMET].S.Name <> '' then
          begin
            idx := UseItems[U_HELMET].S.Looks;
            if idx >= 0 then
            begin
              d := WStateItem.GetCachedImage(idx, ax, ay);
              if d <> nil then
                dsurface.Draw(SurfaceX(bbx + ax), SurfaceY(bby + ay), d.ClientRect, d, TRUE);
            end;
          end;
        end;
        
      1:
        begin //状态值
          l := Left + 112; //66;
          m := Top + 99;
          with dsurface do
          begin
               //SetBkMode (Handle, TRANSPARENT);
//               Font.Color := clWhite;
            TextOut(SurfaceX(l + 0), SurfaceY(m + 0), clWhite, IntToStr(Lobyte(Myself.Abil.AC)) + '-' + IntToStr(Hibyte(Myself.Abil.AC)));
            TextOut(SurfaceX(l + 0), SurfaceY(m + 20), clWhite, IntToStr(Lobyte(Myself.Abil.MAC)) + '-' + IntToStr(Hibyte(Myself.Abil.MAC)));
            TextOut(SurfaceX(l + 0), SurfaceY(m + 40), clWhite, IntToStr(Lobyte(Myself.Abil.DC)) + '-' + IntToStr(Hibyte(Myself.Abil.DC)));
            TextOut(SurfaceX(l + 0), SurfaceY(m + 60), clWhite, IntToStr(Lobyte(Myself.Abil.MC)) + '-' + IntToStr(Hibyte(Myself.Abil.MC)));
            TextOut(SurfaceX(l + 0), SurfaceY(m + 80), clWhite, IntToStr(Lobyte(Myself.Abil.SC)) + '-' + IntToStr(Hibyte(Myself.Abil.SC)));
            TextOut(SurfaceX(l + 0), SurfaceY(m + 100), clWhite, IntToStr(Myself.Abil.HP) + '/' + IntToStr(Myself.Abil.MaxHP));
            TextOut(SurfaceX(l + 0), SurfaceY(m + 120), clWhite, IntToStr(Myself.Abil.MP) + '/' + IntToStr(Myself.Abil.MaxMP));
                   //Release;
          end;
        end;
      2:
        begin //人物属性数值
          bbx := Left + 38;
          bby := Top + 52;
          if g_bo人物四格 then
            d := WProgUse.Images[94]
            else
          d := WProgUse.Images[382];
          if d <> nil then
            dsurface.Draw(SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, FALSE);

          bbx := bbx + 20;
          bby := bby + 10;
          with dsurface do
          begin
               //SetBkMode (Handle, TRANSPARENT);
            mmx := bbx + 85;
               //TextOut (bbx, bby, '经验值');
               //TextOut (mmx, bby, Format('%2.2f',[Myself.Abil.Exp/Myself.Abil.MaxExp*100]) + '%');

            TextOut(bbx, bby, clSilver, '当前经验');
            TextOut(mmx, bby, clSilver, IntToStr(Myself.Abil.Exp));

            TextOut(bbx, bby + 14 * 1, clSilver, '升级经验');
            TextOut(mmx, bby + 14 * 1, clSilver, IntToStr(Myself.Abil.MaxExp));

            TextOut(bbx, bby + 14 * 2, clSilver, '背包重量');
            if Myself.Abil.Weight > Myself.Abil.MaxWeight then
              FColor := clRed
            else
              FColor := clSilver;
            TextOut(mmx, bby + 14 * 2, FColor, IntToStr(Myself.Abil.Weight) + '/' + IntToStr(Myself.Abil.MaxWeight));

            TextOut(bbx, bby + 14 * 3, clSilver, '负重量');
            if Myself.Abil.WearWeight > Myself.Abil.MaxWearWeight then
              FColor := clRed
            else
              FColor := clSilver;
            TextOut(mmx, bby + 14 * 3, FColor, IntToStr(Myself.Abil.WearWeight) + '/' + IntToStr(Myself.Abil.MaxWearWeight));

            TextOut(bbx, bby + 14 * 4, clSilver, '腕力');
            if Myself.Abil.HandWeight > Myself.Abil.MaxHandWeight then
              FColor := clRed
            else
              FColor := clSilver;
            TextOut(mmx, bby + 14 * 4, FColor, IntToStr(Myself.Abil.HandWeight) + '/' + IntToStr(Myself.Abil.MaxHandWeight));

            TextOut(bbx, bby + 14 * 5, clSilver, '精确度');
            TextOut(mmx, bby + 14 * 5, clSilver, IntToStr(MyHitPoint));

            TextOut(bbx, bby + 14 * 6, clSilver, '敏捷度');
            TextOut(mmx, bby + 14 * 6, clSilver, IntToStr(MySpeedPoint));

            TextOut(bbx, bby + 14 * 7, clSilver, '魔法防御');
            TextOut(mmx, bby + 14 * 7, clSilver, '+' + IntToStr(MyAntiMagic * 10) + '%');

            TextOut(bbx, bby + 14 * 8, clSilver, '中毒防御');
            TextOut(mmx, bby + 14 * 8, clSilver, '+' + IntToStr(MyAntiPoison * 10) + '%');

            TextOut(bbx, bby + 14 * 9, clSilver, '中毒恢复');
            TextOut(mmx, bby + 14 * 9, clSilver, '+' + IntToStr(MyPoisonRecover * 10) + '%');

            TextOut(bbx, bby + 14 * 10, clSilver, '体力恢复');
            TextOut(mmx, bby + 14 * 10, clSilver, '+' + IntToStr(MyHealthRecover * 10) + '%');

            TextOut(bbx, bby + 14 * 11, clSilver, '魔法恢复');
            TextOut(mmx, bby + 14 * 11, clSilver, '+' + IntToStr(MySpellRecover * 10) + '%');

            TextOut(bbx, bby + 14 * 12, clSilver, '元宝数量');
            TextOut(mmx, bby + 14 * 12, clSilver, '' + IntToStr(Myself.PlayCash));

          end;   //Release;

        end;
      3:
        begin //魔法背景
          bbx := Left + 38;
          bby := Top + 52;
          if g_bo人物四格 then
            d := WProgUse.Images[93]
            else
          d := WProgUse.Images[383];
          if d <> nil then
            dsurface.Draw(SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, FALSE);

            //lv, exp
          magtop := MagicPage * g_nMagicCount;
          magline := _MIN(MagicPage * g_nMagicCount + g_nMagicCount, MagicList.Count);
          for i := magtop to magline - 1 do
          begin
            pm := PTClientMagic(MagicList[i]);
            m := i - magtop;
            keyimg := 0;
            case byte(pm.Key) of
              byte('1'):
                keyimg := 248;
              byte('2'):
                keyimg := 249;
              byte('3'):
                keyimg := 250;
              byte('4'):
                keyimg := 251;
              byte('5'):
                keyimg := 252;
              byte('6'):
                keyimg := 253;
              byte('7'):
                keyimg := 254;
              byte('8'):
                keyimg := 255;
                  // 2003/08/20 =>魔法力窜绵虐 眠啊  // AddMagicKey
              byte('1') + 20:
                keyimg := 642;
              byte('2') + 20:
                keyimg := 643;
              byte('3') + 20:
                keyimg := 644;
              byte('4') + 20:
                keyimg := 645;
              byte('5') + 20:
                keyimg := 646;
              byte('6') + 20:
                keyimg := 647;
              byte('7') + 20:
                keyimg := 648;
              byte('8') + 20:
                keyimg := 649;
                  //-----------
            end;
            if keyimg > 0 then
            begin
              d := WProgUse.Images[keyimg];
              if d <> nil then
                dsurface.Draw(bbx + 145, bby + 8 + m * 37, d.ClientRect, d, TRUE);
            end;

            if g_boChinese then  d := WProgUse.Images[146]
            else d := WProgUse.Images[112]; //lv
            if d <> nil then
              dsurface.Draw(bbx + 48, bby + 8 + 15 + m * 37, d.ClientRect, d, TRUE);

            if g_boChinese then  d := WProgUse.Images[145]
            else d := WProgUse.Images[111]; //exp
            if d <> nil then
              dsurface.Draw(bbx + 48 + 26, bby + 8 + 15 + m * 37, d.ClientRect, d, TRUE);
          end;

          with dsurface do
          begin
               //SetBkMode (Handle, TRANSPARENT);
//               Font.Color := clSilver;

            if g_boChinese then lx := 4
            else lx := 0;

            for i := magtop to magline - 1 do
            begin
              pm := PTClientMagic(MagicList[i]);
              m := i - magtop;
              if not (pm.Level in [0..3]) then
                pm.Level := 0; //魔法最多3级



              TextOut(bbx + 48, bby + 8 + m * 37, clSilver, pm.Def.MagicName);
              if pm.Level in [0..3] then
                trainlv := pm.Level
              else
                trainlv := 0;



              TextOut(bbx + lx + 48 + 16, bby + 8 + 15 + m * 37, clSilver, IntToStr(pm.Level));
              if pm.Def.MaxTrain[trainlv] > 0 then
              begin
                if trainlv < 3 then
                  TextOut(bbx + 48 + 46, bby  + 8 + 15 + m * 37, clSilver, IntToStr(pm.CurTrain) + '/' + IntToStr(pm.Def.MaxTrain[trainlv]))
                else
                  TextOut(bbx + 48 + 46, bby + 8 + 15 + m * 37, clSilver, '-');
              end;
            end;
               //Release;
          end;
        end;
    end;
      //本代码为显示人物身上所带物品信息，显示位置为人物下方
    if MouseStateItem.S.Name <> '' then
    begin
      MouseItem := MouseStateItem;
      GetMouseItemInfo(iname, d1, d2, d3, d4, d5, useable, TRUE);
      if (iname <> '') and not g_bo悬浮信息 then
      begin
        if MouseItem.Dura = 0 then
          hcolor := clRed
//            else if MouseItem.UpgradeOpt > 0 then hcolor := clAqua  //$0C36E9 //@@@@@
//        else if MouseItem.UpgradeOpt > 0 then     // 极品蓝色  自己身上
//          hcolor := TColor($cccc33)          // 极品蓝色  自己身上   这个代码应该就是那个功能
        else if (MouseItem.UpgradeOpt > 0) and g_bo极品蓝字 then
          hcolor := TColor($cccc33)
        else
          hcolor := clWhite;
        if g_bo人物四格 then
          TempTop := 38
          else
          TempTop := 0;
            // 2003/03/15 本代码为显示人物身上所带物品信息，显示位置为人物下方
        with dsurface do
        begin
          TextOut(SurfaceX(Left + 37), SurfaceY(Top + 272) + TempTop, clYellow, iname);
          TextOut(SurfaceX(Left + 37 + FontManager.Default.TextWidth(iname)), SurfaceY(Top + 272) + TempTop, hcolor, d1);
          TextOut(SurfaceX(Left + 37), SurfaceY(Top + 272 + FontManager.Default.TextHeight('A') + 2) + TempTop, hcolor, d2);
          TextOut(SurfaceX(Left + 37), SurfaceY(Top + 272 + (FontManager.Default.TextHeight('A') + 2) * 2) + TempTop, hcolor, d3 + d4);
        end;

            // 2003/03/15 显示物品信息在上方(漂浮显示)
            //  Str := iname + d1 + '\' + d2 + '\' + d3 + d4;
            //  DScreen.ShowHint(MouseX, MouseY, Str, hcolor, FALSE);  //这里啥都没写   就是用提示输出了

      end;
      MouseItem.S.Name := '';
    end;

      //玩家名称、行会名称、恋爱心
    with dsurface do
    begin
         //SetBkMode (Handle, TRANSPARENT);
//         Font.Color := Myself.NameColor;
//
         tx := 122 - FontManager.Default.TextWidth(FrmMain.CharName) div 2;
////         TextOut (SurfaceX(Left + tx), SurfaceX(Top + 12), Myself.UserName);
         DHeartImg.Left := tx-14;
         DHeartImg.Top := 24;
//
//         TextOut (SurfaceX(Left + 122 - TextWidth(FrmMain.CharName) div 2),
//                  SurfaceY(Top + 23), Myself.UserName);

      TextOut(SurfaceX(Left + 122 - FontManager.Default.TextWidth(FrmMain.CharName) div 2), SurfaceY(Top + 23), Myself.NameColor, Myself.UserName);

      if StatePage = 0 then
      begin
        TextOut(SurfaceX(Left + 45), SurfaceY(Top + 55), clSilver, GuildName + ' ' + GuildRankName);
      end;
         //Release;
    end;
  end;
end;

procedure TFrmDlg.DStateWinMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
  DScreen.ClearHint(True);
  MouseItem.S.Name := '';
  MouseStateItem.S.Name := '';
  MouseUserStateItem.S.Name := '';
end;

procedure TFrmDlg.DSWLightDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  idx: integer;
  d: TAsphyreLockableTexture;
begin
  if StatePage = 0 then
  begin
    if Sender = DSWNecklace then
    begin
      if UseItems[U_NECKLACE].S.Name <> '' then
      begin
        idx := UseItems[U_NECKLACE].S.Looks;
        if idx >= 0 then
        begin
          d := WStateItem.Images[idx];
          if d <> nil then
            dsurface.Draw(DSWNecklace.SurfaceX(DSWNecklace.Left + (DSWNecklace.Width - d.Width) div 2), DSWNecklace.SurfaceY(DSWNecklace.Top + (DSWNecklace.Height - d.Height) div 2), d.ClientRect, d, TRUE);
        end;
      end;
    end;
    if Sender = DSWLight then
    begin
      if UseItems[U_RIGHTHAND].S.Name <> '' then
      begin
        idx := UseItems[U_RIGHTHAND].S.Looks;
        if idx >= 0 then
        begin
          d := WStateItem.Images[idx];
          if d <> nil then
            dsurface.Draw(DSWLight.SurfaceX(DSWLight.Left + (DSWLight.Width - d.Width) div 2), DSWLight.SurfaceY(DSWLight.Top + (DSWLight.Height - d.Height) div 2), d.ClientRect, d, TRUE);
        end;
      end;
    end;
    if Sender = DSWArmRingR then
    begin
      if UseItems[U_ARMRINGR].S.Name <> '' then
      begin
        idx := UseItems[U_ARMRINGR].S.Looks;
        if idx >= 0 then
        begin
          d := WStateItem.Images[idx];
          if d <> nil then
            dsurface.Draw(DSWArmRingR.SurfaceX(DSWArmRingR.Left + (DSWArmRingR.Width - d.Width) div 2), DSWArmRingR.SurfaceY(DSWArmRingR.Top + (DSWArmRingR.Height - d.Height) div 2), d.ClientRect, d, TRUE);
        end;
      end;
    end;
    if Sender = DSWArmRingL then
    begin
      if UseItems[U_ARMRINGL].S.Name <> '' then
      begin
        idx := UseItems[U_ARMRINGL].S.Looks;
        if idx >= 0 then
        begin
          d := WStateItem.Images[idx];
          if d <> nil then
            dsurface.Draw(DSWArmRingL.SurfaceX(DSWArmRingL.Left + (DSWArmRingL.Width - d.Width) div 2), DSWArmRingL.SurfaceY(DSWArmRingL.Top + (DSWArmRingL.Height - d.Height) div 2), d.ClientRect, d, TRUE);
        end;
      end;
    end;
    if Sender = DSWRingR then
    begin
      if UseItems[U_RINGR].S.Name <> '' then
      begin
        idx := UseItems[U_RINGR].S.Looks;
        if idx >= 0 then
        begin
          d := WStateItem.Images[idx];
          if d <> nil then
            dsurface.Draw(DSWRingR.SurfaceX(DSWRingR.Left + (DSWRingR.Width - d.Width) div 2), DSWRingR.SurfaceY(DSWRingR.Top + (DSWRingR.Height - d.Height) div 2), d.ClientRect, d, TRUE);
        end;
      end;
    end;
    if Sender = DSWRingL then
    begin
      if UseItems[U_RINGL].S.Name <> '' then
      begin
        idx := UseItems[U_RINGL].S.Looks;
        if idx >= 0 then
        begin
          d := WStateItem.Images[idx];
          if d <> nil then
            dsurface.Draw(DSWRingL.SurfaceX(DSWRingL.Left + (DSWRingL.Width - d.Width) div 2), DSWRingL.SurfaceY(DSWRingL.Top + (DSWRingL.Height - d.Height) div 2), d.ClientRect, d, TRUE);
        end;
      end;
    end;
      // 2003/03/15 酒捞袍 牢亥配府 犬厘
    if Sender = DSWBujuk then
    begin
      if UseItems[U_BUJUK].S.Name <> '' then
      begin
        idx := UseItems[U_BUJUK].S.Looks;
        if idx >= 0 then
        begin
          d := WStateItem.Images[idx];
          if d <> nil then
            dsurface.Draw(DSWBujuk.SurfaceX(DSWBujuk.Left + (DSWBujuk.Width - d.Width) div 2) + 1, DSWBujuk.SurfaceY(DSWBujuk.Top + (DSWBujuk.Height - d.Height) div 2), d.ClientRect, d, TRUE);
        end;
      end;
    end;
    if Sender = DSWBelt then
    begin
      if UseItems[U_BELT].S.Name <> '' then
      begin
        idx := UseItems[U_BELT].S.Looks;
        if idx >= 0 then
        begin
          d := WStateItem.Images[idx];
          if d <> nil then
            dsurface.Draw(DSWBelt.SurfaceX(DSWBelt.Left + (DSWBelt.Width - d.Width) div 2) + 1, DSWBelt.SurfaceY(DSWBelt.Top + (DSWBelt.Height - d.Height) div 2), d.ClientRect, d, TRUE);
        end;
      end;
    end;
    if Sender = DSWBoots then
    begin
      if UseItems[U_BOOTS].S.Name <> '' then
      begin
        idx := UseItems[U_BOOTS].S.Looks;
        if idx >= 0 then
        begin
          d := WStateItem.Images[idx];
          if d <> nil then
            dsurface.Draw(DSWBoots.SurfaceX(DSWBoots.Left + (DSWBoots.Width - d.Width) div 2 + 1), DSWBoots.SurfaceY(DSWBoots.Top + (DSWBoots.Height - d.Height) div 2), d.ClientRect, d, TRUE);
        end;
      end;
    end;
    if Sender = DSWCharm then
    begin
      if UseItems[U_CHARM].S.Name <> '' then
      begin
        idx := UseItems[U_CHARM].S.Looks;
        if idx >= 0 then
        begin
          d := WStateItem.Images[idx];
          if d <> nil then
            dsurface.Draw(DSWCharm.SurfaceX(DSWCharm.Left + (DSWCharm.Width - d.Width) div 2 + 1), DSWCharm.SurfaceY(DSWCharm.Top + (DSWCharm.Height - d.Height) div 2), d.ClientRect, d, TRUE);
        end;
      end;
    end;
    if Sender = ButTrans then
    begin
      if UseItems[U_TRANS].S.Name <> '' then
      begin
        idx := UseItems[U_TRANS].S.Looks;
        if idx >= 0 then
        begin
          d := WStateItem.Images[idx];
          if d <> nil then
            dsurface.Draw(ButTrans.SurfaceX(ButTrans.Left + (ButTrans.Width - d.Width) div 2 + 1), ButTrans.SurfaceY(ButTrans.Top + (ButTrans.Height - d.Height) div 2), d.ClientRect, d, TRUE);
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DStateWinClick(Sender: TObject; X, Y: Integer);
begin
  if StatePage = 3 then
  begin
    X := DStateWin.LocalX(X) - DStateWin.Left;
    Y := DStateWin.LocalY(Y) - DStateWin.Top;
    if (X >= 33) and (X <= 33 + 166) and (Y >= 55) and (Y <= 55 + 37 * 5) then
    begin
      magcur := (Y - 55) div 37;
      if (magcur + magtop) >= MagicList.Count then
        magcur := (MagicList.Count - 1) - magtop;
    end;
  end;
end;

procedure TFrmDlg.DCloseStateClick(Sender: TObject; X, Y: Integer);
begin
  DStateWin.Visible := FALSE;
end;

procedure TFrmDlg.DPrevStateDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with Sender as TDButton do
  begin
    if TDButton(Sender).Downed then
    begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
    end;
  end;
end;

procedure TFrmDlg.PageChanged;    //页面更改
begin
  case StatePage of
    1: DCheckBoxTrans.Visible := False;
    2:
      begin //付过 惑怕芒
        DStMag1.Visible := FALSE;
        DStMag2.Visible := FALSE;
        DStMag3.Visible := FALSE;
        DStMag4.Visible := FALSE;
        DStMag5.Visible := FALSE;
        DStMag6.Visible := FALSE;
        DStPageUp.Visible := FALSE;
        DStPageDown.Visible := FALSE;
        DCheckBoxTrans.Visible := False;
      end;
    3:
      begin //付过 惑怕芒
        DSWWeapon.Visible := FALSE;
        DSWHelmet.Visible := FALSE;
        DSWDress.Visible := FALSE;
        DSWNecklace.Visible := FALSE;
        DSWLight.Visible := FALSE;
        DSWArmRingR.Visible := FALSE;
        DSWArmRingL.Visible := FALSE;
        DSWRingR.Visible := FALSE;
        DSWRingL.Visible := FALSE;
        DCheckBoxTrans.Visible := False;
        ButTrans.Visible := False;

        DStMag1.Visible := TRUE;
        DStMag2.Visible := TRUE;
        DStMag3.Visible := TRUE;
        DStMag4.Visible := TRUE;
        DStMag5.Visible := TRUE;
        if g_bo人物四格 then
          DStMag6.Visible := TRUE
          else
          DStMag6.Visible := False;
        DStPageUp.Visible := TRUE;
        DStPageDown.Visible := TRUE;
        MagicPage := 0;
      end;
  else
    begin
        DSWWeapon.Visible := TRUE;
        DSWHelmet.Visible := TRUE;
        DSWDress.Visible := TRUE;
        DSWNecklace.Visible := TRUE;
        DSWLight.Visible := TRUE;
        DSWArmRingR.Visible := TRUE;
        DSWArmRingL.Visible := TRUE;
        DSWRingR.Visible := TRUE;
        DSWRingL.Visible := TRUE;
        DCheckBoxTrans.Visible := True;
        ButTrans.Visible := True;

      DStMag1.Visible := FALSE;
      DStMag2.Visible := FALSE;
      DStMag3.Visible := FALSE;
      DStMag4.Visible := FALSE;
      DStMag5.Visible := FALSE;
      DStMag6.Visible := False;
      DStPageUp.Visible := FALSE;
      DStPageDown.Visible := FALSE;
    end;
  end;
  DScreen.ClearHint(True);
end;

procedure TFrmDlg.DPrevStateClick(Sender: TObject; X, Y: Integer);
begin
  Dec(StatePage);
  if StatePage < 0 then
    StatePage := MAXSTATEPAGE - 1;
  PageChanged;
end;

procedure TFrmDlg.DNextStateClick(Sender: TObject; X, Y: Integer);
begin
  Inc(StatePage);
  if StatePage > MAXSTATEPAGE - 1 then
    StatePage := 0;
  PageChanged;
end;

procedure TFrmDlg.DSWWeaponClick(Sender: TObject; X, Y: Integer);
var
  where, n, sel: integer;
  flag, movcancel: Boolean;
begin
  if Myself = nil then
    exit;
  if StatePage <> 0 then
    exit;
  if ItemMoving then
  begin
    flag := FALSE;
    movcancel := FALSE;
    if (MovingItem.Item.S.Stock = 44) or (MovingItem.Item.S.Stock = 45) then
    begin
      AddStallItem(MovingItem.Item);
      ItemMoving := false;
      MovingItem.Item.S.Name := '';

      Exit;
    end;
    if (MovingItem.Index = -97) or (MovingItem.Index = -98) then
      exit;

    if (MovingItem.Item.S.Name = '') or (WaitingUseItem.Item.S.Name <> '') then
      exit;

    where := GetTakeOnPosition(MovingItem.Item.S.StdMode);

    if MovingItem.Index >= 0 then
    begin
      case where of
        U_DRESS:
          begin
            if Sender = DSWDress then
            begin
              if Myself.Sex = 0 then //巢磊
                if MovingItem.Item.S.StdMode <> 10 then //巢磊渴
                  exit;
              if Myself.Sex = 1 then //咯磊
                if MovingItem.Item.S.StdMode <> 11 then //咯磊渴
                  exit;
              flag := TRUE;
            end;
          end;
        U_WEAPON:
          begin
            if Sender = DSWWEAPON then
            begin
              flag := TRUE;
            end;
          end;
        U_NECKLACE:
          begin
            if Sender = DSWNecklace then
              flag := TRUE;
          end;
        U_RIGHTHAND:
          begin
            if Sender = DSWLight then
              flag := TRUE;
          end;
        U_HELMET:
          begin
            if Sender = DSWHelmet then
              flag := TRUE;
          end;
        U_RINGR, U_RINGL:
          begin
            if (x = 1) and (y = 1) then
            begin
            if UseItems[U_RINGR].S.Name = '' then
            begin
              where := U_RINGR;
            end
            else if UseItems[U_RINGL].S.Name = '' then
            begin
              where := U_RINGL;
            end
            else if not g_boRightItemRingEmpty then
            begin
              where := U_RINGR;
              g_boRightItemRingEmpty := True;
            end
            else
            begin
              where := U_RINGL;
              g_boRightItemRingEmpty := False;
            end;
            flag := TRUE;
            end else
            begin
            if Sender = DSWRingL then
            begin
              where := U_RINGL;
              flag := TRUE;
            end;
            if Sender = DSWRingR then
            begin
              where := U_RINGR;
              flag := TRUE;
            end;
            end;
          end;
        U_ARMRINGR,U_ARMRINGL:
          begin  //迫骂
            if (x = 1) and (y = 1) then
            begin
            flag := TRUE;
            if UseItems[U_ARMRINGR].S.Name = '' then
            begin
              where := U_ARMRINGR;
            end
            else if UseItems[U_ARMRINGL].S.Name = '' then
            begin
              where := U_ARMRINGL;
            end
            else if not g_boRightItemArmRingEmpty then
            begin
              where := U_ARMRINGR;
              g_boRightItemArmRingEmpty := True;
            end
            else
            begin
              where := U_ARMRINGL;
              g_boRightItemArmRingEmpty := False;
            end;
            end else
            begin
            if Sender = DSWArmRingL then
            begin
              where := U_ARMRINGL;
              flag := TRUE;
            end;
            if Sender = DSWArmRingR then
            begin
              where := U_ARMRINGR;
              flag := TRUE;
            end;
            end;
          end;
//        U_ARMRINGL:
//          begin  //  迫骂
//            if Sender = DSWArmRingL then
//            begin
//              where := U_ARMRINGL;
//              flag := TRUE;
//            end;
//          end;
            // 2003/03/15 COPARK 酒捞袍 牢亥配府 犬厘
        U_BUJUK:
          begin       //何利, 刀啊风
              if (g_bochksigedu)and(Sender = DSWBujuk) and (MovingItem.Item.S.Shape in [5,6]) then
              begin
                where := U_BUJUK;
                flag := TRUE;
              end
                else
              begin
               if (not g_bochksigedu)and(Sender = DSWBujuk) and (MovingItem.Item.S.Shape in [1,2,5,6]) then
                begin
                where := U_BUJUK;
                flag := TRUE;
              end;
              end;


            if not g_bo人物四格 then
            begin
              if Sender = DSWArmRingL then
              begin
                where := U_ARMRINGL;
                flag := TRUE;
              end;
            end
            else
            begin
              if (Sender = DSWCharm) and (MovingItem.Item.S.Shape in [1, 2]) then
              begin
                where := U_CHARM;
                flag := TRUE;
              end;
            end;
          end;
        U_BELT:
          begin  //骇飘
            if g_bo人物四格 then
            if Sender = DSWBelt then
            begin
              where := U_BELT;
              flag := TRUE;
            end;
          end;
        U_BOOTS:
          begin  //脚惯
            if g_bo人物四格 then
            if Sender = DSWBoots then
            begin
              where := U_BOOTS;
              flag := TRUE;
            end;
          end;
        U_CHARM:
          begin  //荐龋籍
            if Sender = DSWCharm then
            begin
              where := U_CHARM;
              flag := TRUE;
            end;
          end;
        U_TRANS:
          begin  //时装
            if Sender = ButTrans then
            begin
              where := U_TRANS;
              flag := TRUE;
            end;
          end;
      end;
    end
    else
    begin
      n := -(MovingItem.Index + 1);
         // 2003/03/15 COPARK 酒捞袍 牢亥配府 犬厘
      if n in [0..U_TRANS] then
      begin            // 8->12
        ItemClickSound(MovingItem.Item.S);
        UseItems[n] := MovingItem.Item;
        MovingItem.Item.S.Name := '';
        ItemMoving := FALSE;
      end;
    end;
    if flag then
    begin
      ItemClickSound(MovingItem.Item.S);
      WaitingUseItem := MovingItem;
      WaitingUseItem.Index := where;

      FrmMain.SendTakeOnItem(where, MovingItem.Item.MakeIndex, MovingItem.Item.S.Name);
      MovingItem.Item.S.Name := '';
      ItemMoving := FALSE;
    end;
  end
  else
  begin
    flag := FALSE;
    if (MovingItem.Item.S.Name <> '') or (WaitingUseItem.Item.S.Name <> '') then
      exit;
    sel := -1;
    if Sender = DSWDress then
      sel := U_DRESS;
    if Sender = DSWWeapon then
      sel := U_WEAPON;
    if Sender = DSWHelmet then
      sel := U_HELMET;
    if Sender = DSWNecklace then
      sel := U_NECKLACE;
    if Sender = DSWLight then
      sel := U_RIGHTHAND;
    if Sender = DSWRingL then
      sel := U_RINGL;
    if Sender = DSWRingR then
      sel := U_RINGR;
    if Sender = DSWArmRingL then
      sel := U_ARMRINGL;
    if Sender = DSWArmRingR then
      sel := U_ARMRINGR;
      // 2003/03/15 酒捞袍 牢亥配府 犬厘
    if Sender = DSWBujuk then
      sel := U_BUJUK;
    if Sender = DSWBelt then
      sel := U_BELT;
    if Sender = DSWBoots then
      sel := U_BOOTS;
    if Sender = DSWCharm then
      sel := U_CHARM;
    if Sender = ButTrans then
      sel := U_TRANS;

    if sel >= 0 then
    begin
      if UseItems[sel].S.Name <> '' then
      begin
        ItemClickSound(UseItems[sel].S);
        MovingItem.Index := -(sel + 1);
        MovingItem.Item := UseItems[sel];
        UseItems[sel].S.Name := '';
        ItemMoving := TRUE;
      end;
    end;
  end;
  bWindowsType := -1;
end;

procedure TFrmDlg.DSWWeaponMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  sel: integer;
  iname, d0, d1, d2, d3, d4: string;
  useable, TempB: Boolean;
  hcolor, fcolor: TColor;
  lx, ly, htx, hty: integer;
begin

  if StatePage = 1 then
  begin
    lx := X; // - DStateWin.Left;
    ly := Y; // - DStateWin.Top;
//      DScreen.AddChatBoardString ('lx=> '+IntToStr(lx) +'  ly=> '+IntToStr(ly), clYellow, clRed);
    if (lx > 57) and (lx < 180) and (ly > 88) and (ly < 105) then
      DScreen.ShowHint(DStateWin.Left + 158, DStateWin.Top + 90, '', clYellow, FALSE)    //单引号中间的文字是人物属性栏的对应属性，鼠标指上去显示的文字 默认为物理防御
    else if (lx > 57) and (lx < 180) and (ly > 110) and (ly < 127) then
      DScreen.ShowHint(DStateWin.Left + 158, DStateWin.Top + 112, '', clYellow, FALSE)     //单引号中间的文字是人物属性栏的对应属性，鼠标指上去显示的文字 默认为魔法防御
    else if (lx > 57) and (lx < 180) and (ly > 132) and (ly < 149) then
      DScreen.ShowHint(DStateWin.Left + 158, DStateWin.Top + 134, '', clYellow, FALSE)    //单引号中间的文字是人物属性栏的对应属性，鼠标指上去显示的文字 默认为攻击力
    else if (lx > 57) and (lx < 180) and (ly > 154) and (ly < 171) then
      DScreen.ShowHint(DStateWin.Left + 158, DStateWin.Top + 156, '', clYellow, FALSE)    //单引号中间的文字是人物属性栏的对应属性，鼠标指上去显示的文字 默认为魔法力
    else if (lx > 57) and (lx < 180) and (ly > 176) and (ly < 193) then
      DScreen.ShowHint(DStateWin.Left + 158, DStateWin.Top + 178, '', clYellow, FALSE)     //单引号中间的文字是人物属性栏的对应属性，鼠标指上去显示的文字 默认为道术
    else if (lx > 57) and (lx < 180) and (ly > 198) and (ly < 215) then
      DScreen.ShowHint(DStateWin.Left + 158, DStateWin.Top + 200, '', clYellow, FALSE)   //单引号中间的文字是人物属性栏的对应属性，鼠标指上去显示的文字 默认为体力值
    else if (lx > 57) and (lx < 180) and (ly > 220) and (ly < 237) then
      DScreen.ShowHint(DStateWin.Left + 158, DStateWin.Top + 222, '', clYellow, FALSE)    //单引号中间的文字是人物属性栏的对应属性，鼠标指上去显示的文字 默认为魔法值

    else
      DScreen.ClearHint(True);
  end;

  if StatePage <> 0 then
    exit;
   //DScreen.ClearHint(True);
  sel := -1;
  if Sender = DSWDress then
    sel := U_DRESS;
  if Sender = DSWWeapon then
    sel := U_WEAPON;
  if Sender = DSWHelmet then
    sel := U_HELMET;
  if Sender = DSWNecklace then
    sel := U_NECKLACE;
  if Sender = DSWLight then
    sel := U_RIGHTHAND;
  if Sender = DSWRingL then
    sel := U_RINGL;
  if Sender = DSWRingR then
    sel := U_RINGR;
  if Sender = DSWArmRingL then
    sel := U_ARMRINGL;
  if Sender = DSWArmRingR then
    sel := U_ARMRINGR;
   // 2003/03/15 酒捞袍 牢亥配府 犬厘
  if Sender = DSWBujuk then
    sel := U_BUJUK;
  if Sender = DSWBelt then
    sel := U_BELT;
  if Sender = DSWBoots then
    sel := U_BOOTS;
  if Sender = DSWCharm then
    sel := U_CHARM;
  if Sender = ButTrans then
    sel := U_TRANS;
  if sel >= 0 then
  begin
    MouseStateItem := UseItems[sel];
      // 2003/03/15 酒捞袍 牢亥配府 犬厘
    MouseX := DStateWin.Left + X;
    MouseY := DStateWin.Top + Y;
    htx := DStateWin.SurfaceX(DStateWin.left);
    if htx < 100 then
    begin
      TempB := False;
      htx := htx + DStateWin.Width;
    end
    else TempB := True;
    hty := DStateWin.Surfacey(DStateWin.Top) + 45;
    if g_bo悬浮信息 then
    begin
       MouseItem := UseItems[sel];
      //GetMouseItemInfo (iname, d1, d2, d3, useable);
      GetMouseItemInfo(iname, d0, d1, d2, d3, d4, useable, true);
      if iname <> '' then begin
//         if UseItems[sel].Dura = 0 then hcolor := clRed
//         else hcolor := clWhite;
//         with Sender as TDButton do
//            DScreen.ShowHint (htx,
//                              hty,
//                              iname + '|' + IntToStr(clYellow) + '\' + d0 + '\' + d1 + '\' + d2 + d3, hcolor, FALSE, False, True);

        if (MouseItem.UpgradeOpt > 0) and g_bo极品蓝字 then
          hcolor := TColor($cccc33)
        else
          hcolor := clWhite;
        if useable then
        begin
          //hcolor := clWhite;
          fcolor := hcolor;
        end
        else
        begin
          //hcolor := clWhite;
          fcolor := clRed;
        end;
        if d2 <> '' then
         d2 := d2 + '|' + IntToStr(hcolor) + '$';
        if d3 <> '' then
          d3 := d3 + '|' + IntToStr(fcolor);
        with DStateWin do
          DScreen.ShowHint(htx, hty, iname + '|' + IntToStr(clYellow) + '\' + d0 + '\' + d1 + '\' + d2 + d3, hcolor, FALSE, False, TempB);
      end;
      MouseItem.S.Name := '';
    end;
  end;
end;


procedure TFrmDlg.DWGameConfigClick(Sender: TObject; X, Y: Integer);
begin

end;

//惑怕芒 : 付过 其捞瘤

procedure TFrmDlg.DStMag1DirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  idx, icon: integer;
  d: TAsphyreLockableTexture;
  pm: PTClientMagic;
begin
  with Sender as TDButton do
  begin
    idx := _Max(Tag + MagicPage * g_nMagicCount, 0);
    if idx < MagicList.Count then
    begin
      pm := PTClientMagic(MagicList[idx]);
      icon := pm.Def.Effect * 2;
      if icon >= 0 then
      begin //酒捞能捞 绝绰芭..
        if not Downed then
        begin
          d := WMagicon.Images[icon];
          if d <> nil then
            dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
        end
        else
        begin
          d := WMagicon.Images[icon + 1];
          if d <> nil then
            dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DStMag1MouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var
  idx, icon: integer;
  d: TAsphyreLockableTexture;
  pm: PTClientMagic;
begin
  if not g_bo技能备注 then exit;
  with Sender as TDButton do
  begin
    icon := Tag;
    idx := _Max(icon + MagicPage * g_nMagicCount, 0);
    if idx < MagicList.Count then
    begin
      pm := PTClientMagic(MagicList[idx]);
      if pm <> nil then
      begin
        DScreen.ShowHint(SurfaceX(Left) - 120, SurfaceY(Top), g_MagicDesc[pm.Def.MagicId] + '\' + g_MagicDesc1, clWhite, FALSE, True); //clWhite
      end
      else
        DScreen.ClearHint(True);
    end;
  end;
end;

procedure TFrmDlg.DStMag1Click(Sender: TObject; X, Y: Integer);
var
  i, idx: integer;
  selkey: word;
  keych: AnsiChar;
  pm: PTClientMagic;
begin
  if StatePage = 3 then
  begin
    idx := TDButton(Sender).Tag + magtop;
    if (idx >= 0) and (idx < MagicList.Count) then
    begin
      DScreen.ClearHint(True);
      pm := PTClientMagic(MagicList[idx]);
      selkey := word(pm.Key);
      SetMagicKeyDlg(pm.Def.Effect * 2, pm.Def.MagicName, selkey);
      keych := AnsiChar(selkey);

      for i := 0 to MagicList.Count - 1 do
      begin
        pm := PTClientMagic(MagicList[i]);
        if pm.Key = keych then
        begin
          pm.Key := #0;
          FrmMain.SendMagicKeyChange(pm.Def.MagicId, #0);
        end;
      end;
      pm := PTClientMagic(MagicList[idx]);
         //if pm.Def.EffectType <> 0 then begin //八过篮 虐汲沥阑 给窃.
      pm.Key := keych;
      FrmMain.SendMagicKeyChange(pm.Def.MagicId, keych);
         //end;
    end;
  end;
end;

procedure TFrmDlg.DStPageUpClick(Sender: TObject; X, Y: Integer);
begin
  if Sender = DStPageUp then
  begin
    if MagicPage > 0 then
      Dec(MagicPage);
  end
  else
  begin
    if MagicPage < (MagicList.Count + g_nMagicCount - 1) div g_nMagicCount - 1 then
      Inc(MagicPage);
  end;
end;





{------------------------------------------------------------------------}

//底部状态

{------------------------------------------------------------------------}

procedure TFrmDlg.DBottomDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
  function GetJobAttackMode (mode: integer): string;
  begin
    Result := '';
    case mode of
      0: Result := '[全体攻击]';
      1: Result := '[和平攻击]';
      2: Result := '[编组攻击]';
      3: Result := '[行会攻击]';
      4: Result := '[善恶对攻]';
    end;
  end;
var
  d: TAsphyreLockableTexture;
  rc: TRect;
  btop, sx, sy, i, fcolor, bcolor,BOXWIDTH,ATemTime: integer;
  r: Real;
  s: string;
  sHpStr, sMpStr: string;
  phc: pTHornColor;
begin
  dsurface.FillRect(Rect(DBottom.Left, DBottom.Top + 190, DBottom.Left + 200, DBottom.Top + 300),$FF010101);


  if g_bo主界面 then
  begin
  if g_FScreenWidth = 1024 then d := WProgUse.Images[BOTTOMBOARD1024]
  else d := WProgUse.Images[BOTTOMBOARD];
  end else begin
  if g_FScreenWidth = 1024 then d := WProgUse.Images[45]
  else d := WProgUse.Images[44];
  end;

  if d <> nil then
    dsurface.Draw(DBottom.Left, DBottom.Top, d.ClientRect, d, TRUE);
  btop := 0;
  if d <> nil then
  begin
    with d.ClientRect do
      rc := Rect(Left, Top, Right, Top + 120);
    btop := g_FScreenHeight - d.height;
      //上半部透明
    dsurface.Draw(0, btop, rc, d, TRUE);
      //下半部不透明
    with d.ClientRect do
      rc := Rect(Left, Top + 120, Right, Bottom);
    dsurface.Draw(0, btop + 120, rc, d, FALSE);
  end;
   //天气(早上,白天,傍晚,晚上)
  d := nil;
  case DayBright of
    0:
      d := WProgUse.Images[15];  //早上
    1:
      d := WProgUse.Images[12];  //白天
    2:
      d := WProgUse.Images[13];  //傍晚
    3:
      d := WProgUse.Images[14];  //晚上
  end;
  if d <> nil then
    dsurface.Draw(g_FScreenWidth-52, 79 + DBottom.Top, d.ClientRect, d, TRUE);

  if Myself <> nil then
  begin
      if EffectNum = 3 then

        dsurface.BoldTextOut(8, g_FScreenHeight - 16, clWhite, clBlack, MapTitle)
      else
        dsurface.BoldTextOut(8, g_FScreenHeight - 16, clWhite, clBlack, MapTitle + ' ' + IntToStr(Myself.XX) + ':' + IntToStr(Myself.YY));

      //显示HP及MP 图形
    if (Myself.Abil.MaxHP > 0) and (Myself.Abil.MaxMP > 0) then
    begin
      if (Myself.Job = 0) and (Myself.Abil.Level < 28) then
      begin //武士lv26
        d := WProgUse.Images[5];
        if d <> nil then
        begin
          rc := d.ClientRect;
          rc.Right := d.ClientRect.Right - 2;
          dsurface.Draw(38, btop + 90, rc, d, TRUE);
        end;
        d := WProgUse.Images[6];
        if d <> nil then
        begin
          rc := d.ClientRect;
          rc.Right := d.ClientRect.Right - 2;
          rc.Top := Round(rc.Bottom / Myself.Abil.MaxHP * (Myself.Abil.MaxHP - Myself.Abil.HP));
          dsurface.Draw(38, btop + 90 + rc.Top, rc, d, TRUE);
        end;
      end
      else
      begin
        d := WProgUse.Images[4];
        if d <> nil then
        begin
               //HP 图形
          rc := d.ClientRect;
          rc.Right := d.ClientRect.Right div 2 - 1;
          rc.Top := Round(rc.Bottom / Myself.Abil.MaxHP * (Myself.Abil.MaxHP - Myself.Abil.HP));
          rc.Top := _MAX(rc.Top, 0);
          dsurface.Draw(40, btop + 91 + rc.Top, rc, d, TRUE);
               //MP 图形
          rc := d.ClientRect;
          rc.Left := d.ClientRect.Right div 2 + 1;
          rc.Right := d.ClientRect.Right - 1;
          rc.Top := Round(rc.Bottom / Myself.Abil.MaxMP * (Myself.Abil.MaxMP - Myself.Abil.MP));
          rc.Top := _MAX(rc.Top, 0);
          dsurface.Draw(40 + rc.Left, btop + 91 + rc.Top, rc, d, TRUE);
        end;
      end;             //这里
      if g_bo主界面 then
      begin
      with dsurface do begin //左下角血量和魔法值显示
        sHpStr := format('%d/%d',[MySelf.Abil.HP,MySelf.Abil.MaxHP]);
        sMpStr := format('%d/%d',[MySelf.Abil.MP,MySelf.Abil.MaxMP]);
        BoldTextOut (55 - (FontManager.Default.TextWidth(sHpStr) div 2), g_FScreenHeight-37, clWhite, clBlack, sHpStr);
        BoldTextOut (116 - (FontManager.Default.TextWidth(sMpStr) div 2), g_FScreenHeight-37, clWhite, clBlack, sMpStr);
      end;
      end;
    end;



      //等级
    with dsurface do
    begin
      PomiTextOut(dsurface, g_FScreenWidth-140, g_FScreenHeight-104, IntToStr(Myself.Abil.Level));
      //显示网络延时PING值
     // BoldTextOut (g_FScreenWidth-80, g_FScreenHeight-95, clWhite, clBlack, '延时:'+IntToStr(g_nPing)+'毫秒');
      if g_bo主界面 then
      BoldTextOut (g_FScreenWidth-159, g_FScreenHeight-138, clWhite, clBlack, GetJobAttackMode(MySelf.AttackMode));    //右下角攻击模式显示
    end;

//        {-----------------在屏幕右下角显示时间--------------------------------------}
    if g_bo主界面 then
    begin
        Set8087CW(Longword($133F));
        dsurface.BoldTextOut (g_FScreenWidth-128, g_FScreenHeight-20, clWhite, clBlack, FormatDateTime('hh:mm:ss',Now));
    end;

      //经验条, 背包重量条
    if (Myself.Abil.MaxExp > 0) and (Myself.Abil.MaxWeight > 0) then
    begin
      d := WProgUse.Images[7];
      if d <> nil then
      begin
          //经验条
        rc := d.ClientRect;
        if MySelf.Abil.Exp > 0 then
          r := MySelf.Abil.MaxExp / MySelf.Abil.Exp
        else
          r := 0;
        if r > 0 then
          rc.Right := Round(rc.Right / r)
        else
          rc.Right := 0;
        rc.Right := _MIN(rc.Right, d.Width);
        dsurface.Draw(g_FScreenWidth - 134, g_FScreenHeight - 73, rc, d, FALSE);
        //背包重量条


          rc := d.ClientRect;
          if MySelf.Abil.Weight > 0 then r := MySelf.Abil.MaxWeight / MySelf.Abil.Weight
          else r := 0;

          if r > 0 then rc.Right := Round(rc.Right / r)
          else rc.Right := 0;

          rc.Right := _MIN(rc.Right, d.Width);

          dsurface.Draw(g_FScreenWidth div 2 + (g_FScreenWidth div 2 - (400 - 266)), g_FScreenHeight - 40, rc, d, False);

      {  rc := d.ClientRect;
        if MySelf.Abil.WearWeight > 0 then begin
          rc.Right := _MIN(Round(rc.Right / (0 / MySelf.Abil.WearWeight)), rc.Right);
          rc.Right := _MIN(rc.Right, d.Width);
          dsurface.Draw(g_FScreenWidth - 134, g_FScreenHeight - 40, rc, d, FALSE);
        end;  }
      end;
    end;
      //饥饿程度
      { 2003/04/15 率瘤肺 措眉
      if MyHungryState in [1..4] then begin
         d := WProgUse.Images[16 + MyHungryState-1];
         if d <> nil then begin
            dsurface.Draw (754, 553, d.ClientRect, d, TRUE);
         end;
      end;
      }

  end;
 //-----------------------------------------------------------------------
   //显示聊天框文字
  sx := 208;
  sy := g_FScreenHeight - 130;
  with DScreen do
  begin
      //SetBkMode (g_DXCanvas.Handle, OPAQUE);
    for i := ChatBoardTop to ChatBoardTop + VIEWCHATLINE - 1 do
    begin
      if i > ChatStrs.Count - 1 then break;
      fcolor := integer(ChatStrs.Objects[i]);
      bcolor := integer(ChatBks[i]);
      dsurface.FillRect(Rect(sx, sy + (i - ChatBoardTop) * 12,
                               sx + FontManager.Default.TextWidth(ChatStrs.Strings[i]),
                               sy + (i - ChatBoardTop + 1) * 12), bcolor);
      dsurface.TextOut(sx, sy + (i - ChatBoardTop) * 12, ChatStrs.Strings[i], fcolor);
    end;
  end;

  if g_FScreenWidth = 1024 then
    BOXWIDTH := 374 + 224 + 14
  else
    BOXWIDTH := 374 + 14;
  i := 0;
  while i < DScreen.HornStrs.Count do
  begin
   //2019.4.27 时间60秒  传音筒时间控制
    phc := pTHornColor(DScreen.HornStrs.Objects[i]);
    ATemTime := phc.STime;
    if phc.fixde <> 1 then
    begin
      if GetTickCount - ATemTime >= 40000 then
      begin
        DScreen.HornStrs.Delete(i);
        Continue;
      end;
    end;

    dsurface.FillRect(Rect(sx, sy + i * 12, sx + BOXWIDTH, sy + (i * 12) + 12), GetRGB(phc.BColor){ or Integer($FF000000)});

    dsurface.TextOut(sx, sy + i * 12, DScreen.HornStrs.Strings[i], GetRGB(phc.FColor));
    inc(i);
    if i > 4 then
      Break;
  end;
//   g_DXCanvas.//Release;

end;




{--------------------------------------------------------------}
//判断底部面板上的一点是否透明

procedure TFrmDlg.DBottomInRealArea(Sender: TObject; X, Y: Integer; var IsRealArea: Boolean);
var
  d: TAsphyreLockableTexture;
begin
  if g_bo主界面 then
  begin
  if g_FScreenWidth = 1024 then d := WProgUse.Images[BOTTOMBOARD1024]
  else d := WProgUse.Images[BOTTOMBOARD];
  end else begin
  if g_FScreenWidth = 1024 then d := WProgUse.Images[45]
  else d := WProgUse.Images[44];
  end;

  if d <> nil then
  begin
    if d.Pixels[X, Y] > 0 then
      IsRealArea := TRUE
    else
      IsRealArea := FALSE;
  end;
end;

procedure TFrmDlg.DMyStateDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TDButton;
  dd: TAsphyreLockableTexture;
begin
  if Sender is TDButton then
  begin
    d := TDButton(Sender);
    if d.Downed then
    begin
      dd := d.WLib.Images[d.FaceIndex];
      if dd <> nil then
        dsurface.Draw(d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, TRUE);
    end;

  end;
end;

procedure TFrmDlg.DMyStateMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var
  sMsg:String;
begin
  if Sender = DBotMiniMap then
    sMsg := '小地图\全景地图(TAB)';
  if Sender = DBotTrade then
    sMsg := '物品交易';
  if Sender = DBotGuild then
    sMsg := '行会信息';
  if Sender = DBotGroup then
    sMsg := '组队控制/右键开关';
  if Sender = DBotPlusAbil then
    sMsg := '属性';
  if Sender = DBotFriend then
    sMsg := '关系系统';
  if Sender = DBotMaster then
    sMsg := '关系(L)';
  if Sender = DBotMaster1 then
     sMsg := '摆摊';

  if Sender = DBotLogout then
    sMsg := '小退(Alt+X)';
  if Sender = DBotExit then
    sMsg := '退出(Alt+Q)';
  if Sender = DBotMemo then
    sMsg := '邮件(M)';
  if Sender = DMyState then
    sMsg := '状态信息(F10)';
  if Sender = DMyBag then
    sMsg := '包裹物品(F9)';
  if Sender = DMyMagic then
    sMsg := '技能信息(F11)';
  if Sender = DOption then
    sMsg := '音效开关';
  if Sender = DBotHelp then
    sMsg := '帮助';
  if Sender = DBotWhisper then
    sMsg := '私聊记录';

  if Sender = DBotShop then
    sMsg := '商铺';


  if Sender = DBotHostpot then
    sMsg := '热点';
  if Sender = DBotQuestions then
    sMsg := '有问必答';

  with Sender as TDButton do
    if Sender = DBotMiniMap then
    begin
     DScreen.ShowHint(SurfaceX(Left), SurfaceY(Top - 33), sMsg, clYellow, FALSE); // clYellow 按钮文字颜色
    end else begin
     DScreen.ShowHint(SurfaceX(Left), SurfaceY(Top - 20), sMsg, clYellow, FALSE); // clYellow 按钮文字颜色
    end;
end;

procedure TFrmDlg.DBotMemoDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TDButton;
  dd: TAsphyreLockableTexture;
begin
  DMyStateDirectPaint(Sender, dsurface);

  if Sender is TDButton then
  begin
    d := TDButton(Sender);
     // 濒冠烙 钎矫 ??
    if not TDButton(Sender).Downed and MailAlarm then
    begin
      if (GetTickCount mod 1000) > 500 then
        dd := d.WLib.Images[d.FaceIndex]
      else
        dd := d.WLib.Images[d.FaceIndex + 1];

      if dd <> nil then
        dsurface.Draw(d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, TRUE);

    end;
  end;
end;


//弊缝, 背券, 甘 滚瓢
procedure TFrmDlg.DBotGroupDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TDButton;
  dd: TAsphyreLockableTexture;
begin
  if Sender is TDButton then
  begin
    d := TDButton(Sender);
    if not d.Downed then
    begin
      dd := d.WLib.Images[d.FaceIndex];
      if dd <> nil then
        dsurface.Draw(d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, TRUE);
    end
    else
    begin
      dd := d.WLib.Images[d.FaceIndex + 1];
      if dd <> nil then
        dsurface.Draw(d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, TRUE);
    end;
  end;
end;

procedure TFrmDlg.DBotGroupMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
   if ssRight in Shift then

     begin
        if GetTickCount > changegroupmodetime then
          begin
          AllowGroup := not AllowGroup;
          changegroupmodetime := GetTickCount + 2000; //timeout 5秒 //DelayTime 5到 2秒修正 //2004/11/18
          FrmMain.SendGroupMode(AllowGroup);
          end;

       if AllowGroup then
       begin
         DScreen.AddChatBoardString('[允许组队]', clgreen, clwhite);
       end
       else
       begin
         DScreen.AddChatBoardString('[拒绝组队]', clgreen, clblack);
       end;
     end
     else
     ToggleShowGroupDlg;
end;

procedure TFrmDlg.DBotPlusAbilDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TDButton;
  dd: TAsphyreLockableTexture;
begin
  if Sender is TDButton then
  begin
    d := TDButton(Sender);
    if not d.Downed then
    begin
      if (BlinkCount mod 2 = 0) and (not DAdjustAbility.Visible) then
        dd := d.WLib.Images[d.FaceIndex]
      else
        dd := d.WLib.Images[d.FaceIndex + 2];
      if dd <> nil then
        dsurface.Draw(d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, TRUE);
    end
    else
    begin
      dd := d.WLib.Images[d.FaceIndex + 1];
      if dd <> nil then
        dsurface.Draw(d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, TRUE);
    end;

    if GetTickCount - BlinkTime >= 500 then
    begin
      BlinkTime := GetTickCount;
      Inc(BlinkCount);
      if BlinkCount >= 10 then
        BlinkCount := 0;
    end;
  end;
end;

procedure TFrmDlg.DBotQuestionsClick(Sender: TObject; X, Y: Integer);
begin
//  if pos('http://',g_boQuestionsWeb)=0 then
//  g_boQuestionsWeb:='http://'+g_boQuestionsWeb;
//  if ShellExecute(Handle,'open',Pchar(string('Iexplore.exe')),Pchar(string(g_boQuestionsWeb)),nil,SW_SHOWNORMAL)=0 then
//  ShellExecute(Handle,'open',Pchar(string(g_boQuestionsWeb)),nil,nil,SW_SHOWNORMAL);
  DWndWeb.Visible := not DWndWeb.Visible;
  FrmWeb.ShowWeb(g_boQuestionsWeb);
  if not DWndWeb.Visible then begin
    FrmWeb.Visible := False;
    FrmWeb.Enabled := False;
    FrmMain.SetFocus;
    Windows.SetFocus(FrmMain.Handle);
  end else begin
    if DEdChat.Visible then DEdChat.Visible := False;
  end;
end;

procedure TFrmDlg.DBotShopClick(Sender: TObject; X, Y: Integer);
begin
  DCashShopDlg.Visible := not DCashShopDlg.Visible;
  if DCashShopDlg.Visible then begin
    if Myself.BoFisrShopItem then begin
      Myself.BoFisrShopItem := False;
      DButtonType1Click(DButtonType1, X, Y);
    end else begin
      //
    end;
  end;
end;

procedure TFrmDlg.DMyStateClick(Sender: TObject; X, Y: Integer);
begin
   if ItemMoving then
	     if IsStallItem(MovingItem.Index) then //取回
          begin
            if (MovingItem.Item.S.Stock =44) or (MovingItem.Item.S.Stock = 45) then
            begin
             // MovingItem.Item.S.Stock:=0;

              // UpdateItemBag(MovingItem.Item);
              AddStallItem(MovingItem.Item);

              MovingItem.Item.S.Name:='';
             ItemMoving:=false;
            end;
          end;
  if Sender = DMyState then
  begin
    StatePage := 0;
    OpenMyStatus;
  end;
  if Sender = DMyBag then
    OpenItemBag;
  if Sender = DMyMagic then
  begin
    StatePage := 3;
    OpenMyStatus;
  end;
  if Sender = DOption then
  begin
    TogglePlaySoundEffect;
  end;
end;

procedure TFrmDlg.DOptionClick(Sender: TObject);
function GetMagicByID(magid: Integer): PTClientMagic;
var
  i: Integer;
begin
  Result := nil;
  for i := MagicList.count - 1 downto 0 do begin
    if PTClientMagic(MagicList[i]).Def.MagicId = magid then begin
      Result := PTClientMagic(MagicList[i]);
      Break;
    end;
  end;
end;
  function GetMagicid(Mid: Word): Boolean;
  begin
    case Mid of
      3, 4, 7, 12, 25:
        Result := True;
    else
      Result := False;
    end;
  end;
var
  i: Integer;
  pcm: PTClientMagic;
  me: TMemoryStream;
begin
  DWGameConfig.Visible := not DWGameConfig.Visible;
  if DWGameConfig.Visible then begin

    DUpDown_config.Visible  := False;
    DCheckSdoNameShow.Checked := g_NgConfigInfo.boShowName;
    DCheckBoxHideShiti.Checked := g_NgConfigInfo.boNotDeath;
    DCheckSdoDuraWarning.Checked := g_NgConfigInfo.boDuraWarning;
    DCheckSdoAvoidShift.Checked := g_NgConfigInfo.boNotNeedShift;
    DCheckSdoExpFiltrate.Checked := g_NgConfigInfo.boExpShow;
    DEdtSdoExpFiltrate.Text := inttostr(g_NgConfigInfo.nExpShow);
    DCheckMyHp.Checked := g_NgConfigInfo.boBrightShowHp;
    DCheckSdoMapDesc.Checked := g_NgConfigInfo.boShowMap;


    DCheckBox_AllPickup.Checked := g_NgConfigInfo.boPickUpItemAll;

    DCheckSpecial.Checked := g_NgConfigInfo.boSpecialHP;
    DxEditSpecialHP.Text := inttostr(g_NgConfigInfo.nSpecialHP);
    DxEditSpecialHPTime.Text := inttostr(g_NgConfigInfo.nwSpecialHP);
    DCheckRanProtect.Checked := g_NgConfigInfo.boRanHP;
    DxEditRanHP.Text := inttostr(g_NgConfigInfo.nRanHP);
    DxEditRanHPTime.Text := inttostr(g_NgConfigInfo.nwRanHP);
    DListBox_Items.Caption:=g_NgConfigInfo.sRanItemName;

    DCheckPttly.Checked := g_NgConfigInfo.boHpPtEat;
    DEditPtHp.Text := inttostr(g_NgConfigInfo.nHpPtEat);
    DEditPtHpTime.Text := inttostr(g_NgConfigInfo.nwHpPtEat);

    DCheckPtmfy.Checked := g_NgConfigInfo.boMpPtEat;
    DEditPtMp.Text := inttostr(g_NgConfigInfo.nMpPtEat);
    DEditPtMpTime.Text := inttostr(g_NgConfigInfo.nwMpPtEat);

    if (MySelf.Job = 0) then DCheckSdoAutoFireHit.Enabled := True
    else DCheckSdoAutoFireHit.Enabled := False;
    if (MySelf.Job = 1) then DCheckSdoAutoShield.Enabled := True
    else DCheckSdoAutoShield.Enabled := False;
    if (MySelf.Job = 2) then DCheckSdoAutoHide.Enabled := True
    else DCheckSdoAutoHide.Enabled := False;
    if (MySelf.Job = 2) then DCheckSdoAutoHld.Enabled := True
    else DCheckSdoAutoHld.Enabled := False;
    if (MySelf.Job = 2) then DCheckSdoAutoJld.Enabled := True
    else DCheckSdoAutoJld.Enabled := False;
    if (MySelf.Job = 0) and (g_bo刀刀刺杀) then DCheckSdoAutoLongHit.Enabled := True
    else DCheckSdoAutoLongHit.Enabled := False;

    if MySelf <> nil then
    begin
      DCheckSdoAutoFireHit.Checked := g_NgConfigInfo.boAutoFireHit and (MySelf.Job = 0);
      DCheckSdoAutoShield.Checked := g_NgConfigInfo.boAutoShield and (MySelf.Job = 1);
      DCheckSdoAutoHide.Checked := g_NgConfigInfo.boAutoHide and (MySelf.Job = 2);
      DCheckSdoAutoHld.Checked := g_NgConfigInfo.boAutoHld and (MySelf.Job = 2);
      DCheckSdoAutoJld.Checked := g_NgConfigInfo.boAutoJld and (MySelf.Job = 2);
      DCheckSdoAutoLongHit.Checked := g_NgConfigInfo.boAutoLongHit and (MySelf.Job = 0);
    end;
    DCheckSdoAutoMagic.Checked := g_NgConfigInfo.boAutoMagic;
//    DComboBoxAutoMagicList.ItemIndex := g_NgConfigInfo.nAutoMagicID;
    DCheckSdoAutoMagicTime.Text := inttostr(g_NgConfigInfo.nwAutoMagic);
  //------------------------------------------------------------------------------
  //  for I := 0 to DListBox_Items.Item.Count - 1 do
  //  begin
  //    if g_NgConfigInfo.sRanItemName = DListBox_Items.Item.Strings[I] then
  //      DListBox_Items.ItemIndex := I;
  //  end;

    if MySelf = nil then Exit;

    DLBPractice.tag := 0;
    DLBPractice.Items.Clear;
    for i := 0 to MagicList.Count - 1 do begin
      pcm := MagicList.Items[i];
      case Myself.Job of
        0:
        begin
          if (pcm.Def.Job = Myself.Job) and (pcm.Def.MagicId in [26, 27]) then
            DLBPractice.Items.AddObject(pcm.Def.MagicName, TObject(pcm.Def.MagicId));
        end;
        else
        begin
          if (pcm.Def.Job = Myself.Job) and (pcm.Def.EffectType <> 0) then
            DLBPractice.Items.AddObject(pcm.Def.MagicName, TObject(pcm.Def.MagicId));
        end;
      end;
    end;
    DLBPractice.Height := 15 * DLBPractice.Items.Count + 1;

    pcm := GetMagicByID(g_NgConfigInfo.nAutoMagicID);
    if pcm <> nil then begin
      DCBPractice.Caption := pcm.Def.MagicName;
      DCBPractice.tag := pcm.Def.MagicId;
    end else {if DLBRenewBookNowBook.Items.count > 0 then}  begin
      DCBPractice.Caption := '请选择技能';
      DCBPractice.tag := -1;
    end;

    g_MemoList.Clear;
    if DSdoMemo.Lines.Count > 0 then
    begin
      for I := 0 to DSdoMemo.Lines.Count - 1 do
       g_MemoList.Add(DSdoMemo.Lines.Strings[I]);
    end;
    DUpDown_config.Position := 0;
    g_HelpPosition := 0;
  with DWGameConfig do
   begin
    case tag of
      1: begin //基本
          DCheckSdoNameShow.Visible := True;
          DCheckSdoDuraWarning.Visible := True;
          DCheckSdoAvoidShift.Visible := True;
          DCheckSdoExpFiltrate.Visible := True;
          DEdtSdoExpFiltrate.Visible := True;
          DCheckSdoMapDesc.Visible := True;
          DCheckMyHp.Visible := True;
          DCheckBoxHideShiti.Visible := True;
        end;
      2: begin //物品
          DWindowItem.visible := True;
          DComboBox_Items.Visible:=true;
          DxEdit_Items.Visible:=true;
          DUpDown_config.Visible:=true;
//          DBIDown.Visible := True;
//          DBIUP.Visible := True;
//          DMoveButton_items.Visible := True;
//          DComboBox_ItemsChange(DComboBox_Items);

          DButtonDefaultConfig.Visible := true;
          DCheckBox_AllPickup.Visible:=true;
        end;
      3: begin //保护
          DCheckSpecial.Visible := true;
          DxEditSpecialHP.Visible := True;
          DxEditSpecialHPTime.Visible := True;

          DCheckRanProtect.Visible := true;
          DxEditRanHP.Visible := True;
          DxEditRanHPTime.Visible := True;

          DCBRenewBookNowBook.Visible:= True;
        end;
      4: begin //药品
          DCheckPttly.Visible:=True;
          DCheckPtmfy.Visible:=True;
          DEditPtHp.Visible:=True;
          DEditPtHpTime.Visible:=True;
          DEditPtMp.Visible:=True;
          DEditPtMpTime.Visible:=True;
        end;
      5:
        begin //技能
          DCheckSdoAutoFireHit.Visible := True;
          DCheckSdoAutoShield.Visible := True;
          DCheckSdoAutoHide.Visible := True;
          DCheckSdoAutoHld.Visible := True;
          DCheckSdoAutoJld.Visible := True;
          DCheckSdoAutoLongHit.Visible := True;
          DCheckSdoAutoMagic.Visible := True;
          DCBPractice.Visible:=True;
          DCheckSdoAutoMagicTime.Visible := true;
        end;
      6: begin //便签
          DSdoMemo.Visible := True;
          DUpDown_config.Visible:=true;
          SetDFocus(FrmDlg.DSdoMemo);
        end;
      7: begin //帮助
           DUpDown_config.Visible:=true;
           DUpDown_config.MaxPosition := g_HelpStringList.Count - 12;
           DUpDown_config.Position := g_HelpPosition;
//          DBIUP.Visible:=True;
//          DBIDown.Visible:=True;
//          DMoveButton_items.Visible:=True;
//          DMoveButton_items.Max := g_HelpStringList.Count - 12;
//          DMoveButton_items.Position := g_HelpPosition;
//          DMoveButton_items.UpdatePos(DMoveButton_items.Position, True);
         end;
    end;
  end;
  end;
end;





{------------------------------------------------------------------------}

// 1-6 快捷栏

{------------------------------------------------------------------------}
procedure TFrmDlg.DBelt1DirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  idx: integer;
  d: TAsphyreLockableTexture;
begin
  if Myself = nil then
    Exit;
  with Sender as TDButton do
  begin
    idx := Tag;
    if idx in [0..5] then
    begin
      if ItemArr[idx].s.Name <> '' then
      begin
        d := WBagItem.Images[ItemArr[idx].s.Looks];
        if d <> nil then
          dsurface.Draw(SurfaceX(Left + (Width - d.Width) div 2), SurfaceY(Top + (Height - d.Height) div 2), d.ClientRect, d, TRUE);

         // 酒捞袍 般摹扁   //new add
        if ItemArr[idx].s.OverlapItem > 0 then
        begin
               //SetBkMode (g_DXCanvas.Handle, TRANSPARENT);
//               g_DXCanvas.Font.Color := clYellow;

          dsurface.TextOut(SurfaceX(Left + (Width - d.Width) div 2), SurfaceY(Top + (Height - d.Height) div 2), clYellow, IntToStr(ItemArr[idx].Dura));
//               g_DXCanvas.//Release;
        end;

      end;
    end;
    PomiTextOut(dsurface, SurfaceX(Left + 13), SurfaceY(Top + 19), IntToStr(idx + 1));
  end;
end;

procedure TFrmDlg.DBelt1MouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  idx: integer;
  temp: TClientItem;
  iname, d0, d1, d2, d3, d4: string;
  useable: Boolean;
  hcolor, fcolor: TColor;
begin
  DScreen.ClearHint(True);
  idx := TDButton(Sender).Tag;
  if idx in [0..5] then
  begin
    if ItemArr[idx].s.Name <> '' then
    begin
      MouseItem := ItemArr[idx];
     if g_bo悬浮信息 then
    begin
         //GetMouseItemInfo (iname, d0, d1, d2, d3, useable);
      GetMouseItemInfo(iname, d0, d1, d2, d3, d4, useable, FALSE);
      if iname <> '' then
      begin
        if (MouseItem.UpgradeOpt > 0) and g_bo极品蓝字 then
          hcolor := TColor($cccc33)
        else
          hcolor := clWhite;
        if useable then
        begin
          //hcolor := clWhite;
          fcolor := hcolor;
        end
        else
        begin
          //hcolor := clWhite;
          fcolor := clRed;
        end;
        if d2 <> '' then
         d2 := d2 + '|' + IntToStr(hcolor) + '$';
        if d3 <> '' then
          d3 := d3 + '|' + IntToStr(fcolor);
        with TDButton(Sender) do
          DScreen.ShowHint(SurfaceX(Left), SurfaceY(Top) - Height - 10, iname + '|' + IntToStr(clYellow) + '\' + d0 + '\' + d1 + '\' + d2 + d3, hcolor, FALSE);
      end;
      MouseItem.S.Name := '';
    end;
    end;
  end;
end;

procedure TFrmDlg.DBGCActivePage1Click(Sender: TObject; X, Y: Integer);
  procedure FillComponentTag();
  begin
    DBGCActivePage1.PageActive := False;
    DBGCActivePage2.PageActive := False;
    DBGCActivePage3.PageActive := False;
    DBGCActivePage4.PageActive := False;
    DBGCActivePage5.PageActive := False;
    DBGCActivePage6.PageActive := False;
    DBGCActivePage7.PageActive := False;
    TDButton(Sender).PageActive := True;
  end;
var
  i,j: Integer;
begin
  FillComponentTag();
  DWGameConfig.tag := TDButton(Sender).tag;
  //基本
  DCheckSdoNameShow.Visible := false;
  DCheckSdoDuraWarning.Visible := false;
  DCheckSdoAvoidShift.Visible := false;
  DCheckSdoExpFiltrate.Visible := false;
  DEdtSdoExpFiltrate.Visible := false;
  DCheckSdoMapDesc.Visible := false;
  DCheckMyHp.Visible := false;
  DCheckBoxHideShiti.Visible := False;

  DBIUP.Visible:=false;
  DBIDown.Visible:=false;
  DMoveButton_items.Visible:=false;
  DButtonDefaultConfig.Visible := False;
  DCheckBox_AllPickup.Visible:=false;


  DCheckSpecial.Visible := false;
  DCheckRanProtect.Visible := false;
  DxEditSpecialHP.Visible := false;
  DxEditSpecialHPTime.Visible := false;
  DxEditRanHP.Visible := false;
  DxEditRanHPTime.Visible := false;
  DListBox_Items.Visible:=false;

  DWindowItem.visible := False;
  DComboBox_Items.Visible:=false;
  DxEdit_Items.Visible:=false;

  DCBRenewBookNowBook.Visible:=false;
  DLBRenewBookNowBook.Visible:=false;

  DCBPractice.Visible:=false;
  DLBPractice.Visible:=false;

  DCheckPttly.Visible:=false;
  DCheckPtmfy.Visible:=false;
  DEditPtHp.Visible:=false;
  DEditPtHpTime.Visible:=false;
  DEditPtMp.Visible:=false;
  DEditPtMpTime.Visible:=false;


  DCheckSdoAutoFireHit.Visible:=false;
  DCheckSdoAutoShield.Visible:=false;
  DCheckSdoAutoHide.Visible:=false;
  DCheckSdoAutoHld.Visible:=false;
  DCheckSdoAutoJld.Visible:=false;
  DCheckSdoAutoLongHit.Visible:=false;
  DCheckSdoAutoMagic.Visible:=false;
//  DComboBoxAutoMagicList.Visible := False;
  DCheckSdoAutoMagicTime.Visible:=False;

  DSdoMemo.Visible := False;
  DUpDown_config.Visible := false;

  with DWGameConfig do
   begin
    case tag of
      1: begin //基本
          DCheckSdoNameShow.Visible := True;
          DCheckSdoDuraWarning.Visible := True;
          DCheckSdoAvoidShift.Visible := True;
          DCheckSdoExpFiltrate.Visible := True;
          DEdtSdoExpFiltrate.Visible := True;
          DCheckSdoMapDesc.Visible := True;
          DCheckMyHp.Visible := True;
          DCheckBoxHideShiti.Visible := True;
        end;
      2: begin //物品
          DWindowItem.visible := True;
          DComboBox_Items.Visible:=true;
          DxEdit_Items.Visible:=true;
          DUpDown_config.Visible:=true;
//          DBIDown.Visible := True;
//          DBIUP.Visible := True;
//          DMoveButton_items.Visible := True;
          DComboBox_ItemsChange(DComboBox_Items);

          DButtonDefaultConfig.Visible := true;
          DCheckBox_AllPickup.Visible:=true;
        end;
      3: begin //保护
          DCheckSpecial.Visible := true;
          DxEditSpecialHP.Visible := True;
          DxEditSpecialHPTime.Visible := True;

          DCheckRanProtect.Visible := true;
          DxEditRanHP.Visible := True;
          DxEditRanHPTime.Visible := True;

          DCBRenewBookNowBook.Visible:= True;
        end;
      4: begin //药品
          DCheckPttly.Visible:=True;
          DCheckPtmfy.Visible:=True;
          DEditPtHp.Visible:=True;
          DEditPtHpTime.Visible:=True;
          DEditPtMp.Visible:=True;
          DEditPtMpTime.Visible:=True;
        end;
      5:
        begin //技能
          DCheckSdoAutoFireHit.Visible := True;
          DCheckSdoAutoShield.Visible := True;
          DCheckSdoAutoHide.Visible := True;
          DCheckSdoAutoHld.Visible := True;
          DCheckSdoAutoJld.Visible := True;
          DCheckSdoAutoLongHit.Visible := True;
          DCheckSdoAutoMagic.Visible := True;
          DCBPractice.Visible:=True;
          DCheckSdoAutoMagicTime.Visible := true;
        end;
      6: begin //便签
          DSdoMemo.Visible := True;
          DUpDown_config.Visible:=true;
          //DUpDown_config.Position := 0;
          SetDFocus(FrmDlg.DSdoMemo);
        end;
      7: begin //帮助
           DUpDown_config.Visible:=true;
           DUpDown_config.MaxPosition := g_HelpStringList.Count - 12;
           DUpDown_config.Position := g_HelpPosition;
//          DBIUP.Visible:=True;
//          DBIDown.Visible:=True;
//          DMoveButton_items.Visible:=True;
//          DMoveButton_items.Max := g_HelpStringList.Count - 12;
//          DMoveButton_items.Position := g_HelpPosition;
//          DMoveButton_items.UpdatePos(DMoveButton_items.Position, True);
         end;
    end;
  end;
end;

procedure TFrmDlg.DBGCActivePage1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  i, itTop: Integer;
begin
  with TDButton(Sender) do
  begin
    if WLib=nil then Exit;

    itTop := Top;
    if not PageActive then
      //d := WLib.Images[FaceIndex]
      d := WLib.Images[g_sGameConfigPage1]
    else begin
      //d := WLib.Images[FaceIndex + 1]
      d := WLib.Images[g_sGameConfigPage2];
      itTop := Top - 2;
    end;
    if d <> nil then begin
      dsurface.Draw(SurfaceX(Left), SurfaceY(itTop), d.ClientRect, d, True);
      with dsurface do begin
        BoldTextOut(
          SurfaceX(10 + (d.Width - FontManager.Default.TextWidth(Caption)) div 2 + (TDButton(Sender).tag - 1) * 48),
          SurfaceY(itTop + (d.Height - FontManager.Default.TextHeight(Caption)) div 2),
          clWhite, clBlack, Caption);
      end;
    end;
  end;
end;

procedure TFrmDlg.DBGCCloseClick(Sender: TObject; X, Y: Integer);
begin
DWGameConfig.Visible := False;
end;

procedure TFrmDlg.DBGCCloseDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with Sender as TDButton do begin
    if not Downed then
      d := WLib.Images[FaceIndex]
    else
      d := WLib.Images[FaceIndex+1];
    if d <> nil then dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
  end;
end;

procedure TFrmDlg.DBIDownMouseDown(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
  if DMoveButton_items.Position < DMoveButton_items.Max then
  begin
    if DWGameConfig.Tag = 2 then Inc(DMoveButton_items.Position, 8)
    else Inc(DMoveButton_items.Position);

    DMoveButton_items.UpdatePos(DMoveButton_items.Position, True);
    UpDownStart:=True;
    DMoveButton_items.Tag:=1;
    UpDownTick := gettickcount;
  end;
end;

procedure TFrmDlg.DBIDownMouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
  UpDownStart := false;
  DMoveButton_items.Tag := 0;
end;

procedure TFrmDlg.DBIUPDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TDButton;
  dd: TAsphyreLockableTexture;
begin
  if Sender is TDButton then begin
    d := TDButton(Sender);
    if d.Downed then begin
      dd := d.WLib.Images[d.FaceIndex + 1];
    end else begin
      dd := d.WLib.Images[d.FaceIndex];
    end;
    if dd <> nil then
      dsurface.Draw(d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, True);
  end;
end;

procedure TFrmDlg.DBIUPMouseDown(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
  if DMoveButton_items.Position > 0 then
  begin
    if DWGameConfig.tag = 2 then Dec(DMoveButton_items.Position, 8)
    else Dec(DMoveButton_items.Position);
    DMoveButton_items.UpdatePos(DMoveButton_items.Position, True);
    UpDownStart:=true;
    DBIUP.tag:=1;
    UpDownTick := gettickcount;
  end;
end;

procedure TFrmDlg.DBIUPMouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
    UpDownStart:=false;
    DBIUP.tag:=0;
end;

procedure TFrmDlg.DBelt1Click(Sender: TObject; X, Y: Integer);
var
  idx: integer;
  temp: TClientItem;
begin
  idx := TDButton(Sender).Tag;
  if idx in [0..5] then
  begin
    if not ItemMoving then
    begin
      if ItemArr[idx].s.Name <> '' then
      begin
        ItemClickSound(ItemArr[idx].s);
        ItemMoving := TRUE;
        MovingItem.Index := idx;
        MovingItem.Item := ItemArr[idx];
        ItemArr[idx].s.Name := '';
      end;
    end
    else
    begin
    	     if IsStallItem(MovingItem.Index) then //取回
          begin
            if (MovingItem.Item.S.Stock =44) or (MovingItem.Item.S.Stock = 45) then
            begin
            MovingItem.Item.S.Stock:=0;
            UpdateItemBag(MovingItem.Item);
            MovingItem.Item.S.Name:='';
            end;
          end;
      if (MovingItem.Index = -97) or (MovingItem.Index = -98) then
        exit;
//         if MovingItem.Item.S.StdMode <= 3 then begin //器记,澜侥,胶农费
      if (MovingItem.Index < 0) and (MovingItem.Index >= -13) then
      begin  //-99: Sell窗口中....-9->-13
            //状态窗口中
        WaitingUseItem := MovingItem;
        FrmMain.SendTakeOffItem(-(MovingItem.Index + 1), MovingItem.Item.MakeIndex, MovingItem.Item.S.Name);
        MovingItem.Item.S.name := '';
        ItemMoving := FALSE;
      end else
      if (MovingItem.Item.S.StdMode <= 3){ or (MovingItem.Item.S.StdMode = 25)} then
      begin //器记,澜侥,胶农费, 刀啊风, 何利
            //ItemClickSound (MovingItem.Item.S.StdMode);
        if ItemArr[idx].s.Name <> '' then
        begin
          temp := ItemArr[idx];
          ItemArr[idx] := MovingItem.Item;
          MovingItem.Index := idx;
          MovingItem.Item := temp
        end
        else
        begin
          ItemArr[idx] := MovingItem.Item;
          MovingItem.Item.S.name := '';
          ItemMoving := FALSE;
        end;
      end;
    end;
  end;
end;

{procedure TFrmDlg.DBelt1Click(Sender: TObject; X, Y: Integer);
var
   idx: integer;
   temp: TClientItem;
begin
   idx := TDButton(Sender).Tag;
   if idx in [0..5] then begin
      if not ItemMoving then begin
         if ItemArr[idx].S.Name <> '' then begin
            ItemClickSound (ItemArr[idx].S);
            ItemMoving := TRUE;
            MovingItem.Index := idx;
            MovingItem.Item := ItemArr[idx];
            ItemArr[idx].S.Name := '';
         end;
      end else begin
         if (MovingItem.Index = -97) or (MovingItem.Index = -98) then exit;
         if MovingItem.Item.S.StdMode <= 3 then begin //器记,澜侥,胶农费
            //ItemClickSound (MovingItem.Item.S.StdMode);
            if ItemArr[idx].S.Name <> '' then begin
               temp := ItemArr[idx];
               ItemArr[idx] := MovingItem.Item;
               MovingItem.Index := idx;
               MovingItem.Item := temp
            end else begin
               ItemArr[idx] := MovingItem.Item;
               MovingItem.Item.S.name := '';
               ItemMoving := FALSE;
            end;
         end;
      end;
   end;
end;}

procedure TFrmDlg.DBelt1DblClick(Sender: TObject);
var
  idx, where: integer;
  TempSender: TObject;
begin
  idx := TDButton(Sender).Tag;
  if idx in [0..5] then
  begin
  if ItemMoving then begin
      if IsStallItem(MovingItem.Index) then //取回
          begin
            if (MovingItem.Item.S.Stock =44) or (MovingItem.Item.S.Stock = 45) then
            begin
            MovingItem.Item.S.Stock:=0;
            UpdateItemBag(MovingItem.Item);
            MovingItem.Item.S.Name:='';
            end;
          end;
        end;
    if ItemArr[idx].s.Name <> '' then
    begin
      if (ItemArr[idx].s.StdMode <= 4) or (ItemArr[idx].s.StdMode = 31) or (ItemArr[idx].s.StdMode = 66) then  //物品双击使用
      begin //荤侩且 荐 乐绰 酒捞袍
        StBeltAutoFill := True;
        FrmMain.EatItem(idx);
      end;
    end
    else
    begin
//         if ItemMoving and (MovingItem.Index = idx) and
//           (MovingItem.Item.S.StdMode <= 4) or (MovingItem.Item.S.StdMode = 31)
      if ItemMoving and (MovingItem.Index = idx) and (MovingItem.Item.S.StdMode <= 4) or (MovingItem.Item.S.StdMode in [31,66,70,88]) or (ItemArr[idx].s.StdMode = 66) { or (MovingItem.Item.S.StdMode = 25) }then       //物品双击使用
      begin
      if IsStallItem(MovingItem.Index) then //取回
          begin
            if (MovingItem.Item.S.Stock =44) or (MovingItem.Item.S.Stock = 45) then
            begin
              MovingItem.Item.S.Stock:=0;
              UpdateItemBag(MovingItem.Item);
              MovingItem.Item.S.Name:='';
            end;
          end;
      {  if MovingItem.Item.S.StdMode = 25 then
        begin
//      DScreen.AddChatBoardString ('MovingItem.Item.S.Shape=> '+IntToStr(MovingItem.Item.S.Shape), clYellow, clRed);
          where := GetTakeOnPosition(MovingItem.Item.S.StdMode);
          if MovingItem.Index >= 0 then
          begin
            case where of
              U_ARMRINGR, U_BUJUK:
                begin
                //  TempSender := DSWBujuk;
                  TempSender := DSWArmRingL;
                end;
            end;
          end;
          DSWWeaponClick(TempSender, 1, 1);
          Exit;
        end;   }
        StBeltAutoFill := True;
        FrmMain.EatItem(-1);
        BtInDex := idx;
      end;
    end;
  end;
end;

{----------------------------------------------------------}

//物品信息

{----------------------------------------------------------}

procedure TFrmDlg.GetMouseItemInfo(var iname, line1, line2, line3, line4, line5: string; var useable: boolean; bowear: Boolean);

  function GetDuraStr(dura, maxdura: integer): string;
  begin
    if not BoNoDisplayMaxDura then
      Result := IntToStr(Round(dura / 1000)) + '/' + IntToStr(Round(maxdura / 1000))
    else
      Result := IntToStr(Round(dura / 1000));
  end;

  function GetDura100Str(dura, maxdura: integer): string;
  begin
    if not BoNoDisplayMaxDura then
      Result := IntToStr(Round(dura / 100)) + '/' + IntToStr(Round(maxdura / 100))
    else
      Result := IntToStr(Round(dura / 100));
  end;

begin
  if Myself = nil then
    exit;
  iname := '';
  line1 := '';
  line2 := '';
  line3 := '';
  useable := false;

  if MouseItem.S.Name <> '' then
  begin
    iname := MouseItem.S.Name + ' ';
    case MouseItem.S.StdMode of
      0:
        begin //药品
          if MouseItem.S.Shape = 1 then
          begin //贾蕾
            if (MouseItem.S.DC > 0) and (MouseItem.S.MC > 0) then
            begin
              line1 := line1 + 'HP' + IntToStr(MouseItem.S.DC) + '%恢复 ';
              line1 := line1 + 'MP' + IntToStr(MouseItem.S.MC) + '%恢复 ';
            end
            else if (MouseItem.S.DC > 0) then
              line1 := line1 + 'HP' + IntToStr(MouseItem.S.DC) + '%恢复 '
            else if (MouseItem.S.MC > 0) then
              line1 := line1 + 'MP' + IntToStr(MouseItem.S.MC) + '%恢复 ';
          end;

          if MouseItem.S.AC > 0 then
            line1 := '+' + IntToStr(MouseItem.S.AC) + 'HP ';
          if MouseItem.S.MAC > 0 then
            line1 := line1 + '+' + IntToStr(MouseItem.S.MAC) + 'MP ';

          line1 := line1 + '重量' + IntToStr(MouseItem.S.Weight);
          case MouseItem.S.Stock of
		          44:
              begin
               line5 := line5 + '售价金币：' + IntToStr(MouseItem.S.Price)
              end;
              45:
               begin
               line5 := line5 + '售价元宝：' + IntToStr(MouseItem.S.Price);
               end;
		       	end;
        end;
      1..3:
        begin
          if (MouseItem.S.StdMode = 3) and (MouseItem.S.Shape = 12) and (MouseItem.S.Name = '数量') then
          begin
            line1 := line1 + '重量' + IntToStr(MouseItem.S.Weight);
            line3 := MySelf.UserName + '你的生日快乐';
          end
          else if (MouseItem.S.StdMode = 2) and (MouseItem.S.Shape in [0..2]) then begin    //随机石
                     line1 := line1 + '重量' +  IntToStr(MouseItem.S.Weight);
                     line2 := '使用 ' + GetDuraStr(MouseItem.Dura, MouseItem.DuraMax) + ' 次';
          end
          else if (MouseItem.S.Shape = 9) and (MouseItem.S.StdMode = 2) then begin
                     line1 := line1 + '重量' + IntToStr(MouseItem.S.Weight);
                     line2 := '可累计修复持久' + IntToStr(Round(MouseItem.Dura / 100)) + '点';
          end
          else if MouseItem.S.OverlapItem = 1 then
            line1 := line1 + '重量' + IntToStr(MouseItem.Dura div 10) + ' 数量' + IntToStr(MouseItem.Dura)
          else if MouseItem.S.OverlapItem = 2 then
            line1 := line1 + '重量' + IntToStr(MouseItem.S.Weight * MouseItem.Dura) + ' 数量' + IntToStr(MouseItem.Dura)
          else
            line1 := line1 + '重量' + IntToStr(MouseItem.S.Weight);
          case MouseItem.S.Stock of
		          44:
              begin
              line5 := line5 + '售价金币：' + IntToStr(MouseItem.S.Price)
              end;
              45:
               begin
              line5 := line5 + '售价元宝：' + IntToStr(MouseItem.S.Price);
               end;
		       	end;
        end;
      4:
        begin
          line1 := line1 + '重量' + IntToStr(MouseItem.S.Weight);
          useable := FALSE;
          case MouseItem.S.Shape of
            0:
              begin
                line2 := '武士秘籍';
                line4 := '需要等级' + IntToStr(MouseItem.S.DuraMax);
                if (Myself.Job = 0) and (Myself.Abil.Level >= MouseItem.S.DuraMax) then
                  useable := TRUE;
              end;
            1:
              begin
                line2 := '法师秘籍';
                line4 := '需要等级' + IntToStr(MouseItem.S.DuraMax);
                if (Myself.Job = 1) and (Myself.Abil.Level >= MouseItem.S.DuraMax) then
                  useable := TRUE;
              end;
            2:
              begin
                line2 := '道士秘籍';
                line4 := '需要等级' + IntToStr(MouseItem.S.DuraMax);
                if (Myself.Job = 2) and (Myself.Abil.Level >= MouseItem.S.DuraMax) then
                  useable := TRUE;
              end;
          end;
          case MouseItem.S.Stock of
		          44:
              begin
              line5 := line5 + '售价金币：' + IntToStr(MouseItem.S.Price)
              end;
              45:
               begin
               line5 := line5 + '售价元宝：' + IntToStr(MouseItem.S.Price);
               end;
		       	end;
        end;
      5..6: //武器
        begin
          useable := FALSE;
          if MouseItem.S.ItemDesc and $01 <> 0 then  //升级后的武器
            iname := '(*)' + iname;

          line1 := line1 + '重量' + IntToStr(MouseItem.S.Weight) + ' 持久' + GetDuraStr(MouseItem.Dura, MouseItem.DuraMax);
          if MouseItem.S.DC > 0 then
            line2 := '攻击' + IntToStr(Lobyte(MouseItem.S.DC)) + '-' + IntToStr(Hibyte(MouseItem.S.DC)) + ' ';
          if MouseItem.S.MC > 0 then
            line2 := line2 + '魔法' + IntToStr(Lobyte(MouseItem.S.MC)) + '-' + IntToStr(Hibyte(MouseItem.S.MC)) + ' ';
          if MouseItem.S.SC > 0 then
            line2 := line2 + '道术' + IntToStr(Lobyte(MouseItem.S.SC)) + '-' + IntToStr(Hibyte(MouseItem.S.SC)) + ' ';
          if MouseItem.S.SpecialPwr in [1..10] then  //公扁狼 碍档
            line2 := line2 + '强度+' + IntToStr(MouseItem.S.SpecialPwr) + ' ';
          if (MouseItem.S.SpecialPwr <= -1) and (MouseItem.S.SpecialPwr >= -50) then
            line2 := line2 + '神圣+' + IntToStr(-MouseItem.S.SpecialPwr) + ' ';
          if (MouseItem.S.SpecialPwr <= -51) and (MouseItem.S.SpecialPwr >= -100) then
            line2 := line2 + '神圣-' + IntToStr((-MouseItem.S.SpecialPwr) - 50) + ' ';
          if Hibyte(MouseItem.S.AC) > 0 then
            line3 := line3 + '准确+' + IntToStr(Hibyte(MouseItem.S.AC)) + ' ';
          if MouseItem.S.Slowdown > 0 then
            line3 := line3 + '迟钝+' + IntToStr(MouseItem.S.Slowdown) + ' '; //==Upgradeitem==
          if MouseItem.S.Tox > 0 then
            line3 := line3 + '中毒+' + IntToStr(MouseItem.S.Tox) + ' '; //==Upgradeitem==
          if Hibyte(MouseItem.S.MAC) > 0 then
          begin
            if Hibyte(MouseItem.S.MAC) > 10 then
              line3 := line3 + '攻击速度+' + IntToStr(Hibyte(MouseItem.S.MAC) - 10) + ' '
            else
              line3 := line3 + '攻击速度-' + IntToStr(Hibyte(MouseItem.S.MAC)) + ' ';
          end;
          if (MouseItem.S.AC and $80) <> 0 then
          begin
            line3 := line3 + '幸运 ';
          end;
          if Lobyte(MouseItem.S.AC and $7F) > 0 then
            line3 := line3 + '幸运+' + IntToStr(Lobyte(MouseItem.S.AC and $7F)) + ' ';
          if Lobyte(MouseItem.S.MAC) > 0 then
            line3 := line3 + '诅咒+' + IntToStr(Lobyte(MouseItem.S.MAC)) + ' ';
          case MouseItem.S.Need of
            0:
              begin
                if Myself.Abil.Level >= MouseItem.S.NeedLevel then
                  useable := TRUE;
                line4 := line4 + '需要等级' + IntToStr(MouseItem.S.NeedLevel);
              end;
            1:
              begin
                if hibyte(Myself.Abil.DC) >= MouseItem.S.NeedLevel then
                  useable := TRUE;
                line4 := line4 + '需要攻击力' + IntToStr(MouseItem.S.NeedLevel);
              end;
            2:
              begin
                if hibyte(Myself.Abil.MC) >= MouseItem.S.NeedLevel then
                  useable := TRUE;
                line4 := line4 + '需要魔法力' + IntToStr(MouseItem.S.NeedLevel);
              end;
            3:
              begin
                if hibyte(Myself.Abil.SC) >= MouseItem.S.NeedLevel then
                  useable := TRUE;
                line4 := line4 + '需要精神力' + IntToStr(MouseItem.S.NeedLevel);
              end;
            5: begin
                  if (Myself.Abil.Level >= MouseItem.S.NeedLevel) and (Myself.GamePoint >= MouseItem.S.EFFTYPE1) then
                    useable := TRUE;
                  line4 := line4 + '需要等级' + IntToStr(MouseItem.S.NeedLevel) + '佩戴需要荣誉' + IntToStr(MouseItem.S.EFFTYPE1) + '点';
                end;
              7: begin
                        useable := TRUE;
                        line3 := line3 + '沙城成员专用';
                     end;
                  70: begin
                        useable := TRUE;
                        line3 := line3 + '沙城城主专用';
                     end;
           end;
           case MouseItem.S.Stock of
            44:
              begin
              line5 := line5 + '售价金币：' + IntToStr(MouseItem.S.Price)
              end;
            45:
            begin
             line5 := line5 + '售价元宝：' + IntToStr(MouseItem.S.Price);
            end;
            //
          end;
        end;
      7:
        begin //捆绑绳
          if MouseItem.S.OverlapItem = 1 then
            line1 := line1 + '重量' + IntToStr(MouseItem.Dura div 10) + ' 数量' + IntToStr(MouseItem.Dura)
          else if MouseItem.S.OverlapItem = 2 then
            line1 := line1 + '重量' + IntToStr(MouseItem.S.Weight * MouseItem.Dura) + ' 数量' + IntToStr(MouseItem.Dura)
          else
            line1 := line1 + '重量' + IntToStr(MouseItem.S.Weight);
          line2 := '按Ctrl键选择物品进行绑定';
          case MouseItem.S.Stock of
		          44:
              begin
              line5 := line5 + '售价金币：' + IntToStr(MouseItem.S.Price)
              end;
              45:
               begin
               line5 := line5 + '售价元宝：' + IntToStr(MouseItem.S.Price);
               end;
          end;
        end;
      8:
        begin
          case MouseItem.S.Shape of
            0:
              begin //请帖
                line1 := line1 + '行会领土No.' + IntToStr(MouseItem.Dura) + ' 重量' + IntToStr(MouseItem.S.Weight);
                line2 := '有效期为24小时';
              end;
            1:
              begin //王房间移动马牌
                line1 := line1 + '重量' + IntToStr(MouseItem.S.Weight);
                line2 := '矫傍埃阑 檬岿窍咯 磊脚阑 捞掺绰 塞捞';
                line3 := '蠢哺笼聪促.'
              end;
            2:       //礼品盒黄金鸡蛋
              line1 := line1 + '重量' + IntToStr(MouseItem.S.Weight);
          end;
          case MouseItem.S.Stock of
		          44:
              begin
              line5 := line5 + '售价金币：' + IntToStr(MouseItem.S.Price)
              end;
              45:
               begin
               line5 := line5 + '售价元宝：' + IntToStr(MouseItem.S.Price);
               end;
		       	end;
        end;
      9:
        begin //梦想囊
//               line1 := DecoItemDesc( MouseItem.Dura);
//               line1 := line1 + ' 重量' +  IntToStr(MouseItem.S.Weight)
//                                        + ' 持久'+ IntToStr(Round(MouseItem.DuraMax/1000));
          line1 := '重量' + IntToStr(MouseItem.S.Weight) + ' 持久' + IntToStr(Round(MouseItem.DuraMax / 1000));
//                                + ' 持久'+ IntToStr(Trunc(MouseItem.DuraMax/1000));
          line2 := DecoItemDesc(MouseItem.Dura, line3);
          case MouseItem.S.Stock of
		          44:
              begin
               line5 := line5 + '售价金币：' + IntToStr(MouseItem.S.Price)
              end;
              45:
               begin
               line5 := line5 + '售价元宝：' + IntToStr(MouseItem.S.Price);
               end;
		       	end;
        end;
      10, 11:  //男衣服, 女衣服
        begin
          useable := FALSE;
          line1 := line1 + '重量' + IntToStr(MouseItem.S.Weight) + ' 持久' + GetDuraStr(MouseItem.Dura, MouseItem.DuraMax);
               //line1 := line1 + '重量' + IntToStr(MouseItem.S.Weight) +
               //      ' 持久'+ IntToStr(Round(MouseItem.Dura/1000)) + '/' + IntToStr(Round(MouseItem.DuraMax/1000));
          if MouseItem.S.AC > 0 then
            line2 := '防御' + IntToStr(Lobyte(MouseItem.S.AC)) + '-' + IntToStr(Hibyte(MouseItem.S.AC)) + ' ';
          if MouseItem.S.MAC > 0 then
            line2 := line2 + '魔御' + IntToStr(Lobyte(MouseItem.S.MAC)) + '-' + IntToStr(Hibyte(MouseItem.S.MAC)) + ' ';
          if MouseItem.S.DC > 0 then
            line2 := line2 + '攻击' + IntToStr(Lobyte(MouseItem.S.DC)) + '-' + IntToStr(Hibyte(MouseItem.S.DC)) + ' ';
          if MouseItem.S.MC > 0 then
            line2 := line2 + '魔法' + IntToStr(Lobyte(MouseItem.S.MC)) + '-' + IntToStr(Hibyte(MouseItem.S.MC)) + ' ';
          if MouseItem.S.Agility > 0 then
            line2 := line2 + '敏捷+' + IntToStr(MouseItem.S.Agility) + ' '; // ==Upgradeitem==
          if MouseItem.S.SC > 0 then
            line2 := line2 + '道术' + IntToStr(Lobyte(MouseItem.S.SC)) + '-' + IntToStr(Hibyte(MouseItem.S.SC)) + ' ';

          if MouseItem.S.HpAdd > 0 then
            line3 := line3 + 'HP+' + IntToStr(MouseItem.S.HpAdd) + ' ';
          if MouseItem.S.MpAdd > 0 then
            line3 := line3 + 'MP+' + IntToStr(MouseItem.S.MpAdd) + ' ';
          if MouseItem.S.EffType1 = 3 then
            line3 := line3 + '幸运+' + IntToStr(MouseItem.S.EffValue1) + ' ';
          if MouseItem.S.MgAvoid > 0 then
            line3 := line3 + '魔法防御+' + IntToStr(MouseItem.S.MgAvoid) + ' '; //==Upgradeitem==
          if MouseItem.S.ToxAvoid > 0 then
            line3 := line3 + '中毒防御+' + IntToStr(MouseItem.S.ToxAvoid) + ' '; //==Upgradeitem==

          case MouseItem.S.EffType1 of
            5:
              begin
                line3 := line3 + '体力恢复+' + IntToStr(MouseItem.S.EffRate1 * 10) + '% ';
                line3 := line3 + '魔法恢复+' + IntToStr(MouseItem.S.EffValue1 * 10) + '% ';
              end;
          end;
          case MouseItem.S.EffType2 of
            5:
              begin
                line3 := line3 + '体力恢复+' + IntToStr(MouseItem.S.EffRate2 * 10) + '% ';
                line3 := line3 + '魔法恢复+' + IntToStr(MouseItem.S.EffValue2 * 10) + '% ';
              end;
          end;

          case MouseItem.S.Need of
            0:
              begin
                if Myself.Abil.Level >= MouseItem.S.NeedLevel then
                  useable := TRUE;
                line4 := '需要等级' + IntToStr(MouseItem.S.NeedLevel);
              end;
            1:
              begin
                if hibyte(Myself.Abil.DC) >= MouseItem.S.NeedLevel then
                  useable := TRUE;
                line4 := '需要攻击力' + IntToStr(MouseItem.S.NeedLevel);
              end;
            2:
              begin
                if hibyte(Myself.Abil.MC) >= MouseItem.S.NeedLevel then
                  useable := TRUE;
                line4 := '需要魔法力' + IntToStr(MouseItem.S.NeedLevel);
              end;
            3:
              begin
                if hibyte(Myself.Abil.SC) >= MouseItem.S.NeedLevel then
                  useable := TRUE;
                line4 := '需要精神力' + IntToStr(MouseItem.S.NeedLevel);
              end;
            7: begin
                        useable := TRUE;
                        line3 := line3 + '沙城成员专用';
                     end;
                  70: begin
                        useable := TRUE;
                        line3 := line3 + '沙城城主专用';
                     end;
          end;
          case MouseItem.S.Stock of

           // end;
              44:
              begin
              line5 := line5 + '售价金币：' + IntToStr(MouseItem.S.Price)
              end;
              45:
               begin
               line5 := line5 + '售价元宝：' + IntToStr(MouseItem.S.Price);
               end;
          end;
        end;
      15,     //头盔
      19, 20, 21,  //项链
      22, 23,  //戒指
         // 2003/03/15 酒捞袍 牢亥配府 犬厘
      52, 53, 54,65, //腰带 鞋 宝石   rb
      24, 26:  //手镯
        begin
          useable := FALSE;
          line1 := line1 + '重量' + IntToStr(MouseItem.S.Weight) + ' ';
          if (MouseItem.S.StdMode <> 53) then
            line1 := line1 + '持久' + GetDuraStr(MouseItem.Dura, MouseItem.DuraMax) + ' ';
               // 2003/08/25 迫骂 酒捞袍, 脚己加己 浅急 档框富 眠啊.  // AddHolyMent
          if MouseItem.S.StdMode = 15 then
          begin
            if (MouseItem.S.Accurate > 0) then
              line2 := line2 + '准确+' + IntToStr(MouseItem.S.Accurate) + ' '; // ==Upgradeitem==
            if MouseItem.S.MgAvoid > 0 then
              line3 := line3 + '魔法防御+' + IntToStr(MouseItem.S.MgAvoid) + ' '; //==Upgradeitem==
            if MouseItem.S.ToxAvoid > 0 then
              line3 := line3 + '中毒防御+' + IntToStr(MouseItem.S.ToxAvoid) + ' '; //==Upgradeitem==
          end;
          if MouseItem.S.StdMode = 26 then
          begin
            if (MouseItem.S.Accurate > 0) then
              line2 := line2 + '准确+' + IntToStr(MouseItem.S.Accurate) + ' '; // ==Upgradeitem==
            if MouseItem.S.Agility > 0 then
              line2 := line2 + '敏捷+' + IntToStr(MouseItem.S.Agility) + ' '; // ==Upgradeitem==
          end;
          if (MouseItem.S.StdMode = 52) or (MouseItem.S.StdMode = 54) then
          begin
//                  if MouseItem.S.AC > 0 then
//                     line2 := '防御' + IntToStr(Lobyte(MouseItem.S.AC)) + '-' + IntToStr(Hibyte(MouseItem.S.AC)) + ' ';// ==Upgradeitem==
//                  if MouseItem.S.MAC > 0 then
//                     line2 := line2 + '魔御' + IntToStr(Lobyte(MouseItem.S.MAC)) + '-' + IntToStr(Hibyte(MouseItem.S.MAC)) + ' ';// ==Upgradeitem==
            if MouseItem.S.Agility > 0 then
              line2 := line2 + '敏捷+' + IntToStr(MouseItem.S.Agility) + ' '; // ==Upgradeitem==
            if (MouseItem.S.Accurate > 0) then   //2004/01/08
              line2 := line2 + '准确+' + IntToStr(MouseItem.S.Accurate) + ' '; // ==Upgradeitem==

            if MouseItem.S.StdMode = 54 then
            begin
              if MouseItem.S.ToxAvoid > 0 then
                line3 := line3 + '中毒防御+' + IntToStr(MouseItem.S.ToxAvoid) + ' '; //==Upgradeitem==
            end;
          end;

          if (MouseItem.S.SpecialPwr <= -1) and (MouseItem.S.SpecialPwr >= -50) then
            line2 := line2 + '神圣+' + IntToStr(-MouseItem.S.SpecialPwr) + ' ';
          if (MouseItem.S.SpecialPwr <= -51) and (MouseItem.S.SpecialPwr >= -100) then
            line2 := line2 + '神圣-' + IntToStr((-MouseItem.S.SpecialPwr) - 50) + ' ';
               //-----------------

          if ((MouseItem.S.Shape = RING_OF_UNKNOWN) or (MouseItem.S.Shape = BRACELET_OF_UNKNOWN) or (MouseItem.S.Shape = HELMET_OF_UNKNOWN)) and (not bowear) then
          begin
            line2 := '????????';
          end
          else
          begin
            case MouseItem.S.StdMode of
              19: //项链
                begin
                  if MouseItem.S.AtkSpd > 0 then
                    line2 := line2 + '攻击速度+' + IntToStr(MouseItem.S.AtkSpd) + ' ';
                  if (MouseItem.S.Accurate > 0) then
                    line2 := line2 + '准确+' + IntToStr(MouseItem.S.Accurate) + ' '; // ==Upgradeitem==
                  if MouseItem.S.Slowdown > 0 then
                    line2 := line2 + '迟钝+' + IntToStr(MouseItem.S.Slowdown) + ' '; //==Upgradeitem==
                  if MouseItem.S.Tox > 0 then
                    line2 := line2 + '中毒+' + IntToStr(MouseItem.S.Tox) + ' '; //==Upgradeitem==
//                           if MouseItem.S.MgAvoid > 0 then
//                              line3 := line3 + '敏捷+' + IntToStr(MouseItem.S.MgAvoid)+ ' '; //==Upgradeitem==
                  if MouseItem.S.AC > 0 then
                  begin
                   // line3 := line3 + '魔法防御+' + IntToStr(Hibyte(MouseItem.S.AC)) + ' ';
                   line2 := line2 + '魔法躲避+' + IntToStr(Hibyte(MouseItem.S.AC)) + '0% ';
                  end;
                  if Lobyte(MouseItem.S.MAC) > 0 then
                    line2 := line2 + '诅咒+' + IntToStr(Lobyte(MouseItem.S.MAC)) + ' ';
                  if Hibyte(MouseItem.S.MAC) > 0 then
                    line2 := line2 + '幸运+' + IntToStr(Hibyte(MouseItem.S.MAC)) + ' ';
                              //箭磊 钎矫救凳 + IntToStr(Hibyte(MouseItem.S.MAC)) + ' ';
                end;
              20:
                begin
                  if MouseItem.S.AC > 0 then
                    line2 := line2 + '准确+' + IntToStr(Hibyte(MouseItem.S.AC)) + ' ';
                  if MouseItem.S.MAC > 0 then
                    line2 := line2 + '敏捷+' + IntToStr(Hibyte(MouseItem.S.MAC)) + ' ';
                  if MouseItem.S.AtkSpd > 0 then
                    line2 := line2 + '攻击速度+' + IntToStr(MouseItem.S.AtkSpd) + ' ';
                  if MouseItem.S.Slowdown > 0 then
                    line2 := line2 + '迟钝+' + IntToStr(MouseItem.S.Slowdown) + ' '; //==Upgradeitem==
                  if MouseItem.S.Tox > 0 then
                    line2 := line2 + '中毒+' + IntToStr(MouseItem.S.Tox) + ' '; //==Upgradeitem==
                  if MouseItem.S.MgAvoid > 0 then
                    line3 := line3 + '魔法防御+' + IntToStr(MouseItem.S.MgAvoid) + ' '; //==Upgradeitem==
                end;
              21:  //项链
                begin
                  if Hibyte(MouseItem.S.AC) > 0 then
                    line2 := line2 + '体力恢复+' + IntToStr(Hibyte(MouseItem.S.AC)) + '0% ';
                  if Hibyte(MouseItem.S.MAC) > 0 then
                    line2 := line2 + '魔法恢复+' + IntToStr(Hibyte(MouseItem.S.MAC)) + '0% ';
                  if MouseItem.S.Accurate > 0 then
                    line2 := line2 + '准确+' + IntToStr(MouseItem.S.Accurate) + ' '; //==Upgradeitem==
                  if MouseItem.S.Slowdown > 0 then
                    line2 := line2 + '迟钝+' + IntToStr(MouseItem.S.Slowdown) + ' '; //==Upgradeitem==
                  if MouseItem.S.Tox > 0 then
                    line2 := line2 + '中毒+' + IntToStr(MouseItem.S.Tox) + ' '; //==Upgradeitem==
//                           if MouseItem.S.AtkSpd > 0 then
//                              line3 := line3 + '攻击速度+' + IntToStr(MouseItem.S.AtkSpd ) + ' ';
                  if Lobyte(MouseItem.S.AC) + MouseItem.S.AtkSpd > 0 then
                    line3 := line3 + '攻击速度+' + IntToStr(Lobyte(MouseItem.S.AC) + MouseItem.S.AtkSpd) + ' ';
                  if Lobyte(MouseItem.S.MAC) > 0 then
                    line3 := line3 + '攻击速度-' + IntToStr(Lobyte(MouseItem.S.MAC)) + ' ';
                  if MouseItem.S.MgAvoid > 0 then
                    line3 := line3 + '魔法防御+' + IntToStr(MouseItem.S.MgAvoid) + ' '; //==Upgradeitem==
                end;
              22:
                begin
                  if MouseItem.S.AC > 0 then
                    line2 := line2 + '防御' + IntToStr(Lobyte(MouseItem.S.AC)) + '-' + IntToStr(Hibyte(MouseItem.S.AC)) + ' ';
                  if MouseItem.S.MAC > 0 then
                    line2 := line2 + '魔御' + IntToStr(Lobyte(MouseItem.S.MAC)) + '-' + IntToStr(Hibyte(MouseItem.S.MAC)) + ' ';
                  if MouseItem.S.AtkSpd > 0 then
                    line2 := line2 + '攻击速度+' + IntToStr(MouseItem.S.AtkSpd) + ' ';
                  if MouseItem.S.Slowdown > 0 then
                    line2 := line2 + '迟钝+' + IntToStr(MouseItem.S.Slowdown) + ' '; //==Upgradeitem==
                  if MouseItem.S.Tox > 0 then
                    line2 := line2 + '中毒+' + IntToStr(MouseItem.S.Tox) + ' '; //==Upgradeitem==
                end;
              23:  //戒指
                begin
                  if MouseItem.S.Slowdown > 0 then
                    line2 := line2 + '迟钝+' + IntToStr(MouseItem.S.Slowdown) + ' '; //==Upgradeitem==
                  if MouseItem.S.Tox > 0 then
                    line2 := line2 + '中毒+' + IntToStr(MouseItem.S.Tox) + ' '; //==Upgradeitem==
                  if Hibyte(MouseItem.S.AC) > 0 then
                    line2 := line2 + '中毒防御+' + IntToStr(Hibyte(MouseItem.S.AC)) + '0% ';
                  if Hibyte(MouseItem.S.MAC) > 0 then
                    line2 := line2 + '中毒恢复+' + IntToStr(Hibyte(MouseItem.S.MAC)) + '0% ';
//                           if MouseItem.S.AtkSpd > 0 then
//                              line3 := line3 + '攻击速度+' + IntToStr(MouseItem.S.AtkSpd ) + ' ';
                  if Lobyte(MouseItem.S.AC) + MouseItem.S.AtkSpd > 0 then
                    line3 := line3 + '攻击速度+' + IntToStr(Lobyte(MouseItem.S.AC) + MouseItem.S.AtkSpd) + ' ';
                  if Lobyte(MouseItem.S.MAC) > 0 then
                    line3 := line3 + '攻击速度-' + IntToStr(Lobyte(MouseItem.S.MAC)) + ' ';
                end;
              24: //迫骂
                begin
                  if MouseItem.S.AC > 0 then
                    line2 := line2 + '准确+' + IntToStr(Hibyte(MouseItem.S.AC)) + ' ';
                  if MouseItem.S.MAC > 0 then
                    line2 := line2 + '敏捷+' + IntToStr(Hibyte(MouseItem.S.MAC)) + ' ';
{                           if (MouseItem.S.Accurate > 0) then
                              line2 := line2 + '准确+'+ IntToStr(MouseItem.S.Accurate)+ ' '; // ==Upgradeitem==
                           if MouseItem.S.Agility > 0 then
                              line2 := line2 + '敏捷+' + IntToStr(MouseItem.S.Agility) + ' '; // ==Upgradeitem==}
                end;
            else
              begin
                if MouseItem.S.AC > 0 then
                  line2 := line2 + '防御' + IntToStr(Lobyte(MouseItem.S.AC)) + '-' + IntToStr(Hibyte(MouseItem.S.AC)) + ' ';
                if MouseItem.S.MAC > 0 then
                  line2 := line2 + '魔御' + IntToStr(Lobyte(MouseItem.S.MAC)) + '-' + IntToStr(Hibyte(MouseItem.S.MAC)) + ' ';
              end;
            end;
            if MouseItem.S.DC > 0 then
              line2 := line2 + '攻击' + IntToStr(Lobyte(MouseItem.S.DC)) + '-' + IntToStr(Hibyte(MouseItem.S.DC)) + ' ';
            if MouseItem.S.MC > 0 then
              line2 := line2 + '魔法' + IntToStr(Lobyte(MouseItem.S.MC)) + '-' + IntToStr(Hibyte(MouseItem.S.MC)) + ' ';
            if MouseItem.S.SC > 0 then
              line2 := line2 + '道术' + IntToStr(Lobyte(MouseItem.S.SC)) + '-' + IntToStr(Hibyte(MouseItem.S.SC)) + ' ';
                  // 2003/03/15 酒捞袍 牢亥配府 犬厘
            if MouseItem.S.HpAdd > 0 then
              line2 := line2 + 'HP+' + IntToStr(MouseItem.S.HpAdd) + ' ';
            if MouseItem.S.MpAdd > 0 then
            begin
              if MouseItem.S.StdMode = 26 then
                line3 := line3 + 'MP+' + IntToStr(MouseItem.S.MpAdd) + ' '
              else
                line2 := line2 + 'MP+' + IntToStr(MouseItem.S.MpAdd) + ' ';
            end;
            if MouseItem.S.ExpAdd > 0 then
              line2 := line2 + '经验倍数+' + IntToStr(MouseItem.S.ExpAdd) + ' ';
            case MouseItem.S.EffType1 of
              1:
                begin
                  line2 := line2 + '腕力+' + IntToStr(MouseItem.S.EffValue1) + ' ';
                end;
              2:
                begin
                  line2 := line2 + '负重量+' + IntToStr(MouseItem.S.EffValue1) + ' ';
                end;
              4:
                begin
                  line2 := line2 + '背包重量+' + IntToStr(MouseItem.S.EffValue1) + ' ';
                end;
//                     5: begin
//                           line2 := line2 + '体力恢复+' + IntToStr(MouseItem.S.EffRate1) + '% ';
//                           line2 := line2 + '魔法恢复+' + IntToStr(MouseItem.S.EffValue1) + '% ';
//                        end;

            end;
            case MouseItem.S.EffType2 of
              1:
                begin
                  line2 := line2 + '腕力+' + IntToStr(MouseItem.S.EffValue2) + ' ';
                end;
              2:
                begin
                  line2 := line2 + '负重量+' + IntToStr(MouseItem.S.EffValue2) + ' ';
                end;
              4:
                begin
                  line2 := line2 + '背包重量+' + IntToStr(MouseItem.S.EffValue2) + ' ';
                end;
//                     5: begin
//                           line2 := line2 + '体力恢复+' + IntToStr(MouseItem.S.EffRate2) + '% ';
//                           line2 := line2 + '魔法恢复+' + IntToStr(MouseItem.S.EffValue2) + '% ';
//                        end;
            end;

            case MouseItem.S.Need of
              0:
                begin
                  if Myself.Abil.Level >= MouseItem.S.NeedLevel then
                    useable := TRUE;
                  line4 := line4 + '需要等级' + IntToStr(MouseItem.S.NeedLevel);
                 // else
                   if   MouseItem.S.StdMode = 65  then
                            line4 := line4 + ' （rb）'
                end;
              1:
                begin
                  if hibyte(Myself.Abil.DC) >= MouseItem.S.NeedLevel then
                    useable := TRUE;
                  line4 := line4 + '需要攻击力' + IntToStr(MouseItem.S.NeedLevel);
                end;
              2:
                begin
                  if hibyte(Myself.Abil.MC) >= MouseItem.S.NeedLevel then
                    useable := TRUE;
                  line4 := line4 + '需要魔法力' + IntToStr(MouseItem.S.NeedLevel);
                end;
              3:
                begin
                  if hibyte(Myself.Abil.SC) >= MouseItem.S.NeedLevel then
                    useable := TRUE;
                  line4 := line4 + '需要精神力' + IntToStr(MouseItem.S.NeedLevel);
                end;
            5: begin
                  if (Myself.Abil.Level >= MouseItem.S.NeedLevel) and (Myself.GamePoint >= MouseItem.S.EFFTYPE1) then
                    useable := TRUE;
                  line4 := line4 + '需要等级' + IntToStr(MouseItem.S.NeedLevel) + '佩戴需要荣誉' + IntToStr(MouseItem.S.EFFTYPE1) + '点';
                end;
              7: begin
                        useable := TRUE;
                        line3 := line3 + '沙城成员专用';
                     end;
              70: begin
                        useable := TRUE;
                        line3 := line3 + '沙城城主专用';
                     end;
            end;
            case MouseItem.S.Stock of



                44:
              begin
              line5 := line5 + '售价金币：' + IntToStr(MouseItem.S.Price)
              end;
              45:
               begin
               line5 := line5 + '售价元宝：' + IntToStr(MouseItem.S.Price);
               end;
            end;
          end;
        end;
      25: //护身符及毒药
        begin
          line1 := line1 + '重量' + IntToStr(MouseItem.S.Weight);
          line2 := '使用' + GetDura100Str(MouseItem.Dura, MouseItem.DuraMax);
                    case MouseItem.S.Stock of
		          44:
              begin
               line5 := line5 + '售价金币：' + IntToStr(MouseItem.S.Price)
              end;
              45:
               begin
               line5 := line5 + '售价元宝：' + IntToStr(MouseItem.S.Price);
               end;
		       	end;
        end;
      30: //檬,冉阂
        begin
          line1 := line1 + '重量' + IntToStr(MouseItem.S.Weight) + ' 持久' + GetDuraStr(MouseItem.Dura, MouseItem.DuraMax);
//               if MouseItem.S.Shape = 2 then begin
          if MouseItem.S.AC > 0 then
            line2 := '防御' + IntToStr(Lobyte(MouseItem.S.AC)) + '-' + IntToStr(Hibyte(MouseItem.S.AC)) + ' ';
          if MouseItem.S.MAC > 0 then
            line2 := line2 + '魔御' + IntToStr(Lobyte(MouseItem.S.MAC)) + '-' + IntToStr(Hibyte(MouseItem.S.MAC)) + ' ';
          if MouseItem.S.DC > 0 then
            line2 := line2 + '攻击' + IntToStr(Lobyte(MouseItem.S.DC)) + '-' + IntToStr(Hibyte(MouseItem.S.DC)) + ' ';
          if MouseItem.S.MC > 0 then
            line2 := line2 + '魔法' + IntToStr(Lobyte(MouseItem.S.MC)) + '-' + IntToStr(Hibyte(MouseItem.S.MC)) + ' ';
          if MouseItem.S.SC > 0 then
            line2 := line2 + '道术' + IntToStr(Lobyte(MouseItem.S.SC)) + '-' + IntToStr(Hibyte(MouseItem.S.SC)) + ' ';
//               end;
              case MouseItem.S.Need of
              0:
                begin
                  if Myself.Abil.Level >= MouseItem.S.NeedLevel then
                    useable := TRUE;
                  line4 := line4 + '需要等级' + IntToStr(MouseItem.S.NeedLevel);
                end;
              1:
                begin
                  if hibyte(Myself.Abil.DC) >= MouseItem.S.NeedLevel then
                    useable := TRUE;
                  line4 := line4 + '需要攻击力' + IntToStr(MouseItem.S.NeedLevel);
                end;
              2:
                begin
                  if hibyte(Myself.Abil.MC) >= MouseItem.S.NeedLevel then
                    useable := TRUE;
                  line4 := line4 + '需要魔法力' + IntToStr(MouseItem.S.NeedLevel);
                end;
              3:
                begin
                  if hibyte(Myself.Abil.SC) >= MouseItem.S.NeedLevel then
                    useable := TRUE;
                  line4 := line4 + '需要精神力' + IntToStr(MouseItem.S.NeedLevel);
                end;
              4: begin
                if (Myself.Abil.Level >= MouseItem.S.NeedLevel) and (Myself.m_btCreditPoint >= MouseItem.S.ATKSPD) then
                  useable := TRUE;
                line4 := line4 + '需要等级' + IntToStr(MouseItem.S.NeedLevel) + '佩戴需要声望' + IntToStr(MouseItem.S.ATKSPD) + '点';
              end;
              end;
                case  MouseItem.S.Stock of


                44:
              begin
              line5 := line5 + '售价金币：' + IntToStr(MouseItem.S.Price)
              end;
              45:
               begin
               line5 := line5 + '售价元宝：' + IntToStr(MouseItem.S.Price);
               end;
            end;
        end;
      40: //肉
        begin
          line1 := line1 + '重量' + IntToStr(MouseItem.S.Weight) + ' 品质' + GetDuraStr(MouseItem.Dura, MouseItem.DuraMax);
                    case MouseItem.S.Stock of
		          44:
              begin
             line5 := line5 + '售价金币：' + IntToStr(MouseItem.S.Price)
              end;
              45:
               begin
               line5 := line5 + '售价元宝：' + IntToStr(MouseItem.S.Price);
               end;
		       	end;
        end;
      42: //药材
        begin
          if MouseItem.S.OverlapItem = 1 then
            line1 := line1 + '重量' + IntToStr(MouseItem.Dura div 10) + ' 数量' + IntToStr(MouseItem.Dura) + ' 成分'
          else if MouseItem.S.OverlapItem = 2 then
            line1 := line1 + '重量' + IntToStr(MouseItem.S.Weight * MouseItem.Dura) + ' 数量' + IntToStr(MouseItem.Dura) + ' 成分'
          else
            line1 := line1 + '重量' + IntToStr(MouseItem.S.Weight) + ' 成分';
            case MouseItem.S.Stock of
		          44:
              begin
              line5 := line5 + '售价金币：' + IntToStr(MouseItem.S.Price)
              end;
              45:
               begin
               line5 := line5 + '售价元宝：' + IntToStr(MouseItem.S.Price);
               end;
		       	end;
        end;
      43: //矿石
        begin
          line1 := line1 + '重量' + IntToStr(MouseItem.S.Weight) + ' 纯度' + IntToStr(Round(MouseItem.Dura / 1000));
                    case MouseItem.S.Stock of
		          44:
              begin
              line5 := line5 + '售价金币：' + IntToStr(MouseItem.S.Price)
              end;
              45:
               begin
               line5 := line5 + '售价元宝：' + IntToStr(MouseItem.S.Price);
               end;
		       	end;
        end;
      44: //林苛
        begin
          if MouseItem.S.Shape = 1 then
          begin
            if MouseItem.S.OverlapItem = 1 then
              line1 := line1 + '重量' + IntToStr(MouseItem.Dura div 10) + ' 数量' + IntToStr(MouseItem.Dura)
            else if MouseItem.S.OverlapItem = 2 then
              line1 := line1 + '重量' + IntToStr(MouseItem.S.Weight * MouseItem.Dura) + ' 数量' + IntToStr(MouseItem.Dura)// + ' 林苛'
           else if MouseItem.S.OverlapItem = 3 then
            line1 := line1 + '重量' + IntToStr(MouseItem.S.Weight * MouseItem.Dura) + ' 数量' + IntToStr(MouseItem.Dura) + ' 物品材料'// + ' 林苛'
            else
              line1 := line1 + '重量' + IntToStr(MouseItem.S.Weight); // + ' 林苛';
          end
          else
          begin
            line1 := line1 + '重量' + IntToStr(MouseItem.S.Weight) + ' 数量' + IntToStr(MouseItem.Dura) + ' 物品材料';
          end;
                    case MouseItem.S.Stock of
		          44:
              begin
               line4 := line4 + '售价金币：' + IntToStr(MouseItem.S.Price)
              end;
              45:
               begin
               line5 := line5 + '售价元宝：' + IntToStr(MouseItem.S.Price);
               end;
		       	end;
        end;

      60, 61:
        begin
          if MouseItem.S.Shape in [20, 21] then
          begin
            if MouseItem.S.Shape = 20 then
            begin
              line2 := '按Ctrl键并选择防御道具进行维修';
              line3 := '修理范围: 衣服、头盔、皮带、鞋'
            end
            else if MouseItem.S.Shape = 21 then
            begin
              line2 := '按下Ctrl并选择道具进行维修';
              line3 := '修理范围: 项链、戒指、手镯';
            end;
          end
          else
            line2 := '按下Ctrl并选择物品获得加强';

          case MouseItem.S.Shape of
            1:
              begin
                line1 := '重量' + IntToStr(MouseItem.S.Weight) + ' 增加攻击力';
                line3 := '强化范围: 武器、项链、戒指、手镯'
              end;
            2:
              begin
                line1 := '重量' + IntToStr(MouseItem.S.Weight) + ' 增加魔法力';
                line3 := '强化范围: 武器、项链、戒指、手镯'
              end;
            3:
              begin
                line1 := '重量' + IntToStr(MouseItem.S.Weight) + ' 增加精神力';
                line3 := '强化范围: 武器、项链、戒指、手镯'
              end;
            4:
              begin
                line1 := '重量' + IntToStr(MouseItem.S.Weight) + ' 增加防御';
                line3 := '强化范围: 戒指、手链、衣服、头盔、腰带、鞋子'
              end;
            5:
              begin
                line1 := '重量' + IntToStr(MouseItem.S.Weight) + ' 增加魔御';
                line3 := '强化范围: 戒指、手链、衣服、头盔、腰带、鞋子';
              end;
            6:
              begin
                line1 := '重量' + IntToStr(MouseItem.S.Weight) + ' 增加最大持久';
                line3 := '强化范围: 所有装备';
              end;
            7:
              begin
                line1 := '重量' + IntToStr(MouseItem.S.Weight) + ' 增加攻击速度';
                line3 := '强化范围: 武器, 项链, 戒指';
              end;
            8:
              begin
                line1 := '重量' + IntToStr(MouseItem.S.Weight) + ' 增加敏捷';
                line3 := '强化范围: 手镯、服装、腰带、鞋子';
              end;
            9:
              begin
                line1 := '重量' + IntToStr(MouseItem.S.Weight) + ' 增加准确';
                line3 := '强化范围: 项链, 手镯, 头盔, 腰带';
              end;
            10:
              begin
                line1 := '重量' + IntToStr(MouseItem.S.Weight) + ' 中毒+';
                line3 := '强化范围: 武器、项链、戒指';
              end;
            11:
              begin
                line1 := '重量' + IntToStr(MouseItem.S.Weight) + ' 迟钝+';
                line3 := '强化范围: 武器、项链、戒指';
              end;
            12:
              begin
                line1 := '重量' + IntToStr(MouseItem.S.Weight) + ' 增加中毒防御';
                line3 := '强化范围: 项链、衣服、头盔';
              end;
            13:
              begin
                line1 := '重量' + IntToStr(MouseItem.S.Weight) + ' 增加魔法防御';
                line3 := '强化范围: 衣服、头盔、腰带';
              end;
          end;
                    case MouseItem.S.Stock of
		          44:
              begin
               line5 := line5 + '售价金币：' + IntToStr(MouseItem.S.Price)
              end;
              45:
               begin
               line5 := line5 + '售价元宝：' + IntToStr(MouseItem.S.Price);
               end;
		       	end;
        end;
      70:
        begin
          line1 := line1 + '重量' + IntToStr(MouseItem.S.Weight);
          case MouseItem.S.Shape of
            3:begin
              line2 := '使用获得' + IntToStr(MouseItem.DuraMax) + '元宝';
            end;
          end;
          case MouseItem.S.Stock of
		          44:
              begin
              line5 := line5 + '售价金币：' + IntToStr(MouseItem.S.Price)
              end;
              45:
               begin
               line5 := line5 + '售价元宝：' + IntToStr(MouseItem.S.Price);
               end;
		       	end;
        end;
    else
      begin
        line1 := line1 + '重量' + IntToStr(MouseItem.S.Weight);

          case MouseItem.S.Stock of
		          44:
              begin
               line5 := line5 + '售价金币：' + IntToStr(MouseItem.S.Price)
              end;
              45:
               begin
               line5 := line5 + '售价元宝：' + IntToStr(MouseItem.S.Price);
               end;
		       	end;
      end;
    end;
    if MouseItem.S.Shape = 99 then
    begin
      if MouseItem.S.StdMode in [21, 22, 26, 53] then
      begin
        line1 := line1 + '重量' + IntToStr(MouseItem.S.Weight);
        line2 := '扁 ' + IntToStr(MouseItem.S.Undead);
      end;
    end;
  end;
end;

//绘画人物背包
procedure TFrmDlg.DItemBagDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  iname, d0, d1, d2, d3, d4: string;
  n: integer;
  useable: Boolean;
  d: TAsphyreLockableTexture;
  FColor: TColor;
begin
  if Myself = nil then
    exit;
  with DItemBag do
  begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

    GetMouseItemInfo(iname, d0, d1, d2, d3, d4, useable, FALSE);
//      GetMouseItemInfo (d0, d1, d2, d3, useable, FALSE);
    with dsurface do
    begin
         //SetBkMode (Handle, TRANSPARENT);
//         Font.Color := clWhite;
//         TextOut (SurfaceX(Left+64), SurfaceY(Top+185), GetGoldStr(Myself.Gold));
      if NOT g_bo物品窗口 then
      begin
      TextOut(SurfaceX(Left + 64), SurfaceY(Top + 185), clWhite, GetGoldStr(Myself.Gold));
      if (iname <> '') and not g_bo悬浮信息 then
      begin
//            Font.Color := clYellow;
//            TextOut (SurfaceX(Left+70), SurfaceY(Top+215), iname);
        TextOut(SurfaceX(Left + 70), SurfaceY(Top + 215), clYellow, iname);
        n := FontManager.Default.TextWidth(iname);

//            if MouseItem.UpgradeOpt > 0 then Font.Color := clAqua
//        if MouseItem.UpgradeOpt > 0 then     //极品蓝色   自己包里
//          FColor := TColor($cccc33) //极品蓝色   自己包里
//        else                        //极品蓝色   自己包里
          if (MouseItem.UpgradeOpt > 0) and g_bo极品蓝字 then
          FColor := TColor($cccc33)
          else
          FColor := clWhite;
//            TextOut (SurfaceX(Left+70) + n, SurfaceY(Top+215), d0);
//            TextOut (SurfaceX(Left+70), SurfaceY(Top+215+14), d1);
//            TextOut (SurfaceX(Left+70), SurfaceY(Top+215+14*2), d2);

        TextOut(SurfaceX(Left + 70) + n, SurfaceY(Top + 215), FColor, d0);
        TextOut(SurfaceX(Left + 70), SurfaceY(Top + 215 + 14), FColor, d1);
        TextOut(SurfaceX(Left + 70), SurfaceY(Top + 215 + 14 * 2), FColor, d2);
        if not useable then
          FColor := clRed;
        n := FontManager.Default.TextWidth(d2);  //跟随d2 长度参数4    红色绘制d3  参数5
//            TextOut (SurfaceX(Left+70) + n, SurfaceY(Top+215+14*2), d3);

        TextOut(SurfaceX(Left + 70) + n, SurfaceY(Top + 215 + 14 * 2), FColor, d3);
        n := n + FontManager.Default.TextWidth(d3);  //跟随d2 长度参数4    红色绘制d3  参数5
          if (MouseItem.UpgradeOpt > 0) and g_bo极品蓝字 then
          FColor := TColor($cccc33)
          else
          FColor := clWhite;
        TextOut(SurfaceX(Left + 70) + n, SurfaceY(Top + 215 + 14 * 2), FColor, ' ' + d4);
      end;
      end else
      begin  //以下是新包裹的位置参数
      TextOut(SurfaceX(Left + 71), SurfaceY(Top + 213), clWhite, GetGoldStr(Myself.Gold)); //这里是金币数字位置
      if (iname <> '') then
      begin   //下面这些就是装备物品显示信息
//            Font.Color := clYellow;
//            TextOut (SurfaceX(Left+70), SurfaceY(Top+215), iname);
        TextOut(SurfaceX(Left + 76), SurfaceY(Top + 243), clYellow, iname);
        n := FontManager.Default.TextWidth(iname);

//            if MouseItem.UpgradeOpt > 0 then Font.Color := clAqua
//        if MouseItem.UpgradeOpt > 0 then     //极品蓝色   自己包里
//          FColor := TColor($cccc33) //极品蓝色   自己包里
//        else                        //极品蓝色   自己包里
          if (MouseItem.UpgradeOpt > 0) and g_bo极品蓝字 then
          FColor := TColor($cccc33)
          else
          FColor := clWhite;
//            TextOut (SurfaceX(Left+70) + n, SurfaceY(Top+215), d0);
//            TextOut (SurfaceX(Left+70), SurfaceY(Top+215+14), d1);
//            TextOut (SurfaceX(Left+70), SurfaceY(Top+215+14*2), d2);

        TextOut(SurfaceX(Left + 76) + n, SurfaceY(Top + 243), FColor, d0);
        TextOut(SurfaceX(Left + 76), SurfaceY(Top + 243 + 14), FColor, d1);
        TextOut(SurfaceX(Left + 76), SurfaceY(Top + 243 + 14 * 2), FColor, d2);
        if not useable then
          FColor := clRed;
        n := FontManager.Default.TextWidth(d2);  //跟随d2 长度参数4    红色绘制d3  参数5
//            TextOut (SurfaceX(Left+70) + n, SurfaceY(Top+215+14*2), d3);
        TextOut(SurfaceX(Left + 76) + n, SurfaceY(Top + 243 + 14 * 2), FColor, d3);
         n := n + FontManager.Default.TextWidth(d3);  //跟随d2 长度参数4    红色绘制d3  参数5
          if (MouseItem.UpgradeOpt > 0) and g_bo极品蓝字 then
          FColor := TColor($cccc33)
          else
          FColor := clWhite;
        TextOut(SurfaceX(Left + 76) + n, SurfaceY(Top + 243 + 14 * 2), FColor, ' ' + d4);
      end;//到这结束
      end;
         //Release;
    end;
  end;
end;

procedure TFrmDlg.DItemBagMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
  DScreen.ClearHint(True);
  MouseItem.S.Name := '';
  MouseStateItem.S.Name := '';
  MouseUserStateItem.S.Name := '';
end;

procedure TFrmDlg.DRepairItemInRealArea(Sender: TObject; X, Y: Integer; var IsRealArea: Boolean);
begin
{   if (X >= 0) and (Y >= 0) and (X <= DRepairItem.Width) and
      (Y <= DRepairItem.Height) then
         IsRealArea := TRUE
   else IsRealArea := FALSE;}
end;

procedure TFrmDlg.DRepairItemDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with DRepairItem do
  begin
    if not g_bo物品窗口 then
    begin
    d := WLib.Images[FaceIndex];
    if DRepairItem.Downed and (d <> nil) then
      dsurface.Draw(SurfaceX(254), SurfaceY(183), d.ClientRect, d, TRUE);
    end else begin //==============
    if DRepairItem.Downed then
    d := WLib.Images[FaceIndex + 1]
    else d := WLib.Images[FaceIndex];
    if (d <> nil) then
      dsurface.Draw(DRepairItem.SurfaceX(DRepairItem.Left), DRepairItem.SurfaceY(DRepairItem.Top), d.ClientRect, d, TRUE);
      with dsurface do begin       // 包裹整理位置调整
       if DRepairItem.Downed then
         TextOut (DRepairItem.SurfaceX(DRepairItem.Left) + (FontManager.Default.TextWidth('整理') div 2) - 2, DRepairItem.SurfaceY(DRepairItem.Top) + 6, rgb(238, 164, 74), '整理')
        else if Arrived then
        TextOut (DRepairItem.SurfaceX(DRepairItem.Left) + (FontManager.Default.TextWidth('整理') div 2) - 2, DRepairItem.SurfaceY(DRepairItem.Top) + 6, rgb(238, 214, 173), '整理')
        else TextOut (DRepairItem.SurfaceX(DRepairItem.Left) + (FontManager.Default.TextWidth('整理') div 2) - 2, DRepairItem.SurfaceY(DRepairItem.Top) + 6, rgb(238, 197, 140), '整理');
      end;
    end;
  end;
end;

procedure TFrmDlg.DCloseBagDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with DCloseBag do
  begin
    if DCloseBag.Downed then
    begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
    end;
  end;
end;

procedure TFrmDlg.DCloseBagClick(Sender: TObject; X, Y: Integer);
begin
  DItemBag.Visible := FALSE;
end;

function dellStallItem(ci: TClientItem): TClientItem;
var
  i                 : Integer;
begin
  Result.S.Name:='';
  if MySelf = nil then Exit;
  for i := 0 to 10 - 1 do begin
    if mySelf.m_StallMgr.mBlock.Items[i].s.Name <> '' then begin
      if mySelf.m_StallMgr.mBlock.Items[i].MakeIndex = ci.MakeIndex then begin
        Result := mySelf.m_StallMgr.mBlock.Items[i];
        Exit;
      end;
    end;
  end;
end;

procedure TFrmDlg.DItemGridGridMouseMove(Sender: TObject; X, Y: integer; ACol, ARow: Integer; Shift: TShiftState);
var
  idx: integer;
  temp: TClientItem;
  iname, d0, d1, d2, d3, d4: string;
  useable: Boolean;
  hcolor, fcolor: TColor;
begin

//   if ssRight in Shift then begin
//      if ItemMoving then
//         DItemGridGridSelect (self, ACol, ARow, Shift);
//   end else begin
  idx := ACol + ARow * DItemGrid.ColCount + 6{骇飘傍埃};
  DScreen.ClearHint(true);
  if idx in [6..MAXBAGITEM - 1] then
  begin
     if (ItemArr[idx].S.Stock = 44) or (ItemArr[idx].s.Stock =45) then
     MouseItem :=dellStallItem(ItemArr[idx])
     else
     MouseItem := ItemArr[idx];
     if g_bo悬浮信息 then
    begin
         //GetMouseItemInfo (iname, d0, d1, d2, d3, useable);
      GetMouseItemInfo(iname, d0, d1, d2, d3, d4, useable, FALSE);
      if iname <> '' then
      begin
        if (MouseItem.UpgradeOpt > 0) and g_bo极品蓝字 then
          hcolor := TColor($cccc33)
        else
          hcolor := clWhite;
        if useable then
        begin
          //hcolor := clWhite;
          fcolor := hcolor;
        end
        else
        begin
          //hcolor := clWhite;
          fcolor := clRed;
        end;
        if d2 <> '' then
         d2 := d2 + '|' + IntToStr(hcolor) + '$';
        if d3 <> '' then
          d3 := d3 + '|' + IntToStr(fcolor);
        with DItemGrid do
          DScreen.ShowHint(SurfaceX(Left + ACol * ColWidth), SurfaceY(Top + (ARow + 1) * RowHeight), iname + '|' + IntToStr(clYellow) + '\' + d0 + '\' + d1 + '\' + d2 + d3, hcolor, FALSE);
      end;
      MouseItem.S.Name := '';
    end;
  end;
//   end;
end;

procedure TFrmDlg.DItemGridGridSelect(Sender: TObject; X, Y: integer; ACol, ARow: Integer; Shift: TShiftState);
var
  idx, mi, n: integer;
  temp: TClientItem;
  bCheck: Boolean;
  MsgResult, Count: integer;
  valstr: string;
begin
  bCheck := False;
  idx := ACol + ARow * DItemGrid.ColCount + 6{骇飘傍埃};
  if MySelf =nil  then  exit;

        if MySelf.m_StallMgr.OnSale then //
        begin
        //
        Exit;
        end;


  if (not ItemMoving) and (ItemArr[idx].s.Name <> '') then
  begin
    if ssRight in Shift then
    begin
      if (EatTime + 300 < GetTickCount) and (ItemArr[idx].s.StdMode < 4) then
      begin
        if (ItemArr[idx].s.StdMode = 3) and (ItemArr[idx].s.Shape in [1, 2, 3, 4, 5, 6, 9, 10, 11]) then

        else
        begin
          FrmMain.EatItem(idx);
          Exit;
        end
      end;
    end;
  end;

  if idx in [6..MAXBAGITEM - 1] then
  begin
    if not ItemMoving then
    begin
       if( ItemArr[idx].S.Stock = 44) or (ItemArr[idx].S.Stock =45 )then
        Exit;
      if ItemArr[idx].s.Name <> '' then
      begin
        bWindowsType := 2;
        ItemMoving := TRUE;
        MovingItem.Index := idx;
        MovingItem.Item := ItemArr[idx];
        ItemArr[idx].s.Name := '';
        ItemClickSound(ItemArr[idx].s);
      end;
    end
    else
    begin
      if not BoStorageMove or (bWindowsType <> 1) then
      begin
         //物品正在移动
         //ItemClickSound (MovingItem.Item.S.StdMode);
         mi := MovingItem.Index;
         if IsStallItem(mi) then //取回
          begin
          MovingItem.Item.S.Stock:=0;
          UpdateItemBag(MovingItem.Item);
          MovingItem.Item.S.Name:='';
          end;
      if (DMakeItemDlg.Visible) or (DDealDlg.Visible) then
      begin  // 2004/02/23 物品交换，制作，窗口中的物品移动到任何修改
        if (mi >= 0) and (mi < 6) then
        begin
          CancelItemMoving;
          if DMakeItemDlg.Visible then
            DMessageDlg('当事项的制作中,\展品不可以从一地转移到带窗前包窗口.', [mbOk])
          else if DDealDlg.Visible then
            DMessageDlg('在交换项目,\展品不可以从一地转移到带窗前包窗口.', [mbOk]);
          Exit;
        end;
      end;
      if (mi = -97) or (mi = -98) then
        exit; //捣...
         // 2003/03/15 酒捞袍 牢亥配府 犬厘
      if (mi < 0) and (mi >= -14) then
      begin  //-99: Sell窗口中....-9->-13
            //状态窗口中
        WaitingUseItem := MovingItem;
        FrmMain.SendTakeOffItem(-(MovingItem.Index + 1), MovingItem.Item.MakeIndex, MovingItem.Item.S.Name);
        MovingItem.Item.S.name := '';
        ItemMoving := FALSE;
      end
      else
      begin
        if (mi <= -20) and (mi > -30) then
        begin //交换窗口中
          DealItemReturnBag(MovingItem.Item); //send only
               //2004/01/06 物品数量有限 ，变形 --------
          if MovingItem.Item.S.OverlapItem > 0 then
          begin
            MovingItem.Item.S.name := '';
            ItemMoving := FALSE;
            Exit;
          end; //--------------------------------------------
        end;
        if ItemArr[idx].s.Name <> '' then
        begin

          if ssCtrl in Shift then
          begin //####
            if (MovingItem.Item.S.StdMode in [60, 61]) and (not ((MovingItem.Item.S.StdMode = 61) and (MovingItem.Item.S.Shape in [20, 21]))) then
            begin
              if mrOk = DMessageDlg(ItemArr[idx].s.Name + ' 使用 ' + MovingItem.Item.S.Name + ' 进行升级?', [mbOk, mbCancel]) then
                bCheck := True
              else
              begin
                CancelItemMoving;
                Exit;
              end;
            end
            else
              bCheck := True;
          end;

          if bCheck then
          begin
//               if ssCtrl in Shift then begin
            UpItemItem := ItemArr[idx];
            FrmMain.UpGradeItem(ItemArr[idx].MakeIndex, MovingItem.Item.MakeIndex, ItemArr[idx].s.Name, MovingItem.Item.S.Name);
            if AddItemBag(MovingItem.Item) then
            begin
              MovingItem.Item.S.name := '';
              ItemMoving := FALSE;
            end;
          end
          else
          begin
            if (ItemArr[idx].s.OverlapItem > 0) and (ItemArr[idx].s.Name = MovingItem.Item.S.Name) and (not DMakeItemDlg.Visible) then
            begin

              FrmMain.SendItemSumCount(ItemArr[idx].MakeIndex, MovingItem.Item.MakeIndex, ItemArr[idx].s.Name, MovingItem.Item.S.Name);

                     //2004/01/06 酒捞袍 俺荐 力茄 锭巩俊 官柴 -----------
              if (mi > 0) and (mi < 100) then
                CancelItemMoving
              else
              begin
                MovingItem.Item.S.Name := '';
                ItemMoving := FALSE;
              end; //-----------------------------------------------
            end
            else
            begin   //
               if (ItemArr[idx].s.Stock =44) or (ItemArr[idx].s.Stock =45) then
               Exit;
              temp := ItemArr[idx];
              ItemArr[idx] := MovingItem.Item;
              MovingItem.Index := idx;
              MovingItem.Item := temp
            end;
          end;
        end
        else
        begin
          ItemArr[idx] := MovingItem.Item;
          MovingItem.Item.S.name := '';
          ItemMoving := FALSE;
        end;
      end;
      end
      else
      begin
        if not BoStorageMove and (bWindowsType <> 1) then
          Exit;
        if MovingItem.Item.S.OverlapItem > 0 then
        begin
          Total := MovingItem.Item.Dura;
          if Total = 1 then
          begin
            DlgEditText := '1';
            MsgResult := mrOk;
          end
          else
            MsgResult := DCountMsgDlg('当前数量 ' + IntToStr(MovingItem.Item.Dura) + ' 个.\请输入你想购买的商品数量?', [mbAbort]);
          GetValidStrVal(DlgEditText, valstr, [' ']);
          Count := Str_ToInt(valstr, 0);

          if Count > MovingItem.Item.Dura then
            Count := MovingItem.Item.Dura;
          if (MsgResult = mrCancel) or (Count <= 0) then
          begin
            Count := 0;
            Exit;
          end;
          FrmMain.SendTakeBackStorageItem(CurMerchant, MovingItem.Item.MakeIndex, MovingItem.Item.S.Name, word(Count));
        end
        else
          FrmMain.SendTakeBackStorageItem(CurMerchant, MovingItem.Item.MakeIndex, MovingItem.Item.S.Name, word(Count));
        MovingItem.Item.S.name := '';
        ItemMoving := FALSE;
        bWindowsType := -1;
        exit;
      end;
    end;
  end;
  ArrangeItemBag;
end;
//装备穿戴效果

procedure TFrmDlg.DItemGridDblClick(Sender: TObject);
var
  idx, i, where: integer;
  keyvalue: TKeyBoardState;
  cu: TClientItem;
  TempSender: TObject;
begin
        if MySelf.m_StallMgr.OnSale then //
        begin
        //
        Exit;
        end;
  idx := DItemGrid.Col + DItemGrid.Row * DItemGrid.ColCount + 6;
  if idx in [6..MAXBAGITEM - 1] then
  begin
    if ItemArr[idx].s.Name <> '' then
    begin
         {FillChar(keyvalue, sizeof(TKeyboardState), #0);
         GetKeyboardState (keyvalue);
         if keyvalue[VK_CONTROL] = $80 then begin
            //移到其他情况下, 请找到合适的位置
            cu := ItemArr[idx];
            ItemArr[idx].S.Name := '';
            AddItemBag (cu);
         end else
            if (ItemArr[idx].S.StdMode <= 4) or (ItemArr[idx].S.StdMode = 31) then begin //可使用的道具
               FrmMain.EatItem (idx);
            end; }
    end
    else
    begin
      if ItemMoving and (MovingItem.Item.S.Name <> '') then
      begin
        FillChar(keyvalue, sizeof(TKeyboardState), #0);
        GetKeyboardState(keyvalue);
        if keyvalue[VK_CONTROL] = $80 then
        begin
               //骇飘芒栏肺 颗辫
          cu := MovingItem.Item;
          MovingItem.Item.S.Name := '';
          ItemMoving := FALSE;
          AddItemBag(cu);
        end
        else if (MovingItem.Index = idx) and (MovingItem.Item.S.StdMode <= 4) or (ItemArr[idx].s.StdMode in [7,8,31,66,70,88]) then        //物品双击使用
        begin
          FrmMain.EatItem(-1);
        end
//歹喉努腐栏肺 酒捞袍馒侩 2006/03/22----------------------------------------
        else
        begin
          where := GetTakeOnPosition(MovingItem.Item.S.StdMode);
          if not g_bosjcd then Exit;
          if MovingItem.Index >= 0 then
          begin
            case where of
              U_DRESS:
                TempSender := DSWDress;
              U_WEAPON:
                TempSender := DSWWEAPON;
              U_NECKLACE:
                TempSender := DSWNecklace;
              U_RIGHTHAND:
                TempSender := DSWLight;
              U_HELMET:
                TempSender := DSWHelmet;
              U_RINGL:
                begin
                  if UseItems[U_RINGR].s.Name = '' then
                    TempSender := DSWRingR
                  else
                    TempSender := DSWRingL;
                end;
              U_ARMRINGR:
                begin
                  if UseItems[U_ARMRINGR].s.Name = '' then
                    TempSender := DSWArmRingR
                  else
                    TempSender := DSWArmRingL;
                end;
              U_BUJUK:
                begin
                  if (g_bo人物四格) and ( not g_bochksigedu)   then
                  begin
                    if MovingItem.Item.S.Shape in[1,2,5,6] then    begin
                      TempSender := DSWBujuk
                   end else
                   TempSender := DSWArmRingL
//                      TempSender := DSWCharm
                  end
                  else



             //       TempSender := DSWArmRingL;
                   // end;
                 if g_bochksigedu and g_bo人物四格 then
                  begin
                    if MovingItem.Item.S.Shape =5 then
                      TempSender := DSWBujuk
                    else
                      TempSender := DSWCharm
                  end
                  else
                    TempSender := DSWArmRingL

                end;
              U_BELT:
                if g_bo人物四格 then
                  TempSender := DSWBelt;
              U_BOOTS:
                if g_bo人物四格 then
                  TempSender := DSWBoots;
              U_CHARM:
                TempSender := DSWCharm;
              U_TRANS:
                TempSender := ButTrans;
            end;
          end;
          DSWWeaponClick(TempSender, 1, 1);
        end;
//------------------------------------------------------------------------------
      end;
    end;
  end;
end;

procedure TFrmDlg.UpgradeItemEffect(wResult: word);
begin
  UpItemOffset := UPITEMSUCCESSOFFSET;
  UpItemMaxFrame := 8;

  BoUpItemEffect := TRUE;
  CurUpItemEffect := 0;
end;

procedure TFrmDlg.DItemGridGridPaint(Sender: TObject; ACol, ARow: Integer; Rect: TRect; State: TGridDrawState; dsurface: TAsphyreCanvas);
var
 sd, d: TAsphyreLockableTexture;
  idx, ax, ay: integer;

    FSize: TPoint;
  rc:Trect;
begin


  idx := ACol + ARow * DItemGrid.ColCount + 6;
  if idx in [6..MAXBAGITEM - 1] then
  begin
    if ItemArr[idx].s.Name <> '' then
    begin
      d := WBagItem.Images[ItemArr[idx].s.Looks];
      if (ItemArr[idx].s.OverlapItem < 1) or ((ItemArr[idx].s.OverlapItem > 0) and (ItemArr[idx].dura > 0)) then
      begin
        if d <> nil then
        begin
          with DItemGrid do
          begin
            dsurface.Draw(SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1), SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1), d.ClientRect, d, TRUE);


            //摆摊挡板色
            if ItemArr[idx].s.Stock in [44,45] then begin
              rc.Left:=  SurfaceX(Rect.Left + (ColWidth - 36) div 2);
              rc.Top:=  SurfaceY(Rect.Top + (RowHeight - 28) div 2);
              rc.Right:=  rc.Left + 33;
              rc.Bottom:=  rc.Top + 30;
              if Myself.m_StallMgr.OnSale then
                 begin
                    dsurface.FillRectAlpha(rc,$0000FF,50);
                 end
                 else
                 begin
                    dsurface.FillRectAlpha(rc,$00FF00,40);
                 end;
            end;
          end;
        end;


        if ItemArr[idx].s.OverlapItem > 0 then
        begin
               //SetBkMode (g_DXCanvas.Handle, TRANSPARENT);
//               g_DXCanvas.Font.Color := clYellow;

          dsurface.TextOut(DItemGrid.SurfaceX(Rect.Left + 20), DItemGrid.SurfaceY(Rect.Top + 20), clYellow, IntToStr(ItemArr[idx].dura));
//               g_DXCanvas.//Release;
        end;
      end;
    end;
  end;

  if BoUpItemEffect then
  begin  // 酒捞袍 诀弊饭捞靛 瓤苞
    if GetTickCount - upeffecttime > 120 then
    begin
      upeffecttime := GetTickCount;
      Inc(CurUpItemEffect);
      if CurUpItemEffect >= UpItemMaxFrame then
      begin
        FrmMain.DelitemProg;
        BoUpItemEffect := FALSE;
        UpItemItem.S.Name := '';
      end;
    end;
  end;

  if BoUpItemEffect then
  begin

    d := WMagic2.GetCachedImage(UpItemOffset + CurUpItemEffect, ax, ay);

    if d <> nil then
      if idx in [6..MAXBAGITEM - 1] then
        if (UpItemItem.MakeIndex = ItemArr[idx].MakeIndex) and (Trim(UpItemItem.S.Name) = Trim(ItemArr[idx].s.Name)) then
          dsurface.DrawBlend(DItemGrid.SurfaceX(Rect.Left) - 9 + ax, DItemGrid.SurfaceY(Rect.Top) + 41 + ay, d, 1);
  end;
end;

procedure TFrmDlg.DGoldClick(Sender: TObject; X, Y: Integer);
begin
  if Myself = nil then
    exit;
  if not ItemMoving then
  begin
    if Myself.Gold > 0 then
    begin
      PlaySound(s_money);
      ItemMoving := TRUE;
      MovingItem.Index := -98; //捣
      MovingItem.Item.S.Name := '金币';
    end;
  end
  else
  begin
    if (MovingItem.Index = -97) or (MovingItem.Index = -98) then
    begin //捣父..
      ItemMoving := FALSE;
      MovingItem.Item.S.Name := '';
      if MovingItem.Index = -97 then
      begin //交换到窗口中
        DealZeroGold;
      end;
    end;
  end;
  ;
end;






{------------------------------------------------------------------------}

//商人对话窗口

{------------------------------------------------------------------------}

procedure TFrmDlg.ShowMDlg(face: integer; mname, msgstr: string);
var
  i: integer;
begin
  DMerchantDlg.Left := 0;  //默认位置
  DMerchantDlg.Top := 0;
  MerchantFace := face;
  MerchantName := mname;
  MDlgStr := msgstr;
  DMerchantDlg.Visible := TRUE;
  if not g_bo物品窗口 then
  begin
  DItemBag.Left := 440;  //包的偏移  这两句不用改了   就是你默认包裹的坐标
  DItemBag.Top := 0;
  end else
  begin //==============
  DItemBag.Left := 440;  //包的偏移   改这两句就是你换图片要改的坐标
  DItemBag.Top := 0;
  end;
  for i := 0 to MDlgPoints.Count - 1 do
    Dispose(PTClickPoint(MDlgPoints[i]));
  MDlgPoints.Clear;
  RequireAddPoints := TRUE;
  LastestClickTime := GetTickCount;
end;

procedure TFrmDlg.RefuseCRYClick(Sender: TObject; X, Y: Integer);
begin
   if g_RefuseCRY then begin
    g_RefuseCRY := false;
    FrmMain.SendSay('@拒绝喊话1', 1);
    DScreen.AddChatBoardString('拒绝接收(黄颜色字体)喊话', RGB(0, 130, 0), RGB(33, 33, 33));
  end
  else begin
    g_RefuseCRY := true;
    FrmMain.SendSay('@允许喊话1', 1);
    DScreen.AddChatBoardString('允许接收(黄颜色字体)喊话', RGB(0, 130, 0), clWhite);
  end;
end;

procedure TFrmDlg.RefuseguildClick(Sender: TObject; X, Y: Integer);
begin
  if g_Refuseguild then begin
    g_Refuseguild := false;
    FrmMain.SendSay('@拒绝行会聊天1', 1);
    DScreen.AddChatBoardString('拒绝接收行会喊话信息 ', RGB(0, 130, 0), RGB(33, 33, 33));
  end
  else begin
    g_Refuseguild := true;
    FrmMain.SendSay('@允许行会聊天1', 1);
    DScreen.AddChatBoardString('允许接收行会喊话信息 ', RGB(0, 130, 0), clWhite);
  end;
end;

procedure TFrmDlg.RefusePublicChatClick(Sender: TObject; X, Y: Integer);
begin
  if g_boOwnerMsg then begin
    g_boOwnerMsg := false;
//    BoHearCry := not BoHearCry;
     DScreen.AddChatBoardString('拒绝接收公聊信息', RGB(0, 130, 0), RGB(33, 33, 33));
  end
  else begin
    g_boOwnerMsg := true;
    DScreen.AddChatBoardString('允许接收公聊信息', RGB(0, 130, 0), clWhite);
  end;
end;

procedure TFrmDlg.RefusePublicChatDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  boClick: Boolean;
begin
  boClick := False;
  if Sender = RefuseCRY then begin
    boClick := not g_RefuseCRY;
  end else
  if Sender = RefuseWHISPER then begin
    boClick := not g_RefuseWHISPER;
  end else
  if Sender = Refuseguild then begin
    boClick := not g_Refuseguild;
  end else
  if Sender = AutoCRY then begin
    boClick := not g_boAutoTalk;
  end else
  if Sender = RefusePublicChat then begin
    boClick := not g_boOwnerMsg;
  end;
  with Sender as TDButton do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex + Integer(boClick)];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    end;
  end;
end;

procedure TFrmDlg.RefusePublicChatMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var
  nLocalY:Integer;
  nHintX,nHintY:Integer;
  Butt:TDButton;
  sMsg:String;
  Int: Integer;
begin
  if MySelf = nil then Exit;
  Butt:=TDButton(Sender);
  if Sender = RefusePublicChat then sMsg:= '拒绝所有公聊信息';
  if Sender = RefuseCRY then sMsg:= '拒绝所有喊话信息';
  if Sender = RefuseWHISPER then sMsg:= '拒绝所有私聊信息';
  if Sender = Refuseguild then sMsg:= '拒绝行会聊天信息';
  if Sender = AutoCRY then sMsg:= '自动喊话开关';

  if pos('\',sMsg) > 0 then
    nLocalY := 12
  else nLocalY := 0;

  with Butt as TDButton do
   DScreen.ShowHint(Butt.SurfaceX(Butt.Left), Butt.SurfaceY(Butt.Top - 20 -nLocalY ), sMsg, clYellow , FALSE); //clWhite
end;

procedure TFrmDlg.RefuseWHISPERClick(Sender: TObject; X, Y: Integer);
begin
  if g_RefuseWHISPER then begin
    g_RefuseWHISPER := false;
    FrmMain.SendSay('@拒绝私聊1', 1);
    DScreen.AddChatBoardString('拒绝接收私聊信息', RGB(0, 130, 0), RGB(33, 33, 33));
  end
  else begin
    g_RefuseWHISPER := true;
    FrmMain.SendSay('@允许私聊1', 1);
    DScreen.AddChatBoardString('允许接收私聊信息', RGB(0, 130, 0),clWhite );
  end;
end;

procedure TFrmDlg.ResetMenuDlg;
var
  i: integer;
begin
  CloseDSellDlg;
  for i := 0 to MenuItemList.Count - 1 do  //菜单也清晰的细节
    Dispose(PTClientItem(MenuItemList[i]));
  MenuItemList.Clear;

  for i := 0 to MenuList.Count - 1 do
    Dispose(PTClientGoods(MenuList[i]));
  MenuList.Clear;

  for i := 0 to JangwonList.Count - 1 do
    Dispose(PTClientJangwon(JangwonList[i]));
  JangwonList.Clear;

  for i := 0 to GABoardList.Count - 1 do
    Dispose(PTClientGABoard(GABoardList[i]));
  GABoardList.Clear;

   //CurDetailItem := '';
  MenuIndex := -1;
  MenuTopLine := 0;
  BoStorageMove := False;
  BoDetailMenu := FALSE;
  BoStorageMenu := FALSE;
  BoMakeDrugMenu := FALSE;
  BoMakeItemMenu := FALSE;
  NameMakeItem := '';

  DSellDlg.Visible := FALSE;
  DMenuDlg.Visible := FALSE;
  DWindowSaveItem.Visible := False;
end;

procedure TFrmDlg.ShowShopMenuDlg(bStorageType: Byte);
begin
  MenuIndex := -1;

  DMerchantDlg.Left := 0;  //默认位置
  DMerchantDlg.Top := 0;
  DMerchantDlg.Visible := TRUE;

  DSellDlg.Visible := FALSE;

  DMenuDlg.Left := 0;
  DMenuDlg.Top := 176;
  DMenuDlg.Visible := bStorageType = 0;
  DWindowSaveItem.Visible := bStorageType = 255;
  BoStorageMove := bStorageType = 255;
  MenuTop := 0;
  if not g_bo物品窗口 then
  begin
  DItemBag.Left := 440; //这个跟上面那个一样
  DItemBag.Top := 0;
  end else begin  //==============
  DItemBag.Left := 440; //改这里
  DItemBag.Top := 0;
  end;
  DItemBag.Visible := TRUE;

  LastestClickTime := GetTickCount;
end;

procedure TFrmDlg.ShowItemMarketDlg; //2004/01/15 ItemMarket..
var
  i: integer;
begin

  DSellDlg.Visible := FALSE;
  BoInRect := False;

  if not DItemBag.Visible then
  begin
    DItemBag.Left := 440;
    DItemBag.Top := 0;
    DItemBag.Visible := TRUE;
  end;
  if not DItemMarketDlg.Visible then
  begin
    DItemMarketDlg.Left := 0; //10;
    DItemMarketDlg.Top := 90; //20;
    DItemMarketDlg.Visible := TRUE;
  end;

  if g_Market.GetFirst = 1 then
  begin
    MenuTop := 0;
    MenuIndex := -1;
  end;

//   HideAllControls;
//   DItemMarketDlg.ShowModal;
  DItemMarketDlg.Show;

  with ItemSearchEdit do
  begin
    Text := '';
    Width := 132;
    Left := DItemMarketDlg.Left + 13;
    Top := DItemMarketDlg.Top + 328;
  end;

  if g_Market.GetUserMode = 1 then
  begin
    DItemBuy.Visible := True;
    DItemSellCancel.Visible := False;
    DItemFind.Visible := True;
    DItemMarketDlg.EnableFocus := True;
    ItemSearchEdit.Visible := TRUE;
    ItemSearchEdit.SetFocus;
    DlgEditText := ItemSearchEdit.Text;
  end
  else if g_Market.GetUserMode = 2 then
  begin
    DItemBuy.Visible := False;
    DItemSellCancel.Visible := True;
    DItemFind.Visible := False;
    ItemSearchEdit.Visible := False;
  end;
  DItemCancel.Visible := True;

//  SetImeMode(PlayScene.EdChat.Handle, imSHanguel); //@@@@
//   RestoreHideControls;
  if FrmDlg.DEdChat.Visible then
    FrmDlg.DEdChat.SetFocus;

  LastestClickTime := GetTickCount;

end;

procedure TFrmDlg.ShowJangwonDlg; //2004/01/15 ItemMarket..
var
  i: integer;
begin

  BoMemoJangwon := False;
  DSellDlg.Visible := FALSE;

  if not DJangwonListDlg.Visible then
  begin
    DJangwonListDlg.Left := 0; //10;
    DJangwonListDlg.Top := 175; //20;
    DJangwonListDlg.Visible := TRUE;
  end;

  MenuIndex := -1;
  DJangwonListDlg.Show;
  LastestClickTime := GetTickCount;

end;

procedure TFrmDlg.ShowGADecorateDlg; //2004/06/18 庄园装饰
var
  i: integer;
begin

  if not DItemBag.Visible then
  begin
    DItemBag.Left := 440;
    DItemBag.Top := 0;
//      DItemBag.Visible := TRUE;
  end;
  if not DGADecorateDlg.Visible then
  begin
    DGADecorateDlg.Left := 0; //10;
    DGADecorateDlg.Top := 55; //90;//20;
    DGADecorateDlg.Visible := TRUE;
  end;

  MenuTop := 0;
  MenuIndex := 0;

  DGADecorateDlg.Show;
  LastestClickTime := GetTickCount;

end;

procedure TFrmDlg.ShowGABoardListDlg;
var
  i: integer;
begin

//   BoMemoJangwon := False;
  DSellDlg.Visible := FALSE;
  GABoard_BoWrite := 0;
  GABoard_BoNotice := 1;

  if not DGABoardListDlg.Visible then
  begin
    DGABoardListDlg.Left := 0; //10;
    DGABoardListDlg.Top := 175; //20;
    DGABoardListDlg.Visible := TRUE;
  end;

  MenuIndex := -1;
  DGABoardListDlg.Show;
  LastestClickTime := GetTickCount;

end;

procedure TFrmDlg.ShowGABoardReadDlg;
var
  d: TAsphyreLockableTexture;
  i: integer;
  data: string;
begin
  with DGABoardDlg do
  begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
    begin
      Left := 240;
      Top := 175;
    end;

    DGABoardDlg.ShowModal;
    if (GABoard_BoReply = 1) or (GABoard_BoWrite = 1) then
    begin
      DGABoardReply.Visible := False;
      DGABoardDel.Visible := False;
      DGABoardMemo.Visible := False;
    end
    else
    begin
      DGABoardReply.Visible := True;
      DGABoardDel.Visible := True;
      DGABoardMemo.Visible := True;
    end;
    DGABoardOk2.Visible := True;

    if Memo.ReadOnly then
    begin
      DGABoardDel.Visible := False;
    end;

    Memo.Left := SurfaceX(Left + 11);
    Memo.Top := SurfaceY(Top + 37);
    Memo.Width := d.Width - 22;
    Memo.Height := 142;
    Memo.Lines.Assign(GABoard_Notice);
    Memo.Visible := TRUE;
  end;

end;

procedure TFrmDlg.CloseItemMarketDlg;
begin
  DItemMarketCloseClick(DItemMarketClose, 0, 0);
end;

procedure TFrmDlg.ShowShopSellDlg;
begin
  SellStHold := False;
  DSellDlg.Left := 260;
  DSellDlg.Top := 176;
  DSellDlg.Visible := TRUE;

  DMenuDlg.Visible := FALSE;
  DWindowSaveItem.Visible := FALSE;

  if not g_bo物品窗口 then
  begin
  DItemBag.Left := 440;   //这里也是该位置
  DItemBag.Top := 0;
  end
  else begin  //==============
  DItemBag.Left := 440; //改这里
  DItemBag.Top := 0;
  end;
  DItemBag.Visible := TRUE;

  LastestClickTime := GetTickCount;
  SellPriceStr := '';
end;

procedure TFrmDlg.CloseMDlg;
var
  i: integer;
begin
  MDlgStr := '';
  DMerchantDlg.Visible := FALSE;
  for i := 0 to MDlgPoints.Count - 1 do
    Dispose(PTClickPoint(MDlgPoints[i]));
  MDlgPoints.Clear;
   //倡导关闭菜单
  if not g_bo物品窗口 then
  begin
  DItemBag.Left := 0;  //@@@@   这里也是该位置
  DItemBag.Top := 0;
  end else begin  //==============
  DItemBag.Left := 0;  //@@@@     改这里
  DItemBag.Top := 0;
  end;
  DMenuDlg.Visible := FALSE;
  DWindowSaveItem.Visible := FALSE;
  CloseDSellDlg;
end;

procedure TFrmDlg.CloseMDlg2;
var
  i: integer;
begin
  MDlgStr := '';
  DMerchantDlg.Visible := FALSE;
  for i := 0 to MDlgPoints.Count - 1 do
    Dispose(PTClickPoint(MDlgPoints[i]));
  MDlgPoints.Clear;

  DMenuDlg.Visible := FALSE;
  DWindowSaveItem.Visible := FALSE;
  CloseDSellDlg;
end;

procedure TFrmDlg.CloseDSellDlg;
begin
  DSellDlg.Visible := FALSE;
  if SellDlgItem.S.Name <> '' then
    AddItemBag(SellDlgItem);
  SellDlgItem.S.Name := '';
end;

//NPC脚本文字{功能}显示位置
(*
procedure TFrmDlg.DMerchantDlgDirectPaint(Sender: TObject; dsurface: TDXTexture);
var
  d: TDXTexture;
  str, data, fdata, cmdstr, cmdmsg, cmdparam: string;
  lx, ly, sx: integer;
  drawcenter: Boolean;
  pcp: PTClickPoint;
begin
  with Sender as TDWindow do
  begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
      //SetBkMode (g_DXCanvas.Handle, TRANSPARENT); //设置透明
    lx := 30;
    ly := 20;
    str := MDlgStr;
    drawcenter := FALSE;
    while TRUE do
    begin
      if str = '' then
        break;
      str := GetValidStr3(str, data, [char($a)]);
      if data <> '' then
      begin
        sx := 0;
        fdata := '';
        while (pos('<', data) > 0) and (pos('>', data) > 0) and (data <> '') do
        begin
          if data[1] <> '<' then
          begin
            data := '<' + GetValidStr3(data, fdata, ['<']);
          end;
          data := ArrestStringEx(data, '<', '>', cmdstr);

               //fdata + cmdstr + data
          if cmdstr <> '' then
          begin
            if Uppercase(cmdstr) = 'C' then
            begin
              drawcenter := TRUE;
              continue;
            end;
            if UpperCase(cmdstr) = '/C' then
            begin
              drawcenter := FALSE;
              continue;
            end;
            cmdparam := GetValidStr3(cmdstr, cmdstr, ['/']); //cmdparam : 命令参数
          end
          else
          begin
            DMenuDlg.Visible := FALSE;
            DSellDlg.Visible := FALSE;
          end;

          if fdata <> '' then
          begin
            g_ImageDraw.TextOut(SurfaceX(Left + lx + sx), SurfaceY(Top + ly), clWhite, {clBlack,} fdata);
            sx := sx + g_DXCanvas.TextWidth(fdata);
          end;
          if cmdstr <> '' then
          begin
            if RequireAddPoints then
            begin //茄锅父...
              new(pcp);
              pcp.rc := Rect(lx + sx, ly, lx + sx + g_DXCanvas.TextWidth(cmdstr), ly + 14);
              pcp.RStr := cmdparam;
              MDlgPoints.Add(pcp);
            end;
            if SelectMenuStr = cmdparam then
            begin
              g_ImageDraw.TextOut(SurfaceX(Left + lx + sx), SurfaceY(Top + ly), clRed, cmdstr);
              g_DXCanvas.MoveTo(SurfaceX(Left + lx + sx), SurfaceY(Top + ly) + g_DXCanvas.TextHeight(cmdstr) + 2);
              g_DXCanvas.LineTo(SurfaceX(Left + lx + sx) + g_DXCanvas.TextWidth(cmdstr) - 1, SurfaceY(Top + ly) + g_DXCanvas.TextHeight(cmdstr) + 2, clRed);
            end
            else
            begin
              g_ImageDraw.TextOut(SurfaceX(Left + lx + sx), SurfaceY(Top + ly), clYellow, cmdstr);
              g_DXCanvas.MoveTo(SurfaceX(Left + lx + sx), SurfaceY(Top + ly) + g_DXCanvas.TextHeight(cmdstr) + 2);
              g_DXCanvas.LineTo(SurfaceX(Left + lx + sx) + g_DXCanvas.TextWidth(cmdstr) - 1, SurfaceY(Top + ly) + g_DXCanvas.TextHeight(cmdstr) + 2, clYellow);
            end;

            sx := sx + g_DXCanvas.TextWidth(cmdstr);
//                  g_DXCanvas.Font.Style := g_DXCanvas.Font.Style - [fsUnderline];
          end;
        end;
        if data <> '' then
          g_ImageDraw.TextOut(SurfaceX(Left + lx + sx), SurfaceY(Top + ly), clWhite, {clBlack,} data);
      end;
      ly := ly + 16;
    end;
//      g_DXCanvas.//Release;
    RequireAddPoints := FALSE;
  end;

end;  *)
procedure TFrmDlg.DMerchantDlgDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d, ATexture: TAsphyreLockableTexture;
  Str, data, FData, fdata2: string;
  cmdstr, cmdmsg, cmdparam: string;
  i, j, k, lx, ly, sX, L: Integer;
  pcp: pTClickPoint;
  cl: TColor;
  scl: string;
  DestRect: TRect;
begin
  with Sender as TDWindow do begin
    Left := 0;
    Top := 0;
    d := WLib.Images[FaceIndex];
    if d <> nil then begin
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    end;

    lx := 30;
    ly := 20;
    Str := MDlgStr;

    L := 0;
    while True do begin
      if Str = '' then Break;
      Str := GetValidStr3(Str, data, ['\', char($a)]);
      if data <> '' then begin
        sX := 0;
        //fdata := '';
        while (data <> '') and (Pos('<', data) > 0) and (Pos('>', data) > 0) do begin
          FData := '';
          if data[1] <> '<' then
            data := '<' + GetValidStr3(data, FData, ['<']);
          data := ArrestStringEx(data, '<', '>', cmdstr);

          fdata2 := '';

          if cmdstr <> '' then begin
            j := Pos('COLOR=', UpperCase(cmdstr));
            if j > 0 then begin
              fdata2 := GetValidStr3(cmdstr, scl, [' ', #9, ',']);
              scl := Copy(scl, 7, Length(scl) - 6);
              cl := clWhite;
              if scl <> '' then begin
                if scl[1] = '#' then begin
                  cl := StrToInt(Copy(scl, 2, Length(scl) - 1));
                end else begin
                  if CompareText('clLtGray', scl) = 0 then
                    cl := clLtGray
                  else if CompareText('clDkGray', scl) = 0 then
                    cl := clDkGray
                  else
                    cl := StringToColor(scl);
                end
              end;
              cmdstr := '';
            end else
              cmdparam := GetValidStr3(cmdstr, cmdstr, ['/']);
          end else begin
            DMenuDlg.Visible := False;
            DWindowSaveItem.Visible := FALSE;
            DSellDlg.Visible := False;
          end;

          if FData <> '' then begin
            dsurface.BoldTextOut(SurfaceX(Left + lx + sX), SurfaceY(Top + ly), clWhite, clBlack, FData);
            sX := sX + FontManager.Default.TextWidth(FData);
          end;
          if fdata2 <> '' then begin
            dsurface.BoldTextOut(SurfaceX(Left + lx + sX), SurfaceY(Top + ly), cl, clBlack, fdata2);
            sX := sX + FontManager.Default.TextWidth(fdata2);
          end;

          if cmdstr <> '' then begin
            if RequireAddPoints then begin
              New(pcp);
              pcp.rc := Rect(lx + sX, ly, lx + sX + FontManager.Default.TextWidth(cmdstr), ly + 14);
              pcp.rstr := cmdparam;
              MDlgPoints.Add(pcp);
            end;
            ATexture := FontManager.GetFont('宋体', 9, [fsUnderline]).TextOut(cmdstr);
            if SelectMenuStr = cmdparam then
              dsurface.DrawBoldText(SurfaceX(Left + lx + sX), SurfaceY(Top + ly), ATexture, clRed, clBlack)
            else
              dsurface.DrawBoldText(SurfaceX(Left + lx + sX), SurfaceY(Top + ly), ATexture, clYellow, clBlack);
            sX := sX + FontManager.Default.TextWidth(cmdstr);
          end;
        end;
        if data <> '' then
          dsurface.BoldTextOut( SurfaceX(Left + lx + sX), SurfaceY(Top + ly), clWhite, clBlack, data);
      end;
      ly := ly + 16;
    end;
    RequireAddPoints := False;
  end;
end;

procedure TFrmDlg.DMerchantDlgCloseClick(Sender: TObject; X, Y: Integer);
begin
  CloseMDlg;
end;

procedure TFrmDlg.DMenuDlgDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);

  function sx(x: integer): integer;
  begin
    Result := DMenuDlg.SurfaceX(DMenuDlg.Left + x);
  end;

  function sy(y: integer): integer;
  begin
    Result := DMenuDlg.SurfaceY(DMenuDlg.Top + y);
  end;

var
  i, lh, k, m, menuline: integer;
  d: TAsphyreLockableTexture;
  pg: PTClientGoods;
  str: string;
  FColor: TColor;
begin
  with dsurface do
  begin
    with DMenuDlg do
    begin
      d := DMenuDlg.WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
    end;

      //SetBkMode (g_DXCanvas.Handle, TRANSPARENT);
      //SetBkMode (Handle, TRANSPARENT);
      //title
    FColor := clWhite;
    if not BoStorageMenu then
    begin
      TextOut(sx(19), sy(11), FColor, '物品列表');
      TextOut(sx(156), sy(11), FColor, '价格');
      if not BoMakeItemMenu then
        TextOut(sx(245), sy(11), FColor, '持久');
      lh := LISTLINEHEIGHT;
      menuline := _MIN(MAXMENU, MenuList.Count - MenuTop);
         //产品清单
      for i := MenuTop to MenuTop + menuline - 1 do
      begin
        m := i - MenuTop;
        if i = MenuIndex then
        begin
          FColor := clRed;
          TextOut(sx(12), sy(32 + m * lh), FColor, char(7));
        end
        else
          FColor := clWhite;
        pg := PTClientGoods(MenuList[i]);
        TextOut(sx(19), sy(32 + m * lh), FColor, pg.Name);
        if (pg.SubMenu >= 1) and (pg.SubMenu <> 2) then
          TextOut(sx(137), sy(32 + m * lh), FColor, #31);
        TextOut(sx(156), sy(32 + m * lh), FColor, IntToStr(pg.Price) + '金币');
        str := '';
        if pg.Grade = -1 then
          str := '-'
        else
          TextOut(sx(245), sy(32 + m * lh), FColor, IntToStr(pg.Grade));
            {else for k:=0 to pg.Grade-1 do
               str := str + '*';
            if Length(str) >= 4 then begin
               Font.Color := clYellow;
               TextOut (SX(245), SY(32 + m*lh), str);
            end else
               TextOut (SX(245), SY(32 + m*lh), str);}
      end;
    end
    else
    begin
      TextOut(sx(19), sy(11), FColor, '托管物品列表(' + IntToStr(MenuList.Count) + '/80件)');     //仓库设置显示存的总数
      TextOut(sx(156), sy(11), FColor, '持久');
      TextOut(sx(245), sy(11), FColor, '');
      lh := LISTLINEHEIGHT;
      menuline := _MIN(MAXMENU, MenuList.Count - MenuTop);
         //产品清单
      for i := MenuTop to MenuTop + menuline - 1 do
      begin
        m := i - MenuTop;
        if i = MenuIndex then
        begin
          FColor := clRed;
          TextOut(sx(12), sy(32 + m * lh), FColor, char(7));
        end
        else
          FColor := clWhite;
        pg := PTClientGoods(MenuList[i]);
        TextOut(sx(19), sy(32 + m * lh), FColor, pg.Name);
        if (pg.SubMenu >= 1) and (pg.SubMenu <> 2) then
          TextOut(sx(137), sy(32 + m * lh), FColor, #31);
        TextOut(sx(156), sy(32 + m * lh), FColor, IntToStr(pg.Stock) + '/' + IntToStr(pg.Grade));
      end;
    end;
      //TextOut (0, 0, IntToStr(MenuTopLine));

      //Release;
  end;
end;

procedure TFrmDlg.DMenuDlgInRealArea(Sender: TObject; X, Y: Integer;
  var IsRealArea: Boolean);
var
  d: TAsphyreLockableTexture;
begin
  d := WProgUse.Images[385];
  if d <> nil then
  begin
    if d.Pixels[X, Y] > 0 then
      IsRealArea := TRUE
    else
      IsRealArea := FALSE;
  end;
end;

{
procedure TFrmDlg.DMenuDlgDirectPaint(Sender: TObject;
  dsurface: TDXTexture);
  function SX(x: integer): integer;
  begin
      Result := DMenuDlg.SurfaceX (DMenuDlg.Left + x);
  end;
  function SY(y: integer): integer;
  begin
      Result := DMenuDlg.SurfaceY (DMenuDlg.Top + y);
  end;
var
   i, lh, k, m, menuline: integer;
   d: TDXTexture;
   pg: PTClientGoods;
   str: string;
begin
   with  g_DXCanvas do begin
      with DMenuDlg do begin
         d := DMenuDlg.WLib.Images[FaceIndex];
         if d <> nil then
            dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
      end;

      //SetBkMode (g_DXCanvas.Handle, TRANSPARENT);
      //SetBkMode (Handle, TRANSPARENT);
      //title
      Font.Color := clWhite;
      if not BoStorageMenu then begin
         TextOut (SX(19),  SY(11), '物品列表');
         TextOut (SX(156), SY(11), '价格');
         if not BoMakeItemMenu then
            TextOut (SX(245), SY(11), '持久');
         lh := LISTLINEHEIGHT;
         menuline := _MIN(MAXMENU, MenuList.Count-MenuTop);
         //惑前 府胶飘
         for i:=MenuTop to MenuTop+menuline-1 do begin
            m := i-MenuTop;
            if i = MenuIndex then begin
               Font.Color := clRed;
               TextOut (SX(12),  SY(32 + m*lh), char(7));
            end else Font.Color := clWhite;
            pg := PTClientGoods (MenuList[i]);
            TextOut (SX(19),  SY(32 + m*lh), pg.Name);
            if (pg.SubMenu >= 1) and (pg.SubMenu <> 2) then
               TextOut (SX(137), SY(32 + m*lh), #31);
            TextOut (SX(156), SY(32 + m*lh), IntToStr(pg.Price) + '金币');
            str := '';
            if pg.Grade = -1 then str := '-'
            else TextOut (SX(245), SY(32 + m*lh), IntToStr(pg.Grade));
         end;
      end else begin
         TextOut (SX(19),  SY(11), '托管物品列表');
         TextOut (SX(156), SY(11), '持久');
         TextOut (SX(245), SY(11), '');
         lh := LISTLINEHEIGHT;
         menuline := _MIN(MAXMENU, MenuList.Count-MenuTop);
         //产品清单
         for i:=MenuTop to MenuTop+menuline-1 do begin
            m := i-MenuTop;
            if i = MenuIndex then begin
               Font.Color := clRed;
               TextOut (SX(12),  SY(32 + m*lh), char(7));
            end else Font.Color := clWhite;
            pg := PTClientGoods (MenuList[i]);
            TextOut (SX(19),  SY(32 + m*lh), pg.Name);
            if (pg.SubMenu >= 1) and (pg.SubMenu <> 2) then
               TextOut (SX(137), SY(32 + m*lh), #31);
            TextOut (SX(156), SY(32 + m*lh), IntToStr(pg.Stock) + '/' + IntToStr(pg.Grade));
         end;
      end;
      //TextOut (0, 0, IntToStr(MenuTopLine));

      //Release;
   end;
end;}

procedure TFrmDlg.DMenuDlgClick(Sender: TObject; X, Y: Integer);
var
  lx, ly, idx: integer;
  iname, d1, d2, d3, d4, d5: string;
  useable: Boolean;
begin
  DScreen.ClearHint(True);
  lx := DMenuDlg.LocalX(X) - DMenuDlg.Left;
  ly := DMenuDlg.LocalY(Y) - DMenuDlg.Top;
  if (lx >= 14) and (lx <= 279) and (ly >= 32) and (ly <= 158) then
  begin
    idx := (ly - 32) div LISTLINEHEIGHT + MenuTop;
    if idx < MenuList.Count then
    begin
      PlaySound(s_glass_button_click);
      MenuIndex := idx;
      if DMakeItemDlg.Visible then
        DMakeItemDlgOkClick(DMakeItemDlgCancel, 0, 0);
    end;
  end;

  if BoStorageMenu then
  begin
    if (MenuIndex >= 0) and (MenuIndex < SaveItemList.Count) then
    begin
      MouseItem := PTClientItem(SaveItemList[MenuIndex])^;
      GetMouseItemInfo(iname, d1, d2, d3, d4, d5, useable, FALSE);
      if iname <> '' then
      begin
        lx := 240;
        ly := 32 + (MenuIndex - MenuTop) * LISTLINEHEIGHT;
        with Sender as TDButton do
          DScreen.ShowHint(DMenuDlg.SurfaceX(Left + lx), DMenuDlg.SurfaceY(Top + ly), iname + d1 + '\' + d2 + '\' + d3 + d4, clYellow, FALSE);
      end;
      MouseItem.S.Name := '';
    end;
  end
  else
  begin
    if (MenuIndex >= 0) and (MenuIndex < MenuItemList.Count) and ((PTClientGoods(MenuList[MenuIndex]).SubMenu = 0) or (PTClientGoods(MenuList[MenuIndex]).SubMenu = 2)) then
    begin
      MouseItem := PTClientItem(MenuItemList[MenuIndex])^;
      BoNoDisplayMaxDura := TRUE;
      GetMouseItemInfo(iname, d1, d2, d3, d4, d5, useable, FALSE);
      BoNoDisplayMaxDura := FALSE;
      if iname <> '' then
      begin
        lx := 240;
        ly := 32 + (MenuIndex - MenuTop) * LISTLINEHEIGHT;
        with Sender as TDButton do
          DScreen.ShowHint(DMenuDlg.SurfaceX(Left + lx), DMenuDlg.SurfaceY(Top + ly), iname + d1 + '\' + d2 + '\' + d3 + d4, clYellow, FALSE);
      end;
      MouseItem.S.Name := '';
    end;
  end;
end;

procedure TFrmDlg.DMenuDlgMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
begin
  with DMenuDlg do
    if (X < SurfaceX(Left + 10)) or (X > SurfaceX(Left + Width - 20)) or (Y < SurfaceY(Top + 30)) or (Y > SurfaceY(Top + Height - 50)) then
    begin
      DScreen.ClearHint(True);
    end;
end;

procedure TFrmDlg.DMenuBuyClick(Sender: TObject; X, Y: Integer);
var
  pg: PTClientGoods;
  MsgResult, Count: integer;
  valstr: string;
begin
  Count := 0;
  if GetTickCount < LastestClickTime then
    exit; //经常点击不限制
  if (MenuIndex >= 0) and (MenuIndex < MenuList.Count) then
  begin
    pg := PTClientGoods(MenuList[MenuIndex]);
    LastestClickTime := GetTickCount + 5000;
    if (pg.SubMenu > 0) and (pg.SubMenu <> 2) then
    begin
      FrmMain.SendGetDetailItem(CurMerchant, 0, pg.Name);
      MenuTopLine := 0;
      CurDetailItem := pg.Name;
    end
    else
    begin
      if BoStorageMenu then
      begin
        try
          MouseItem := PTClientItem(SaveItemList[MenuIndex])^;
        except
        end;
        if MouseItem.S.OverlapItem > 0 then
        begin
          Total := MouseItem.Dura;
          if Total = 1 then
          begin
            DlgEditText := '1';
            MsgResult := mrOk;
          end
          else
            MsgResult := DCountMsgDlg('当前数量 ' + IntToStr(MouseItem.Dura) + ' 个.\请输入你想购买的商品数量?', [mbAbort]);
          GetValidStrVal(DlgEditText, valstr, [' ']);
          Count := Str_ToInt(valstr, 0);

          if Count > MouseItem.Dura then
            Count := MouseItem.Dura;
          if (MsgResult = mrCancel) or (Count <= 0) then
          begin// or (Count < 1) or(Count > MAX_OVERLAPITEM ) then begin
            Count := 0;
            Exit;
          end;
          FrmMain.SendTakeBackStorageItem(CurMerchant, pg.Price{MakeIndex}, pg.Name, word(Count));
        end
        else
          FrmMain.SendTakeBackStorageItem(CurMerchant, pg.Price{MakeIndex}, pg.Name, word(Count));
        exit;
      end;
      if BoMakeItemMenu then
      begin
        NameMakeItem := pg.Name;
        FrmMain.SendMakeItemSel(CurMerchant, pg.Name);
        MakeItemDlgShow('');
        exit;
      end;
      if BoMakeDrugMenu then
      begin
        FrmMain.SendMakeDrugItem(CurMerchant, pg.Name);
        exit;
      end;

      if pg.SubMenu = 2 then
      begin // pg.SubMenu = 2 捞搁 般摹扁 酒捞袍..
        Total := 100;
        MsgResult := DCountMsgDlg('你想买多少?', [mbOk, mbCancel, mbAbort]);
        GetValidStrVal(DlgEditText, valstr, [' ']);
        Count := Str_ToInt(valstr, 0);
        if (MsgResult = mrCancel) or (Count <= 0) or (Count > MAX_OVERLAPITEM) then
        begin
          Exit;
        end;
      end;
      FrmMain.SendBuyItem(CurMerchant, pg.Stock, pg.Name, word(Count));
    end;
  end;
end;

procedure TFrmDlg.DMenuPrevClick(Sender: TObject; X, Y: Integer);
begin
  if not BoDetailMenu then
  begin
    if MenuTop > 0 then
      Dec(MenuTop, MAXMENU - 1);
    if MenuTop < 0 then
      MenuTop := 0;
  end
  else
  begin
    if MenuTopLine > 0 then
    begin
      MenuTopLine := _MAX(0, MenuTopLine - 10);
      FrmMain.SendGetDetailItem(CurMerchant, MenuTopLine, CurDetailItem);
    end;
  end;
end;

procedure TFrmDlg.DMenuNextClick(Sender: TObject; X, Y: Integer);
begin
  if not BoDetailMenu then
  begin
    if MenuTop + MAXMENU < MenuList.Count then
      Inc(MenuTop, MAXMENU - 1);
  end
  else
  begin
    MenuTopLine := MenuTopLine + 10;
    FrmMain.SendGetDetailItem(CurMerchant, MenuTopLine, CurDetailItem);
  end;
end;

procedure TFrmDlg.SoldOutGoods(itemserverindex: integer);
var
  i: integer;
  pg: PTClientGoods;
begin
  for i := 0 to MenuList.Count - 1 do
  begin
    pg := PTClientGoods(MenuList[i]);
    if (pg.Grade >= 0) and (pg.Stock = itemserverindex) then
    begin
      Dispose(pg);
      MenuList.Delete(i);
      if i < MenuItemList.Count then
        MenuItemList.Delete(i);
      if MenuIndex > MenuList.Count - 1 then
        MenuIndex := MenuList.Count - 1;
      break;
    end;
  end;
end;

procedure TFrmDlg.DelStorageItem(itemserverindex: integer; remain: word);
var
  i: integer;
  pg: PTClientGoods;
begin
  for i := 0 to MenuList.Count - 1 do
  begin
    pg := PTClientGoods(MenuList[i]);
    if (pg.Price = itemserverindex) then
    begin //焊包格废牢版款 Price = ItemServerIndex烙.
      if (remain > 0) and (PTClientItem(SaveItemList[i])^.s.OverlapItem > 0) then
      begin
        PTClientItem(SaveItemList[i])^.dura := remain;
        Exit;
      end;
      Dispose(pg);
      MenuList.Delete(i);
      if i < SaveItemList.Count then
        SaveItemList.Delete(i);
      if MenuIndex > MenuList.Count - 1 then
        MenuIndex := MenuList.Count - 1;
      break;
    end;
  end;
end;

procedure TFrmDlg.DMenuCloseClick(Sender: TObject; X, Y: Integer);
begin
  DMenuDlg.Visible := FALSE;
end;

procedure TFrmDlg.DMerchantDlgClick(Sender: TObject; X, Y: Integer);
var
  i, L, T: integer;
  p: PTClickPoint;
begin
  if GetTickCount < LastestClickTime then
    exit; //努腐阑 磊林 给窍霸 力茄
  L := DMerchantDlg.Left;
  T := DMerchantDlg.Top;
  with DMerchantDlg do
    for i := 0 to MDlgPoints.Count - 1 do
    begin
      p := PTClickPoint(MDlgPoints[i]);
      if (X >= SurfaceX(L + p.rc.Left)) and (X <= SurfaceX(L + p.rc.Right)) and (Y >= SurfaceY(T + p.rc.Top)) and (Y <= SurfaceY(T + p.rc.Bottom)) then
      begin
        PlaySound(s_glass_button_click);
        if DMakeItemDlg.Visible then
          DMakeItemDlgOkClick(DMakeItemDlgCancel, 0, 0);
        if DSellDlg.Visible then
          CloseDSellDlg;
        SafeCloseDlg;
{            if DItemMarketDlg.Visible then CloseItemMarketDlg;
            if DJangwonListDlg.Visible then DJangwonCloseClick(DJangwonClose, 0, 0);
            if DGABoardListDlg.Visible then DGABoardListCloseClick(FrmDlg.DGABoardListClose, 0, 0);
            if DGABoardDlg.Visible then DGABoardCloseClick(FrmDlg.DGABoardClose, 0, 0);
            if DGADecorateDlg.Visible then DGADecorateCloseClick(FrmDlg.DGADecorateClose, 0, 0);}

        FrmMain.SendMerchantDlgSelect(CurMerchant, p.RStr);
        LastestClickTime := GetTickCount + 5000; //5檬饶俊 荤侩 啊瓷
        break;
      end;
    end;
end;

procedure TFrmDlg.DMerchantDlgMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
  i, L, T: integer;
  p: PTClickPoint;
begin
  if GetTickCount < LastestClickTime then
    exit; //努腐阑 磊林 给窍霸 力茄
  SelectMenuStr := '';
  L := DMerchantDlg.Left;
  T := DMerchantDlg.Top;
  with DMerchantDlg do
    for i := 0 to MDlgPoints.Count - 1 do
    begin
      p := PTClickPoint(MDlgPoints[i]);
      if (X >= SurfaceX(L + p.rc.Left)) and (X <= SurfaceX(L + p.rc.Right)) and (Y >= SurfaceY(T + p.rc.Top)) and (Y <= SurfaceY(T + p.rc.Bottom)) then
      begin
        SelectMenuStr := p.RStr;
        break;
      end;
    end;
end;

procedure TFrmDlg.DMerchantDlgMouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  SelectMenuStr := '';
end;

procedure TFrmDlg.DSellDlgDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  actionname: string;
begin
  with DSellDlg do
  begin
    d := DMenuDlg.WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

    with dsurface do
    begin
         //SetBkMode (Handle, TRANSPARENT);
//         Font.Color := clWhite;
      actionname := '';
      case SpotDlgMode of
        dmSell:
          actionname := '卖: ';
        dmRepair:
          actionname := '修理: ';
        dmStorage:
          actionname := ' 托管物品';
        dmMaketSell:
          actionname := ' 拍卖货物';
      end;
      TextOut(SurfaceX(Left + 8), SurfaceY(Top + 6), clWhite, actionname + SellPriceStr);
         //Release;
    end;
  end;
end;

procedure TFrmDlg.DSellDlgCloseClick(Sender: TObject; X, Y: Integer);
begin
  CloseDSellDlg;
end;

procedure TFrmDlg.DSellDlgSpotClick(Sender: TObject; X, Y: Integer);
var
  temp: TClientItem;
  MsgResult, Count: integer;
  valstr: string;
begin
  SellPriceStr := '';
  if not ItemMoving then
  begin
    if SellDlgItem.S.Name <> '' then
    begin
      ItemClickSound(SellDlgItem.S);
      ItemMoving := TRUE;
      MovingItem.Index := -99; //sell 芒俊辑 唱咳..
      MovingItem.Item := SellDlgItem;
      SellDlgItem.S.Name := '';
    end;
  end
  else
  begin
    if (MovingItem.Index = -97) or (MovingItem.Index = -98) then
      exit;
    if (MovingItem.Index >= 0) or (MovingItem.Index = -99) then
    begin
      ItemClickSound(MovingItem.Item.S);
      if SellDlgItem.S.Name <> '' then
      begin //磊府俊 乐栏搁
        temp := SellDlgItem;
        SellDlgItem := MovingItem.Item;
        MovingItem.Index := -99; //sell 芒俊辑 唱咳..
        MovingItem.Item := temp;
      end
      else if MovingItem.Item.S.OverlapItem = 0 then
      begin
        SellDlgItem := MovingItem.Item;
        MovingItem.Item.S.name := '';
        ItemMoving := FALSE;
      end
      else if MovingItem.Item.S.OverlapItem > 0 then
      begin
        SellDlgItem := MovingItem.Item;
        ItemMoving := FALSE;
        Total := MovingItem.Item.Dura;
        if Total = 1 then
        begin
          DlgEditText := '1';
          MsgResult := mrOk;
        end
        else
          MsgResult := DCountMsgDlg('当前数量 ' + IntToStr(MovingItem.Item.Dura) + ' 个.\请输入你想出售的商品数量?', [mbOk, mbCancel, mbAbort]);
        ItemMoving := TRUE;
        GetValidStrVal(DlgEditText, valstr, [' ']);
        Count := Str_ToInt(valstr, 0);
        if Count <= 0 then
        begin
          Count := 0;
          AddItemBag(SellDlgItem);
          SellDlgItem.S.Name := '';
          SellDlgItem.Dura := 0;
          MovingItem.Item.S.name := '';
          CancelItemMoving;
          Exit;
        end;
        if Count >= SellDlgItem.Dura then
        begin
          Count := SellDlgItem.Dura;
          MovingItem.Item.Dura := 0;
        end;
        if MsgResult = mrOk then
        begin
          SellDlgItem.Dura := word(Count);
          if MovingItem.Item.Dura > 0 then
          begin
            MovingItem.Item.Dura := MovingItem.Item.Dura - word(Count);
          end;
          if MovingItem.Item.Dura <= 0 then
          begin
            MovingItem.Item.Dura := 0;
            MovingItem.Item.S.name := '';
            ItemMoving := FALSE;
          end;
//               MovingItem.Index := 0;
          CancelItemMoving;
        end;
        if MsgResult = mrCancel then
        begin
          AddItemBag(SellDlgItem);
          SellDlgItem.S.Name := '';
          SellDlgItem.Dura := 0;
          MovingItem.Item.S.name := '';
//               MovingItem.Index := 0;
          CancelItemMoving;
          Exit;
        end;
      end;

      BoQueryPrice := TRUE;
      QueryPriceTime := GetTickCount;
         //圈靛滚瓢贸府 2006/04/04
      if SellStHold and (SellDlgItem.S.Name <> '') then
        DSellDlgOkClick(DSellDlgOk, 1, 1);
    end;
  end;
end;

procedure TFrmDlg.DSellDlgSpotDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  if SellDlgItem.S.Name <> '' then
  begin
    d := WBagItem.Images[SellDlgItem.S.Looks];
    if d <> nil then
    begin
      with DSellDlgSpot do
        dsurface.Draw(SurfaceX(Left + (Width - d.Width) div 2), SurfaceY(Top + (Height - d.Height) div 2), d.ClientRect, d, TRUE);

      if SellDlgItem.S.OverlapItem > 0 then
      begin
               //SetBkMode (g_DXCanvas.Handle, TRANSPARENT);
//               g_DXCanvas.Font.Color := clYellow;
        with DSellDlgSpot do
          dsurface.TextOut(SurfaceX(Left + (Width - d.Width) div 2) + 21, SurfaceY(Top + (Height - d.Height) div 2) + 15, clYellow, IntToStr(SellDlgItem.Dura));
//               g_DXCanvas.//Release;
      end;
    end;
  end;
end;

procedure TFrmDlg.DSellDlgSpotMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
begin
  MouseItem := SellDlgItem;
end;

procedure TFrmDlg.DSellDlgOkClick(Sender: TObject; X, Y: Integer);
var
  dropgold: integer;
  valstr: string;
  MsgResult: integer;
begin
  if (SellDlgItem.S.Name = '') and (SellDlgItemSellWait.S.Name = '') then
    exit;
  if GetTickCount < LastestClickTime then
    exit; //经常点击不限制
  case SpotDlgMode of
    dmSell:
      FrmMain.SendSellItem(CurMerchant, SellDlgItem.MakeIndex, SellDlgItem.S.Name, SellDlgItem.Dura);
    dmRepair:
      FrmMain.SendRepairItem(CurMerchant, SellDlgItem.MakeIndex, SellDlgItem.S.Name);
    dmStorage:
      FrmMain.SendStorageItem(CurMerchant, SellDlgItem.MakeIndex, SellDlgItem.S.Name, SellDlgItem.Dura);
    dmMaketSell:
      begin
        DMessageDlg('请输入你的销售价格', [mbOk, mbAbort]);
        GetValidStrVal(DlgEditText, valstr, [' ']);

        try
          dropgold := Str_ToInt(valstr, 0);
        except
          DMessageDlg('输入错误', [mbOk]);
          Exit;
        end;
        if (dropgold > 0) and (dropgold <= MAX_MARKETPRICE) then
        begin
          MsgResult := DMessageDlg(SellDlgItem.S.Name + ' 的价格为 ' + GetGoldStr(dropgold) + '金币？', [mbOk, mbCancel]);
          if MsgResult = mrOk then
            FrmMain.SendMaketSellItem(CurMerchant, SellDlgItem.MakeIndex, valstr, SellDlgItem.Dura)
          else if MsgResult = mrCancel then
            Exit;
        end
        else
        begin
          DMessageDlg('请合理的输入上架物品的价格。\最高销售价格限制为 ' + GetGoldStr(MAX_MARKETPRICE) + ' 金币。', [mbOk]);
          Exit;
        end;
      end;
  end;

  SellDlgItemSellWait := SellDlgItem;
  SellDlgItem.S.Name := '';
  LastestClickTime := GetTickCount + 5000;
  SellPriceStr := '';
end;





{------------------------------------------------------------------------}

//魔法键设置窗口 (对话)

{------------------------------------------------------------------------}

procedure TFrmDlg.SetMagicKeyDlg(icon: integer; magname: string; var curkey: word);
begin
  MagKeyIcon := icon;
  MagKeyMagName := magname;
  MagKeyCurKey := curkey;

  DKeySelDlg.Left := (g_FScreenWidth - DKeySelDlg.Width) div 2;
  DKeySelDlg.Top := (g_FScreenHeight - DKeySelDlg.Height) div 2;
  HideAllControls;
  DKeySelDlg.ShowModal;

  while TRUE do
  begin
    if not DKeySelDlg.Visible then
      break;
      //FrmMain.DXTimerTimer (self, 0);
    frmMain.ProcOnIdle();
    Application.ProcessMessages;
    if Application.Terminated then
      exit;
      Sleep(20);
  end;

  RestoreHideControls;
  curkey := MagKeyCurKey;
end;

procedure TFrmDlg.DKeySelDlgDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with DKeySelDlg do
  begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
      //付过 捞抚
    with dsurface do
    begin
         //SetBkMode (Handle, TRANSPARENT);
//         Font.Color := clSilver;
      BoldTextOut(SurfaceX(Left + 95), SurfaceY(Top + 38), clSilver, clBlack, MagKeyMagName + '快捷键盘被设置为.');
         //Release;
    end;
  end;
end;

procedure TFrmDlg.DKsIconDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with DksIcon do
  begin
    d := WMagicon.Images[MagKeyIcon];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
  end;
end;

procedure TFrmDlg.DKsF1DirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  b: TDButton;
  d: TAsphyreLockableTexture;
begin
  b := nil;
  case MagKeyCurKey of
    word('1'):
      b := DKsF1;
    word('2'):
      b := DKsF2;
    word('3'):
      b := DKsF3;
    word('4'):
      b := DKsF4;
    word('5'):
      b := DKsF5;
    word('6'):
      b := DKsF6;
    word('7'):
      b := DKsF7;
    word('8'):
      b := DKsF8;
      // 2003/08/20 =>付过窜绵虐 眠啊  // AddMagicKey
    word('1') + 20:
      b := DKsConF1;
    word('2') + 20:
      b := DKsConF2;
    word('3') + 20:
      b := DKsConF3;
    word('4') + 20:
      b := DKsConF4;
    word('5') + 20:
      b := DKsConF5;
    word('6') + 20:
      b := DKsConF6;
    word('7') + 20:
      b := DKsConF7;
    word('8') + 20:
      b := DKsConF8;
      //-------
  else
    b := DKsNone;
  end;
  if b = Sender then
  begin
    with b do
    begin
      d := WLib.Images[FaceIndex + 1];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
    end;
  end;
  with Sender as TDButton do
  begin
    if Downed then
    begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
    end;
  end;
end;

procedure TFrmDlg.DKsOkClick(Sender: TObject; X, Y: Integer);
begin
  DKeySelDlg.Visible := FALSE;
end;

procedure TFrmDlg.DKsF1Click(Sender: TObject; X, Y: Integer);
begin
  if Sender = DKsF1 then
    MagKeyCurKey := integer('1');
  if Sender = DKsF2 then
    MagKeyCurKey := integer('2');
  if Sender = DKsF3 then
    MagKeyCurKey := integer('3');
  if Sender = DKsF4 then
    MagKeyCurKey := integer('4');
  if Sender = DKsF5 then
    MagKeyCurKey := integer('5');
  if Sender = DKsF6 then
    MagKeyCurKey := integer('6');
  if Sender = DKsF7 then
    MagKeyCurKey := integer('7');
  if Sender = DKsF8 then
    MagKeyCurKey := integer('8');
   // 2003/08/20 =>付过窜绵虐 眠啊  // AddMagicKey
  if Sender = DKsConF1 then
    MagKeyCurKey := integer('1') + 20;
  if Sender = DKsConF2 then
    MagKeyCurKey := integer('2') + 20;
  if Sender = DKsConF3 then
    MagKeyCurKey := integer('3') + 20;
  if Sender = DKsConF4 then
    MagKeyCurKey := integer('4') + 20;
  if Sender = DKsConF5 then
    MagKeyCurKey := integer('5') + 20;
  if Sender = DKsConF6 then
    MagKeyCurKey := integer('6') + 20;
  if Sender = DKsConF7 then
    MagKeyCurKey := integer('7') + 20;
  if Sender = DKsConF8 then
    MagKeyCurKey := integer('8') + 20;
   //------
  if Sender = DKsNone then
    MagKeyCurKey := 0;
end;



{------------------------------------------------------------------------}

//基本创意微型按钮

{------------------------------------------------------------------------}

//小地图
procedure TFrmDlg.DBotMiniMapClick(Sender: TObject; X, Y: Integer);
begin
  BoWantMiniMap := TRUE;
  if ViewMiniMapStyle=0 then
     ViewMiniMapStyle:=1
  else begin
    if g_bo大地图开关 then begin

       if ViewMiniMapStyle=2 then
          begin
            ViewMiniMapStyle:=0;
            BoWantMiniMap := FALSE;
            PrevVMMStyle:=0;
          end
       else begin
           inc(ViewMiniMapStyle);
       end;
    end else begin
      if ViewMiniMapStyle in [1,2] then
      begin
        ViewMiniMapStyle:=0;
        BoWantMiniMap := FALSE;
        PrevVMMStyle:=0;
      end else begin
        inc(ViewMiniMapStyle);
      end;
    end;
  end;
  if MiniMapIndex=-1 then
     begin
       querymsgtime := GetTickCount + 3000;
       FrmMain.SendWantMiniMap;
     end;
//  if ViewMiniMapStyle = 0 then
//  begin
//    if GetTickCount > querymsgtime then
//    begin
//      querymsgtime := GetTickCount + 3000;
//      FrmMain.SendWantMiniMap;
//      BoWantMiniMap := TRUE;
//      Inc(ViewMiniMapStyle);
//    end;
//  end
//  else
//  begin
//    Inc(ViewMiniMapStyle);
//    if ViewMiniMapStyle > 3 then
//    begin
//      ViewMiniMapStyle := 0;
//      PrevVMMStyle := 1;  //初始值
//      BoWantMiniMap := FALSE;
//    end;
//  end;
end;

procedure TFrmDlg.DBotTradeClick(Sender: TObject; X, Y: Integer);
begin
  if GetTickCount > querymsgtime then
  begin
    querymsgtime := GetTickCount + 3000;
    FrmMain.SendDealTry;
  end;
end;

procedure TFrmDlg.DBotWhisperClick(Sender: TObject; X, Y: Integer);
begin
  DWhisperDlg.Visible := not DWhisperDlg.Visible;
  DEdtWhisper.SetFocus;
end;

function StallItemCount(): Integer;
var
  i                 : Integer;
begin
  Result := 0;
  if MySelf = nil then Exit;
  for i := 0 to 10 - 1 do begin
    if mySelf.m_StallMgr.mBlock.Items[i].s.Name <> '' then begin
      Inc(Result);
      //Break;
    end;
  end;
end;

procedure TFrmDlg.DBStoreBuyClick(Sender: TObject; X, Y: Integer);
var
  i, ii, cnt: Integer;
  msg: TDefaultMessage;

  cr: TClientStallItems;
begin
  if (Myself = nil) then Exit;
  if Myself.m_StallMgr.OnSale then begin      //摆摊状态
    DScreen.AddChatBoardString('[提示：你正在摆摊中！]', clYellow, clRed);
    Exit;
  end;

  cnt := StallItemCount();
  if cnt in [1..10] then
  begin
    FillChar(cr, SizeOf(TClientStallItems), #0);

    Myself.m_StallMgr.mBlock.StallName := DEditStoreName.Text;
    cr.Name := Myself.m_StallMgr.mBlock.StallName;

    ii := 0;
    for i := 0 to 9 do begin
      if (Myself.m_StallMgr.mBlock.Items[i].MakeIndex <> 0) and (Myself.m_StallMgr.mBlock.Items[i].s.Name <> '') then begin
        cr.Items[ii].MakeIndex := Myself.m_StallMgr.mBlock.Items[i].MakeIndex; //物品idx
        cr.Items[ii].Price := Myself.m_StallMgr.mBlock.Items[i].s.Price;
        cr.Items[ii].GoldType := Myself.m_StallMgr.mBlock.Items[i].s.Stock;
//        Dscreen.AddSysMsg(format('%d %d %d',[cr.Items[ii].MakeIndex,cr.Items[ii].Price,cr.Items[ii].GoldType]));
//        Dscreen.AddChatBoardString(format('%d %d %d',[cr.Items[ii].MakeIndex,cr.Items[ii].Price,cr.Items[ii].GoldType]),clBtnFace,clWhite);
        Inc(ii);
      end;
    end;
    case Myself.Dir of //修正朝向
      0, 1: Myself.Dir := 1;
      2, 3: Myself.Dir := 3;
      4, 5: Myself.Dir := 5;
      6, 7: Myself.Dir := 7;
    end;
    frmMain.SendStallInfo(cr, cnt);
    DCloseBagClick(nil, 0, 0);
  end else begin
    DMessageDlg('提示：你没有放入任何物品！',[mbOk]);
  end;
  //DxEditStoreItemPrice
end;

procedure TFrmDlg.DBStoreBuyDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
   with Sender as TDButton do begin
    if not Downed then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
      if OnbtnState = tdisable then
        dsurface.BoldTextOut( SurfaceX(Left + (Width - FontManager.Default.TextWidth(Caption)) div 2), SurfaceY(Top + (Height - FontManager.Default.TextHeight(Caption)) div 2), clGray, clBlack, Caption)
      else begin
        if Arrived then
          dsurface.BoldTextOut( SurfaceX(Left + (Width - FontManager.Default.TextWidth(Caption)) div 2), SurfaceY(Top + (Height - FontManager.Default.TextHeight(Caption)) div 2), GetRGB(95), clBlack, Caption)
        else
          dsurface.BoldTextOut( SurfaceX(Left + (Width - FontManager.Default.TextWidth(Caption)) div 2), SurfaceY(Top + (Height - FontManager.Default.TextHeight(Caption)) div 2), GetRGB(93), clBlack, Caption)
      end;
    end else begin
      d := WLib.Images[FaceIndex+1];
      if d <> nil then dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
      dsurface.BoldTextOut( SurfaceX(Left + (Width - FontManager.Default.TextWidth(Caption)) div 2 + 1), SurfaceY(Top + (Height - FontManager.Default.TextHeight(Caption)) div 2 + 1), GetRGB(94), clBlack, Caption);
    end;
  end;
end;

procedure TFrmDlg.DBStoreCancelClick(Sender: TObject; X, Y: Integer);
var
  cr: TClientStallItems;
  cnt: Integer;
begin
  if (Myself = nil) then Exit;
  if not Myself.m_StallMgr.OnSale then begin
    cnt := StallItemCount();
    if cnt = 0 then begin
      DWHeroStore.Visible := False;
    end else begin
      FillChar(MySelf.m_StallMgr.mBlock, SizeOf(TClientStallInfo), 0);
      FrmMain.FillBagStallItem(0);
    end;
    Exit;
  end;
  frmMain.SendStallInfo(cr, 0);
end;


procedure TFrmDlg.DBStoreCancelDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
//var
//  d: TDirectDrawSurface;
//begin
//  with Sender as TDButton do begin
//    if not Downed then
//    begin
//      d := WLib.Images[FaceIndex];
//      if d <> nil then dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
//           with g_DXCanvas do begin
//      TextOutEx(SurfaceX(Left) + (Width - TextWidth(Caption)) div 2,
//        SurfaceY(Top) + (Height - TextHeight(Caption)) div 2, Caption,$00A8D4E8{DFColor});
//    end;
//
//    end
//    else
//    begin
//      d := WLib.Images[FaceIndex + 1];
//      if d <> nil then dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
//      with g_DXCanvas do begin
//      TextOutEx(SurfaceX(Left) + (Width - TextWidth(Caption)) div 2+2,
//        SurfaceY(Top) + (Height - TextHeight(Caption)) div 2+2, Caption, $0088C4E8{DFColor});
//      end;
//    end;
//  end;
//end;
var
  d:TAsphyreLockableTexture;
begin
  with Sender as TDButton do begin
    begin
      if TDButton(Sender).Downed then
      begin
        d := WLib.Images[FaceIndex + 1];
        if d <> nil then
            dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);    //按下颜色
        with dsurface do
      TextOut(SurfaceX(Left) + (Width - FontManager.Default.TextWidth(Caption)) div 2+2,          //
        SurfaceY(Top) + (Height - FontManager.Default.TextHeight(Caption)) div 2+2, Caption,$0088C4E8);//按下颜色

      end
      else
      begin
        if Arrived then
                begin
          d := WLib.Images[FaceIndex];
          if d <> nil then
              dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
               with dsurface do
      TextOut(SurfaceX(Left) + (Width - FontManager.Default.TextWidth(Caption)) div 2,
        SurfaceY(Top) + (Height - FontManager.Default.TextHeight(Caption)) div 2, Caption,$00C6E2F0);//鼠标颜色
        end
        else
        begin
          d := WLib.Images[FaceIndex];
          if d <> nil then
            dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
          with dsurface do
          TextOut(SurfaceX(Left) + (Width - FontManager.Default.TextWidth(Caption)) div 2,
          SurfaceY(Top) + (Height - FontManager.Default.TextHeight(Caption)) div 2, Caption,$00A8D4E8);//默认颜色                                                        //最终
         end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DBStoreCloseClick(Sender: TObject; X, Y: Integer);
begin
DWHeroStore.Visible := False;
end;

procedure TFrmDlg.DBStoreItemPriceCancelClick(Sender: TObject; X, Y: Integer);
begin
  if g_WaitingStallItem.item.s.Name <> '' then begin
    g_WaitingStallItem.item.s.Name := '';
  end;
  DWStoreItemPrice.Visible := False;
  DEditStoreItemPrice.Visible:=False;
end;

procedure TFrmDlg.DBStoreItemPriceOkClick(Sender: TObject; X, Y: Integer);
var
  Price: Integer;
  DefMsg: TDefaultMessage;
//  StallItem: TClientStall;
begin
  if DEditStoreItemPrice.Text = '' then begin
    DMessageDlg('提示：请输入金额！',[mbOk]);
    DEditStoreItemPrice.SetFocus;
    Exit;
  end;
  if g_WaitingStallItem.item.s.Name = '' then Exit;
  Price := StrToIntDef(DEditStoreItemPrice.Text, 0);
  if DWStoreItemPrice.tag = 44 then begin
    if (Price <= 0) or (Price > 88888888) then begin
      DMessageDlg('输入金币价格错误，请输入一个在 1-88,888,888 之间的数字', [mbOk, mbCancel]);
      if (Price > 88888888) then
        DEditStoreItemPrice.Text := '88888888';
      Exit;
    end;
  end
  else
  if DWStoreItemPrice.tag = 45 then begin
    if (Price <= 0) or (Price > 88888888) then begin
      DMessageDlg('输入元宝价格错误，请输入一个在 1-88,888,888 之间的数字', [mbOk, mbCancel]);
      if (Price > 88888888) then
        DEditStoreItemPrice.Text := '88888888';
      Exit;
    end;
  end;
  g_WaitingStallItem.item.s.Stock := DWStoreItemPrice.tag;   //出售类型  元宝金币
  g_WaitingStallItem.item.s.Price := Price; //价格写入

//  DxEditStoreItemPrice.Visible:=False;
//  DWStoreItemPrice.Visible := False;
  if not Myself.m_StallMgr.OnSale then //false  //没有摆摊 那么允许添加
  begin
    if AddStallItem(g_WaitingStallItem.item) then begin
      UpdateBagStallItem(g_WaitingStallItem.item,g_WaitingStallItem.item.S.Stock);
      ItemClickSound(g_WaitingStallItem.item.s);
      g_WaitingStallItem.item.s.Name := '';
    end else begin
      AddItemBag(g_WaitingStallItem.item, g_WaitingStallItem.Index);
      UpdateBagStallItem(g_WaitingStallItem.item, 0);
      g_WaitingStallItem.item.s.Name := '';
    end;
    DBStoreItemPriceCancelClick(nil, 0, 0);
    Exit;
  end;
    //发送     摆摊后添加？
//  if CanAddStallItem() then begin
//    StallItem.MakeIndex := g_WaitingStallItem.item.MakeIndex;
//    StallItem.GoldType := DWStoreItemPrice.tag;
//    StallItem.Price := Price;
//    DefMsg := EDcode.MakeDefaultMsg(CM_UPDATESTALLITEM, 0, 0, 0, 1);
//    frmMain.SendSocket(EncodeMessage(DefMsg) + EncodeBuffer(@StallItem, SizeOf(StallItem)));
//    DWStoreItemPrice.Visible := False;
//  end;
end;

procedure TFrmDlg.DBStorePage1Click(Sender: TObject; X, Y: Integer);
  procedure FillComponentTag();
  begin
    DBStorePage1.PageActive := False;
    DBStorePage2.PageActive := False;
    TDButton(Sender).PageActive := True;
  end;
var
  i: Integer;
begin
  DEditStoreItemPrice.Text := '';
//  DxEditStoreItemPrice.SelStart := -1;
//  DxEditStoreItemPrice.SelEnd := -1;
  FillComponentTag();
  DWStoreItemPrice.tag := TDButton(Sender).tag;
  with DWStoreItemPrice do begin
    case tag of
      44: begin
          DEditStoreItemPrice.MaxLength := 9;
        end;
      45: begin
          DEditStoreItemPrice.MaxLength := 9;
        end;
    end;
  end;
end;

procedure TFrmDlg.DBStorePage1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  i, itTop: Integer;
  cl: TColor;
begin
  with TDButton(Sender) do begin
    itTop := Top;
    if not PageActive then begin
      d := WLib.Images[FaceIndex];
      cl := GetRGB(92);
    end else begin
      d := WLib.Images[FaceIndex+1];
      itTop := Top - 2;
      cl := GetRGB(95);
    end;
    if d <> nil then begin
      dsurface.Draw(SurfaceX(Left), SurfaceY(itTop), d.ClientRect, d, True);
      with dsurface do begin
        BoldTextOut(
          SurfaceX(10 + (d.Width - FontManager.Default.TextWidth(Caption)) div 2 + (TDButton(Sender).tag - 44) * Width),
          SurfaceY(itTop + (d.Height - FontManager.Default.TextHeight(Caption)) div 2),
          cl, clBlack, Caption);
      end;
    end;
  end;
end;


procedure TFrmDlg.DBStorePriceCloseClick(Sender: TObject; X, Y: Integer);
begin
  if g_WaitingStallItem.item.s.Name <> '' then begin
    //AddItemBag(g_WaitingStallItem.item, g_WaitingStallItem.Index);
 //  UpdateBagStallItem(g_WaitingStallItem.item, 0);      20191314
    g_WaitingStallItem.item.s.Name := '';
  end;
  DWStoreItemPrice.Visible := False;
  DEditStoreItemPrice.Visible:=False;
end;

procedure TFrmDlg.DBUserStallBuyClick(Sender: TObject; X, Y: Integer);

var
  i, ii, cnt: Integer;
  msg: TDefaultMessage;

  cr: TClientStallItems;

  MsgResult: Integer;
begin   //买入事件
  if (Myself = nil) then Exit;
  if Myself.m_StallMgr.OnSale then Exit;
  if not (Myself.m_StallMgr.uSelIdx in [0..9]) or (Myself.m_StallMgr.uBlock.Items[Myself.m_StallMgr.uSelIdx].s.Name = '') then begin
    DMessageDlg('提示：请选择你要购买的物品！',[mbOk]);
    Exit;
  end;

  //
  MsgResult := -1;
  case Myself.m_StallMgr.uBlock.Items[Myself.m_StallMgr.uSelIdx].s.Stock of
    44: MsgResult := DMessageDlg(Format('你将以 %d 金币购买 %s，确定吗？', [Myself.m_StallMgr.uBlock.Items[Myself.m_StallMgr.uSelIdx].s.Price, Myself.m_StallMgr.uBlock.Items[Myself.m_StallMgr.uSelIdx].s.Name]), [mbOk, mbCancel]);
    45: MsgResult := DMessageDlg(Format('你将以 %d 元宝购买 %s，确定吗？', [Myself.m_StallMgr.uBlock.Items[Myself.m_StallMgr.uSelIdx].s.Price, Myself.m_StallMgr.uBlock.Items[Myself.m_StallMgr.uSelIdx].s.Name]), [mbOk, mbCancel]);
  end;
  if MsgResult = mrCancel then begin
    Myself.m_StallMgr.uSelIdx := -1;
    Exit;
  end;
  if MsgResult = mrOk then begin
    if Myself.m_StallMgr.uBlock.Items[Myself.m_StallMgr.uSelIdx].s.OverlapItem > 0 then
      frmMain.SendBuyItem(Myself.m_StallMgr.CurActor,
        Myself.m_StallMgr.uBlock.Items[Myself.m_StallMgr.uSelIdx].MakeIndex,
        Myself.m_StallMgr.uBlock.Items[Myself.m_StallMgr.uSelIdx].s.Name,
        Myself.m_StallMgr.uBlock.Items[Myself.m_StallMgr.uSelIdx].Dura)
    else
      frmMain.SendBuyItem(Myself.m_StallMgr.CurActor,
        Myself.m_StallMgr.uBlock.Items[Myself.m_StallMgr.uSelIdx].MakeIndex,
        Myself.m_StallMgr.uBlock.Items[Myself.m_StallMgr.uSelIdx].s.Name,
        1);
  end;
end;

procedure TFrmDlg.DBUserStallBuyDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
 var
d:TAsphyreLockableTexture;
begin
  with Sender as TDButton do begin
     begin
      if TDButton(Sender).Downed then
      begin
        d := WLib.Images[FaceIndex + 1];
        if d <> nil then
            dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);    //按下颜色
        with dsurface do
      TextOut(SurfaceX(Left) + (Width - FontManager.Default.TextWidth(Caption)) div 2+2,          //
        SurfaceY(Top) + (Height - FontManager.Default.TextHeight(Caption)) div 2+2, Caption,$0088C4E8);//按下颜色

      end
      else
      begin
        if Arrived then
                begin
          d := WLib.Images[FaceIndex];
          if d <> nil then
              dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
               with dsurface do
      TextOut(SurfaceX(Left) + (Width - FontManager.Default.TextWidth(Caption)) div 2,
        SurfaceY(Top) + (Height - FontManager.Default.TextHeight(Caption)) div 2, Caption,$00C6E2F0);//鼠标颜色
        end
        else
        begin
          d := WLib.Images[FaceIndex];
          if d <> nil then
            dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
          with dsurface do
          TextOut(SurfaceX(Left) + (Width - FontManager.Default.TextWidth(Caption)) div 2,
          SurfaceY(Top) + (Height - FontManager.Default.TextHeight(Caption)) div 2, Caption,$00A8D4E8);//默认颜色                                                        //最终
         end;
      end;
     end;

  end;
end;


procedure TFrmDlg.DBotGuildClick(Sender: TObject; X, Y: Integer);
begin
  if DGuildDlg.Visible then
  begin
    DGuildDlg.Visible := FALSE;
  end
  else if GetTickCount > querymsgtime then
  begin
    querymsgtime := GetTickCount + 3000;
    FrmMain.SendGuildDlg;
  end;
end;

procedure TFrmDlg.DBotHelpClick(Sender: TObject; X, Y: Integer);
begin
  DHelpDlg.Visible := not DHelpDlg.Visible;
end;

procedure TFrmDlg.DBotHostpotClick(Sender: TObject; X, Y: Integer);
begin
  if DEdChat.Visible then DEdChat.Visible := False;

  with frmWebBrowser do begin
    if not Showing then begin
      if pos('http://',g_boHostpotWeb)=0 then
      g_boHostpotWeb:='http://'+g_boHostpotWeb;
      Open(g_boHostpotWeb);
    end
  end;
//    if g_boHostpotWeb <> '' then frmBrowser.Open(frmMain, g_boHostpotWeb);
end;

procedure TFrmDlg.DBotGroupClick(Sender: TObject; X, Y: Integer);
begin
//  ToggleShowGroupDlg;
end;


{------------------------------------------------------------------------}

//弊缝 促捞倔肺弊

{------------------------------------------------------------------------}

procedure TFrmDlg.ToggleShowGroupDlg;
begin

  DGroupDlg.Visible := not DGroupDlg.Visible;
end;

procedure TFrmDlg.DGridSaveItemDblClick(Sender: TObject);
var
  idx: integer;
  MsgResult, Count: integer;
  valstr: string;
  pg: PTClientGoods;
  temp: TClientItem;
begin
  if ItemMoving then
  begin
    if MenuList.Count <= 0 then
      Exit;
    idx := DGridSaveItem.Col + DGridSaveItem.Row * DGridSaveItem.ColCount;
    if idx in [0..MenuList.Count - 1] then
      MenuIndex := idx
      else
    Exit;
    if MenuIndex < 0 then
      Exit;
    Count := 0;
    if GetTickCount < LastestClickTime then
      exit; //经常点击不限制
    if (MenuIndex >= 0) and (MenuIndex < MenuList.Count) then
    begin
      if BoStorageMenu then
      begin
        if MovingItem.Item.S.OverlapItem > 0 then
        begin
          Total := MovingItem.Item.Dura;
          if Total = 1 then
          begin
            DlgEditText := '1';
            MsgResult := mrOk;
          end
          else
            MsgResult := DCountMsgDlg('当前数量 ' + IntToStr(MovingItem.Item.Dura) + ' 个.\请输入你想购买的商品数量?', [mbAbort]);
          GetValidStrVal(DlgEditText, valstr, [' ']);
          Count := Str_ToInt(valstr, 0);

          if Count > MovingItem.Item.Dura then
            Count := MovingItem.Item.Dura;
          if (MsgResult = mrCancel) or (Count <= 0) then
          begin
            Count := 0;
            Exit;
          end;
          FrmMain.SendTakeBackStorageItem(CurMerchant, MovingItem.Item.MakeIndex, MovingItem.Item.S.Name, word(Count));
        end
        else
          FrmMain.SendTakeBackStorageItem(CurMerchant, MovingItem.Item.MakeIndex, MovingItem.Item.S.Name, word(Count));
        MovingItem.Item.S.Name := '';
        ItemMoving := False;
        bWindowsType := -1;
        exit;
      end;
    end;
  end
end;

procedure TFrmDlg.DGridSaveItemGridMouseMove(Sender: TObject; X, Y, ACol,
  ARow: Integer; Shift: TShiftState);
var
  idx: integer;
  temp: TClientItem;
  iname, d0, d1, d2, d3, d4: string;
  useable: Boolean;
  hcolor, fcolor: TColor;
begin
  DScreen.ClearHint(true);
  if SaveItemList.Count <= 0 then
    Exit;
  idx := ACol + ARow * DGridSaveItem.ColCount;
  if idx in [0..SaveItemList.Count - 1] then
  begin
    MouseItem := PTClientItem(SaveItemList[idx])^;
    // if g_bo悬浮信息 then
    begin
      GetMouseItemInfo(iname, d0, d1, d2, d3, d4, useable, FALSE);
      if iname <> '' then
      begin
        if (MouseItem.UpgradeOpt > 0) and g_bo极品蓝字 then
          hcolor := TColor($cccc33)
        else
          hcolor := clWhite;
        if useable then
        begin
          //hcolor := clWhite;
          fcolor := hcolor;
        end
        else
        begin
          //hcolor := clWhite;
          fcolor := clRed;
        end;
        if d2 <> '' then
         d2 := d2 + '|' + IntToStr(hcolor) + '$';
        if d3 <> '' then
          d3 := d3 + '|' + IntToStr(fcolor);
        with DGridSaveItem do
          DScreen.ShowHint(SurfaceX(Left + ACol * ColWidth), SurfaceY(Top + (ARow + 1) * RowHeight), iname + '|' + IntToStr(clYellow) + '\' + d0 + '\' + d1 + '\' + d2 + d3, hcolor, FALSE);
      end;
      MouseItem.S.Name := '';
    end;
  end;
end;

procedure TFrmDlg.DGridSaveItemGridPaint(Sender: TObject; ACol, ARow: Integer;
  Rect: TRect; State: TGridDrawState; DSurface: TAsphyreCanvas);
var
 sd, d: TAsphyreLockableTexture;
  idx, ax, ay: integer;
  FSize: TPoint;
  rc:Trect;
  ClientItem: PTClientItem;
begin
  if SaveItemList.Count <= 0 then
    Exit;
  idx := ACol + ARow * DGridSaveItem.ColCount;
  if idx in [0..SaveItemList.Count - 1] then
  begin
    ClientItem := PTClientItem(SaveItemList[idx]);
    if ClientItem <> nil then
    begin
      if ClientItem.S.Name <> '' then
      begin
        d := WBagItem.Images[ClientItem.s.Looks];
        if d <> nil then
        begin
          with DGridSaveItem do
          begin
            DSurface.Draw(SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1), SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1), d.ClientRect, d, TRUE);
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DGridSaveItemGridSelect(Sender: TObject; X, Y, ACol,
  ARow: Integer; Shift: TShiftState);
var
  idx: integer;
  MsgResult, Count: integer;
  valstr: string;
  pg: PTClientGoods;
  temp: TClientItem;
  TempItem: pTClientItem;
begin
  if not ItemMoving then
  begin
    if MenuList.Count <= 0 then
      Exit;
    idx := DGridSaveItem.Col + DGridSaveItem.Row * DGridSaveItem.ColCount;
    if idx in [0..MenuList.Count - 1] then
      MenuIndex := idx
      else
    Exit;
    if MenuIndex < 0 then
      Exit;
    TempItem := PTClientItem(SaveItemList[MenuIndex]);
    if TempItem.s.Name <> '' then
    begin
      ItemMoving := TRUE;
      MovingItem.Index := MenuIndex;
      MovingItem.Item := TempItem^;
      TempItem.s.Name := '';
      ItemClickSound(TempItem.s);
    end;
    bWindowsType := 1;
  end
  else
  begin
    if (bWindowsType <> 2) then
      Exit;
    SellPriceStr := '';
    if (MovingItem.Index = -97) or (MovingItem.Index = -98) then
      exit;
    if (MovingItem.Index >= 0) or (MovingItem.Index = -99) then
    begin
      ItemClickSound(MovingItem.Item.S);
      if MovingItem.Item.S.OverlapItem = 0 then
      begin
        temp := MovingItem.Item;
        MovingItem.Item.S.name := '';
        ItemMoving := FALSE;
      end
      else if MovingItem.Item.S.OverlapItem > 0 then
      begin
        temp := MovingItem.Item;
        ItemMoving := FALSE;
        Total := MovingItem.Item.Dura;
        if Total = 1 then
        begin
          DlgEditText := '1';
          MsgResult := mrOk;
        end
        else
          MsgResult := DCountMsgDlg('当前数量 ' + IntToStr(MovingItem.Item.Dura) + ' 个.\请输入你想出售的商品数量?', [mbOk, mbCancel, mbAbort]);
        ItemMoving := TRUE;
        GetValidStrVal(DlgEditText, valstr, [' ']);
        Count := Str_ToInt(valstr, 0);
        if Count <= 0 then
        begin
          Count := 0;
          AddItemBag(temp);
          temp.S.Name := '';
          temp.Dura := 0;
          MovingItem.Item.S.name := '';
          CancelItemMoving;
          Exit;
        end;
        if Count >= temp.Dura then
        begin
          Count := temp.Dura;
          MovingItem.Item.Dura := 0;
        end;
        if MsgResult = mrOk then
        begin
          temp.Dura := word(Count);
          if MovingItem.Item.Dura > 0 then
          begin
            MovingItem.Item.Dura := MovingItem.Item.Dura - word(Count);
          end;
          if MovingItem.Item.Dura <= 0 then
          begin
            MovingItem.Item.Dura := 0;
            MovingItem.Item.S.name := '';
            ItemMoving := FALSE;
          end;
//               MovingItem.Index := 0;
          CancelItemMoving;
        end;
        if MsgResult = mrCancel then
        begin
          AddItemBag(temp);
          temp.S.Name := '';
          temp.Dura := 0;
          MovingItem.Item.S.name := '';
          CancelItemMoving;
          Exit;
        end;
      end;
    end;

    if GetTickCount < LastestClickTime then
      exit; //经常点击不限制
    FrmMain.SendStorageItem(CurMerchant, temp.MakeIndex, temp.S.Name, temp.Dura);
    bWindowsType := -1;
  end;
end;

procedure TFrmDlg.DGridShop1GridPaint(Sender: TObject; ACol, ARow: Integer;
  Rect: TRect; State: TGridDrawState; DSurface: TAsphyreCanvas);
var
  idx: Integer;
  sDesc, s, ss: string;
  pShopItem: pTShopItem;
  d: TAsphyreLockableTexture;
  FontColor:tColor;
begin
  if not DCashShopDlg.Visible then Exit;
  if g_ShopListArr[m_nShopClass].Count <= 0 then Exit;
  idx := ACol + ARow * DGridShop1.ColCount + m_nShopPage * 10;
  if (idx >= 0) and (idx < g_ShopListArr[m_nShopClass].Count) then begin
    pShopItem := pTShopItem(g_ShopListArr[m_nShopClass].Items[idx]);
    d := WBagItem.Images[pShopItem.wLooks];
    if d <> nil then
      with DGridShop1 do begin
        dsurface.Draw(SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1 - 62), SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1), d.ClientRect, d, True);
        ss := GetValidStr3(pShopItem.sExplain, s, ['|']);
        if m_nShopItemIndex = idx then begin
          FontColor := clWhite;
          idx := 0;
          while True do begin
            if ss = '' then
              Break;
            ss := GetValidStr3(ss, sDesc, ['|']);
            if sDesc <> '' then
              dsurface.TextOut(SurfaceX(Left - 156), SurfaceY(Top + 198) + 15 * idx,FontColor, sDesc)
            else
              Break;
            Inc(idx);
          end;
          FontColor := clRed;
        end else
          FontColor := clWhite;
        dsurface.TextOut(SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 + 44 - 62), SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 - 6),FontColor, pShopItem.sItemName);
        dsurface.TextOut(SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 + 44 - 62), SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 - 6) + 15 * 1,FontColor, s);
        if g_btSellType = 0 then
          dsurface.TextOut(SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 + 44 - 62), SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 - 6) + 15 * 2,FontColor, IntToStr(pShopItem.wPrice) + '元宝')
        else
          dsurface.TextOut(SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 + 44 - 62), SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 - 6) + 15 * 2,FontColor, IntToStr(pShopItem.wPrice) + '金币');
      end;
  end;
end;

procedure TFrmDlg.DGridShop1GridSelect(Sender: TObject; X, Y, ACol,
  ARow: Integer; Shift: TShiftState);
var
  idx: Integer;
  s: string;
  d: TAsphyreLockableTexture;
begin
  g_ClickShopItem.sItemName := '';
  if g_ShopListArr[m_nShopClass].Count <= 0 then Exit;
  idx := ACol + ARow * DGridShop1.ColCount + m_nShopPage * 10;
  if (idx >= 0) and (idx < g_ShopListArr[m_nShopClass].Count) then begin
    g_ClickShopItem := pTShopItem(g_ShopListArr[m_nShopClass].Items[idx])^;
    m_nShopItemIndex := idx;
    m_nShopItemIndex2 := -1;

    m_dwShopEffectTick := GetTickCount + 200;
    m_nShopShowMaxFrame := g_ClickShopItem.wShape2;
    m_nShopShowEffectFrame := g_ClickShopItem.wShape1;
    m_nShopShowCurrentFrame := g_ClickShopItem.wShape1;

    PlaySound(s_glass_button_click);
  end;
end;

procedure TFrmDlg.DGridShop2GridPaint(Sender: TObject; ACol, ARow: Integer;
  Rect: TRect; State: TGridDrawState; DSurface: TAsphyreCanvas);
var
  idx: Integer;
  sDesc, s, ss: string;
  pShopItem: pTShopItem;
  d: TAsphyreLockableTexture;
  FontColor:tColor;
begin
  if not DCashShopDlg.Visible then Exit;
  if g_ShopListArr[5].Count <= 0 then Exit;
  idx := ACol + ARow * DGridShop2.ColCount;
  if (idx >= 0) and (idx < g_ShopListArr[5].Count) then begin
    pShopItem := pTShopItem(g_ShopListArr[5].Items[idx]);
    d := WBagItem.Images[pShopItem.wLooks];
    if d <> nil then
      with DGridShop2 do begin
        dsurface.Draw(SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 + 12), SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 - 16), d.ClientRect, d, True);
        ss := GetValidStr3(pShopItem.sExplain, s, ['|']);
        if m_nShopItemIndex2 = idx then begin
          FontColor := clWhite;
          idx := 0;
          while True do begin
            if ss = '' then
              Break;
            ss := GetValidStr3(ss, sDesc, ['|']);
            if sDesc <> '' then
              dsurface.TextOut(DGridShop1.SurfaceX(DGridShop1.Left - 156), DGridShop1.SurfaceY(DGridShop1.Top + 198) + 15 * idx,FontColor, sDesc)
            else
              Break;
            Inc(idx);
          end;
          FontColor := clRed;
        end else
          FontColor := clWhite;
        dsurface.TextOut(SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 + 44 - 65), SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 17),FontColor, pShopItem.sItemName);
        if g_btSellType = 0 then
         dsurface.TextOut(SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 + 44 - 65), SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 17) + 12 * 1,FontColor, IntToStr(pShopItem.wPrice) + '元宝')
        else
          dsurface.TextOut(SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 + 44 - 65), SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 17) + 12 * 1,FontColor, IntToStr(pShopItem.wPrice) + '金币');
      end;
  end;
end;

procedure TFrmDlg.DGridShop2GridSelect(Sender: TObject; X, Y, ACol,
  ARow: Integer; Shift: TShiftState);
var
  idx: Integer;
  s: string;
  d: TAsphyreCanvas;
begin
  g_ClickShopItem.sItemName := '';
  if g_ShopListArr[5].Count <= 0 then Exit;
  idx := ACol + ARow * DGridShop2.ColCount;
  if (idx >= 0) and (idx < g_ShopListArr[5].Count) then begin
    g_ClickShopItem := pTShopItem(g_ShopListArr[5].Items[idx])^;
    m_nShopItemIndex := -1;
    m_nShopItemIndex2 := idx;

    m_dwShopEffectTick := GetTickCount + 200;
    m_nShopShowMaxFrame := g_ClickShopItem.wShape2;
    m_nShopShowEffectFrame := g_ClickShopItem.wShape1;
    m_nShopShowCurrentFrame := g_ClickShopItem.wShape1;

    PlaySound(s_glass_button_click);
  end;
end;

procedure TFrmDlg.DGridStoreGridMouseMove(Sender: TObject; X, Y, ACol,
  ARow: Integer; Shift: TShiftState);
var
  idx, itemidx: Integer;
  temp: TClientItem;
  shint: string;
  useable: Boolean;
  hcolor: TColor;
  iname, d0, d1, d2, d3, d4: string;
  n:integer;
    FColor: tColor;
begin     //鼠标移动查看价格
  DScreen.ClearHint(true);
  if not DWHeroStore.Visible then Exit;
  if MySelf = nil then Exit;
 // DScreen.ClearHint;  //未使用该函数绘制
  idx := ACol + ARow * TDGrid(Sender).ColCount; //10个
  if idx in [0..10 - 1] then begin   //判断
    MouseItem := Myself.m_StallMgr.mBlock.Items[idx]; //取选中  交给paint绘画
    //画指针  绘制在 背包进行

     if g_bo悬浮信息 then
    begin
         //GetMouseItemInfo (iname, d0, d1, d2, d3, useable);
      GetMouseItemInfo(iname, d0, d1, d2, d3, d4, useable, FALSE);
      if iname <> '' then
      begin
        if (MouseItem.UpgradeOpt > 0) and g_bo极品蓝字 then
          hcolor := TColor($cccc33)
        else
          hcolor := clWhite;
        if useable then
        begin
          //hcolor := clWhite;
          fcolor := hcolor;
        end
        else
        begin
          //hcolor := clWhite;
          fcolor := clRed;
        end;
        if d2 <> '' then
         d2 := d2 + '|' + IntToStr(hcolor) + '$';
        if d3 <> '' then
          d3 := d3 + '|' + IntToStr(fcolor);
        if d4 <> '' then
          d4 := d4 + '|' + IntToStr(clLime);
        with DGridStore do
          DScreen.ShowHint(SurfaceX(Left + ACol * ColWidth), SurfaceY(Top + (ARow + 1) * RowHeight), iname + '|' + IntToStr(clYellow) + '\' + d0 + '\' + d1 + '\' + d2 + d3 + '\' + d4, hcolor, FALSE);
      end;
      MouseItem.S.Name := '';
    end;
  end;
end;

procedure TFrmDlg.DGridStoreGridPaint(Sender: TObject; ACol, ARow: Integer;
  Rect: TRect; State: TGridDrawState; dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  idx, ax, ay: integer;
  //-
  iname, d0, d1, d2, d3: string;
  n: integer;
  useable: Boolean;

  FColor: TColor;
  g_HintSurface_Olive:TAsphyreLockableTexture;
begin
if not DWHeroStore.Visible then Exit;
if MySelf = nil then Exit;
//  g_HintSurface_Olive := TDirectDrawSurface.Create(FrmMain.Owner);
//  g_HintSurface_Olive.SetSize(550, 550);
//  g_HintSurface_Olive.FillRect(g_HintSurface_Olive.ClientRect,clRed);
  idx := ACol + ARow * DGridStore.ColCount;
  if idx in [0..10 - 1] then
  begin

  if Myself.m_StallMgr.mBlock.Items[idx].s.Name <> '' then
   begin

      d := WBagItem.Images[Myself.m_StallMgr.mBlock.Items[idx].s.looks]; //每一个外观
      if (Myself.m_StallMgr.mBlock.Items[idx].s.OverlapItem < 1) or ((Myself.m_StallMgr.mBlock.Items[idx].s.OverlapItem > 0) and (Myself.m_StallMgr.mBlock.Items[idx].dura > 0)) then
      begin
        if d <> nil then
        with DGridStore do
        begin
        dsurface.Draw(SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1), SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1), d.ClientRect, d, TRUE);
        end;
       end;
//       if idx = g_Myself.m_StallMgr.uSelIdx then begin
//        d := g_HintSurface_Olive;
//        with DGridStore do
//          DrawBlend(dsurface,
//            SurfaceX(Rect.Left + (ColWidth - 38) div 2 - 1),
//            SurfaceY(Rect.Top + (RowHeight - 36) div 2 + 1),
//            d, 0, 0,
//            36,
//            34, 0);
//      end;

    end;
  end;
end;


procedure TFrmDlg.DGridStoreGridSelect(Sender: TObject; X, Y, ACol,
  ARow: Integer; Shift: TShiftState);
var
  idx, mi: Integer;
  temp: TClientItem;
  MsgResult, Count: Integer;
  valstr: string;
  keyvalue: TKeyBoardState;
begin   //物品移入事件
if MySelf = nil then Exit;
  begin
    FillChar(keyvalue, SizeOf(TKeyBoardState), #0);
    GetKeyboardState(keyvalue);
    idx := ACol + ARow * DGridStore.ColCount;  //取位置
    if idx in [0..10 - 1] then begin   //判断是否0.。10
      if not ItemMoving then   //直接覆盖？
      begin //是否移动
        if MySelf.m_StallMgr.OnSale then //
        begin
        //
        Exit;
        end;
        if Myself.m_StallMgr.mBlock.Items[idx].s.Name <> '' then begin //覆盖？
          ItemMoving := True;
          MovingItem.Index := idx + STALL_MIIDX_OFFSET; //设置 卖？
          MovingItem.item := Myself.m_StallMgr.mBlock.Items[idx];//取回？
          Myself.m_StallMgr.mBlock.Items[idx].s.Name := ''; //拿走清空
         ItemClickSound(Myself.m_StallMgr.mBlock.Items[idx].s); //播放声音
        end;
      end
      else
      begin
        if MySelf.m_StallMgr.OnSale then
        begin
        CancelItemMoving;
        Exit;
        end;
        mi := MovingItem.Index;//客户端 网格坐标
        //DScreen.AddChatBoardString(IntToStr(mi) + ' - ' + g_MovingItem.item.s.Name, clWhite, clRed);
        if MovingItem.item.s.Name <> '' then begin  //如果有物品
          if mi in [6..MAXBAGITEM - 1] then begin //46个？
            if CanAddStallItem() then begin //判断满了否
              //if not g_Myself.m_StallMgr.OnSale or (g_WaitingStallItem.item.s.Name = '') then begin
              g_WaitingStallItem := MovingItem;  //用来判断价格
              CancelItemMoving;//返回物品
              DEditStoreItemPrice.Text := ''; //清空价格标签
              DBStorePage1Click(DBStorePage2,0,0);
              DEditStoreItemPrice.Visible:=True;
              DWStoreItemPrice.Visible := True;//开价格界面
              DEditStoreItemPrice.SetFocus;
              //end;
            end
            else
            begin
              DMessageDlg('摊位已满，无法继续添加物品！', [mbOk, mbCancel]);
              CancelItemMoving;//返回物品 满了不反回？？ bug
            end;
          end
          else
          if IsStallItem(mi) then //取回
          begin
            AddStallItem(MovingItem.item); //物品清理
            ItemMoving := False;  //
            MovingItem.item.s.Name := '';//
          end;
        end;
      end;
    end;
    //ArrangeItembag;
  end;
end;

procedure TFrmDlg.DGroupDlgDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  lx, ly, n: integer;
begin
  with DGroupDlg do
  begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
    if GroupMembers.Count > 0 then
    begin
      with dsurface do
      begin
            //SetBkMode (Handle, TRANSPARENT);
//            Font.Color := clSilver;
        lx := SurfaceX(28) + Left;
        ly := SurfaceY(80) + Top;
        TextOut(lx, ly, clSilver, GroupMembers[0]);
        for n := 1 to GroupMembers.Count - 1 do
        begin
          lx := SurfaceX(28) + Left + ((n - 1) mod 2) * 100;
          ly := SurfaceY(80 + 16) + Top + ((n - 1) div 2) * 16;
          TextOut(lx, ly, clSilver, GroupMembers[n]);
        end;
            //Release;
      end;
    end;
  end;
end;

procedure TFrmDlg.DGrpDlgCloseClick(Sender: TObject; X, Y: Integer);
begin
  DGroupDlg.Visible := FALSE;
end;

procedure TFrmDlg.DGrpAllowGroupDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with Sender as TDButton do
  begin
    if AllowGroup then
    begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
    end;
  end;
end;

procedure TFrmDlg.DGrpAllowGroupClick(Sender: TObject; X, Y: Integer);
begin

  if GetTickCount > changegroupmodetime then
  begin
    AllowGroup := not AllowGroup;
    changegroupmodetime := GetTickCount + 2000; //timeout 5秒 //DelayTime 5到 2秒修正 //2004/11/18
    FrmMain.SendGroupMode(AllowGroup);
  end;
end;

procedure TFrmDlg.DGrpCreateClick(Sender: TObject; X, Y: Integer);
var
  who: string;
begin
  if (GetTickCount > changegroupmodetime) and (GroupMembers.Count = 0) then
  begin
    DialogSize := 1;
    DMessageDlg('输入你想加入编组的人的名字。', [mbOk, mbAbort]);
    who := Trim(DlgEditText);
    if who <> '' then
    begin
      changegroupmodetime := GetTickCount + 2000; //timeout 5檬 //DelayTime 5檬俊辑 2檬肺修正 //2004/11/18
      FrmMain.SendCreateGroup(Trim(DlgEditText));
    end;
  end;
end;

procedure TFrmDlg.DGrpAddMemClick(Sender: TObject; X, Y: Integer);
var
  who: string;
begin
  if (GetTickCount > changegroupmodetime) and (GroupMembers.Count > 0) then
  begin
    DialogSize := 1;
    DMessageDlg('输入你想加入编组的人的名字。', [mbOk, mbAbort]);
    who := Trim(DlgEditText);
    if who <> '' then
    begin
      changegroupmodetime := GetTickCount + 2000; //timeout 5檬 //DelayTime 5檬俊辑 2檬肺修正 //2004/11/18
      FrmMain.SendAddGroupMember(Trim(DlgEditText));
    end;
  end;
end;

procedure TFrmDlg.DGrpDelMemClick(Sender: TObject; X, Y: Integer);
var
  who: string;
begin
  if (GetTickCount > changegroupmodetime) and (GroupMembers.Count > 0) then
  begin
    DialogSize := 1;
    DMessageDlg('输入你想从编组中删除的人的名字。', [mbOk, mbAbort]);
    who := Trim(DlgEditText);
    if who <> '' then
    begin
      changegroupmodetime := GetTickCount + 2000; //timeout 5檬 //DelayTime 5檬俊辑 2檬肺修正 //2004/11/18
      FrmMain.SendDelGroupMember(Trim(DlgEditText));
    end;
  end;
end;

procedure TFrmDlg.DBotLogoutClick(Sender: TObject; X, Y: Integer);
begin
   if g_bo战斗退出 then
   begin
       FrmMain.AppLogOut;
   end;
  if (not g_bo战斗退出) then
   begin
     if (GetTickCount - LatestStruckTime > 10000) and
        (GetTickCount - LatestMagicTime > 10000) and
        (GetTickCount - LatestHitTime > 10000) or
        (Myself.Death) then
      begin
          LocalLanguage := imSAlpha;
          FrmMain.SendClientMessage(CM_CANCLOSE, 0, 0, 0, 0);//发送给服务器 我要退，如果pk 不允许退
      end else
        DScreen.AddChatBoardString ('在战斗的时候你不能退出游戏', clYellow, clRed);
   end;
end;

procedure TFrmDlg.DBotExitClick(Sender: TObject; X, Y: Integer);
begin
   if g_bo战斗退出 then
   begin
       FrmMain.AppExit;
   end;
   if (not g_bo战斗退出) then
   begin
     if (GetTickCount - LatestStruckTime > 10000) and
        (GetTickCount - LatestMagicTime > 10000) and
        (GetTickCount - LatestHitTime > 10000) or
        (Myself.Death) then
      begin
        FrmMain.AppExit;
      end else
        DScreen.AddChatBoardString('在战斗的时候你不能退出游戏', clYellow, clRed);
   end;
end;

procedure TFrmDlg.DBotPlusAbilClick(Sender: TObject; X, Y: Integer);
begin
  FrmDlg.OpenAdjustAbility;
end;


{------------------------------------------------------------------------}

//背券 促捞倔肺弊

{------------------------------------------------------------------------}

procedure TFrmDlg.OpenDealDlg(DealCase: Byte);
var
  d: TAsphyreCanvas;
begin
  if DealCase = 1 then
  begin
    DDealDlg.Floating := True;
    DDealRemoteDlg.Floating := True;
    DDealRemoteDlg.Left := g_FScreenWidth - 236 - 100;
    DDealRemoteDlg.Top := 0;
    DDealDlg.Left := g_FScreenWidth - 236 - 100;
    DDealDlg.Top := DDealRemoteDlg.Height;
    DDealJangwon.Visible := False;
  end
  else if DealCase = 2 then
  begin
    DDealJangwon.Floating := False;
    DDealJangwon.Visible := True;
    DDealDlg.Floating := False;
    DDealRemoteDlg.Floating := False;
    DDealRemoteDlg.Left := 548;
    DDealRemoteDlg.Top := 202;
    DDealDlg.Left := 312;
    DDealDlg.Top := 202;
  end;
  DItemBag.Left := 0; //475;
  DItemBag.Top := 0;
  DItemBag.Visible := TRUE;
  DDealDlg.Visible := TRUE;
  DDealRemoteDlg.Visible := TRUE;

  FillCHar(DealItems, sizeof(TClientItem) * 10, #0);
  FillCHar(DealRemoteItems, sizeof(TClientItem) * 20, #0);
  DealGold := 0;
  DealRemoteGold := 0;
  BoDealEnd := FALSE;

   //物品包中的残留影像检查
  ArrangeItembag;
end;

procedure TFrmDlg.CloseDealDlg;
begin
  DDealDlg.Visible := FALSE;
  DDealRemoteDlg.Visible := FALSE;
  if DDealJangwon.Visible then
    DDealJangwon.Visible := False;

   //物品包中的残留影像检查
  ArrangeItembag;
end;

procedure TFrmDlg.DDealOkClick(Sender: TObject; X, Y: Integer);
var
  mi: integer;
begin
  if GetTickCount > dealactiontime then
  begin
      //CloseDealDlg;
    FrmMain.SendDealEnd;
    dealactiontime := GetTickCount + 4000;
    BoDealEnd := TRUE;
      //交易窗口中用鼠标拖在交易窗口鼠标的残留影像(复制)
    if ItemMoving then
    begin
      mi := MovingItem.Index;
      if (mi <= -20) and (mi > -30) then
      begin //窗口中去的
        AddDealItem(MovingItem.Item);  // 交换=>干涩
        ItemMoving := FALSE;
        MovingItem.Item.S.name := '';
        MovingItem.Item.Dura := 0; // 10/29
      end;
    end;
  end;
end;

procedure TFrmDlg.DDealCloseClick(Sender: TObject; X, Y: Integer);
begin
  if GetTickCount > dealactiontime then
  begin
    CloseDealDlg;
    FrmMain.SendCancelDeal;
  end;
end;

procedure TFrmDlg.DDealRemoteDlgDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with DDealRemoteDlg do
  begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
    with dsurface do
    begin
         //SetBkMode (Handle, TRANSPARENT);
//         Font.Color := clWhite;
      TextOut(SurfaceX(Left + 64), SurfaceY(Top + 196 - 65), clWhite, GetGoldStr(DealRemoteGold));
//         TextOut (SurfaceX(Left+(110-(TextWidth(FrmMain.CharName)div 2))), SurfaceY(Top+3)+5, DealWho);
      TextOut(SurfaceX(Left + 59 + (106 - FontManager.Default.TextWidth(DealWho)) div 2), SurfaceY(Top + 3) + 3, clWhite, DealWho);
         //Release;
    end;
  end;
end;

procedure TFrmDlg.DDealDlgDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with DDealDlg do
  begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
    with dsurface do
    begin
         //SetBkMode (Handle, TRANSPARENT);
//         Font.Color := clWhite;
      TextOut(SurfaceX(Left + 64), SurfaceY(Top + +196 - 65), clWhite, GetGoldStr(DealGold));
//         TextOut (SurfaceX(Left+(110-(TextWidth(FrmMain.CharName)div 2))), SurfaceY(Top+3)+5, FrmMain.CharName);
      TextOut(SurfaceX(Left + 59 + (106 - FontManager.Default.TextWidth(FrmMain.CharName)) div 2), SurfaceY(Top + 3) + 3, clWhite, FrmMain.CharName);
         //Release;
    end;
  end;
end;

procedure TFrmDlg.DealItemReturnBag(mitem: TClientItem);
begin
  if not BoDealEnd then
  begin
    DealDlgItem := mitem;
    FrmMain.SendDelDealItem(DealDlgItem);
    dealactiontime := GetTickCount + 4000;
  end;
end;

procedure TFrmDlg.DDGridGridSelect(Sender: TObject; X, Y: integer; ACol, ARow: Integer; Shift: TShiftState);
var
  temp: TClientItem;
  mi, idx: integer;
  MsgResult, Count: integer;
  valstr: string;
begin
  if not BoDealEnd and (GetTickCount > dealactiontime) then
  begin
      //2004/01/15 ItemSafeGuard..
    if not ItemMoving then
    begin
//         idx := ACol + ARow * DDGrid.ColCount;
//         if idx in [0..9] then begin
//            if DealItems[idx].S.Name <> '' then begin
//               ItemMoving := TRUE;
//               MovingItem.Index := -idx - 20;
//               MovingItem.Item := DealItems[idx];
//               DealItems[idx].S.Name := '';
//               ItemClickSound (MovingItem.Item.S);
//            end;
//         end;
    end
    else
    begin

      mi := MovingItem.Index;
        if IsDetectItem(mi) then begin
          g_WaitingDetectItem := MovingItem;
          ItemMoving := False;
          MovingItem.Index := 0;
          MovingItem.item.s.Name := '';
          //20191314
//          DefMsg := EDcode.MakeDefaultMsg(CM_MoveDetectItem, g_WaitingDetectItem.item.MakeIndex, 0, 0, 0);
//          frmMain.SendSocket(EncodeMessage(DefMsg));
//          Exit;
        end;


        if IsStallItem(mi) then begin
//          if Myself.m_StallMgr.OnSale then begin  //检测状态
//            //if g_WaitingStallItem.Item.s.Name <> '' then exit;
//            g_WaitingStallItem := g_MovingItem;
//            g_boItemMoving := False;
//            g_MovingItem.Index := 0;
//            g_MovingItem.item.s.Name := '';
//
//            StallItem.MakeIndex := g_WaitingStallItem.item.MakeIndex;
////            DefMsg := EDcode.MakeDefaultMsg(CM_UPDATESTALLITEM, 0, 0, 0, 0);
////            frmMain.SendSocket(EncodeMessage(DefMsg) + EncodeBuffer(@StallItem, SizeOf(StallItem)));
//          end else begin
////            UpdateBagStallItem(g_MovingItem.item, 0);
////            DelStallItem(g_MovingItem.item);
//            ItemMoving := False;
//            MovingItem.Index := 0;
//            MovingItem.item.s.Name := '';
//          end;
//          Exit;
        end;
        if (DDealDlg.Visible) then begin
          if (mi >= 0) and (mi < 6) then begin
            CancelItemMoving;
            DMessageDlg('[注意] 交易时不能将物品放到包裹中', [mbOk]);
            Exit;
          end;
        end;

      if (mi >= 0) or (mi <= -20) and (mi > -30) then
      begin //啊规,俊辑 柯巴父
        ItemClickSound(MovingItem.Item.S);
        ItemMoving := FALSE;
        if mi >= 0 then
        begin
          if MovingItem.Item.S.OverlapItem > 0 then
          begin

            Total := MovingItem.Item.Dura;
            if Total = 1 then
            begin
              DlgEditText := '1';
              MsgResult := mrOk;
            end
            else
              MsgResult := DCountMsgDlg('当前数量 ' + IntToStr(MovingItem.Item.Dura) + ' 个.\你将交易多少件?', [mbOk, mbCancel, mbAbort]);
            GetValidStrVal(DlgEditText, valstr, [' ']);
            Count := Str_ToInt(valstr, 0);
            if Count <= 0 then
              Count := 0;
            if Count > MovingItem.Item.Dura then
            begin
              Count := MovingItem.Item.Dura;
            end;
            ItemMoving := TRUE;
            if MsgResult = mrOk then
            begin //and (Count > 0) and (Count < MAX_OVERLAPITEM+1 ) then begin
              DealDlgItem := MovingItem.Item; //服务器等待结果期间保管
              DealDlgItem.Dura := word(Count);
              MovingItem.Item.Dura := MovingItem.Item.Dura - Count;
              if MovingItem.Item.Dura = 0 then
              begin
                MovingItem.Item.S.name := '';
                ItemMoving := FALSE;
              end;
              CancelItemMoving;
              FrmMain.SendAddDealItem(DealDlgItem);
              dealactiontime := GetTickCount + 4000;
            end
            else if MsgResult = mrCancel then
            begin
              CancelItemMoving;
              dealactiontime := GetTickCount;
            end;
          end
          else
          begin
            DealDlgItem := MovingItem.Item;
            FrmMain.SendAddDealItem(DealDlgItem);
            dealactiontime := GetTickCount + 4000;
          end;
        end
        else
          AddDealItem(MovingItem.Item);
        MovingItem.Item.S.name := '';
      end;
//      if mi = -98 then
//        DDGoldClick(nil, 0, 0);
    end;
    ArrangeItemBag;
  end;
end;

procedure TFrmDlg.DCountDlgKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);
begin
  if Key = 13 then
  begin
    if DCountDlgOk.Visible then
    begin
      DCountDlg.DialogResult := mrOk;
      DCountDlg.Visible := FALSE;
    end;
  end;
  if Key = 27 then
  begin
    if DCountDlgCancel.Visible then
    begin
      DCountDlg.DialogResult := mrCancel;
      DCountDlg.Visible := FALSE;
    end;
  end;
end;

procedure TFrmDlg.DDGridGridPaint(Sender: TObject; ACol, ARow: Integer; Rect: TRect; State: TGridDrawState; dsurface: TAsphyreCanvas);
var
  idx: integer;
  d: TAsphyreLockableTexture;
begin
  idx := ACol + ARow * DDGrid.ColCount;
  if idx in [0..9] then
  begin
    if DealItems[idx].s.Name <> '' then
    begin
      d := WBagItem.Images[DealItems[idx].s.Looks];
      if d <> nil then
        with DDGrid do
          dsurface.Draw(SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1), SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1), d.ClientRect, d, TRUE);
         // 酒捞袍 般摹扁
      if DealItems[idx].s.OverlapItem > 0 then
      begin
            //SetBkMode (g_DXCanvas.Handle, TRANSPARENT);
//            g_DXCanvas.Font.Color := clYellow;

        dsurface.TextOut(DDGrid.SurfaceX(Rect.Left + 20), DDGrid.SurfaceY(Rect.Top + 20), clYellow, IntToStr(DealItems[idx].dura));
//            g_DXCanvas.//Release;
      end;
    end;
  end;
end;

procedure TFrmDlg.DDGoldClick(Sender: TObject; X, Y: Integer);
var
  dgold: integer;
  valstr: string;
begin
  if Myself = nil then
    exit;
  if not BoDealEnd and (GetTickCount > dealactiontime) then
  begin
    if not ItemMoving then
    begin
//      if DealGold > 0 then
//      begin
//        PlaySound(s_money);
//        ItemMoving := TRUE;
//        MovingItem.Index := -97; //背券 芒俊辑狼 捣
//        MovingItem.Item.S.Name := '金币';
//      end;
    end
    else
    begin
      if (MovingItem.Index = -97) or (MovingItem.Index = -98) then
      begin //捣父..
        if (MovingItem.Index = -98) then
        begin //啊规芒俊辑 柯 捣
          if MovingItem.Item.S.Name = '金币' then
          begin
                  //倔付甫 滚副 扒瘤 拱绢夯促.
            DialogSize := 1;
            ItemMoving := FALSE;
            MovingItem.Item.S.Name := '';
            DMessageDlg('你想支付多少金币？', [mbOk, mbAbort]);
            GetValidStrVal(DlgEditText, valstr, [' ']);
            dgold := Str_ToInt(valstr, 0);
            if (dgold <= (DealGold + Myself.Gold)) and (dgold > 0) then
            begin
              FrmMain.SendChangeDealGold(dgold);
              dealactiontime := GetTickCount + 4000;
            end
            else
              dgold := 0;
          end;
        end;
        ItemMoving := FALSE;
        MovingItem.Item.S.Name := '';
      end;
    end;
  end;
end;

procedure TFrmDlg.DDGridGridMouseMove(Sender: TObject; X, Y: integer; ACol, ARow: Integer; Shift: TShiftState);
var
  idx: integer;
  temp: TClientItem;
  iname, d0, d1, d2, d3, d4: string;
  useable: Boolean;
  hcolor, fcolor: TColor;
begin
  DScreen.ClearHint(True);
  idx := ACol + ARow * DDGrid.ColCount;
  if idx in [0..9] then
  begin
    MouseItem := DealItems[idx];
    if g_bo悬浮信息 then
    begin
         //GetMouseItemInfo (iname, d0, d1, d2, d3, useable);
      GetMouseItemInfo(iname, d0, d1, d2, d3, d4, useable, FALSE);
      if iname <> '' then
      begin
        if (MouseItem.UpgradeOpt > 0) and g_bo极品蓝字 then
          hcolor := TColor($cccc33)
        else
          hcolor := clWhite;
        if useable then
        begin
          //hcolor := clWhite;
          fcolor := hcolor;
        end
        else
        begin
          //hcolor := clWhite;
          fcolor := clRed;
        end;
        if d2 <> '' then
         d2 := d2 + '|' + IntToStr(hcolor) + '$';
        if d3 <> '' then
          d3 := d3 + '|' + IntToStr(fcolor);
        with DDGrid do
          DScreen.ShowHint(SurfaceX(Left + ACol * ColWidth), SurfaceY(Top + (ARow + 1) * RowHeight), iname + '|' + IntToStr(clYellow) + '\' + d0 + '\' + d1 + '\' + d2 + d3, hcolor, FALSE);
      end;
      MouseItem.S.Name := '';
    end;
  end;
end;

procedure TFrmDlg.DDRGridGridPaint(Sender: TObject; ACol, ARow: Integer; Rect: TRect; State: TGridDrawState; dsurface: TAsphyreCanvas);
var
  idx: integer;
  i, k: integer;
  d: TAsphyreLockableTexture;
begin

   //吝汗等 酒捞袍捞 乐栏搁 绝矩促.
  for i := 0 to 19 do
  begin
    if DealRemoteItems[i].s.Name <> '' then
    begin
      for k := i + 1 to 19 do
      begin
        if DealRemoteItems[i].s.OverlapItem > 0 then
        begin
          if (DealRemoteItems[i].s.Name = DealRemoteItems[k].s.Name) then
          begin //(ItemArr[i].MakeIndex <> ItemArr[k].MakeIndex) and
            DealRemoteItems[i].dura := DealRemoteItems[i].dura + DealRemoteItems[k].dura;
            FillChar(DealRemoteItems[k], sizeof(TClientItem), #0);
          end;
        end
        else if (DealRemoteItems[i].s.Name = DealRemoteItems[k].s.Name) and (DealRemoteItems[i].MakeIndex = DealRemoteItems[k].MakeIndex) then
        begin
          FillChar(DealRemoteItems[k], sizeof(TClientItem), #0);
        end;
      end;
    end;
  end;

  idx := ACol + ARow * DDRGrid.ColCount;
  if idx in [0..19] then
  begin
    if DealRemoteItems[idx].s.Name <> '' then
    begin
      d := WBagItem.Images[DealRemoteItems[idx].s.Looks];
      if d <> nil then
        with DDRGrid do
          dsurface.Draw(SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1), SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1), d.ClientRect, d, TRUE);
         // 酒捞袍 般摹扁
      if DealRemoteItems[idx].s.OverlapItem > 0 then
      begin
            //SetBkMode (g_DXCanvas.Handle, TRANSPARENT);
//            g_DXCanvas.Font.Color := clYellow;

        dsurface.TextOut(DDRGrid.SurfaceX(Rect.Left + 20), DDRGrid.SurfaceY(Rect.Top + 20), clYellow, IntToStr(DealRemoteItems[idx].dura));
//            g_DXCanvas.//Release;
      end;

    end;
  end;
end;

procedure TFrmDlg.DDRGridGridMouseMove(Sender: TObject; X, Y: integer; ACol, ARow: Integer; Shift: TShiftState);
var
  idx: integer;
  temp: TClientItem;
  iname, d0, d1, d2, d3, d4: string;
  useable: Boolean;
  hcolor, fcolor: TColor;
begin
  DScreen.ClearHint(True);
  idx := ACol + ARow * DDRGrid.ColCount;
  if idx in [0..19] then
  begin
    MouseItem := DealRemoteItems[idx];

    if g_bo悬浮信息 then
    begin
         //GetMouseItemInfo (iname, d0, d1, d2, d3, useable);
      GetMouseItemInfo(iname, d0, d1, d2, d3, d4, useable, FALSE);
      if iname <> '' then
      begin
        if (MouseItem.UpgradeOpt > 0) and g_bo极品蓝字 then
          hcolor := TColor($cccc33)
        else
          hcolor := clWhite;
        if useable then
        begin
          //hcolor := clWhite;
          fcolor := hcolor;
        end
        else
        begin
          //hcolor := clWhite;
          fcolor := clRed;
        end;
        if d2 <> '' then
         d2 := d2 + '|' + IntToStr(hcolor) + '$';
        if d3 <> '' then
          d3 := d3 + '|' + IntToStr(fcolor);
        with DDRGrid do
          DScreen.ShowHint(SurfaceX(Left + ACol * ColWidth), SurfaceY(Top + (ARow + 1) * RowHeight), iname + '|' + IntToStr(clYellow) + '\' + d0 + '\' + d1 + '\' + d2 + d3, hcolor, FALSE);
      end;
      MouseItem.S.Name := '';
    end;
  end;
end;

procedure TFrmDlg.DealZeroGold;
begin
  if not BoDealEnd and (DealGold > 0) then
  begin
    dealactiontime := GetTickCount + 4000;
    FrmMain.SendChangeDealGold(0);
  end;
end;
{--------------------------------------------------------------}
procedure TFrmDlg.DUserState1DirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  i, l, m, pgidx, bbx, bby, idx, ax, ay, sex, hair, tx: integer;
  d: TAsphyreLockableTexture;
  hcolor, keyimg, TempTop: integer;
  iname, d1, d2, d3, d4, d5, str: string;
  useable: Boolean;
  FColor: tColor;
begin
  with DUserState1 do
  begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

      //观察别人的装备(着装状态)
    sex := DRESSfeature(UserState1.Feature) mod 2;
    hair := HAIRfeature(UserState1.Feature);
    if sex = 1 then
//      if g_bo人物四格 then
//       pgidx := 91
//       else

         if (g_bo人物四格)and (not g_bochksigedu) then
           pgidx := 91
           else
         if (g_bo人物四格) and (g_bochksigedu) then    
             pgidx := 805
             else
      pgidx := 377   //女
    else
//      if g_bo人物四格 then
//        pgidx := 90
//        else
          if (g_bo人物四格)and (not g_bochksigedu) then
          pgidx := 90
          else 
         if (g_bo人物四格) and (g_bochksigedu) then    
          pgidx := 804
          else
      pgidx := 376;     //男
    bbx := Left + 38;
    bby := Top + 52;
    d := WProgUse.Images[pgidx];
    if d <> nil then
      dsurface.Draw(SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, FALSE);
    bbx := bbx - 7;
    bby := bby + 44;

    if UserState1.UseItems[U_DRESS].s.Name <> '' then
    begin
      idx := UserState1.UseItems[U_DRESS].s.Looks; //衣服 if Sex = 1 then idx := 80; //女衣服
      if idx >= 0 then
      begin
        d := WStateItem.GetCachedImage(idx, ax, ay);
        if d <> nil then
          dsurface.Draw(SurfaceX(bbx + ax), SurfaceY(bby + ay), d.ClientRect, d, TRUE);
      end;
    end;

      //衣服, 武器, 发型
    idx := 440 + hair div 2; //发型
    if sex = 1 then
      idx := 480 + hair div 2;

    if idx > 0 then
    begin
      d := WProgUse.GetCachedImage(idx, ax, ay);
      if d <> nil then
        dsurface.Draw(SurfaceX(bbx + ax), SurfaceY(bby + ay), d.ClientRect, d, TRUE);
    end;

    if UserState1.UseItems[U_WEAPON].s.Name <> '' then
    begin
      idx := UserState1.UseItems[U_WEAPON].s.Looks;
      if idx >= 0 then
      begin
        d := WStateItem.GetCachedImage(idx, ax, ay);
        if d <> nil then
          dsurface.Draw(SurfaceX(bbx + ax), SurfaceY(bby + ay), d.ClientRect, d, TRUE);
      end;
      if idx = 923 then
      begin
        d := WStateItem.GetCachedImage(idx - 1, ax, ay);
        if d <> nil then
          dsurface.DrawBlend(SurfaceX(bbx + ax), SurfaceY(bby + ay), d, 1);
      end;
    end;
    if UserState1.UseItems[U_HELMET].s.Name <> '' then
    begin
      idx := UserState1.UseItems[U_HELMET].s.Looks;
      if idx >= 0 then
      begin
        d := WStateItem.GetCachedImage(idx, ax, ay);
        if d <> nil then
          dsurface.Draw(SurfaceX(bbx + ax), SurfaceY(bby + ay), d.ClientRect, d, TRUE);
      end;
    end;
      //原为打开，显示其它人物信息里的装备信息，显示在人物下方
    if MouseUserStateItem.S.Name <> '' then
    begin
      MouseItem := MouseUserStateItem;
      GetMouseItemInfo(iname, d1, d2, d3, d4, d5, useable, FALSE);
      if (iname <> '') and not g_bo悬浮信息 then
      begin
        if MouseItem.Dura = 0 then
          hcolor := clRed
//            else if MouseItem.UpgradeOpt > 0 then hcolor := clAqua //@@@@@
//        else if MouseItem.UpgradeOpt > 0 then     / 极品蓝色  别人身上
//          hcolor := TColor($cccc33)              // 极品蓝色  别人身上
        else
           if (MouseItem.UpgradeOpt > 0) and g_bo极品蓝字 then
           hcolor := TColor($cccc33)
           else
          hcolor := clWhite;
        if g_bo人物四格 then
          TempTop := 38
          else
          TempTop := 0;
        with dsurface do
        begin
               //SetBkMode (Handle, TRANSPARENT);
          FColor := clYellow;
          TextOut(SurfaceX(Left + 37), SurfaceY(Top + 272) + TempTop, FColor, iname);
          FColor := hcolor;
          TextOut(SurfaceX(Left + 37 + FontManager.Default.TextWidth(iname)), SurfaceY(Top + 272) + TempTop, FColor, d1); //+35
          TextOut(SurfaceX(Left + 37), SurfaceY(Top + 272 + FontManager.Default.TextHeight('A') + 2) + TempTop, FColor, d2);
          TextOut(SurfaceX(Left + 37), SurfaceY(Top + 272 + (FontManager.Default.TextHeight('A') + 2) * 2) + TempTop, FColor, d3 + d4);
               //Release;
        end;

            // 2003/03/15 显示在上面
            //Str := iname + d1 + '\' + d2 + '\' + d3 + d4;
            //DScreen.ShowHint(MouseX, MouseY, Str, hcolor, FALSE);
      end;
      MouseItem.S.Name := '';
    end
    else if not UserState1.bExistLover then
      DScreen.ClearHint(True); //@@@@@

      //名字和行会
    with dsurface do
    begin
         //SetBkMode (Handle, TRANSPARENT);
      FColor := UserState1.NameColor;
      TextOut(SurfaceX(Left + 122 - FontManager.Default.TextWidth(UserState1.UserName) div 2), SurfaceY(Top + 23), FColor, UserState1.UserName);
      FColor := clSilver;
      TextOut(SurfaceX(Left + 45), SurfaceY(Top + 58), FColor, UserState1.GuildName + ' ' + UserState1.GuildRankName);
      tx := 122 - FontManager.Default.TextWidth(UserState1.UserName) div 2;
         //Release;
    end;

  end;
  DHeartImgUS.Left := tx - 14;
  DHeartImgUS.Top := 24; //@@@@@

end;

procedure TFrmDlg.DUserState1MouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  X := DUserState1.LocalX(X) - DUserState1.Left;
  Y := DUserState1.LocalY(Y) - DUserState1.Top;
  if (X > 42) and (X < 201) and (Y > 54) and (Y < 71) then
  begin
      //DScreen.AddSysMsg (IntToStr(X) + ' ' + IntToStr(Y) + ' ' + UserState1.GuildName);
    if UserState1.GuildName <> '' then
    begin
      FrmDlg.DEdChat.Visible := TRUE;
      FrmDlg.DEdChat.SetFocus;
//      SetImeMode(FrmDlg.EdChat.Handle, LocalLanguage);
      FrmDlg.DEdChat.Text := UserState1.GuildName;
      FrmDlg.DEdChat.ChangeCurPos(AnsiTextLength(FrmDlg.DEdChat.Text), True);
      FrmDlg.DEdChat.SelStart := AnsiTextLength(FrmDlg.DEdChat.Text);
      FrmDlg.DEdChat.SelLength := 0;
    end;
  end
  else if (X > 80) and (X < 160) and (Y > 18) and (Y < 38) then
  begin
    if UserState1.UserName <> '' then
    begin
      FrmDlg.DEdChat.Visible := TRUE;
      FrmDlg.DEdChat.SetFocus;
//      SetImeMode(FrmDlg.EdChat.Handle, LocalLanguage);
      FrmDlg.DEdChat.Text := '/' + UserState1.UserName + ' ';
      FrmDlg.DEdChat.ChangeCurPos(AnsiTextLength(FrmDlg.DEdChat.Text), True);
      FrmDlg.DEdChat.SelStart := AnsiTextLength(FrmDlg.DEdChat.Text);
      FrmDlg.DEdChat.SelLength := 0;
    end;
  end;

end;

procedure TFrmDlg.DUserState1MouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
begin
  DScreen.ClearHint(True);
  MouseUserStateItem.S.Name := '';
  if UserState1.bExistLover then
  begin
    X := DUserState1.LocalX(X) - DUserState1.Left;
    Y := DUserState1.LocalY(Y) - DUserState1.Top;
    if (X > 80) and (X < 160) and (Y > 18) and (Y < 38) then
      DScreen.ShowHint(DUserState1.Left + DHeartImgUS.Left + 10, DUserState1.Top + DHeartImgUS.Top + 14, UserState1.LoverName + '的爱人', clWhite, FALSE)
    else if Y < 200 then
      DScreen.ClearHint(True);
  end;

end;

procedure TFrmDlg.DWeaponUS1MouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  sel: integer;
  iname, d0, d1, d2, d3, d4: string;
  useable, TempB: Boolean;
  hcolor, fcolor: TColor;
  lx, ly, htx, hty: integer;
begin
  sel := -1;
  if MySelf =nil  then  exit;

        if MySelf.m_StallMgr.OnSale then //
        begin
        //
        Exit;
        end;

  if Sender = DDressUS1 then
    sel := U_DRESS;
  if Sender = DWeaponUS1 then
    sel := U_WEAPON;
  if Sender = DHelmetUS1 then
    sel := U_HELMET;
  if Sender = DNecklaceUS1 then
    sel := U_NECKLACE;
  if Sender = DLightUS1 then
    sel := U_RIGHTHAND;
  if Sender = DRingLUS1 then
    sel := U_RINGL;
  if Sender = DRingRUS1 then
    sel := U_RINGR;
  if Sender = DArmRingLUS1 then
    sel := U_ARMRINGL;
  if Sender = DArmRingRUS1 then
    sel := U_ARMRINGR;
   // 2003/03/15 酒捞袍 牢亥配府 犬厘
  if Sender = DBujukUS1 then
    sel := U_BUJUK;
  if Sender = DBeltUS1 then
    sel := U_BELT;
  if Sender = DBootsUS1 then
    sel := U_BOOTS;
  if Sender = DCharmUS1 then
    sel := U_CHARM;
  if Sender = UserButTrans then
    sel := U_TRANS;

  if sel >= 0 then
  begin
    MouseUserStateItem := UserState1.UseItems[sel];
      // 2003/03/15 酒捞袍 牢亥配府 犬厘
    MouseX := DUserState1.Left + X;
    MouseY := DUserState1.Top + Y;

    htx := DUserState1.SurfaceX(DUserState1.left);
    if htx < 100 then
    begin
      TempB := False;
      htx := htx + DUserState1.Width;
    end
    else TempB := True;
    hty := DUserState1.Surfacey(DUserState1.Top) + 45;
    if g_bo悬浮信息 then
    begin
       MouseItem := UserState1.UseItems[sel];
      //GetMouseItemInfo (iname, d1, d2, d3, useable);
      GetMouseItemInfo(iname, d0, d1, d2, d3, d4, useable, FALSE);
      if iname <> '' then begin
        if (MouseItem.UpgradeOpt > 0) and g_bo极品蓝字 then
          hcolor := TColor($cccc33)
        else
          hcolor := clWhite;
        if useable then
        begin
          //hcolor := clWhite;
          fcolor := hcolor;
        end
        else
        begin
          //hcolor := clWhite;
          fcolor := hcolor;
        end;
        if d2 <> '' then
         d2 := d2 + '|' + IntToStr(hcolor) + '$';
        if d3 <> '' then
          d3 := d3 + '|' + IntToStr(fcolor);
        with UserState1 do
          DScreen.ShowHint(htx, hty, iname + '|' + IntToStr(clYellow) + '\' + d0 + '\' + d1 + '\' + d2 + d3, hcolor, FALSE, False, TempB);
      end;
      MouseItem.S.Name := '';
    end;
  end;

end;

procedure TFrmDlg.DxEdit_Items_Search_OnTextChanged(Sender: TObject; sText: string);
var
  i, ii, idx: Integer;
  p, p2: pTCItemRule;
  AList: TStringlist;
begin
//  if sText = '' then begin
//    for i := Low(g_caItems) to High(g_caItems) do
//      g_caItems[i] := g_caItems2[i];
//    Exit;
//  end;
//  FillChar(g_caItems, SizeOf(g_caItems), 0);
//  p := pTCItemRule(g_ItemsFilter_All.GetValues(sText));
//  if p <> nil then begin
//    g_ptItems_Pos := 0;
//    //DMoveButton_items.UpdatePos(DMoveButton_items.Position, True);
//    g_caItems[0] := p;
//  end;

  AList := nil;
  case g_ptItems_Type of
    0:
      AList := g_ItemsFilter_All_Str;
    1:
      AList := g_ItemsFilter_Other;
    2:
      AList := g_ItemsFilter_Drug;
    3:
      AList := g_ItemsFilter_Dress;
    4:
      AList := g_ItemsFilter_Weapon;
    5:
      AList := g_ItemsFilter_Headgear;
  end;
  if (DxEdit_Items.Text <> '') then
  begin
    ItemFilterFind(AList, g_ItemsFilter_Find_Str, DxEdit_Items.Text);
    AList := g_ItemsFilter_Find_Str;
  end;
//  DMoveButton_items.Max := _MAX(0, AList.Count - 8);
//  DMoveButton_items.Tag := AList.Count;
//  DMoveButton_items.Position := 0;
//  DMoveButton_items.UpdatePos(DMoveButton_items.Position, True);
  DUpDown_config.MaxPosition := _MAX(0, AList.Count - 8);
  DUpDown_config.Position := 0;
end;

procedure TFrmDlg.DListBox_ItemsOnChangeSelect(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
  TmpSel: Integer;
begin
  with Sender as TASPCustomListBox do begin
    if (FSelected in [0..5]) and (g_ptItems_Type <> FSelected) then begin
      g_ptItems_Type := FSelected;
//      case g_ptItems_Type of
//        0: DMoveButton_items.Max := _MAX(0, (g_ItemsFilter_All.Count div 8) + byte(g_ItemsFilter_All.Count mod 8 <> 0) - 1);
//        1: DMoveButton_items.Max := _MAX(0, (g_ItemsFilter_Dress.Count div 8) + byte(g_ItemsFilter_Dress.Count mod 8 <> 0) - 1);
//        2: DMoveButton_items.Max := _MAX(0, (g_ItemsFilter_Weapon.Count div 8) + byte(g_ItemsFilter_Weapon.Count mod 8 <> 0) - 1);
//        3: DMoveButton_items.Max := _MAX(0, (g_ItemsFilter_Headgear.Count div 8) + byte(g_ItemsFilter_Headgear.Count mod 8 <> 0) - 1);
//        4: DMoveButton_items.Max := _MAX(0, (g_ItemsFilter_Drug.Count div 8) + byte(g_ItemsFilter_Drug.Count mod 8 <> 0) - 1);
//        5: DMoveButton_items.Max := _MAX(0, (g_ItemsFilter_Other.Count div 8) + byte(g_ItemsFilter_Other.Count mod 8 <> 0) - 1);
//      end;

      case g_ptItems_Type of
        0: DUpDown_config.MaxPosition := _MAX(0, g_ItemsFilter_All_Str.Count - 8);
        1: DUpDown_config.MaxPosition := _MAX(0, g_ItemsFilter_Other.Count - 8);
        2: DUpDown_config.MaxPosition := _MAX(0, g_ItemsFilter_Drug.Count - 8);
        3: DUpDown_config.MaxPosition := _MAX(0, g_ItemsFilter_Dress.Count - 8);
        4: DUpDown_config.MaxPosition := _MAX(0, g_ItemsFilter_Weapon.Count - 8);
        5: DUpDown_config.MaxPosition := _MAX(0, g_ItemsFilter_Headgear.Count - 8);
      end;

//      DMoveButton_items.Position := 0;
//      DMoveButton_items.UpdatePos(DMoveButton_items.Position, True);
//      DMoveButton_itemsMouseMove(DMoveButton_items, [ssLeft], 0, 0);


  DUpDown_config.Position := 0;
    end;
  end;
end;

procedure TFrmDlg.DWGameConfigDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  i, T, AIdx, k, Ay: Integer;
  d, dc1, dc2: TAsphyreLockableTexture;
  pt: TPoint;
  rc, dc: TRect;
  AStr: WideString;
  AColor: longword;
  p, p2: pTCItemRule;
  AList: TStringlist;
begin
  with DWGameConfig do
  begin
    d := DWGameConfig.WLib.Images[DWGameConfig.FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
  end;
  dc1 := WDragonImg.Images[333];
  dc2 := WDragonImg.Images[334];
  case DWGameConfig.tag of
    1:
      begin //base
        with dsurface do
        begin
          with DWGameConfig do
            dsurface.BoldTextOut(SurfaceX(Left + 27), SurfaceX(Top + 50), '基本功能设置', clSilver, clBlack, [fsBold], 9);
//          with DCheckSdoNameShow do
//            if Arrived then
//              BoldTextOut(SurfaceX(Left + 20), SurfaceY(Top + 2), rgb(255, 255, 255), clBlack, caption)
//            else
//              BoldTextOut(SurfaceX(Left + 20), SurfaceY(Top + 2), rgb(224, 224, 224), clBlack, caption);
//          with DCheckBoxHideShiti do
//            if Arrived then
//              BoldTextOut(SurfaceX(Left + 20), SurfaceY(Top + 2), rgb(255, 255, 255), clBlack, caption)
//            else
//              BoldTextOut(SurfaceX(Left + 20), SurfaceY(Top + 2), rgb(224, 224, 224), clBlack, caption);
//          with DCheckSdoDuraWarning do
//            if Arrived then
//              BoldTextOut(SurfaceX(Left + 20), SurfaceY(Top + 2), rgb(255, 255, 255), clBlack, caption)
//            else
//              BoldTextOut(SurfaceX(Left + 20), SurfaceY(Top + 2), rgb(224, 224, 224), clBlack, caption);
//          with DCheckSdoAvoidShift do
//            if Arrived then
//              BoldTextOut(SurfaceX(Left + 20), SurfaceY(Top + 2), rgb(255, 255, 255), clBlack, caption)
//            else
//              BoldTextOut(SurfaceX(Left + 20), SurfaceY(Top + 2), rgb(224, 224, 224), clBlack, caption);
//          with DCheckMyHp do
//            if Arrived then
//              BoldTextOut(SurfaceX(Left + 20), SurfaceY(Top + 2), rgb(255, 255, 255), clBlack, caption)
//            else
//              BoldTextOut(SurfaceX(Left + 20), SurfaceY(Top + 2), rgb(224, 224, 224), clBlack, caption);
//          with DCheckSdoMapDesc do
//            if Arrived then
//              BoldTextOut(SurfaceX(Left + 20), SurfaceY(Top + 2), rgb(255, 255, 255), clBlack, caption)
//            else
//              BoldTextOut(SurfaceX(Left + 20), SurfaceY(Top + 2), rgb(224, 224, 224), clBlack, caption);
//          with DCheckSdoExpFiltrate do
//            if Arrived then
//              BoldTextOut(SurfaceX(Left + 20), SurfaceY(Top + 2), rgb(255, 255, 255), clBlack, caption)
//            else
//              BoldTextOut(SurfaceX(Left + 20), SurfaceY(Top + 2), rgb(224, 224, 224), clBlack, caption);
        end;
      end;
    2:
      begin
        with DWGameConfig do
        begin
          d := WProgUse.Images[335];
          if d <> nil then
          begin
            dc.Left := SurfaceX(Left + 384);
            dc.Top := SurfaceY(Top + 38);
            dc.Right := SurfaceX(left + 384 + 16);
            dc.Bottom := SurfaceY(top + 38 + 219 - 14);
            rc.Left := 0;
            rc.Top := 0;
            rc.Right := d.ClientRect.Right;
            rc.Bottom := d.ClientRect.Bottom;
            dsurface.StretchDraw(dc, rc, d, clWhite4, True);
          end;
        end;
        with dsurface, DWGameConfig do
        begin
          BoldTextOut(SurfaceX(Left + 25), SurfaceY(Top + 45), '物品名称', clSilver, clBlack, [fsBold], 9);
          BoldTextOut(SurfaceX(Left + 165), SurfaceY(Top + 45), '极品提示', clSilver, clBlack, [fsBold], 9);
          BoldTextOut(SurfaceX(Left + 235), SurfaceY(Top + 45), '自动拾取', clSilver, clBlack, [fsBold], 9);
          BoldTextOut(SurfaceX(Left + 305), SurfaceY(Top + 45), '显示名字', clSilver, clBlack, [fsBold], 9);
          Line(SurfaceX(Left + 25), SurfaceY(Top + 63),
               SurfaceX(Left + 25) + 350, SurfaceY(Top + 63),
               clGray);
        end;
        with dsurface, DCheckBox_AllPickup do
          if Arrived then
            BoldTextOut(SurfaceX(Left + 20), SurfaceY(Top + 2), rgb(255, 255, 255), clBlack, caption)
          else
            BoldTextOut(SurfaceX(Left + 20), SurfaceY(Top + 2), rgb(224, 224, 224), clBlack, caption);

//        if UpDownStart then
//        begin
//          if gettickcount - UpDownTick >= 350 then
//          begin
//            UpDownTick := gettickcount;
//            if DBIUP.tag = 1 then
//            begin
//              if DMoveButton_items.Position > 0 then
//              begin
//                Dec(DMoveButton_items.Position);
//                DMoveButton_items.UpdatePos(DMoveButton_items.Position, True);
//              end;
//            end
//            else
//            begin
//              if DMoveButton_items.Position < DMoveButton_items.Max then
//              begin
//                Inc(DMoveButton_items.Position);
//                DMoveButton_items.UpdatePos(DMoveButton_items.Position, True);
//              end;
//            end;
//          end;
//        end;
      end;
    3:
      begin
        with DWGameConfig do
        begin
          with dsurface do
          begin
            BoldTextOut(SurfaceX(Left + 26), SurfaceX(Top + 50), '特殊药品', clSilver, clBlack, [fsBold], 9);
            BoldTextOut(SurfaceX(Left + 26), SurfaceX(Top + 98), '随机保护', clSilver, clBlack, [fsBold], 9);

            BoldTextOut(SurfaceX(Left + 35), SurfaceX(Top + 145), rgb(197, 197, 197), clBlack, '卷轴类型');
            BoldTextOut(SurfaceX(Left + 70), SurfaceX(Top + 76), rgb(224, 224, 224), clBlack, 'HP');
            BoldTextOut(SurfaceX(Left + 70), SurfaceX(Top + 124), rgb(224, 224, 224), clBlack, 'HP'); //MP错误改为HP

            BoldTextOut(SurfaceX(Left + 172), SurfaceX(Top + 76), rgb(224, 224, 224), clBlack, '秒');
            BoldTextOut(SurfaceX(Left + 172), SurfaceX(Top + 124), rgb(224, 224, 224), clBlack, '秒');
          end;
        end;
      end;
    4:
      begin
        with DWGameConfig do
        begin
          with dsurface do
          begin
            Line(SurfaceX(Left + 22), SurfaceX(Top + 65),
                 SurfaceX(Left + 372), SurfaceX(Top + 65), clGray);

            BoldTextOut(SurfaceX(Left + 270), SurfaceX(Top + 49), rgb(255, 255, 255), clBlack, 'HP/MP');
            BoldTextOut(SurfaceX(Left + 315), SurfaceX(Top + 47), rgb(255, 255, 255), clBlack, '秒');
            with DCheckPttly do
              if Arrived then
                BoldTextOut(SurfaceX(Left + 20), SurfaceY(Top + 2), rgb(255, 255, 255), clBlack, caption)
              else
                BoldTextOut(SurfaceX(Left + 20), SurfaceY(Top + 2), rgb(224, 224, 224), clBlack, caption);
            with DCheckPtmfy do
              if Arrived then
                BoldTextOut(SurfaceX(Left + 20), SurfaceY(Top + 2), rgb(255, 255, 255), clBlack, caption)
              else
                BoldTextOut(SurfaceX(Left + 20), SurfaceY(Top + 2), rgb(224, 224, 224), clBlack, caption);
          end;
        end;
      end;
    5:
      begin
        with dsurface do
        begin
          with DCheckSdoAutoFireHit do
          begin
            if Arrived then
              BoldTextOut(SurfaceX(Left + 20), SurfaceY(Top + 2), rgb(255, 255, 255), clBlack, caption)
            else
              BoldTextOut(SurfaceX(Left + 20), SurfaceY(Top + 2), rgb(224, 224, 224), clBlack, caption);

            BoldTextOut(SurfaceX(Left - 10), SurfaceY(Top - 25), '战士技能', rgb(197, 197, 197), clBlack, [fsBold], 9);
          end;
          with DCheckSdoAutoShield do
          begin
            if Arrived then
              BoldTextOut(SurfaceX(Left + 20), SurfaceY(Top + 2), rgb(255, 255, 255), clBlack, caption)
            else
              BoldTextOut(SurfaceX(Left + 20), SurfaceY(Top + 2), rgb(224, 224, 224), clBlack, caption);
            BoldTextOut(SurfaceX(Left - 10), SurfaceY(Top - 25), '法师技能', rgb(197, 197, 197), clBlack, [fsBold], 9);
          end;
          with DCheckSdoAutoHide do
          begin
            if Arrived then
              BoldTextOut(SurfaceX(Left + 20), SurfaceY(Top + 2), rgb(255, 255, 255), clBlack, caption)
            else
              BoldTextOut(SurfaceX(Left + 20), SurfaceY(Top + 2), rgb(224, 224, 224), clBlack, caption);
            BoldTextOut(SurfaceX(Left - 10), SurfaceY(Top - 25), '道士技能', rgb(197, 197, 197), clBlack, [fsBold], 9);
          end;


          with DCheckSdoAutoMagic do
          begin
            if Arrived then
              BoldTextOut(SurfaceX(Left + 20), SurfaceY(Top + 2), rgb(255, 255, 255), clBlack, caption)
            else
              BoldTextOut(SurfaceX(Left + 20), SurfaceY(Top + 2), rgb(224, 224, 224), clBlack, caption);
            BoldTextOut(SurfaceX(Left - 10), SurfaceY(Top - 25), '自动练功', rgb(197, 197, 197), clBlack, [fsBold], 9);
          end;
          with DCheckSdoAutoMagicTime do
            BoldTextOut(SurfaceX(Left + width + 5), SurfaceY(Top + 3), clSilver, clBlack, '秒');
        end;
        g_NgConfigInfo.nAutoMagicID := DCBPractice.tag;
      end;
    6:
      begin

      end;
    7:
      begin
        with DWGameConfig do
        begin
          d := WProgUse.Images[335];
          if d <> nil then
          begin
            dc.Left := SurfaceX(Left + 384);
            dc.Top := SurfaceY(Top + 38);
            dc.Right := SurfaceX(left + 384 + 16);
            dc.Bottom := SurfaceY(top + 38 + 219 - 14);
            rc.Left := 0;
            rc.Top := 0;
            rc.Right := d.ClientRect.Right;
            rc.Bottom := d.ClientRect.Bottom;
            dsurface.StretchDraw(dc, rc, d, clWhite4, True);
          end;
        end;
        g_HelpPosition := DUpDown_config.Position;
        for i := g_HelpPosition to g_HelpPosition + 11 do
        begin
          if i >= g_HelpStringList.Count then
            break;
          AStr := g_HelpStringList.strings[i];
          Ay := (i - g_HelpPosition) * 16;
          if Byte(i) in [0, 9, 18, 35, 47, 55] then
            AColor := clwhite
          else
            AColor := rgb(224, 224, 224);
          dsurface.BoldTextOut(DWGameConfig.SurfaceX(DWGameConfig.Left) + 24, DWGameConfig.SurfaceY(DWGameConfig.Top) + 46 + Ay, AColor, clBlack, AStr);
        end;
//        exit;
//        if UpDownStart then
//        begin
//          if gettickcount - UpDownTick >= 350 then
//          begin
//            UpDownTick := gettickcount;
//            if DBIUP.tag = 1 then
//            begin
//              if DMoveButton_items.Position > 0 then
//              begin
//                Dec(DMoveButton_items.Position);
//                DMoveButton_items.UpdatePos(DMoveButton_items.Position, True);
//              end;
//            end
//            else
//            begin
//              if DMoveButton_items.Position < DMoveButton_items.Max then
//              begin
//                Inc(DMoveButton_items.Position);
//                DMoveButton_items.UpdatePos(DMoveButton_items.Position, True);
//              end;
//            end;
//          end;
//        end;
      end;
  end;
end;

procedure TFrmDlg.DWGameConfigMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
  DScreen.ClearHint(True);
end;

procedure TFrmDlg.DWGameConfigVisible(Sender: TObject; boVisible: Boolean);
  function GetMagicid(Mid: Word): Boolean;
  begin
    case Mid of
      3, 4, 7, 12, 25:
        Result := True;
    else
      Result := False;
    end;
  end;
var
  i: Integer;
  pcm: PTClientMagic;
  me: TMemoryStream;
begin
  DUpDown_config.Visible  := False;
  DCheckSdoNameShow.Checked := g_NgConfigInfo.boShowName;
  DCheckBoxHideShiti.Checked := g_NgConfigInfo.boNotDeath;
  DCheckSdoDuraWarning.Checked := g_NgConfigInfo.boDuraWarning;
  DCheckSdoAvoidShift.Checked := g_NgConfigInfo.boNotNeedShift;
  DCheckSdoExpFiltrate.Checked := g_NgConfigInfo.boExpShow;
  DEdtSdoExpFiltrate.Text := inttostr(g_NgConfigInfo.nExpShow);
  DCheckMyHp.Checked := g_NgConfigInfo.boBrightShowHp;
  DCheckSdoMapDesc.Checked := g_NgConfigInfo.boShowMap;

  DCheckBox_AllPickup.Checked := g_NgConfigInfo.boPickUpItemAll;

  DCheckSpecial.Checked := g_NgConfigInfo.boSpecialHP;
  DxEditSpecialHP.Text := inttostr(g_NgConfigInfo.nSpecialHP);
  DxEditSpecialHPTime.Text := inttostr(g_NgConfigInfo.nwSpecialHP);
  DCheckRanProtect.Checked := g_NgConfigInfo.boRanHP;
  DxEditRanHP.Text := inttostr(g_NgConfigInfo.nRanHP);
  DxEditRanHPTime.Text := inttostr(g_NgConfigInfo.nwRanHP);
  //DListBox_Items.Visible:=g_NgConfigInfo.sRanItemName;

  DCheckPttly.Checked := g_NgConfigInfo.boHpPtEat;
  DEditPtHp.Text := inttostr(g_NgConfigInfo.nHpPtEat);
  DEditPtHpTime.Text := inttostr(g_NgConfigInfo.nwHpPtEat);

  DCheckPtmfy.Checked := g_NgConfigInfo.boMpPtEat;
  DEditPtMp.Text := inttostr(g_NgConfigInfo.nMpPtEat);
  DEditPtMpTime.Text := inttostr(g_NgConfigInfo.nwMpPtEat);

  if (MySelf.Job = 0) then DCheckSdoAutoFireHit.Enabled := True
  else DCheckSdoAutoFireHit.Enabled := False;
  if (MySelf.Job = 1) then DCheckSdoAutoShield.Enabled := True
  else DCheckSdoAutoShield.Enabled := False;
  if (MySelf.Job = 2) then DCheckSdoAutoHide.Enabled := True
  else DCheckSdoAutoHide.Enabled := False;
  if (MySelf.Job = 2) then DCheckSdoAutoHld.Enabled := True
  else DCheckSdoAutoHld.Enabled := False;
  if (MySelf.Job = 2) then DCheckSdoAutoJld.Enabled := True
  else DCheckSdoAutoJld.Enabled := False;
  if (MySelf.Job = 0) and (g_bo刀刀刺杀) then DCheckSdoAutoLongHit.Enabled := True
  else DCheckSdoAutoLongHit.Enabled := False;

  if MySelf <> nil then
  begin
    DCheckSdoAutoFireHit.Checked := g_NgConfigInfo.boAutoFireHit and (MySelf.Job = 0);
    DCheckSdoAutoShield.Checked := g_NgConfigInfo.boAutoShield and (MySelf.Job = 1);
    DCheckSdoAutoHide.Checked := g_NgConfigInfo.boAutoHide and (MySelf.Job = 2);
    DCheckSdoAutoHld.Checked := g_NgConfigInfo.boAutoHld and (MySelf.Job = 2);
    DCheckSdoAutoJld.Checked := g_NgConfigInfo.boAutoJld and (MySelf.Job = 2);
    DCheckSdoAutoLongHit.Checked := g_NgConfigInfo.boAutoLongHit and (MySelf.Job = 0);
  end;
  DCheckSdoAutoMagic.Checked := g_NgConfigInfo.boAutoMagic;
  //DComboBoxAutoMagicList.ItemIndex := g_NgConfigInfo.nAutoMagicID;
  DCheckSdoAutoMagicTime.Text := inttostr(g_NgConfigInfo.nwAutoMagic);

//------------------------------------------------------------------------------
//  for I := 0 to DListBox_Items.Item.Count - 1 do
//  begin
//    if g_NgConfigInfo.sRanItemName = DListBox_Items.Item.Strings[I] then
//      DListBox_Items.ItemIndex := I;
//  end;

  if MySelf = nil then Exit;
//  if (DComboBoxAutoMagicList.ItemIndex >= 0) and (DComboBoxAutoMagicList.ItemIndex < DComboBoxAutoMagicList.Item.Count) then
//    g_NgConfigInfo.nAutoMagicID := Integer(DComboBoxAutoMagicList.Item.Objects[DComboBoxAutoMagicList.ItemIndex])
//    else g_NgConfigInfo.nAutoMagicID := 0;
//  DComboBoxAutoMagicList.Item.Clear;
  //DComboBoxAutoMagicList.ItemIndex := -1;

//  for i := 0 to MagicList.Count - 1 do
//  begin
//    pcm := PTClientMagic(MagicList.Items[I]);
//    if (pcm <> nil) and not GetMagicid(pcm.Def.MagicId) then
//    begin
//      DComboBoxAutoMagicList.Item.AddObject(pcm.Def.MagicName, TObject(pcm.Def.MagicId));
//      if g_NgConfigInfo.nAutoMagicID = pcm.Def.MagicId then
//        DComboBoxAutoMagicList.ItemIndex := DComboBoxAutoMagicList.Item.Count - 1;
//    end;
//  end;
//  if not g_NgConfigInfo.boAutoMagic and (DComboBoxAutoMagicList.Item.Count > 0) then
//    DComboBoxAutoMagicList.ItemIndex := 0;
//
//  DComboBoxAutoMagicList.ShowCount := DComboBoxAutoMagicList.Item.Count;
//  SetImeMode(FrmMain.Handle, LocalLanguage);

  g_MemoList.Clear;
  if DSdoMemo.Lines.Count > 0 then
  begin
    for I := 0 to DSdoMemo.Lines.Count - 1 do
     g_MemoList.Add(DSdoMemo.Lines.Strings[I]);
  end;
end;

procedure DrawWindow(dsuf: TAsphyreCanvas; x, y: integer; ssuf: TAsphyreLockableTexture);
begin
  dsuf.Draw(x, y, ssuf.ClientRect, ssuf, True);
end;
procedure TFrmDlg.DWHeroStoreDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  ax, ay: integer;
begin
  with Sender as TDWindow do begin
    ax := SurfaceX(Left);
    ay := SurfaceY(Top);
    d := WLib.Images[FaceIndex];
    if d <> nil then
      DrawWindow(dsurface, ax, ay, d);
  end;
end;

procedure TFrmDlg.DWHeroStoreMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
  DScreen.ClearHint(True);
end;

procedure TFrmDlg.DWhisperCloseClick(Sender: TObject; X, Y: Integer);
begin
  DWhisperDlg.Visible := False;
end;

procedure TFrmDlg.AddWhisper(Str: string);
var
   i, len, aline: integer;
   temp: string;
const
   BOXWIDTH = 325; //41 聊天框文字宽度
begin
   //str:= FormatDateTime('hh:mm:ss',Now)+ ' ' + str;
   //增加闪烁By TasNat at: 2012-06-24 13:16:05

   len := Length (Str);
   temp := '';
   i := 1;
   while TRUE do begin
      if i > len then break;
      if byte (str[i]) >= 128 then begin
         temp := temp + str[i];
         Inc (i);
         if i <= len then temp := temp + str[i]
         else break;
      end else
         temp := temp + str[i];

      aline := FontManager.Default.TextWidth (temp);
      if aline > BOXWIDTH then begin
         DWhisperInfoList.Add (temp);
         str := Copy (str, i+1, Len-i);
         temp := '';
         break;
      end;
      Inc (i);
   end;
   if temp <> '' then begin
      DWhisperInfoList.Add (temp);
      str := '';
   end;

   if WhisperPoints.Count > 0 then
    for i:=0 to FrmDlg.WhisperPoints.Count-1 do
      Dispose (pTClickSLPoint (FrmDlg.WhisperPoints[i]));
    FrmDlg.WhisperPoints.Clear;
   WhisperAddPoints := True;
   if str <> '' then
      AddWhisper ('         ' + str);
end;

procedure TFrmDlg.AutoWhisper(str: string);
   function ExtractUserName (line: string): string;
   var
      uname: string;
   begin
      GetValidStr3 (line, line, ['(', '!', '*', '/', ')']);
      GetValidStr3 (line, uname, [' ', '=', ':', '[']);
      if uname <> '' then
         if (uname[1] = '/') or (uname[1] = '(') or (uname[1] = ' ') or (uname[1] = '[') then
            uname := '';
      Result := uname;
   end;
begin
  FrmMain.SendSay ('/' + ExtractUserName (str) + ' '+FrmDlg.DEdtWhisper.Text);
end;

function TFrmDlg.IsBlockNameList(str: string):Boolean;
var
  uname: string;
  I: Integer;
begin
  if not g_boRelationWin then begin
    Result := False;
    Exit;
  end;

  Result:= False;
  GetValidStr3 (str, str, ['(', '!', '-', '*', '/', ')']);
  GetValidStr3 (str, uname, [' ', '=', '!', ':', '[']);
  if uname <> '' then
     if (uname[1] = '/') or (uname[1] = '(') or (uname[1] = ' ') or (uname[1] = '[') then
        uname := '';

  for i := BlackMembers.Count - 1 downto 0 do
  begin
    if PTFriend(BlackMembers[i]).CharID = uname then
    begin
      Result := true;
      Exit;
    end;
  end;
end;

procedure TFrmDlg.DWhisperDlgDirectPaint(Sender: TObject;
  DSurface: TAsphyreCanvas);
var
  d, dd: TAsphyreLockableTexture;
  dc, rc: TRect;
  ax, ay, i ,k: Integer;
  AList: TStringlist;
  sdata: string;
begin
  with DWhisperDlg do begin
    d := WLib.Images[FaceIndex];
    if d <> nil then dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);

    dd := WProgUse.Images[335];
    if dd <> nil then
    begin
      dc.Left := SurfaceX(Left + 365);
      dc.Top := SurfaceY(Top + 42);
      dc.Right := SurfaceX(left + 365 + 16);
      dc.Bottom := SurfaceY(top + 42 + 219 - 39);
      rc.Left := 0;
      rc.Top := 0;
      rc.Right := dd.ClientRect.Right;
      rc.Bottom := dd.ClientRect.Bottom;
      dsurface.StretchDraw(dc, rc, dd, clWhite4, True);
    end;
    ax := SurfaceX(Left);
    ay := SurfaceY(Top);

    dsurface.Line(ax + 15, ay + 221, ax + 379, ay + 221, $406F77);


    AList := DWhisperInfoList;
    DWhisperBar.Max := DWhisperInfoList.Count - 2;
    WhisperTop := DWhisperBar.Position;
//    DScreen.AddChatBoardString('WhisperTop='+IntToStr(WhisperTop), clWhite, clRed);
    for i := WhisperTop to WhisperTop + 11 do
    begin
      if i >= AList.Count then
        break;
//      p2 := pTCItemRule(AList.Objects[i]);
      sdata := AList.Strings[I];
      with dsurface do
      begin

        if WhisperSelect = i then TextOut (SurfaceX(Left+3+16), SurfaceY(Top+(i - WhisperTop)*14+3+40), sdata, clRed)
        else if WhisperMoveed = (i - WhisperTop) then TextOut (SurfaceX(Left+3+16), SurfaceY(Top+(i - WhisperTop)*14+3+40), sdata, clYellow)
        else TextOut (SurfaceX(Left+3+16), SurfaceY(Top+(i - WhisperTop)*14+3+40), sdata, clWhite);
      end;
    end;

  end;
end;

procedure TFrmDlg.DWhisperDlgMouseDown(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
var
  lx, ly, idx: integer;
begin
  lx := DWhisperDlg.LocalX(X) - DWhisperDlg.Left;
  ly := DWhisperDlg.LocalY(Y) - DWhisperDlg.Top;
  WhisperSelect := -1;
  if (lx >= 16) and (lx <= 370) and (ly >= 40) and (ly <= 200) then begin
    idx := (ly-40) div 14;
    if idx < DWhisperInfoList.Count then begin
      WhisperSelect := idx + WhisperTop;
    end;
  end;
end;

procedure TFrmDlg.DWhisperDlgMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var
  lx, ly, idx: integer;
begin
  lx := DWhisperDlg.LocalX(X) - DWhisperDlg.Left;
  ly := DWhisperDlg.LocalY(Y) - DWhisperDlg.Top;
  WhisperMoveed := -1;
  if (lx >= 16) and (lx <= 370) and (ly >= 40) and (ly <= 200) then begin
    idx := (ly-40) div 14;
    if idx < DWhisperInfoList.Count then begin
      WhisperMoveed := idx;
    end;
  end;
end;

procedure TFrmDlg.DWhisperDlgMouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
   function ExtractUserName (line: string): string;
   var
      uname: string;
   begin
      line := Copy(line, 10, Length(line)-1);
      GetValidStr3 (line, line, ['(', '!', '*', '/', ')']);
      GetValidStr3 (line, uname, [' ', '=', ':', '[']);
      if uname <> '' then
         if (uname[1] = '/') or (uname[1] = '(') or (uname[1] = ' ') or (uname[1] = '[') then
            uname := '';
      Result := uname;
   end;
   function ExtractLen (line: string): string;
   var
      uname: string;
   begin
      line := Copy(line, 10, Length(line)-1);
//      GetValidStr3 (line, line, ['(', '!', '*', '/', ')']);
//      GetValidStr3 (line, uname, [' ', '=', ':', '[']);
//      if uname <> '' then
//         if (uname[1] = '/') or (uname[1] = '(') or (uname[1] = ' ') or (uname[1] = '[') then
//            uname := '';
      Result := line;
   end;

var
  i, L, T: integer;
  p: pTClickSLPoint;
  lx, ly, idx: integer;
  WhisperSelectStr: string;
begin
  lx := DWhisperDlg.LocalX(X) - DWhisperDlg.Left;
  ly := DWhisperDlg.LocalY(Y) - DWhisperDlg.Top;
  WhisperSelectStr := '';
  if (lx >= 16) and (lx <= 370) and (ly >= 40) and (ly <= 200) then begin
    if WhisperSelect <> -1 then begin
      WhisperSelectStr := DWhisperInfoList[WhisperSelect];

      if not FrmDlg.DEdChat.Visible then begin
        FrmDlg.DEdChat.Visible := TRUE;
        FrmDlg.DEdChat.SetFocus;
      end;
      if boWhisperLen then FrmDlg.DEdChat.Text := ExtractLen (WhisperSelectStr)
      else
        FrmDlg.DEdChat.Text := '/' + ExtractUserName (WhisperSelectStr) + ' ';

      FrmDlg.DEdChat.ChangeCurPos(AnsiTextLength(FrmDlg.DEdChat.Text), True);
      FrmDlg.DEdChat.SelLength := 0;
      FrmDlg.DEdChat.SetFocus;
    end;
  end;
end;

procedure TFrmDlg.DWhisperDownMouseDown(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
  if DWhisperBar.Position < DWhisperBar.Max then
  begin
    Inc(DWhisperBar.Position);
    DWhisperBar.UpdatePos(DWhisperBar.Position, True);
  end;
end;

procedure TFrmDlg.DWhisperUPMouseDown(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
  if DWhisperBar.Position > 0 then
  begin
    Dec(DWhisperBar.Position);
    DWhisperBar.UpdatePos(DWhisperBar.Position, True);
  end;
end;

procedure TFrmDlg.DWindowItemDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  p2: pTCItemRule;
  AList: TStringlist;
  i, k: Integer;
  d, dd: TAsphyreLockableTexture;
begin
  case g_ptItems_Type of
    0:
      AList := g_ItemsFilter_All_Str;
    1:
      AList := g_ItemsFilter_Other;     //
    2:
      AList := g_ItemsFilter_Drug;
    3:
      AList := g_ItemsFilter_Dress;
    4:
      AList := g_ItemsFilter_Weapon;
    5:
      AList := g_ItemsFilter_Headgear;
  end;
  if DxEdit_Items.Text <> '' then
    AList := g_ItemsFilter_Find_Str;
//  k := DMoveButton_items.Position;
  k := DUpDown_config.Position;
  d := nil;
  dd := nil;
  for i := k to k + 7 do
  begin
    if i >= AList.Count then
      break;
    p2 := pTCItemRule(AList.Objects[i]);
    with dsurface, DWindowItem do
    begin
      if SelectIndex = i then
        BoldTextOut(SurfaceX(Left) + 5, SurfaceY(Top + 15) + (i - k) * 17, clRed, clBlack, p2.Name)
      else
        BoldTextOut(SurfaceX(Left) + 5, SurfaceY(Top + 15) + (i - k) * 17, clwhite, clBlack, p2.Name);
      if WProgUse <> nil then
      begin
        d := WProgUse.Images[333];
        dd := WProgUse.Images[334];
      end;
      if d <> nil then
        Draw(SurfaceX(Left) + 5 + 160, SurfaceY(Top + 11) + (i - k) * 17, d.ClientRect, d, True);
      if dd <> nil then
        if p2.rare then
          Draw(SurfaceX(Left) + 5 + 160, SurfaceY(Top + 11) + (i - k) * 17, dd.ClientRect, dd, True);
      if d <> nil then
        Draw(SurfaceX(Left) + 5 + 230, SurfaceY(Top + 11) + (i - k) * 17, d.ClientRect, d, True);
      if dd <> nil then
        if p2.pick then
          Draw(SurfaceX(Left) + 5 + 230, SurfaceY(Top + 11) + (i - k) * 17, dd.ClientRect, dd, True);
      if d <> nil then
        Draw(SurfaceX(Left) + 5 + 300, SurfaceY(Top + 11) + (i - k) * 17, d.ClientRect, d, True);
      if dd <> nil then
        if p2.Show then
          Draw(SurfaceX(Left) + 5 + 300, SurfaceY(Top + 11) + (i - k) * 17, dd.ClientRect, dd, True);
    end;
  end;
end;

procedure TFrmDlg.DWindowItemMouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
var
  p2: pTCItemRule;
  AList: TStringlist;
  TempSelectIndex: Integer;
begin
  if (Button = mbRight)  then exit;

  case g_ptItems_Type of
    0:
      AList := g_ItemsFilter_All_Str;
    1:
      AList := g_ItemsFilter_Other;
    2:
      AList := g_ItemsFilter_Drug;
    3:
      AList := g_ItemsFilter_Dress;
    4:
      AList := g_ItemsFilter_Weapon;
    5:
      AList := g_ItemsFilter_Headgear;
  end;
  if DxEdit_Items.Text <> '' then
    AList := g_ItemsFilter_Find_Str;
  with Sender as TDWindow do
  begin
    if (x >= 25) and (y >= 75) and (x < 25 + 355) and (y <= 75 + 150) then
    begin
      //TempSelectIndex := (y - 75) div 17 + DMoveButton_items.Position;
      TempSelectIndex := (y - 75) div 17 + DUpDown_config.Position;
      if (TempSelectIndex >= 0) and (TempSelectIndex < AList.Count) then
      begin
        p2 := pTCItemRule(AList.Objects[TempSelectIndex]);
        if (x >= 25) and (x <= 25 + FontManager.Default.TextWidth(p2.Name)) then
          SelectIndex := TempSelectIndex;
        if (x >= 185) and (x <= 200) then
        begin
          SelectIndex := TempSelectIndex;
          p2.rare := not p2.rare;
        end;
        if (x >= 255) and (x <= 270) then
        begin
          SelectIndex := TempSelectIndex;
          p2.pick := not p2.pick;
        end;
        if (x >= 325) and (x <= 340) then
        begin
          SelectIndex := TempSelectIndex;
          p2.Show := not p2.Show;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DWindowSaveItemDirectPaint(Sender: TObject;
  DSurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with dsurface do
  begin
    with DWindowSaveItem do
    begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
    end;
  end;
end;

procedure TFrmDlg.DWndWebCloseClick(Sender: TObject; X, Y: Integer);
begin
  FrmWeb.Hide;
  FrmWeb.Visible := False;
  DWndWeb.Visible := False;
  FrmMain.SetFocus;
  Windows.SetFocus(FrmMain.Handle);
end;

procedure TFrmDlg.DWndWebDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
    d: TAsphyreLockableTexture;
begin
  with Sender as TDWindow do begin

    d := WLib.Images[FaceIndex];
       if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);

    FrmWeb.Left := DWndWeb.Left + 33;
    FrmWeb.Top := DWndWeb.Top + 46;
    FrmWeb.ClientWidth := 394 + 25;
    FrmWeb.ClientHeight := 397 + 35;

    if not FrmWeb.Visible then
      FrmWeb.ShowWeb(g_boQuestionsWeb);
  end;
end;

procedure TFrmDlg.DWndWebInRealArea(Sender: TObject; X, Y: Integer;
  var IsRealArea: Boolean);
begin
  IsRealArea := True;
end;

procedure TFrmDlg.DWndWebVisible(Sender: TObject; boVisible: Boolean);
begin
  if not boVisible then begin
    FrmWeb.Hide;
    Windows.SetFocus(FrmMain.Handle);
//    g_TopDWindow := nil;
  end else begin
//    g_TopDWindow := DWndWeb;
  end;
end;

procedure TFrmDlg.DWStoreItemPriceDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
  var
    d: TAsphyreLockableTexture;
begin
if Myself = nil then Exit;
  if g_WaitingStallItem.item.s.Name = '' then Exit;

  with DWStoreItemPrice do begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);

    if tag = 44 then
    begin
      with dsurface do begin
        BoldTextOut(
          SurfaceX(Left + 36),
          SurfaceY(Top + 60),
          $FF00, clBlack, g_WaitingStallItem.item.s.Name);
        BoldTextOut(
          SurfaceX(Left + 126),
          SurfaceY(Top + 60),
          GetRGB(95), clBlack, '金额范围 150,000,000 金币');
      end;
    end else if tag = 45 then begin
      with dsurface do begin
        BoldTextOut(
          SurfaceX(Left + 36),
          SurfaceY(Top + 60),
          $FF00, clBlack, g_WaitingStallItem.item.s.Name);
        BoldTextOut(
          SurfaceX(Left + 126),
          SurfaceY(Top + 60),
          GetRGB(95), clBlack, '金额范围 8,000,000 元宝');
      end;
    end;
    with dsurface do
    begin
      BoldTextOut(
        SurfaceX(Left + 36),
        SurfaceY(Top + 80),
        GetRGB(95), clBlack, '输入物品价格：');
    end;
  end;
//    begin
//      if not DxEditStoreName.Visible then begin
//       SetImeMode(DxEditStoreItemPrice.Handle, imOpen);
//         DxEditStoreItemPrice.Visible := TRUE;
//         DxEditStoreItemPrice.SetFocus;
//      end;
//   end;
end;

procedure TFrmDlg.DWUserStallDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  //if g_Myself = nil then Exit;
  with DWUserStall do begin
    //d := WLib.Images[FaceIndex];
    d := WLib.Images[FaceIndex];
    if d <> nil then dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);

    if Myself.m_StallMgr.uBlock.StallName <> '' then  //   商店名字
    with dsurface do begin
      TextOut(SurfaceX(Left + 30),
              SurfaceY(Top + 36),
              clSilver, Myself.m_StallMgr.uBlock.StallName);
    end
//      with dsurface.Canvas do begin
//        BoldTextOut(dsurface,
//          SurfaceX(Left + 30),
//          SurfaceY(Top + 36),
//          clSilver, clBlack, g_Myself.m_StallMgr.uBlock.StallName);
//      end;
  end;
end;

procedure TFrmDlg.DxEditRanHPLeave(Sender: TObject);
begin
  if DxEditRanHP.Text <> '' then
    g_NgConfigInfo.nRanHP := StrToInt(DxEditRanHP.Text);
end;

procedure TFrmDlg.DxEditRanHPTextChanged(Sender: TObject; sText: string);
begin
 if DxEditRanHP.Text <> '' then
    g_NgConfigInfo.nRanHP := StrToInt(DxEditRanHP.Text);
end;

procedure TFrmDlg.DxEditRanHPTimeLeave(Sender: TObject);
begin
  if DxEditRanHPTime.Text <> '' then
    g_NgConfigInfo.nwRanHP := StrToInt(DxEditRanHPTime.Text);
end;

procedure TFrmDlg.DxEditRanHPTimeTextChanged(Sender: TObject; sText: string);
begin
  if DxEditRanHPTime.Text <> '' then
    g_NgConfigInfo.nwRanHP := StrToInt(DxEditRanHPTime.Text);
end;

procedure TFrmDlg.DxEditSpecialHPLeave(Sender: TObject);
begin
  if DxEditSpecialHP.Text <> '' then
    g_NgConfigInfo.nSpecialHP := StrToInt(DxEditSpecialHP.Text);
end;

procedure TFrmDlg.DxEditSpecialHPTextChanged(Sender: TObject; sText: string);
begin
  if DxEditSpecialHP.Text <> '' then
    g_NgConfigInfo.nSpecialHP := StrToInt(DxEditSpecialHP.Text);
end;

procedure TFrmDlg.DxEditSpecialHPTimeLeave(Sender: TObject);
begin
  if DxEditSpecialHPTime.Text <> '' then
    g_NgConfigInfo.nwSpecialHP := StrToInt(DxEditSpecialHPTime.Text);
end;

procedure TFrmDlg.DxEditSpecialHPTimeTextChanged(Sender: TObject;
  sText: string);
begin
  if DxEditSpecialHPTime.Text <> '' then
    g_NgConfigInfo.nwSpecialHP := StrToInt(DxEditSpecialHPTime.Text);
end;

procedure TFrmDlg.DxEdit_ItemsChange(Sender: TObject; sText: string);
begin
 DComboBox_ItemsChange(DComboBox_Items);
end;

procedure TFrmDlg.EdChatKeyDown(Sender: TObject; var Key: Word;
  Shift: TShiftState);
begin

end;

procedure TFrmDlg.EdChatKeyPress(Sender: TObject; var Key: Char);
begin
//         if DxEditStoreItemPrice.Visible then
//         begin
//          // DxEditStoreItemPrice.AutoSelect :=True;
//          DxEditStoreItemPrice.SetFocus;
//       //   DxEditStoreItemPrice.Text := DxEditStoreItemPrice.Text+key;
//       //   DxEditStoreItemPrice.SelStart := Length(DxEditStoreItemPrice.Text);
//          //DxEditStoreItemPrice.SelLength := 0;
//          SetImeMode(DxEditStoreItemPrice.Handle, imOpen);
//          g_HIMC := ImmGetContext(DxEditStoreItemPrice.Handle);
//       //   ImmAssociateContext(FrmMain.Handle,0);
//
//        //  Key:=#0;
//        //  exit;
//         end;
//         if DxEditStoreName.Visible then
//         begin
//           SetImeMode(DxEditStoreName.Handle, imOpen);
//          g_HIMC := ImmGetContext(DxEditStoreName.Handle);
//        //  ImmAssociateContext(FrmMain.Handle,0);
//          DxEditStoreName.SetFocus;
//          DxEditStoreName.Text := DxEditStoreName.Text+key;
//          //DxEditStoreName.SelStart := Length(DxEditStoreName.Text);
//         // DxEditStoreName.SelLength := 0;
//
//        //  Key:=#0;
//         end;
//    DxEditStoreName: TEdit;
//    DxEditStoreItemPrice:TEdit;
//  if Key = #13 then
//  begin
//    FrmMain.SendSay((Sender as TEdit).Text);
//    (Sender as TEdit).Text := '';
//    (Sender as TEdit).Visible := FALSE;
//    Key := #0;
//    g_HIMC := ImmGetContext((Sender as TEdit).Handle);
//    ImmAssociateContext(FrmMain.Handle,0);
////    SetImeMode(EdChat.Handle, imSAlpha);
//  end;
//  if Key = #27 then
//  begin
//    (Sender as TEdit).Text := '';
//    (Sender as TEdit).Visible := FALSE;
//    Key := #0;
//    g_HIMC := ImmGetContext((Sender as TEdit).Handle);
//    ImmAssociateContext(FrmMain.Handle,0);
////    SetImeMode(EdChat.Handle, imSAlpha);
//  end;
end;

procedure TFrmDlg.DCloseUS1Click(Sender: TObject; X, Y: Integer);
begin
  DUserState1.Visible := FALSE;
end;

procedure TFrmDlg.DNecklaceUS1DirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  idx: integer;
  d: TAsphyreLockableTexture;
begin
  if Sender = DNecklaceUS1 then
  begin
    if UserState1.UseItems[U_NECKLACE].s.Name <> '' then
    begin
      idx := UserState1.UseItems[U_NECKLACE].s.Looks;
      if idx >= 0 then
      begin
        d := WStateItem.Images[idx];
        if d <> nil then
          dsurface.Draw(DNecklaceUS1.SurfaceX(DNecklaceUS1.Left + (DNecklaceUS1.Width - d.Width) div 2), DNecklaceUS1.SurfaceY(DNecklaceUS1.Top + (DNecklaceUS1.Height - d.Height) div 2), d.ClientRect, d, TRUE);
      end;
    end;
  end;
  if Sender = DLightUS1 then
  begin
    if UserState1.UseItems[U_RIGHTHAND].s.Name <> '' then
    begin
      idx := UserState1.UseItems[U_RIGHTHAND].s.Looks;
      if idx >= 0 then
      begin
        d := WStateItem.Images[idx];
        if d <> nil then
          dsurface.Draw(DLightUS1.SurfaceX(DLightUS1.Left + (DLightUS1.Width - d.Width) div 2), DLightUS1.SurfaceY(DLightUS1.Top + (DLightUS1.Height - d.Height) div 2), d.ClientRect, d, TRUE);
      end;
    end;
  end;
  if Sender = DArmRingRUS1 then
  begin
    if UserState1.UseItems[U_ARMRINGR].s.Name <> '' then
    begin
      idx := UserState1.UseItems[U_ARMRINGR].s.Looks;
      if idx >= 0 then
      begin
        d := WStateItem.Images[idx];
        if d <> nil then
          dsurface.Draw(DArmRingRUS1.SurfaceX(DArmRingRUS1.Left + (DArmRingRUS1.Width - d.Width) div 2), DArmRingRUS1.SurfaceY(DArmRingRUS1.Top + (DArmRingRUS1.Height - d.Height) div 2), d.ClientRect, d, TRUE);
      end;
    end;
  end;
  if Sender = DArmRingLUS1 then
  begin
    if UserState1.UseItems[U_ARMRINGL].s.Name <> '' then
    begin
      idx := UserState1.UseItems[U_ARMRINGL].s.Looks;
      if idx >= 0 then
      begin
        d := WStateItem.Images[idx];
        if d <> nil then
          dsurface.Draw(DArmRingLUS1.SurfaceX(DArmRingLUS1.Left + (DArmRingLUS1.Width - d.Width) div 2), DArmRingLUS1.SurfaceY(DArmRingLUS1.Top + (DArmRingLUS1.Height - d.Height) div 2), d.ClientRect, d, TRUE);
      end;
    end;
  end;
  if Sender = DRingRUS1 then
  begin
    if UserState1.UseItems[U_RINGR].s.Name <> '' then
    begin
      idx := UserState1.UseItems[U_RINGR].s.Looks;
      if idx >= 0 then
      begin
        d := WStateItem.Images[idx];
        if d <> nil then
          dsurface.Draw(DRingRUS1.SurfaceX(DRingRUS1.Left + (DRingRUS1.Width - d.Width) div 2), DRingRUS1.SurfaceY(DRingRUS1.Top + (DRingRUS1.Height - d.Height) div 2), d.ClientRect, d, TRUE);
      end;
    end;
  end;
  if Sender = DRingLUS1 then
  begin
    if UserState1.UseItems[U_RINGL].s.Name <> '' then
    begin
      idx := UserState1.UseItems[U_RINGL].s.Looks;
      if idx >= 0 then
      begin
        d := WStateItem.Images[idx];
        if d <> nil then
          dsurface.Draw(DRingLUS1.SurfaceX(DRingLUS1.Left + (DRingLUS1.Width - d.Width) div 2), DRingLUS1.SurfaceY(DRingLUS1.Top + (DRingLUS1.Height - d.Height) div 2), d.ClientRect, d, TRUE);
      end;
    end;
  end;
   // 2003/03/15 酒捞袍 牢亥配府 犬厘
  if Sender = DBujukUS1 then
  begin
    if UserState1.UseItems[U_BUJUK].s.Name <> '' then
    begin
      idx := UserState1.UseItems[U_BUJUK].s.Looks;
      if idx >= 0 then
      begin
        d := WStateItem.Images[idx];
        if d <> nil then
          dsurface.Draw(DBujukUS1.SurfaceX(DBujukUS1.Left + (DBujukUS1.Width - d.Width) div 2), DBujukUS1.SurfaceY(DBujukUS1.Top + (DBujukUS1.Height - d.Height) div 2), d.ClientRect, d, TRUE);
      end;
    end;
  end;
  if Sender = DBeltUS1 then
  begin
    if UserState1.UseItems[U_BELT].s.Name <> '' then
    begin
      idx := UserState1.UseItems[U_BELT].s.Looks;
      if idx >= 0 then
      begin
        d := WStateItem.Images[idx];
        if d <> nil then
          dsurface.Draw(DBeltUS1.SurfaceX(DBeltUS1.Left + (DBeltUS1.Width - d.Width) div 2), DBeltUS1.SurfaceY(DBeltUS1.Top + (DBeltUS1.Height - d.Height) div 2), d.ClientRect, d, TRUE);
      end;
    end;
  end;
  if Sender = DBootsUS1 then
  begin
    if UserState1.UseItems[U_BOOTS].s.Name <> '' then
    begin
      idx := UserState1.UseItems[U_BOOTS].s.Looks;
      if idx >= 0 then
      begin
        d := WStateItem.Images[idx];
        if d <> nil then
          dsurface.Draw(DBootsUS1.SurfaceX(DBootsUS1.Left + (DBootsUS1.Width - d.Width) div 2), DBootsUS1.SurfaceY(DBootsUS1.Top + (DBootsUS1.Height - d.Height) div 2), d.ClientRect, d, TRUE);
      end;
    end;
  end;
  if Sender = DCharmUS1 then
  begin
    if UserState1.UseItems[U_CHARM].s.Name <> '' then
    begin
      idx := UserState1.UseItems[U_CHARM].s.Looks;
      if idx >= 0 then
      begin
        d := WStateItem.Images[idx];
        if d <> nil then
          dsurface.Draw(DCharmUS1.SurfaceX(DCharmUS1.Left + (DCharmUS1.Width - d.Width) div 2), DCharmUS1.SurfaceY(DCharmUS1.Top + (DCharmUS1.Height - d.Height) div 2), d.ClientRect, d, TRUE);
      end;
    end;
  end;
  if Sender = UserButTrans then
  begin
    if UserState1.UseItems[U_TRANS].s.Name <> '' then
    begin
      idx := UserState1.UseItems[U_TRANS].s.Looks;
      if idx >= 0 then
      begin
        d := WStateItem.Images[idx];
        if d <> nil then
          dsurface.Draw(UserButTrans.SurfaceX(UserButTrans.Left + (UserButTrans.Width - d.Width) div 2), UserButTrans.SurfaceY(UserButTrans.Top + (UserButTrans.Height - d.Height) div 2), d.ClientRect, d, TRUE);
      end;
    end;
  end;
end;

procedure TFrmDlg.ShowGuildDlg;
begin
  DGuildDlg.Visible := TRUE;  //not DGuildDlg.Visible;
  DGuildDlg.Top := -3;
  DGuildDlg.Left := 0;
  if DGuildDlg.Visible then
  begin
    if GuildCommanderMode then
    begin
      DGDAddMem.Visible := TRUE;
      DGDDelMem.Visible := TRUE;
      DGDEditNotice.Visible := TRUE;
      DGDEditGrade.Visible := TRUE;
      DGDAlly.Visible := TRUE;
      DGDBreakAlly.Visible := TRUE;
      DGDWar.Visible := TRUE;
      DGDCancelWar.Visible := TRUE;
    end
    else
    begin
      DGDAddMem.Visible := FALSE;
      DGDDelMem.Visible := FALSE;
      DGDEditNotice.Visible := FALSE;
      DGDEditGrade.Visible := FALSE;
      DGDAlly.Visible := FALSE;
      DGDBreakAlly.Visible := FALSE;
      DGDWar.Visible := FALSE;
      DGDCancelWar.Visible := FALSE;
    end;

  end;
  GuildTopLine := 0;
end;

procedure TFrmDlg.ShowGuildEditNotice;
var
  d: TAsphyreLockableTexture;
  i: integer;
  data: string;
begin
  with DGuildEditNotice do
  begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
    begin
      Left := (g_FScreenWidth - d.Width) div 2;
      Top := (g_FScreenHeight - d.Height) div 2;
    end;
    HideAllControls;
    DGuildEditNotice.ShowModal;

    Memo.Left := SurfaceX(Left + 16);
    Memo.Top := SurfaceY(Top + 36);
    Memo.Width := 571;
    Memo.Height := 246;
    Memo.Lines.Assign(GuildNotice);
    Memo.ReadOnly := False;
    Memo.Visible := TRUE;

    while TRUE do
    begin
      if not DGuildEditNotice.Visible then
        break;
      frmMain.ProcOnIdle();
      Application.ProcessMessages;
      if Application.Terminated then
        exit;
        Sleep(20);
    end;

    DGuildEditNotice.Visible := FALSE;
    RestoreHideControls;

    if DMsgDlg.DialogResult = mrOk then
    begin
         //搬苞... 巩颇傍瘤荤亲阑 诀单捞飘 茄促.
      data := '';
      for i := 0 to Memo.Lines.Count - 1 do
      begin
        if Memo.Lines[i] = '' then
          data := data + Memo.Lines[i] + ' '#13
        else
          data := data + Memo.Lines[i] + #13;
      end;
      if Length(data) > 4000 then
      begin
        data := Copy(data, 1, 4000);
        DMessageDlg('公告内容超过限制大小，公告内容将被截短！', [mbOk]);
      end;
      FrmMain.SendGuildUpdateNotice(data);
    end;
  end;
end;

procedure TFrmDlg.ShowGuildEditGrade;
var
  d: TAsphyreLockableTexture;
  data: string;
  i: integer;
begin
  if GuildMembers.Count <= 0 then
  begin
    DMessageDlg('请先点击 [列表] 编辑公会成员信息。', [mbOk]);
    exit;
  end;

  with DGuildEditNotice do
  begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
    begin
      Left := (g_FScreenWidth - d.Width) div 2;
      Top := (g_FScreenHeight - d.Height) div 2;
    end;
    HideAllControls;
    DGuildEditNotice.ShowModal;
    DGuildEditNotice.EnableFocus := True;
    Memo.Left := SurfaceX(Left + 16);
    Memo.Top := SurfaceY(Top + 36);
    Memo.Width := 571;
    Memo.Height := 246;
    Memo.Lines.Assign(GuildMembers);
    Memo.Visible := TRUE;
    Memo.SetFocus;

    while TRUE do
    begin
      if not DGuildEditNotice.Visible then
        break;
      frmMain.ProcOnIdle();
      Application.ProcessMessages;
      if Application.Terminated then
        exit;
        Sleep(20);
    end;

    DGuildEditNotice.Visible := FALSE;
    RestoreHideControls;

    if DMsgDlg.DialogResult = mrOk then
    begin
         //GuildMembers.Assign (Memo.Lines);
         //结果... 门派更新
      data := '';
      for i := 0 to Memo.Lines.Count - 1 do
      begin
        data := data + Memo.Lines[i] + #13;  //在服务器上处理
      end;
      if Length(data) > 5000 then
      begin
        data := Copy(data, 1, 5000);
        DMessageDlg('内容超过限制大小，内容将被截短！', [mbOk]);
      end;
      FrmMain.SendGuildUpdateGrade(data);
    end;
  end;
end;

{ATexture: TAsphyreLockableTexture;
begin
  with DButtonDefaultConfig do
  begin
    ATexture := FontManager.GetFont('宋体', 9, [fsUnderline]).TextOut(caption);
    if Downed then
      dsurface.DrawBoldText(SurfaceX(Left), SurfaceY(Top), ATexture, clRed, clBlack)
    else
      dsurface.DrawBoldText(SurfaceX(Left), SurfaceY(Top), ATexture, clYellow, clBlack);
  end;}

procedure TFrmDlg.DGuildDlgDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  i, n, bx, by: integer;
  FColor: tColor;
  tStra,tStrb,tStrc,tStrd,tStre:string;
  tStr : AnsiString;
  inamea,inameb,inamec,inamed,inamee: string[18];
begin
  with DGuildDlg do
  begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

    with dsurface do
    begin
      FColor := clWhite;
      TextOut(Left + 320, Top + 13, FColor, Guild);

      bx := Left + 24;
      by := Top + 41;
      for i := GuildTopLine to GuildStrs.Count - 1 do
      begin
        n := i - GuildTopLine;
        if n * 14 > 356 then
          break;
        if Integer(GuildStrs.Objects[i]) <> 0 then
          FColor := TColor(GuildStrs.Objects[i])
        else
        begin
          if BoGuildChat then
            FColor := GetRGB(2)
          else
            FColor := clSilver;
        end;
        //TextOut(bx, by + n * 14, FColor, GuildStrs[i]);
        BoldTextOut(bx, by + n * 14, FColor, clBlack, GuildStrs[i]);

        tStr := GuildStrs[i];
        if tStr <> '' then begin
          FillChar(inamea[1], 18, #$20);
          FillChar(inameb[1], 18, #$20);
          FillChar(inamec[1], 18, #$20);
          FillChar(inamed[1], 18, #$20);
          FillChar(inamee[1], 18, #$20);

          tStr := GetValidStr3(tStr, tStra, [' ']);
          tStr := GetValidStr3(tStr, tStrb, [' ']);
          tStr := GetValidStr3(tStr, tStrc, [' ']);
          tStr := GetValidStr3(tStr, tStrd, [' ']);
          tStr := GetValidStr3(tStr, tStre, [' ']);

          inamea[0] := ANSIChar(90);
          Move(tStra[1], inamea[1], Length(tStra));
          Move(tStrb[1], inameb[1], Length(tStrb));
          Move(tStrc[1], inamec[1], Length(tStrc));
          Move(tStrd[1], inamed[1], Length(tStrd));
          Move(tStre[1], inamee[1], Length(tStre));
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DGDUpClick(Sender: TObject; X, Y: Integer);
begin
  if GuildTopLine > 0 then
    Dec(GuildTopLine, 3);
  if GuildTopLine < 0 then
    GuildTopLine := 0;
end;

procedure TFrmDlg.DGDDownClick(Sender: TObject; X, Y: Integer);
begin
  if GuildTopLine + 12 < GuildStrs.Count then
    Inc(GuildTopLine, 3);
end;

procedure TFrmDlg.DGDCloseClick(Sender: TObject; X, Y: Integer);
begin
  DGuildDlg.Visible := FALSE;
  BoGuildChat := FALSE;
end;

procedure TFrmDlg.DGDHomeClick(Sender: TObject; X, Y: Integer);
begin
  if GetTickCount > querymsgtime then
  begin
    querymsgtime := GetTickCount + 3000;
    FrmMain.SendGuildHome;
    BoGuildChat := FALSE;
  end;
end;

procedure TFrmDlg.DGDListClick(Sender: TObject; X, Y: Integer);
begin
  if GetTickCount > querymsgtime then
  begin
    querymsgtime := GetTickCount + 3000;
    FrmMain.SendGuildMemberList;
    BoGuildChat := FALSE;
  end;
end;

procedure TFrmDlg.DGDAddMemClick(Sender: TObject; X, Y: Integer);
begin
  DMessageDlg(Guild + '输入你想加为行会成员的角色名.', [mbOk, mbAbort]);
  if DlgEditText <> '' then
    FrmMain.SendGuildAddMem(DlgEditText);
end;

procedure TFrmDlg.DGDDelMemClick(Sender: TObject; X, Y: Integer);
begin
  DMessageDlg(Guild + '输入你想从行会中删除的角色名.', [mbOk, mbAbort]);
  if DlgEditText <> '' then
    FrmMain.SendGuildDelMem(DlgEditText);
end;

procedure TFrmDlg.DGDEditNoticeClick(Sender: TObject; X, Y: Integer);
begin
  GuildEditHint := '[修改行会公告内容.]';
  ShowGuildEditNotice;
end;

procedure TFrmDlg.DGDEditGradeClick(Sender: TObject; X, Y: Integer);
begin
  GuildEditHint := '[修改行会成员的等级和职位。 # 警告 : 不能增加行会成员/删除行会成员.]';
  ShowGuildEditGrade;
end;

procedure TFrmDlg.DGDAllyClick(Sender: TObject; X, Y: Integer);
begin
  if mrOk = DMessageDlg('和对方行会结盟应该在 [允许结盟] 状态下进行\'+'而且你应该面对对方行会首领\'+'你想结盟吗？', [mbOk, mbCancel]) then
    FrmMain.SendSay('@联盟');
end;

procedure TFrmDlg.DGDBreakAllyClick(Sender: TObject; X, Y: Integer);
begin
  DMessageDlg('请键入你想取消结盟的行会的名字。', [mbOk, mbAbort]);
  if DlgEditText <> '' then
    FrmMain.SendSay('@取消联盟 ' + DlgEditText);
end;

procedure TFrmDlg.DGuildEditNoticeDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with DGuildEditNotice do
  begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

    with dsurface do
    begin
      TextOut(Left + 18, Top + 291, clSilver, GuildEditHint);
    end;
  end;
end;

procedure TFrmDlg.DGECloseClick(Sender: TObject; X, Y: Integer);
begin
  DGuildEditNotice.Visible := FALSE;
  Memo.Visible := FALSE;
  DMsgDlg.DialogResult := mrCancel;
end;

procedure TFrmDlg.DGEOkClick(Sender: TObject; X, Y: Integer);
begin
  DGECloseClick(self, 0, 0);
  DMsgDlg.DialogResult := mrOk;
end;

procedure TFrmDlg.AddGuildChat(str: string);
var
  i: integer;
begin
  GuildChats.Add(str);
  if GuildChats.Count > 500 then
  begin
    for i := 0 to 100 do
      GuildChats.Delete(0);
  end;
  if BoGuildChat then
    GuildStrs.Assign(GuildChats);
end;



procedure TFrmDlg.AutoCRYClick(Sender: TObject; X, Y: Integer);
begin
  g_boAutoTalk := not g_boAutoTalk;
  if g_boAutoTalk then begin
     g_sAutoTalkStr := FrmDlg.DEdChat.Text;
     DScreen.AddChatBoardString('启用了自动喊话功能，聊天框中的内容已记录为喊话内容', RGB(0, 130, 0), clWhite)
  end else begin
     g_sAutoTalkStr := '';
     DScreen.AddChatBoardString('自动喊话功能已关闭', RGB(0, 130, 0), clWhite)
  end;
end;

procedure TFrmDlg.DGDChatClick(Sender: TObject; X, Y: Integer);
begin
  BoGuildChat := not BoGuildChat;
  if BoGuildChat then
  begin
    GuildStrs2.Assign(GuildStrs);
    GuildStrs.Assign(GuildChats);
  end
  else
    GuildStrs.Assign(GuildStrs2);
end;

procedure TFrmDlg.DGoldDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  if Myself = nil then
    exit;
  with dgold do
  begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
  end;
end;


{--------------------------------------------------------------}
//瓷仿摹 炼沥 芒

procedure TFrmDlg.DAdjustAbilCloseClick(Sender: TObject; X, Y: Integer);
begin
  DAdjustAbility.Visible := FALSE;
  BonusPoint := SaveBonusPoint;
end;

procedure TFrmDlg.DAdjustAbilityDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);

  procedure AdjustAb(abil: byte; val: word; var lov, hiv: byte);
  var
    lo, hi: byte;
    i: integer;
  begin
    lo := Lobyte(abil);
    hi := Hibyte(abil);
    lov := 0;
    hiv := 0;
    for i := 1 to val do
    begin
      if lo + 1 < hi then
      begin
        Inc(lo);
        Inc(lov);
      end
      else
      begin
        Inc(hi);
        Inc(hiv);
      end;
    end;
  end;

var
  d: TAsphyreLockableTexture;
  l, m, adc, amc, asc, aac, amac: integer;
  ldc, lmc, lsc, lac, lmac, hdc, hmc, hsc, hac, hmac: byte;
  FColor: TColor;
begin
  if Myself = nil then
    exit;
  with dsurface do
  begin
    with DAdjustAbility do
    begin
      d := DMenuDlg.WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
    end;

      //SetBkMode (Handle, TRANSPARENT);
//      Font.Color := clSilver;

    l := DAdjustAbility.SurfaceX(DAdjustAbility.Left) + 36;
    m := DAdjustAbility.SurfaceY(DAdjustAbility.Top) + 22;

    TextOut(l, m, clSilver, '恭喜: 你已经到了下一个等级了!.');
    TextOut(l, m + 14, clSilver, '选择你想提高的能力。');
    TextOut(l, m + 14 * 2, clSilver, '这样的选择你只可以做一次。');
    TextOut(l, m + 14 * 3, clSilver, '最好能很小心的选择。.');

      //目前的能力值
    l := DAdjustAbility.SurfaceX(DAdjustAbility.Left) + 100; //66;
    m := DAdjustAbility.SurfaceY(DAdjustAbility.Top) + 101;

    adc := (BonusAbil.DC + BonusAbilChg.DC) div BonusTick.DC;
    amc := (BonusAbil.MC + BonusAbilChg.MC) div BonusTick.MC;
    asc := (BonusAbil.SC + BonusAbilChg.SC) div BonusTick.SC;
    aac := (BonusAbil.AC + BonusAbilChg.AC) div BonusTick.AC;
    amac := (BonusAbil.MAC + BonusAbilChg.MAC) div BonusTick.MAC;

    AdjustAb(NakedAbil.DC, adc, ldc, hdc);
    AdjustAb(NakedAbil.MC, amc, lmc, hmc);
    AdjustAb(NakedAbil.SC, asc, lsc, hsc);
      //AdjustAb (NakedAbil.AC, aac, lac, hac);
      //AdjustAb (NakedAbil.MAC, amac, lmac, hmac);
    lac := 0;
    hac := aac;
    lmac := 0;
    hmac := amac;

    TextOut(l + 0, m + 0, clWhite, IntToStr(Lobyte(Myself.Abil.DC) + ldc) + '-' + IntToStr(Hibyte(Myself.Abil.DC) + hdc));
    TextOut(l + 0, m + 20, clWhite, IntToStr(Lobyte(Myself.Abil.MC) + lmc) + '-' + IntToStr(Hibyte(Myself.Abil.MC) + hmc));
    TextOut(l + 0, m + 40, clWhite, IntToStr(Lobyte(Myself.Abil.SC) + lsc) + '-' + IntToStr(Hibyte(Myself.Abil.SC) + hsc));
    TextOut(l + 0, m + 60, clWhite, IntToStr(Lobyte(Myself.Abil.AC) + lac) + '-' + IntToStr(Hibyte(Myself.Abil.AC) + hac));
    TextOut(l + 0, m + 80, clWhite, IntToStr(Lobyte(Myself.Abil.MAC) + lmac) + '-' + IntToStr(Hibyte(Myself.Abil.MAC) + hmac));
    TextOut(l + 0, m + 100, clWhite, IntToStr(Myself.Abil.MaxHP + (BonusAbil.HP + BonusAbilChg.HP) div BonusTick.HP));
    TextOut(l + 0, m + 120, clWhite, IntToStr(Myself.Abil.MaxMP + (BonusAbil.MP + BonusAbilChg.MP) div BonusTick.MP));
    TextOut(l + 0, m + 140, clWhite, IntToStr(MyHitPoint + (BonusAbil.Hit + BonusAbilChg.Hit) div BonusTick.Hit));
    TextOut(l + 0, m + 160, clWhite, IntToStr(MySpeedPoint + (BonusAbil.Speed + BonusAbilChg.Speed) div BonusTick.Speed));

    TextOut(l + 0, m + 180, clYellow, IntToStr(BonusPoint));

    l := DAdjustAbility.SurfaceX(DAdjustAbility.Left) + 155; //66;
    m := DAdjustAbility.SurfaceY(DAdjustAbility.Top) + 101;

    if BonusAbilChg.DC > 0 then
      FColor := clWhite
    else
      FColor := clSilver;
    TextOut(l + 0, m + 0, FColor, IntToStr(BonusAbilChg.DC + BonusAbil.DC) + '/' + IntToStr(BonusTick.DC));

    if BonusAbilChg.MC > 0 then
      FColor := clWhite
    else
      FColor := clSilver;
    TextOut(l + 0, m + 20, FColor, IntToStr(BonusAbilChg.MC + BonusAbil.MC) + '/' + IntToStr(BonusTick.MC));

    if BonusAbilChg.SC > 0 then
      FColor := clWhite
    else
      FColor := clSilver;
    TextOut(l + 0, m + 40, FColor, IntToStr(BonusAbilChg.SC + BonusAbil.SC) + '/' + IntToStr(BonusTick.SC));

    if BonusAbilChg.AC > 0 then
      FColor := clWhite
    else
      FColor := clSilver;
    TextOut(l + 0, m + 60, FColor, IntToStr(BonusAbilChg.AC + BonusAbil.AC) + '/' + IntToStr(BonusTick.AC));

    if BonusAbilChg.MAC > 0 then
      FColor := clWhite
    else
      FColor := clSilver;
    TextOut(l + 0, m + 80, FColor, IntToStr(BonusAbilChg.MAC + BonusAbil.MAC) + '/' + IntToStr(BonusTick.MAC));

    if BonusAbilChg.HP > 0 then
      FColor := clWhite
    else
      FColor := clSilver;
    TextOut(l + 0, m + 100, FColor, IntToStr(BonusAbilChg.HP + BonusAbil.HP) + '/' + IntToStr(BonusTick.HP));

    if BonusAbilChg.MP > 0 then
      FColor := clWhite
    else
      FColor := clSilver;
    TextOut(l + 0, m + 120, FColor, IntToStr(BonusAbilChg.MP + BonusAbil.MP) + '/' + IntToStr(BonusTick.MP));

    if BonusAbilChg.Hit > 0 then
      FColor := clWhite
    else
      FColor := clSilver;
    TextOut(l + 0, m + 140, FColor, IntToStr(BonusAbilChg.Hit + BonusAbil.Hit) + '/' + IntToStr(BonusTick.Hit));

    if BonusAbilChg.Speed > 0 then
      FColor := clWhite
    else
      FColor := clSilver;
    TextOut(l + 0, m + 160, FColor, IntToStr(BonusAbilChg.Speed + BonusAbil.Speed) + '/' + IntToStr(BonusTick.Speed));

      //Release;
  end;

end;

procedure TFrmDlg.DPlusDCClick(Sender: TObject; X, Y: Integer);
var
  incp: integer;
begin
  if BonusPoint > 0 then
  begin
    if IsKeyPressed(VK_CONTROL) and (BonusPoint > 10) then
      incp := 10
    else
      incp := 1;
    Dec(BonusPoint, incp);
    if Sender = DPlusDC then
      Inc(BonusAbilChg.DC, incp);
    if Sender = DPlusMC then
      Inc(BonusAbilChg.MC, incp);
    if Sender = DPlusSC then
      Inc(BonusAbilChg.SC, incp);
    if Sender = DPlusAC then
      Inc(BonusAbilChg.AC, incp);
    if Sender = DPlusMAC then
      Inc(BonusAbilChg.MAC, incp);
    if Sender = DPlusHP then
      Inc(BonusAbilChg.HP, incp);
    if Sender = DPlusMP then
      Inc(BonusAbilChg.MP, incp);
    if Sender = DPlusHit then
      Inc(BonusAbilChg.Hit, incp);
    if Sender = DPlusSpeed then
      Inc(BonusAbilChg.Speed, incp);
  end;
end;

procedure TFrmDlg.DPopUpEditsPopIndex(Sender, DControl: TDControl;
  ItemIndex: Integer; UserName: string);
var
  Key: Word;
begin
//  with DControl do begin
//    case Integer(TDPopUpMemu(Sender).Item.Objects[ItemIndex]) of
//      1: begin
//          Key := Word('X');
//          KeyDown(Key, [ssCtrl]);
//        end;
//      2: begin
//          Key := Word('C');
//          KeyDown(Key, [ssCtrl]);
//        end;
//      3: begin
//          Key := Word('V');
//          KeyDown(Key, [ssCtrl]);
//        end;
//      4: begin
//          Key := VK_DELETE;
//          KeyDown(Key, []);
//        end;
//    end;
//  end;
end;
procedure TFrmDlg.DMinusDCClick(Sender: TObject; X, Y: Integer);
var
  decp: integer;
begin
  if IsKeyPressed(VK_CONTROL) and (BonusPoint - 10 > 0) then
    decp := 10
  else
    decp := 1;
  if Sender = DMinusDC then
    if BonusAbilChg.DC >= decp then
    begin
      Dec(BonusAbilChg.DC, decp);
      Inc(BonusPoint, decp);
    end;
  if Sender = DMinusMC then
    if BonusAbilChg.MC >= decp then
    begin
      Dec(BonusAbilChg.MC, decp);
      Inc(BonusPoint, decp);
    end;
  if Sender = DMinusSC then
    if BonusAbilChg.SC >= decp then
    begin
      Dec(BonusAbilChg.SC, decp);
      Inc(BonusPoint, decp);
    end;
  if Sender = DMinusAC then
    if BonusAbilChg.AC >= decp then
    begin
      Dec(BonusAbilChg.AC, decp);
      Inc(BonusPoint, decp);
    end;
  if Sender = DMinusMAC then
    if BonusAbilChg.MAC >= decp then
    begin
      Dec(BonusAbilChg.MAC, decp);
      Inc(BonusPoint, decp);
    end;
  if Sender = DMinusHP then
    if BonusAbilChg.HP >= decp then
    begin
      Dec(BonusAbilChg.HP, decp);
      Inc(BonusPoint, decp);
    end;
  if Sender = DMinusMP then
    if BonusAbilChg.MP >= decp then
    begin
      Dec(BonusAbilChg.MP, decp);
      Inc(BonusPoint, decp);
    end;
  if Sender = DMinusHit then
    if BonusAbilChg.Hit >= decp then
    begin
      Dec(BonusAbilChg.Hit, decp);
      Inc(BonusPoint, decp);
    end;
  if Sender = DMinusSpeed then
    if BonusAbilChg.Speed >= decp then
    begin
      Dec(BonusAbilChg.Speed, decp);
      Inc(BonusPoint, decp);
    end;
end;

procedure TFrmDlg.DAdjustAbilOkClick(Sender: TObject; X, Y: Integer);
begin
  FrmMain.SendAdjustBonus(BonusPoint, BonusAbilChg);
  DAdjustAbility.Visible := FALSE;
end;

procedure TFrmDlg.DAdjustAbilityMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  i, lx, ly: integer;
  flag: Boolean;
begin
  with DAdjustAbility do
  begin
    lx := LocalX(X - Left);
    ly := LocalY(Y - Top);
    flag := FALSE;
    if (lx >= 50) and (lx < 150) then
      for i := 0 to 8 do
      begin  //DC,MC,SC..狼 腮飘啊 唱坷霸 茄促.
        if (ly >= 98 + i * 20) and (ly < 98 + (i + 1) * 20) then
        begin
          DScreen.ShowHint(SurfaceX(Left) + lx + 10, SurfaceY(Top) + ly + 5, AdjustAbilHints[i], clWhite, FALSE);
          flag := TRUE;
          break;
        end;
      end;
    if not flag then
      DScreen.ClearHint(True);
  end;
end;

procedure TFrmDlg.DSServer1DirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
begin
   with Sender as TDButton do begin
      if not Downed then begin
         d := WLib.Images[FaceIndex];
      end else begin
         d := WLib.Images[FaceIndex+1];
      end;
      if d <> nil then
         dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

      d := FontManager.GetFont('宋体', 12, [fsBold]).TextOut(TDButton(Sender).Caption);
      if d <> nil then
      begin
         if TDButton(Sender).Downed then
            dsurface.DrawBoldText(SurfaceX(Left + (WIDTH - d.WIDTH) div 2) + 1,
              SurfaceY(Top + (Height - d.Height) div 2) + 1, d, GetRGB(150), FontBorderColor)
         else
            dsurface.DrawBoldText(SurfaceX(Left + (WIDTH - d.WIDTH) div 2),
              SurfaceY(Top + (Height - d.Height) div 2), d, GetRGB(150), FontBorderColor);
      end;
   end;
end;


// 2003/04/15 模备, 率瘤 =============== 捞窍 场鳖瘤
procedure TFrmDlg.DBotFriendClick(Sender: TObject; X, Y: Integer);
begin
  ToggleShowFriendsDlg;
end;

procedure TFrmDlg.DBotFriendDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TDButton;
  dd: TAsphyreLockableTexture;
begin
  if Sender is TDButton then
  begin
    d := TDButton(Sender);
    if not d.Downed then
    begin
      dd := d.WLib.Images[d.FaceIndex];
      if dd <> nil then
        dsurface.Draw(d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, TRUE);
    end
    else
    begin
      dd := d.WLib.Images[d.FaceIndex + 1];
      if dd <> nil then
        dsurface.Draw(d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, TRUE);
    end;
  end;
end;

procedure TFrmDlg.DBotFriendMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  lx, ly: integer;
  sx, sy: integer;
begin
  with DBotFriend do
  begin
    lx := LocalX(X - Left);
    ly := LocalY(Y - Top);
    sx := SurfaceX(Left) + DBottom.SurfaceX(DBottom.Left) + lx + 13;
    sy := SurfaceY(Top) + DBottom.SurfaceX(DBottom.Top) + ly - 2;
    DScreen.ShowHint(sx, sy, '朋友(W)', clYellow, FALSE);
  end;
end;

procedure TFrmDlg.ToggleShowFriendsDlg;
begin
  DFriendDlg.Visible := not DFriendDlg.Visible;
end;

procedure TFrmDlg.ToggleShowMailListDlg;
begin
  DMailListDlg.Visible := not DMailListDlg.Visible;
  MailAlarm := false;
end;

procedure TFrmDlg.ToggleShowBlockListDlg;
begin
  DBlockListDlg.Visible := not DBlockListDlg.Visible;
end;

procedure TFrmDlg.ToggleShowMemoDlg;
begin
  DMemo.Visible := not DMemo.Visible;
  MemoMail.Visible := DMemo.Visible;
end;

procedure TFrmDlg.DFriendDlgDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
//  b: TAsphyreLockableTexture;
  lx, ly, n, t, l, ax, ay: integer;
  CurrentPage, maxPage, UpPage, DownPage: integer;
  FColor: TColor;
  str: string;
begin
  if ViewRelation = 0 then
  begin
    CurrentPage := FriendPage + 1;
    maxPage := FriendMembers.Count div 10 + 1;
  end
  else
  begin
    CurrentPage := BlackListPage + 1;
    maxPage := BlackMembers.Count div 10 + 1;
  end;

  if CurrentPage > 1 then UpPage := CurrentPage - 1
  else UpPage := CurrentPage;
  if CurrentPage < maxPage then DownPage := CurrentPage + 1
  else DownPage := CurrentPage;

//  DFrdpgUp.hint := IntToStr(UpPage) + '/' + IntToStr(maxPage);
//  DFrdpgDn.hint := IntToStr(DownPage) + '/' + IntToStr(maxPage);

//  b := WProgUse.GetCachedImage (534, ax, ay);
  with DFriendDlg do begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
    if ViewRelation = 0 then begin
      if FriendMembers.Count > 0 then begin
        t := FriendPage * 10;
        l := _MIN(FriendPage * 10 + 10, FriendMembers.Count);
        for n := t to l - 1 do begin
          if PTFriend(FriendMembers[n]).Status >= 4 then
            FColor := clWhite
          else
            FColor := clSilver;
          FColor := clWhite;
          lx := SurfaceX(40) + Left;
          ly := SurfaceY(50) + Top + (n - t) * 17;

          if fLover.Find(PTFriend(FriendMembers[n]).CharID) then
            str := '⒔' + PTFriend(FriendMembers[n]).CharID
          else
            str := PTFriend(FriendMembers[n]).CharID;

          if n = CurrentFriend then FColor := clRed;

          dsurface.TextOut(lx, ly, str, FColor);
          FColor := clWhite;
//          lx := SurfaceX(25) + Left;
//          ly := SurfaceY(240) + Top;
//          dsurface.TextOut(lx, ly, FColor, IntToStr(ConnectFriend) + '/' + IntToStr(FriendMembers.Count));

        end;
      end;
    end else if ViewRelation = 1 then begin
      lx := SurfaceX(32) + Left;
      ly := SurfaceY(60) + Top;
      dsurface.TextOut(lx, ly + 13 * 0, '拜师的最高等级为18级', clWhite);     //拜师的最高等级为18级
      dsurface.TextOut(lx, ly + 13 * 1, '，收徒的最低等级为28', clWhite);    //，收徒的最低等级为28
      dsurface.TextOut(lx, ly + 13 * 2, '级，当您以徒弟的身份', clWhite);
      dsurface.TextOut(lx, ly + 13 * 3, '达到28级时，您将自动', clWhite);     //达到28级时，您将自动
      dsurface.TextOut(lx, ly + 13 * 4, '与您的师傅解除师徒关', clWhite);
      dsurface.TextOut(lx, ly + 13 * 5, '系。您可以前往竞技之', clWhite);
      dsurface.TextOut(lx, ly + 13 * 6, '地武馆教头处查看进一', clWhite);
      dsurface.TextOut(lx, ly + 13 * 7, '步的说明，并进行拜师', clWhite);
      dsurface.TextOut(lx, ly + 13 * 8, '、收徒，竞技之地位置', clWhite);
      dsurface.TextOut(lx, ly + 13 * 9, '在', clWhite);
      dsurface.TextOut(lx+12, ly + 13 * 9, '比奇城（416，244）', clYellow);
    end
    else begin
      if BlackMembers.Count > 0 then begin
        with dsurface do begin
          FColor := clSilver;
          t := BlackListPage * 10;
          l := _MIN(BlackListPage * 10 + 10, BlackMembers.Count);
          for n := t to l - 1 do begin

            if PTFriend(BlackMembers[n]).Status >= 4 then
              FColor := clWhite
            else
              FColor := clSilver;
            FColor := clWhite;
            lx := SurfaceX(40) + Left;
            ly := SurfaceY(50) + Top + (n - t) * 17;

            str := PTFriend(BlackMembers[n]).CharID;
            if n = CurrentBlack then
              FColor := clRed;

            TextOut(lx, ly, FColor, str);
          end;

          FColor := clWhite;
          lx := SurfaceX(25) + Left;
          ly := SurfaceY(240) + Top;
//          dsurface.TextOut(lx, ly, FColor, IntToStr(ConnectBlack) + '/' + IntToStr(BlackMembers.Count));
        end;
      end;
    end;
      //捞抚
//    with dsurface do begin
//      TextOut (SurfaceX(Left + 134 - FontManager.Default.TextWidth(MySelf.UserName) div 2),
//               SurfaceY(Top + 13), MySelf.NameColor, MySelf.UserName);
//    end;
  end;
end;

procedure TFrmDlg.DFrdPgUpClick(Sender: TObject; X, Y: Integer);
begin
  if Sender = DFrdPgUp then
  begin
    if ViewRelation = 0 then
    begin
      if FriendPage > 0 then
        Dec(FriendPage);
    end
    else
    if ViewRelation = 2 then begin
      if BlackListPage > 0 then
        Dec(BlackListPage);
    end;
  end
  else
  begin
    if ViewRelation = 0 then
    begin
      if FriendPage < (FriendMembers.Count + 9) div 10 - 1 then
        Inc(FriendPage);
    end
    else
    if ViewRelation = 2 then begin
      if BlackListPage < (BlackMembers.Count + 9) div 10 - 1 then
        Inc(BlackListPage);
    end;
  end;
end;

procedure TFrmDlg.DFrdPgUpDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with Sender as TDButton do
  begin
    if TDButton(Sender).Downed then
    begin
      d := WLib.Images[FaceIndex + 1];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
    end else begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
    end;
  end;
end;

procedure TFrmDlg.DFrdFriendClick(Sender: TObject; X, Y: Integer);
begin
//  ViewFriends := TRUE;
//  DFriendDlg.hint := '';
  ViewRelation := TDButton(Sender).Tag;
end;

procedure TFrmDlg.DFrdBlackListClick(Sender: TObject; X, Y: Integer);
begin
  ViewFriends := FALSE;
  DFriendDlg.hint := '';
end;

procedure TFrmDlg.DFrdAddMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  lx, ly: integer;
  sx, sy: integer;
begin
  with DFrdAdd do
  begin
    lx := LocalX(X - Left);
    ly := LocalY(Y - Top);
    sx := SurfaceX(Left) + DFriendDlg.SurfaceX(DFriendDlg.Left) + lx + 8;
    sy := SurfaceY(Top) + DFriendDlg.SurfaceX(DFriendDlg.Top) + ly + 6;
    DScreen.ShowHint(sx, sy, '增加', clWhite, FALSE);     //clYellow
    DFriendDlg.hint := '';
  end;
end;

procedure TFrmDlg.DFrdDelMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  lx, ly: integer;
  sx, sy: integer;
begin
  with DFrdDel do
  begin
    lx := LocalX(X - Left);
    ly := LocalY(Y - Top);
    sx := SurfaceX(Left) + DFriendDlg.SurfaceX(DFriendDlg.Left) + lx + 8;
    sy := SurfaceY(Top) + DFriendDlg.SurfaceX(DFriendDlg.Top) + ly + 6;
    DScreen.ShowHint(sx, sy, '删除', clWhite, FALSE);     //clYellow
    DFriendDlg.hint := '';
  end;
end;

procedure TFrmDlg.DFrdMemoMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  lx, ly: integer;
  sx, sy: integer;
begin
  with DFrdMemo do
  begin
    lx := LocalX(X - Left);
    ly := LocalY(Y - Top);
    sx := SurfaceX(Left) + DFriendDlg.SurfaceX(DFriendDlg.Left) + lx + 8;
    sy := SurfaceY(Top) + DFriendDlg.SurfaceX(DFriendDlg.Top) + ly + 6;
    DScreen.ShowHint(sx, sy, '备忘录', clWhite, FALSE);     //clYellow
    DFriendDlg.hint := '';
  end;
end;

procedure TFrmDlg.DFrdMailMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  lx, ly: integer;
  sx, sy: integer;
begin
  with DFrdMail do
  begin
    lx := LocalX(X - Left);
    ly := LocalY(Y - Top);
    sx := SurfaceX(Left) + DFriendDlg.SurfaceX(DFriendDlg.Left) + lx + 8;
    sy := SurfaceY(Top) + DFriendDlg.SurfaceX(DFriendDlg.Top) + ly + 6;
    DScreen.ShowHint(sx, sy, '邮件', clWhite, FALSE);     //clYellow
    DFriendDlg.hint := '';
  end;
end;

procedure TFrmDlg.DFrdWhisperMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  lx, ly: integer;
  sx, sy: integer;
begin
  with DFrdWhisper do
  begin
    lx := LocalX(X - Left);
    ly := LocalY(Y - Top);
    sx := SurfaceX(Left) + DFriendDlg.SurfaceX(DFriendDlg.Left) + lx + 8;
    sy := SurfaceY(Top) + DFriendDlg.SurfaceX(DFriendDlg.Top) + ly + 6;
    DScreen.ShowHint(sx, sy, '私聊', clWhite, FALSE);     //clYellow
    DFriendDlg.hint := '';
  end;
end;

procedure TFrmDlg.DFrdCloseClick(Sender: TObject; X, Y: Integer);
begin
  ToggleShowFriendsDlg;
end;

procedure TFrmDlg.DFrdFriendDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with Sender as TDButton do
  begin
    if TDButton(Sender).Tag = ViewRelation then
    begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
    end;
  end;
end;

procedure TFrmDlg.DFrdBlackListDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with Sender as TDButton do
  begin
    if ViewFriends then
    begin
      d := WLib.Images[FaceIndex + 1];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
    end
    else
    begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
    end;
  end;
end;

procedure TFrmDlg.DMailListDlgDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  b: TAsphyreLockableTexture;
  ATextLine: TAsphyreLockableTexture;
  ATextureFont: TAsphyreTextureFont;
  lx, ly, n, t, l, ax, ay: integer;
  Rect: TRect;
  CurrentPage, maxPage, UpPage, DownPage: integer;
  LockStr: string;
  FColor: TColor;
begin
  CurrentPage :=  MailPage + 1;
  MaxPage     :=  MailLists.Count div 10 + 1;
  if CurrentPage > 1 then UpPage := CurrentPage -1
  else UpPage := CurrentPage;
  if CurrentPage < MaxPage then DownPage := CurrentPage+1
  else DownPage := CurrentPage;

  DMailListPgUp.hint   := IntToStr ( UpPage   ) + '/' + IntToStr ( MaxPage );
  DMailListpgDn.hint   := IntToStr ( DownPage ) + '/' + IntToStr ( MaxPage );

  b := WProgUse.GetCachedImage (543, ax, ay);
  with DMailListDlg do
  begin
    d := WLib.Images[FaceIndex];

    if d <> nil then
      dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

    dsurface.Draw (SurfaceX(Left+15), SurfaceY(Top+35), b.ClientRect, b, TRUE);

    if MailLists.Count > 0 then begin
      t := MailPage * 11;
      l := _MIN(MailPage * 11 + 11, MailLists.Count);

      for n := t to l - 1 do begin

        lx := SurfaceX(30) + Left;
        ly := SurfaceY(60) + Top + (n - t) * 15;
        if n = CurrentMail then begin
          dsurface.FillRect(lx, ly, FontManager.Default.TextWidth(PTMail(MailLists[n]).Sender), FontManager.Default.TextHeight(PTMail(MailLists[n]).Sender), $FF808080);
        end
        else begin
          dsurface.FillRect(lx, ly, FontManager.Default.TextWidth(PTMail(MailLists[n]).Sender), FontManager.Default.TextHeight(PTMail(MailLists[n]).Sender), $FF000000);
        end;

        LockStr := '';
        FColor := clWhite;
        case PTMail(MailLists[n]).Status of
          0:
            FColor := clWhite;
          1:
            FColor := clSilver;
          2:
            begin
              FColor := clWhite;
              LockStr := '[*]';
            end;
          3:
            FColor := clBlue;
        end;

        Rect.Left := lx - 10;
        Rect.Top := ly;
        Rect.Right := lx + 215;
        Rect.Bottom := ly + 15;
        dsurface.TextOut(lx, ly + 2, PTMail(MailLists[n]).Sender, FColor);

        lx := SurfaceX(145) + Left;
        ly := SurfaceY(60) + Top + (n - t) * 15;

        Rect.Left := lx;
        Rect.Top := ly;
        Rect.Right := lx + 100;
        Rect.Bottom := ly + 15;

        ATextureFont := FontManager.GetFont('宋体',9,[]);
        ATextLine := ATextureFont.TextOut(LockStr + StrToVisibleOnly(SqlSafeToStr(PTMail(MailLists[n]).Mail)));
        if ATextLine <> nil then
        begin
          dsurface.DrawInRect(lx, ly, Rect,
          ATextLine, cColor4(cColor1(FColor)));
        end;

        FColor := clWhite;
        lx := SurfaceX(25) + Left;
        ly := SurfaceY(240) + Top;
        dsurface.TextOut(lx, ly, FColor, IntToStr(NotReadMailCount) + '/' + IntToStr(MailLists.Count));
      end;
    end;

    //捞抚
    with dsurface do
    begin
      TextOut (SurfaceX(Left + 134 - FontManager.Default.TextWidth(MySelf.UserName) div 2),
               SurfaceY(Top + 13), MySelf.NameColor, MySelf.UserName);
    end;
  end;
end;

procedure TFrmDlg.DMailListCloseClick(Sender: TObject; X, Y: Integer);
begin
  ToggleShowMailListDlg;
end;

procedure TFrmDlg.DMailListPgUpClick(Sender: TObject; X, Y: Integer);
begin
  if Sender = DMailListPgUp then
  begin
    if MailPage > 0 then
      Dec(MailPage);
  end
  else
  begin
    if MailPage < (MailLists.Count + 10) div 11 - 1 then
      Inc(MailPage);
  end;
end;

procedure TFrmDlg.DMLReplyMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  lx, ly: integer;
  sx, sy: integer;
begin
  with DMLReply do
  begin
    lx := LocalX(X - Left);
    ly := LocalY(Y - Top);
    sx := SurfaceX(Left) + DMailListDlg.SurfaceX(DMailListDlg.Left) + lx + 8;
    sy := SurfaceY(Top) + DMailListDlg.SurfaceX(DMailListDlg.Top) + ly + 6;
    DScreen.ShowHint(sx, sy, '回复', clWhite, FALSE);    //clYellow
  end;
end;

procedure TFrmDlg.DMoveButton_itemsDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TDMoveButton;
  dd: TAsphyreLockableTexture;
begin
  if Sender is TDMoveButton then begin
    d := TDMoveButton(Sender);
    dd := d.WLib.Images[d.FaceIndex];
    if dd <> nil then
      dsurface.Draw(d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, True);
  end;
end;


procedure TFrmDlg.DMLReadMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  lx, ly: integer;
  sx, sy: integer;
begin
  with DMLRead do
  begin
    lx := LocalX(X - Left);
    ly := LocalY(Y - Top);
    sx := SurfaceX(Left) + DMailListDlg.SurfaceX(DMailListDlg.Left) + lx + 8;
    sy := SurfaceY(Top) + DMailListDlg.SurfaceX(DMailListDlg.Top) + ly + 6;
    DScreen.ShowHint(sx, sy, '阅读', clWhite, FALSE);   //clYellow
  end;
end;

procedure TFrmDlg.DMLDelMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  lx, ly: integer;
  sx, sy: integer;
begin
  with DMLDel do
  begin
    lx := LocalX(X - Left);
    ly := LocalY(Y - Top);
    sx := SurfaceX(Left) + DMailListDlg.SurfaceX(DMailListDlg.Left) + lx + 8;
    sy := SurfaceY(Top) + DMailListDlg.SurfaceX(DMailListDlg.Top) + ly + 6;
    DScreen.ShowHint(sx, sy, '删除', clWhite, FALSE);     //clYellow
  end;
end;

procedure TFrmDlg.DMLLockMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  lx, ly: integer;
  sx, sy: integer;
begin
  with DMLLock do
  begin
    lx := LocalX(X - Left);
    ly := LocalY(Y - Top);
    sx := SurfaceX(Left) + DMailListDlg.SurfaceX(DMailListDlg.Left) + lx + 8;
    sy := SurfaceY(Top) + DMailListDlg.SurfaceX(DMailListDlg.Top) + ly + 6;
    DScreen.ShowHint(sx, sy, '保护', clWhite, FALSE);    //clYellow
  end;
end;

procedure TFrmDlg.DMLBlockMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  lx, ly: integer;
  sx, sy: integer;
begin
  with DMLBlock do
  begin
    lx := LocalX(X - Left);
    ly := LocalY(Y - Top);
    sx := SurfaceX(Left) + DMailListDlg.SurfaceX(DMailListDlg.Left) + lx + 8;
    sy := SurfaceY(Top) + DMailListDlg.SurfaceX(DMailListDlg.Top) + ly + 6;
    DScreen.ShowHint(sx, sy, '屏蔽列表', clWhite, FALSE);     //clYellow
  end;
end;

procedure TFrmDlg.DMailListDlgClick(Sender: TObject; X, Y: Integer);
var
  lx, ly: integer;
  pos: integer;
begin
  ItemSearchEdit.Visible := False;
  lx := X - DMailListDlg.Left;
  ly := Y - DMailListDlg.Top;
  if (lx > 20) and (lx < 250) and (ly > 60) and (ly < 225) then
  begin
    pos := (ly - 60) div 15 + MailPage * 11;
    if MailLists.Count > pos then
      CurrentMail := pos;
  end;
end;

procedure TFrmDlg.DMailListDlgDblClick(Sender: TObject);
begin
  MailListDlgDblClicked := true;
end;

procedure TFrmDlg.DMailListDlgMouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  if not MailListDlgDblClicked then
    Exit;

  MailListDlgDblClicked := false;
  DMLReadClick(nil, 0, 0);
end;

procedure TFrmDlg.DFriendDlgClick(Sender: TObject; X, Y: Integer);
var
  lx, ly, pos, sx, sy: integer;
begin
  ItemSearchEdit.Visible := False;

  lx := X - DFriendDlg.Left;
  ly := Y - DFriendDlg.Top;
  (Sender as TDWindow).hint := '';
  if (lx > 35) and (lx < 130) and (ly > 50) and (ly < 220) then
  begin

    pos := ((ly - 50) div 17) + FriendPage * 10;
    if ViewRelation = 0 then
    begin
      if FriendMembers.Count > pos then
      begin
        CurrentFriend := pos;

        if CurrentFriend >= 0 then
        begin
          (Sender as TDWindow).hint := StrToHint(SqlSafeToStr(PTFriend(FriendMembers[CurrentFriend]).Memo));
        end;
      end;
    end
    else
    begin
      if BlackMembers.Count > pos then
      begin
        CurrentBlack := pos;
        if CurrentBlack >= 0 then
        begin
          (Sender as TDWindow).hint := StrToHint(SqlSafeToStr(PTFriend(BlackMembers[CurrentBlack]).Memo));
        end;
      end;
    end;

  end


//    DScreen.AddSysMsg (IntToStr(lx) + ' ' + IntToStr(ly) + ' ' + IntToStr(pos));
end;

procedure TFrmDlg.DFriendDlgDblClick(Sender: TObject);
begin
  if ViewRelation = 1 then Exit;
  FriendDlgDblClicked := true;
end;

procedure TFrmDlg.DFriendDlgMouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  if not FriendDlgDblClicked then
    Exit;

  FriendDlgDblClicked := false;

  if ViewRelation = 0 then
  begin
    if CurrentFriend >= 0 then
    begin
//      if (PTFriend(FriendMembers[CurrentFriend]).Status >= 4) then
        DFrdWhisperClick(nil, 0, 0);
//      else
//        DFrdMailClick(nil, 0, 0);
    end;
  end
  else
  if ViewRelation = 2 then begin
    if CurrentBlack >= 0 then
    begin
//      if (PTFriend(BlackMembers[CurrentBlack]).Status >= 4) then
        DFrdWhisperClick(nil, 0, 0);
//      else
//        DFrdMailClick(nil, 0, 0);
    end;
  end;

end;

procedure TFrmDlg.DBlockListCloseClick(Sender: TObject; X, Y: Integer);
begin
  ToggleShowBlockListDlg;
end;

procedure TFrmDlg.DBLPgUpClick(Sender: TObject; X, Y: Integer);
begin
  if Sender = DBLPgUp then
  begin
    if BlockPage > 0 then
      Dec(BlockPage);
  end
  else
  begin
    if BlockPage < (BlockLists.Count + 10) div 11 - 1 then
      Inc(BlockPage);
  end;
end;

procedure TFrmDlg.DBlockListDlgDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  b: TAsphyreLockableTexture;
  lx, ly, n, t, l, ax, ay: integer;
  Rect: TRect;
  CurrentPage, maxPage, UpPage, DownPage: integer;
  FColor: TColor;
begin
  CurrentPage :=  BlockPage + 1;
  MaxPage     :=  BlockLists.Count div 10 + 1;
  if CurrentPage > 1 then UpPage := CurrentPage -1
  else UpPage := CurrentPage;
  if CurrentPage < MaxPage then DownPage := CurrentPage+1
  else DownPage := CurrentPage;

  DBLpgUp.hint := IntToStr(UpPage) + '/' + IntToStr(maxPage);
  DBLpgDn.hint := IntToStr(DownPage) + '/' + IntToStr(maxPage);

  b := WProgUse.GetCachedImage (542, ax, ay);
  with DBlockListDlg do begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
    dsurface.Draw (SurfaceX(Left+15), SurfaceY(Top+35), b.ClientRect, b, TRUE);
    if BlockLists.Count > 0 then begin
      t := BlockPage * 11;
      l := _MIN(BlockPage * 11 + 11, BlockLists.Count);
      for n := t to l - 1 do begin

        lx := SurfaceX(30) + Left + ((n - t) mod 2) * 120;
        ly := SurfaceY(70) + Top + ((n - t) div 2) * 15;
        if n = CurrentBlock then begin
          FColor := clBlack;
          dsurface.FillRect(lx, ly, FontManager.Default.TextWidth(BlockLists[n]), FontManager.Default.TextHeight(BlockLists[n]), $FF808080);
        end
        else begin
          FColor := clSilver;
          dsurface.FillRect(lx, ly, FontManager.Default.TextWidth(BlockLists[n]), FontManager.Default.TextHeight(BlockLists[n]), $FF000000);
        end;
        dsurface.TextOut(lx, ly, BlockLists[n], FColor);
      end;
    end;
    //捞抚
    with dsurface do begin
      TextOut (SurfaceX(Left + 134 - FontManager.Default.TextWidth(MySelf.UserName) div 2),
               SurfaceY(Top + 13), MySelf.NameColor, MySelf.UserName);
    end;
  end;
end;

procedure TFrmDlg.DBlockListDlgClick(Sender: TObject; X, Y: Integer);
var
  lx, ly: integer;
  pos: integer;
begin
  ItemSearchEdit.Visible := False;

  lx := X - DBlockListDlg.Left;
  ly := Y - DBlockListDlg.Top;
  if (lx > 20) and (lx < 250) and (ly > 60) and (ly < 225) then
  begin
    pos := (lx div 140) + ((ly - 70) div 15) * 2 + FriendPage * 20;
//       pos := (ly - 60) div 15 + BlockPage * 11;
    if BlockLists.Count > pos then
      CurrentBlock := pos;
  end;
end;

procedure TFrmDlg.DBLAddMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  lx, ly: integer;
  sx, sy: integer;
begin
  with DBLAdd do
  begin
    lx := LocalX(X - Left);
    ly := LocalY(Y - Top);
    sx := SurfaceX(Left) + DBlockListDlg.SurfaceX(DBlockListDlg.Left) + lx + 8;
    sy := SurfaceY(Top) + DBlockListDlg.SurfaceX(DBlockListDlg.Top) + ly + 6;
    DScreen.ShowHint(sx, sy, '加入屏蔽列表', clWhite, FALSE);    //clYellow
  end;
end;

procedure TFrmDlg.DBLDelMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  lx, ly: integer;
  sx, sy: integer;
begin
  with DBLDel do
  begin
    lx := LocalX(X - Left);
    ly := LocalY(Y - Top);
    sx := SurfaceX(Left) + DBlockListDlg.SurfaceX(DBlockListDlg.Left) + lx + 8;
    sy := SurfaceY(Top) + DBlockListDlg.SurfaceX(DBlockListDlg.Top) + ly + 6;
    DScreen.ShowHint(sx, sy, '删除', clWhite, FALSE);  //clYellow
  end;
end;

procedure TFrmDlg.DMLBlockClick(Sender: TObject; X, Y: Integer);
begin
  ToggleShowBlockListDlg;
end;

procedure TFrmDlg.DBotMemoMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  lx, ly: integer;
  sx, sy: integer;
begin
  with DBotMemo do
  begin
    lx := LocalX(X - Left);
    ly := LocalY(Y - Top);
    sx := SurfaceX(Left) + DBottom.SurfaceX(DBottom.Left) + lx + 8;
    sy := SurfaceY(Top) + DBottom.SurfaceX(DBottom.Top) + ly + 6;
    DScreen.ShowHint(sx, sy, '邮件包(M)', clWhite, FALSE);   //clYellow
  end;

end;

procedure TFrmDlg.DBotMemoClick(Sender: TObject; X, Y: Integer);
begin
  ToggleShowMailListDlg;

  if WantMailList = false then
  begin
    FrmMain.SendMailList;
    FrmMain.SendRejectLIst;
    WantMailList := true;
  end;

  MailAlarm := false;

end;

procedure TFrmDlg.AddFriend(FriendName: string; ShowMessage: Boolean);
var
  frdtype: integer;
begin
  if FriendName <> '' then
  begin
      // 磊脚篮 殿废且 荐 绝促
    if FriendName = MySelf.UserName then
    begin
      if ShowMessage then
        DMessageDlg('你不能添加自己', [mbOk]);
      Exit;
    end;

    if FrmMain.IsMyMember(FriendName) then
    begin
      if ShowMessage then
        DMessageDlg(FriendName + '已经添加到列表', [mbOk]);
      Exit;
    end;

    if ViewRelation = 0 then
      frdtype := 1
    else
      frdtype := 8;
    FrmMain.SendAddFriend(FriendName, frdtype);
  end;

end;

procedure TFrmDlg.DFrdAddClick(Sender: TObject; X, Y: Integer);
var
  str:string;
begin
   { 2003/04/15
   if (not DMemo.Visible) then begin
      ViewWindowNo := 1;
      DMemoB1.SetImgIndex(WProgUse, 544);
      ShowEditMail;
   end;
   }
  if ViewRelation = 1 then Exit;


  // 殿废且 模备 肚绰 厩楷狼 俺荐甫 汲沥茄促.
  if ViewRelation = 0 then
  begin
    if Friendmembers.Count >= MAX_FRIEND_COUNT then
    begin
      DMessageDlg('没有更多的位置可增加你的好友', [mbOk]);
      Exit;
    end;
    str := '添加新的好友';
  end
  else
  begin
    if Blackmembers.Count >= MAX_FRIEND_COUNT then
    begin
      DMessageDlg('没有更多的位置可以增加你的敌人', [mbOk]);
      Exit;
    end;
    str := '添加新的黑名单';
  end;

  DScreen.ClearHint(True);
  DMessageDlg(str, [mbOk, mbAbort]);
  AddFriend(DlgEditText, true);

end;

procedure TFrmDlg.DFrdDelClick(Sender: TObject; X, Y: Integer);
var
  delchar: string;
begin
  if ViewRelation = 1 then Exit;
  if ViewRelation = 0 then
  begin
    if CurrentFriend >= 0 then
      delchar := PTFriend(FriendMembers[CurrentFriend]).CharID
    else
      Exit;
  end
  else
  begin
    if CurrentBlack >= 0 then
      delchar := PTFriend(BlackMembers[CurrentBlack]).CharID
    else
      Exit;
  end;

  if delchar <> '' then
  begin
    if mrOk = FrmDlg.DMessageDlg('你确认删除 [ ' + delchar + ' ] 吗？', [mbOk, mbCancel]) then
    begin
      FrmMain.sendDelFriend(delchar);
      if ViewRelation = 0 then CurrentFriend := -1
      else CurrentBlack := -1;
    end;
  end;

end;

procedure TFrmDlg.DFrdMailClick(Sender: TObject; X, Y: Integer);
begin

//   if (not DMemo.Visible)then
  begin
    if ViewFriends then
    begin
      if (CurrentFriend < 0) then
        Exit;
      ViewWindowData := CurrentFriend;
      MemoCharID := PTFriend(FriendMembers[ViewWindowData]).CharID;
    end
    else
    begin
      if (CurrentBlack < 0) then
        Exit;
      ViewWindowData := CurrentBlack;
      MemoCharID := PTFriend(BlackMembers[ViewWindowData]).CharID;
    end;

    ViewWindowNo := VIEW_MAILSEND;
    DMemoB1.SetImgIndex(WProgUse, 546);
    DMemoB2.SetImgIndex(WProgUse, 538);
    DMemoB1.Visible := true;
    memoMail.Clear;

    ShowEditMail;
  end;
end;

procedure TFrmDlg.DMLReadClick(Sender: TObject; X, Y: Integer);
var
  str: string;
begin
//   if (not DMemo.Visible) and (CurrentMail >= 0) then begin
  if (CurrentMail >= 0) then
  begin

    ViewWindowNo := VIEW_MAILREAD;
    ViewWindowData := CurrentMail;
    DMemoB1.Visible := false; //.SetImgIndex(WProgUse, 544);
    DMemoB2.SetImgIndex(WProgUse, 544);
    MemoMail.Text := SQlSafeToStr(pTMail(MailLists[CurrentMail]).Mail);
    MemoMail.ReadOnly := true;
    MemoCharID := PTMail(MailLists[ViewWindowData]).Sender;
    str := PTMail(MailLists[ViewWindowData]).Date;
    MemoDate := '20' + str[1] + str[2] + '/' + str[3] + str[4] + '/' + str[5] + str[6] + ' ' + str[7] + str[8] + ':' + str[9] + str[10];
      // 佬菌澜阑 傈价
    if (pTMail(MailLists[CurrentMail]).Status = 0) then
      FrmMain.SendReadingMail(pTMail(MailLists[CurrentMail]).Date);

    ShowEditMail;

  end;
end;

procedure TFrmDlg.DFrdMemoClick(Sender: TObject; X, Y: Integer);
begin
//   if (not DMemo.Visible) then
  begin
    if ViewFriends then
    begin
      if (CurrentFriend >= 0) then
      begin
        ViewWindowData := CurrentFriend;
        MemoCharID := PTFriend(FriendMembers[ViewWindowData]).CharID;
        ViewWindowNo := VIEW_MEMO;
        memoMail.Text := SqlSafeToStr(PTFriend(FriendMembers[CurrentFriend]).Memo);
        DMemoB1.SetImgIndex(WProgUse, 544);
        DMemoB2.SetImgIndex(WProgUse, 538);
        DMemoB1.Visible := true;

        ShowEditMail;
      end;
    end
    else
    begin
      if (CurrentBlack >= 0) then
      begin
        ViewWindowData := CurrentBlack;
        MemoCharID := PTFriend(BlackMembers[ViewWindowData]).CharID;
        ViewWindowNo := VIEW_MEMO;
        memoMail.Text := SqlSafeToStr(PTFriend(BlackMembers[CurrentBlack]).Memo);
        DMemoB1.SetImgIndex(WProgUse, 544);
        DMemoB2.SetImgIndex(WProgUse, 538);
        DMemoB1.Visible := true;

        ShowEditMail;
      end;

    end;

  end;
end;

procedure TFrmDlg.DFrdWhisperClick(Sender: TObject; X, Y: Integer);
var
  wisname: string;
  actionchar: char;
begin

  if ViewRelation = 0 then
  begin
    if CurrentFriend >= 0 then
      wisname := PTFriend(FriendMembers[CurrentFriend]).CharID
    else
      Exit;
  end
  else
  begin
    if CurrentBlack >= 0 then
      wisname := PTFriend(BlackMembers[CurrentBlack]).CharID
    else
      Exit;
  end;

  FrmDlg.DEdChat.Visible := FALSE;
  FrmMain.WhisperName := wisname;
//  if FrmMain.WhisperName = Copy(fLover.GetDisplay(0), length(STR_LOVER) + 1, 20) then
//    actionchar := ','
//  else
    actionchar := '/';
  FrmMain.FormKeyPress(Sender, actionchar);
end;

procedure TFrmDlg.DMemoDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  b: TAsphyreLockableTexture;
  lx, ly, n, t, l, ax, ay: integer;
  Rect: TRect;
begin
//     if not (Sender As TDWindow).CanFocus then MemoMail.Visible := false
//     else MemoMail.Visible := true;

  case ViewWindowNo of
    VIEW_MAILREAD:
      begin
        memoMail.Left := DMemo.Left + 28;
        memoMail.Top := DMemo.Top + 36 + 14;
        memoMail.Width := 148;
        memoMail.Height := 72 - 14;
      end;
  else
    begin
      memoMail.Left := DMemo.Left + 28;
      memoMail.Top := DMemo.Top + 36;
      memoMail.Width := 148;
      memoMail.Height := 72;
    end;
  end;

  with DMemo do
  begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

      //名字...纸条试图, 发送点输出, 输入注册的朋友
    case ViewWindowNo of
      VIEW_FRIEND:  // 朋友: 朋友添加上, 注意: 输入下面的
        begin
          b := WProgUse.GetCachedImage(549 + 1, ax, ay);
        end;
      VIEW_MAILSEND:  // 单位: 收件人发送输出，输入下面的内容: 单
        begin
          b := WProgUse.GetCachedImage(549 + 2, ax, ay);

          with dsurface do
          begin
             //SetBkMode (Handle, TRANSPARENT);
//             Font.Color := clSilver;
//             MemoCharID := PTFriend(FriendMembers[ViewWindowData]).CharID;
            TextOut(SurfaceX(Left + 140 - FontManager.Default.TextWidth(MemoCharID) div 2), SurfaceY(Top + 13), clSilver, MemoCharID);
             //Release;
          end;
        end;
      VIEW_MAILREAD:  // 单位: 发件人显示输入 ，下面的内容:单输出
        begin
          b := WProgUse.GetCachedImage(549 + 3, ax, ay);

          with dsurface do
          begin
//             //SetBkMode (Handle, TRANSPARENT);
//             Brush.Style := bsSolid;
//             Brush.Color := clGray;
//             Font.Color  := clWhite;

//            FillRect(SurfaceX(Left + 28),
//                      SurfaceY(Top + 36),TextWidth(MemoDate) ,TextHeight(MemoDate), $FF808080);

            TextOut(SurfaceX(Left + 28), SurfaceY(Top + 36), MemoDate, clWhite);

//             Brush.Style := bsClear;
//             Font.Color := clSilver;
            MemoCharID := PTMail(MailLists[ViewWindowData]).Sender;


//            FillRect(SurfaceX(Left + 140 - TextWidth(MemoCharID) div 2),
//                    SurfaceY(Top + 13),TextWidth(MemoCharID) ,TextHeight(MemoCharID), $FFC0C0C0);

            TextOut(SurfaceX(Left + 140 - FontManager.Default.TextWidth(MemoCharID) div 2), SurfaceY(Top + 13), MemoCharID, clSilver);
             //Release;
          end;

        end;
      VIEW_MEMO:  //朋友: 朋友的信息上，输入下: 注意输入
        begin
          b := WProgUse.GetCachedImage(549 + 1, ax, ay);

          with dsurface do
          begin
             //SetBkMode (Handle, TRANSPARENT);
//             Font.Color := clSilver;
//             MemoCharID := PTFriend(FriendMembers[ViewWindowData]).CharID;
            TextOut(SurfaceX(Left + 140 - FontManager.Default.TextWidth(MemoCharID) div 2), SurfaceY(Top + 13), clSilver, MemoCharID);
             //Release;
          end;
        end;
    end;

    dsurface.Draw(SurfaceX(Left + 9), SurfaceY(Top + 7), b.ClientRect, b, TRUE);

      //SetBkMode (g_DXCanvas.Handle, TRANSPARENT);
//      g_DXCanvas.Font.Color  := clSilver;
//      if n = CurrentBlock then
//         g_DXCanvas.Brush.Color := clGray
//      else
//         g_DXCanvas.Brush.Color := clBlack;

//      g_DXCanvas.//Release;
  end;
end;

procedure TFrmDlg.ShowEditMail;
var
  d: TAsphyreLockableTexture;
  i: integer;
  data: string;
begin
  with DMemo do
  begin

    d := WLib.Images[FaceIndex];
    if d <> nil then
    begin
//         Left := (SCREENWIDTH - d.Width) div 2;
//         Top := (SCREENHEIGHT - d.Height) div 2;
    end;
    HideAllControls;

      //注意窗口大小设置
{
      case ViewWindowNo of
      VIEW_MAILREAD:
            begin
            memoMail.Left  := SurfaceX(Left+21);
            memoMail.Top   := SurfaceY(Top+36+14);
            memoMail.Width := 146;
            memoMail.Height:= 72 - 14;
            end;
      else
            begin
            memoMail.Left := SurfaceX(Left+21);
            memoMail.Top  := SurfaceY(Top+36);
            memoMail.Width := 146;
            memoMail.Height := 72;
            end;
      end;
}
      // 记录的情况下更改现有的留言了
    if ViewWindowNo = VIEW_MEMO then
    begin
      BackupMemoMail := memoMail.Text;
    end;
    memomail.MaxLength := 80;
    if not memoMail.visible then
      memoMail.Visible := TRUE;

    SetImeMode(MemoMail.Handle, LocalLanguage);

    DMemo.Show;

    while TRUE do
    begin
      if not DMemo.Visible then
        break;
      frmMain.ProcOnIdle();
      Application.ProcessMessages;
      if Application.Terminated then
        exit;
        Sleep(20);
    end;

    DMemo.Visible := FALSE;
    RestoreHideControls;

    if DMsgDlg.DialogResult = mrOk then
    begin
         //结果... 门派提示更新.
      data := '';
      for i := 0 to Memo.Lines.Count - 1 do
      begin
        if Memo.Lines[i] = '' then
          data := data + Memo.Lines[i] + ' '#13
        else
          data := data + Memo.Lines[i] + #13;
      end;
      data := ConvertEscChar(data);
      if Length(data) > 70 then
      begin
        data := Copy(data, 1, 70);
        DMessageDlg('摘要信息数量超过了内容限制\所以超过部分，不被显示出来。', [mbOk]);
      end;
         //case ViewWindowNo of
         //1: FrmMain.SendAddFriend (data);
         //2: FrmMain.SendMail (data);
         //3: begin end;
         //4: FrmMain.SendUpdateFriend (data);
         //end;
    end;
  end;
end;

function TFrmDlg.ConvertEscChar(str: string): string;
begin
   // Convert...
  Result := str;
end;

procedure TFrmDlg.DMemoCloseClick(Sender: TObject; X, Y: Integer);
begin
  DMemo.Visible := FALSE;
  case ViewWindowNo of
    VIEW_FRIEND:
      begin
        edCharID.Visible := FALSE;
        memoMail.Visible := FALSE;
        memoMail.ReadOnly := FALSE;
      end;
    VIEW_MAILSEND:
      begin
        edCharID.Visible := FALSE;
        memoMail.Visible := FALSE;
        memoMail.ReadOnly := FALSE;
      end;
    VIEW_MAILREAD:
      begin
        memoMail.Visible := FALSE;
        memoMail.ReadOnly := FALSE;
      end;
    VIEW_MEMO:
      begin
        memoMail.Visible := FALSE;
        memoMail.ReadOnly := FALSE;
      end;
  end;
  DMsgDlg.DialogResult := mrCancel;

//  SetImeMode(PlayScene.EdChat.Handle, LocalLanguage);
end;

procedure TFrmDlg.DMemoB1DirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with Sender as TDButton do
  begin

    if TDButton(Sender).Downed then
      d := WLib.Images[FaceIndex + 1]
    else
      d := WLib.Images[FaceIndex];

    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

  end;

end;

procedure TFrmDlg.DMemoB2DirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with Sender as TDButton do
  begin

    if TDButton(Sender).Downed then
      d := WLib.Images[FaceIndex + 1]
    else
      d := WLib.Images[FaceIndex];

    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

  end;

end;

procedure TFrmDlg.DMemoB1Click(Sender: TObject; X, Y: Integer);
begin

  // 阿啊狼 惑炔老 OK 悼累 沥狼
  case ViewWindowNo of
    VIEW_FRIEND:
      begin

      end;
    VIEW_MAILSEND:
      begin
        if MemoMail.Text <> '' then
        begin
          if frmDlg.BoMemoJangwon then
            FrmMain.SendMail(MemoCharID + '/' + MemoCharID2 + '/' + StrToSqlSafe(MemoMail.Text))
          else
            FrmMain.SendMail(MemoCharID + '/' + StrToSqlSafe(MemoMail.Text));
        end
        else
          frmDlg.BoMemoJangwon := False;

      end;
    VIEW_MAILREAD:
      begin

      end;
    VIEW_MEMO:
      begin
        if BackupMemoMail <> MemoMail.Text then
          FrmMain.SendUpdateFriend(MemoCharID + '/' + StrToSqlSafe(MemoMail.Text));
      end;
  end;

  edCharID.Visible := FALSE;
  MemoMail.Visible := FALSE;
  DMemo.Visible := FALSE;
  MemoMail.ReadOnly := FALSE;

  DMsgDlg.DialogResult := mrOK;

//  SetImeMode(PlayScene.EdChat.Handle, LocalLanguage);

end;

procedure TFrmDlg.DBLAddClick(Sender: TObject; X, Y: Integer);
begin
  DMessageDlg('请输入你想增加到屏蔽列表的人物名字:', [mbOk, mbAbort]);
  if DlgEditText <> '' then
  begin
    FrmMain.SendAddReject(DlgEditText);
  end;

end;

procedure TFrmDlg.DBLDelClick(Sender: TObject; X, Y: Integer);
begin
  if CurrentBlock < 0 then Exit;
  if mrOk = FrmDlg.DMessageDlg('你想从该列表中删除吗？', [mbOk, mbCancel]) then
  begin
    FrmMain.SendDelReject(BlockLists[CurrentBlock]);
  end;
end;

procedure TFrmDlg.DMLReplyClick(Sender: TObject; X, Y: Integer);
begin
  if CurrentMail >= 0 then
  begin
    ViewWindowNo := VIEW_MAILSEND;
    ViewWindowData := CurrentMail;
    DMemoB1.SetImgIndex(WProgUse, 548);
    DMemoB2.SetImgIndex(WProgUse, 538);
    DMemoB1.Visible := true;
    MemoMail.Clear;
    MemoMail.ReadOnly := false;
    MemoCharID := PTMail(MailLists[CurrentMail]).Sender;
    ShowEditMail;
  end;

end;

procedure TFrmDlg.DMLDelClick(Sender: TObject; X, Y: Integer);
begin
  if CurrentMail < 0 then Exit;
  if pTMail(MailLists[CurrentMail]).Status = 2 then
  begin
    FrmDlg.DMessageDlg('你不能删除受保护的邮件，你先解除保护。', [mbOk]);
    exit;
  end;

  if pTMail(MailLists[CurrentMail]).Status = 3 then
  begin
    FrmDlg.DMessageDlg('邮件已经被删除。', [mbOk]);
    exit;
  end;

  if mrOk = FrmDlg.DMessageDlg('你想删除选择的邮件吗？', [mbOk, mbCancel]) then
  begin
    FrmMain.SendDelMail(pTMail(MailLists[CurrentMail]).Date);
  end;

end;

procedure TFrmDlg.DMLLockClick(Sender: TObject; X, Y: Integer);
var
  IsLock: Boolean;
  mstate: Byte;
begin
  if CurrentMail < 0 then Exit;

  mstate := pTMail(MailLists[CurrentMail]).Status;

      // 昏力等 逞捞搁 泪臂荐 绝澜
  if (mstate = 3) then
    exit;

  if (mstate = 2) then
    IsLock := TRUE
  else
    IsLock := FALSE;

  if IsLock then
    FrmMain.SendUnLockMail(pTMail(MailLists[CurrentMail]).Date)
  else
    FrmMain.SendLockMail(pTMail(MailLists[CurrentMail]).Date)
end;

procedure TFrmDlg.DFrdPgUpMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  lx, ly: integer;
  sx, sy: integer;
begin
  with (Sender as TDbutton) do
  begin
    lx := LocalX(X - Left);
    ly := LocalY(Y - Top);
    sx := SurfaceX(Left) + DFriendDlg.SurfaceX(DFriendDlg.Left) + lx + 8;
    sy := SurfaceY(Top) + DFriendDlg.SurfaceX(DFriendDlg.Top) + ly + 6;
    DScreen.ShowHint(sx, sy, (Sender as TDbutton).Hint, clYellow, FALSE);
  end;

end;

procedure TFrmDlg.DFrdPgDnMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  lx, ly: integer;
  sx, sy: integer;
begin
  with (Sender as TDbutton) do
  begin
    lx := LocalX(X - Left);
    ly := LocalY(Y - Top);
    sx := SurfaceX(Left) + DFriendDlg.SurfaceX(DFriendDlg.Left) + lx + 8;
    sy := SurfaceY(Top) + DFriendDlg.SurfaceX(DFriendDlg.Top) + ly + 6;
    DScreen.ShowHint(sx, sy, (Sender as TDbutton).Hint, clYellow, FALSE);
  end;

end;

procedure TFrmDlg.DMailListPgUpMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  lx, ly: integer;
  sx, sy: integer;
begin
  with (Sender as TDbutton) do
  begin
    lx := LocalX(X - Left);
    ly := LocalY(Y - Top);
    sx := SurfaceX(Left) + DMailListDlg.SurfaceX(DMailListDlg.Left) + lx + 8;
    sy := SurfaceY(Top) + DMailListDlg.SurfaceX(DMailListDlg.Top) + ly + 6;
    DScreen.ShowHint(sx, sy, (Sender as TDbutton).Hint, clYellow, FALSE);
  end;

end;

procedure TFrmDlg.DMailListPgDnMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  lx, ly: integer;
  sx, sy: integer;
begin
  with (Sender as TDbutton) do
  begin
    lx := LocalX(X - Left);
    ly := LocalY(Y - Top);
    sx := SurfaceX(Left) + DMailListDlg.SurfaceX(DMailListDlg.Left) + lx + 8;
    sy := SurfaceY(Top) + DMailListDlg.SurfaceX(DMailListDlg.Top) + ly + 6;
    DScreen.ShowHint(sx, sy, (Sender as TDbutton).Hint, clYellow, FALSE);
  end;

end;

procedure TFrmDlg.DBLPgUpMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  lx, ly: integer;
  sx, sy: integer;
begin
  with (Sender as TDbutton) do
  begin
    lx := LocalX(X - Left);
    ly := LocalY(Y - Top);
    sx := SurfaceX(Left) + DBlockListDlg.SurfaceX(DBlockListDlg.Left) + lx + 8;
    sy := SurfaceY(Top) + DBlockListDlg.SurfaceX(DBlockListDlg.Top) + ly + 6;
    DScreen.ShowHint(sx, sy, (Sender as TDbutton).Hint, clYellow, FALSE);
  end;

end;

procedure TFrmDlg.DBLPgDnMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  lx, ly: integer;
  sx, sy: integer;
begin
  with (Sender as TDbutton) do
  begin
    lx := LocalX(X - Left);
    ly := LocalY(Y - Top);
    sx := SurfaceX(Left) + DBlockListDlg.SurfaceX(DBlockListDlg.Left) + lx + 8;
    sy := SurfaceY(Top) + DBlockListDlg.SurfaceX(DBlockListDlg.Top) + ly + 6;
    DScreen.ShowHint(sx, sy, (Sender as TDbutton).Hint, clYellow, FALSE);
  end;

end;

procedure TFrmDlg.DFriendDlgMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  lx, ly: integer;
  sx, sy: integer;
begin
  if (Sender as TDWindow).hint = '' then
    DScreen.ClearHint(True)
  else
  begin
    with (Sender as TDWindow) do
    begin
      if ViewFriends then
      begin
        lx := 30 + (CurrentFriend mod 2) * 120;
        ly := 82 + ((CurrentFriend mod 20) div 2) * 15;
      end
      else
      begin
        lx := 30 + (CurrentBlack mod 2) * 120;
        ly := 82 + ((CurrentBlack mod 20) div 2) * 15;
      end;

      sx := SurfaceX(Left) + lx;
      sy := SurfaceY(Top) + ly;
      DScreen.ShowHint(sx, sy, (Sender as TDWindow).Hint, clWhite, FALSE);
    end;
  end;
end;

procedure TFrmDlg.DMailListDlgMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
begin
  DScreen.ClearHint(True);
end;

procedure TFrmDlg.DMailDlgMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
begin
  DScreen.ClearHint(True);
end;

procedure TFrmDlg.DBlockListDlgMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
begin
  DScreen.ClearHint(True);
end;

procedure TFrmDlg.DMemoMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
begin
  DScreen.ClearHint(True);
end;

procedure TFrmDlg.DMakeItemDlgOkDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with Sender as TDButton do
  begin
    if Downed then
    begin
      d := WLib.Images[FaceIndex];
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
    end;
  end;
end;

procedure TFrmDlg.DCountDlgDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d, dr: TAsphyreLockableTexture;
  ly, px, py, i: integer;
  str, data: string;
begin
  with Sender as TDWindow do
  begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
      //SetBkMode (g_DXCanvas.Handle, TRANSPARENT);
    ly := msgly;
    str := MsgText;
    while TRUE do
    begin
      if str = '' then
        break;
      str := GetValidStr3(str, data, ['\']);
      if data <> '' then
        dsurface.TextOut(SurfaceX(Left + msglx), SurfaceY(Top + ly), clWhite, {clBlack,} data);
      ly := ly + 14;
    end;
//      g_DXCanvas.//Release;
  end;
  if not EdCountEdit.Visible then
  begin
    EdCountEdit.Visible := TRUE;
    EdCountEdit.SetFocus;
  end;
end;

function TFrmDlg.DCountMsgDlg(msgstr: string; DlgButtons: TMsgDlgButtons): TModalResult;
var
  lx, ly, i: integer;
  d: TAsphyreLockableTexture;
begin

  msglx := 31;
  msgly := 34;
  lx := 205;
  ly := 136;

  d := WProgUse.Images[660];
  if d <> nil then
  begin
    DCountDlg.SetImgIndex(WProgUse, 660);
    DCountDlg.Left := (g_FScreenWidth - d.Width) div 2;
    DCountDlg.Top := (g_FScreenHeight - d.Height) div 2;
    DCountDlg.Visible := True;
  end;

  MsgText := msgstr;
  DCountDlg.Floating := False;   //信息盒走了..
  DCountDlg.Left := (g_FScreenWidth - DCountDlg.Width) div 2;
  DCountDlg.Top := (g_FScreenHeight - DCountDlg.Height) div 2;
  DCountDlg.Visible := True;

  DCountDlgCancel.Left := lx;
  DCountDlgCancel.Top := ly;
  DCountDlgCancel.Visible := TRUE;
  lx := lx - 69;

  DCountDlgOk.Left := lx;
  DCountDlgOk.Top := ly;
  DCountDlgOk.Visible := TRUE;
  lx := lx - 69;

  DCountDlgMax.Left := lx;
  DCountDlgMax.Top := ly;
  DCountDlgMax.Visible := TRUE;

  DCountDlgClose.Left := 287;
  DCountDlgClose.Top := 0;
  DCountDlgClose.Visible := True;

  HideAllControls;
  DCountDlg.ShowModal;

  with EdCountEdit do
  begin
    Text := '';
    Width := DCountDlg.Width - 80;
    Left := (g_FScreenWidth - EdCountEdit.Width) div 2 - 8;
    Top := (g_FScreenHeight - EdCountEdit.Height) div 2 + 13;
  end;

  Result := mrOk;

  while TRUE do
  begin
    if not DCountDlg.Visible then
      break;
    frmMain.ProcOnIdle();
    Application.ProcessMessages;
    if Application.Terminated then
      exit;
      Sleep(20);
  end;

  EdCountEdit.Visible := TRUE;
  RestoreHideControls;
  DlgEditText := EdCountEdit.Text;
  if FrmDlg.DEdChat.Visible then
    FrmDlg.DEdChat.SetFocus;

  EdCountEdit.Visible := FALSE;
  Result := DCountDlg.DialogResult;
end;

procedure TFrmDlg.DCountDlgOkDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with Sender as TDButton do
  begin
    if Downed then
    begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
    end;
  end;
end;

procedure TFrmDlg.DCountDlgOkClick(Sender: TObject; X, Y: Integer);
begin
  if Sender = DCountDlgMax then
  begin
    EdCountEdit.Text := IntToStr(Total);
    DlgEditText := EdCountEdit.Text;
    DCountDlg.DialogResult := mrAll;
  end;
  if Sender = DCountDlgOk then
    DCountDlg.DialogResult := mrOk;
  if Sender = DCountDlgCancel then
    DCountDlg.DialogResult := mrCancel;
  if Sender <> DCountDlgMax then
  begin
    EdCountEdit.Visible := False;
    DCountDlg.Visible := False;
  end;

end;

procedure TFrmDlg.DComboBoxAutoMagicListChange(Sender: TObject);
begin
//  if (DComboBoxAutoMagicList.ItemIndex >=0) and (DComboBoxAutoMagicList.ItemIndex< DComboBoxAutoMagicList.Item.Count) then
//   g_NgConfigInfo.nAutoMagicID := Integer(DComboBoxAutoMagicList.Item.Objects[DComboBoxAutoMagicList.ItemIndex]);
end;

procedure TFrmDlg.DComboBox_ItemsChange(Sender: TObject);
var
  AList: TStringlist;
begin
//  g_ptItems_Type := DListBox_Items.FSelected;
  AList := nil;
  case g_ptItems_Type of
    0:
      AList := g_ItemsFilter_All_Str;
    1:
      AList := g_ItemsFilter_Other;
    2:
      AList := g_ItemsFilter_Drug;
    3:
      AList := g_ItemsFilter_Dress;
    4:
      AList := g_ItemsFilter_Weapon;
    5:
      AList := g_ItemsFilter_Headgear;
  end;
  if (DxEdit_Items.Text <> '') then
  begin
    ItemFilterFind(AList, g_ItemsFilter_Find_Str, DxEdit_Items.Text);
    AList := g_ItemsFilter_Find_Str;
  end;
//  DMoveButton_items.Max := _MAX(0, AList.Count - 8);
//  DMoveButton_items.Tag := AList.Count;
//  DMoveButton_items.Position := 0;
//  DMoveButton_items.UpdatePos(DMoveButton_items.Position, True);
  DUpDown_config.MaxPosition := _MAX(0, AList.Count - 8);
  DUpDown_config.Position := 0;
end;

procedure TFrmDlg.DCountDlgCloseClick(Sender: TObject; X, Y: Integer);
begin
  DCountDlg.DialogResult := mrCancel;
  DCountDlg.Visible := False;
  DCountDlgClose.Downed := False;
end;

procedure TFrmDlg.DMakeItemDlgOkClick(Sender: TObject; X, Y: Integer);
var
  data: string;
begin

  if Sender = DMakeItemDlgOk then
  begin
    DMakeItemDlg.DialogResult := mrOk;
    data := NameMakeItem;
    data := data + '/' + MakeStrMakeItem();
    FrmMain.SendMakeItem(CurMerchant, data);
  end;
  if (Sender = DMakeItemDlgCancel) or (Sender = DMakeItemDlgClose) then
  begin
    DMakeItemDlg.DialogResult := mrCancel;
  end;
  MoveMakeItemToBag;

  DMakeItemDlg.Visible := False;
  DMakeItemDlgClose.Downed := False;

end;

procedure TFrmDlg.DMakeItemDlgDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  if Myself = nil then
    exit;
  with DMakeItemDlg do
  begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

//      GetMouseItemInfo (d0, d1, d2, d3, useable, FALSE);
    with dsurface do
    begin
         //SetBkMode (Handle, TRANSPARENT);
//         Font.Color := clWhite;
      TextOut(SurfaceX(Left + 19), SurfaceY(Top + 60), clWhite, '请放入正确打造需要的物品');
         //Release;
    end;
  end;
end;

function TFrmDlg.MakeItemDlgShow(msgstr: string): TModalResult;
var
  i: integer;
begin

  DMakeItemDlg.Left := 212; //140;//291;
  DMakeItemDlg.Top := 176; //176;

  DMakeItemDlg.Visible := True;

   //酒捞袍 啊规俊 儡惑捞 乐绰瘤 八荤
  ArrangeItembag;

end;

procedure TFrmDlg.DMakeitemGridGridPaint(Sender: TObject; ACol, ARow: Integer; Rect: TRect; State: TGridDrawState; dsurface: TAsphyreCanvas);
var
  idx: integer;
  d: TAsphyreLockableTexture;
begin
  idx := ACol + ARow * DMakeitemGrid.ColCount;
  if idx in [0..5] then
  begin
    if MakeItemArr[idx].s.Name <> '' then
    begin
      d := WBagItem.Images[MakeItemArr[idx].s.Looks];
      if d <> nil then
        with DMakeitemGrid do
          dsurface.Draw(SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1), SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1), d.ClientRect, d, TRUE);
            // 酒捞袍 般摹扁
      if MakeItemArr[idx].s.OverlapItem > 0 then
      begin
               //SetBkMode (g_DXCanvas.Handle, TRANSPARENT);
//               g_DXCanvas.Font.Color := clYellow;

        dsurface.TextOut(DMakeitemGrid.SurfaceX(Rect.Left + 20), DMakeitemGrid.SurfaceY(Rect.Top + 20), clYellow, IntToStr(MakeItemArr[idx].dura));
//               g_DXCanvas.//Release;
      end;
    end;
  end;

end;

procedure TFrmDlg.DMakeitemGridGridSelect(Sender: TObject; X, Y: integer; ACol, ARow: Integer; Shift: TShiftState);
var
  temp: TClientItem;
  mi, idx: integer;
  MsgResult, Count, OrgCount: integer;
  valstr: string;
begin
  MsgResult := mrCancel;
  if not ItemMoving then
  begin
    idx := ACol + ARow * DMakeitemGrid.ColCount;
    if idx in [0..5] then
    begin
      if MakeItemArr[idx].s.Name <> '' then
      begin
        ItemMoving := TRUE;
        MovingItem.Item := MakeItemArr[idx];
        MakeItemArr[idx].s.Name := '';
        ItemClickSound(MovingItem.Item.S);
      end;
    end;
  end
  else
  begin
    mi := MovingItem.Index;
    if mi >= 6 then
    begin //啊规,俊辑 柯巴父

      if SearchOverlapItem(MovingItem.Item) then
      begin
        CancelItemMoving;
        DMessageDlg('同样种类的物品只能存入重复一次.', [mbOk]);
        Exit;
      end;

      ItemClickSound(MovingItem.Item.S);
      OrgCount := MovingItem.Item.Dura;
      MakingDlgItem := MovingItem.Item; //辑滚俊 搬苞甫 扁促府绰悼救 焊包
      if MakingDlgItem.S.OverlapItem > 0 then
      begin
        Total := MovingItem.Item.Dura;
        ItemMoving := FALSE;
        if Total = 1 then
        begin
          DlgEditText := '1';
          MsgResult := mrOk;
        end
        else
          MsgResult := DCountMsgDlg('当前数量 ' + IntToStr(MovingItem.Item.Dura) + ' 个.\你需要兑换多少?', [mbOk, mbCancel, mbAbort]);

        ItemMoving := TRUE;
        GetValidStrVal(DlgEditText, valstr, [' ']);
        Count := Str_ToInt(valstr, 0);
        if Count <= 0 then
        begin
          Count := 0;
          MakingDlgItem.S.Name := '';
        end;
        if Count > MovingItem.Item.Dura then
        begin
          Count := MovingItem.Item.Dura;
//                  MovingItem.Item.Dura := 0;
        end;
        if MsgResult = mrOk then
        begin //and (Count > 0) and (Count < MAX_OVERLAPITEM+1 ) then begin
          MakingDlgItem.Dura := word(Count);
          MovingItem.Item.Dura := MovingItem.Item.Dura - Count;
          if MovingItem.Item.Dura = 0 then
          begin
            MovingItem.Item.S.name := '';
            ItemMoving := FALSE;
          end;
        end
        else if MsgResult = mrCancel then
        begin
          CancelItemMoving;
          Exit;
        end;
      end;
      if (not AddMakeItem(MakingDlgItem)) and (MakingDlgItem.S.OverlapItem > 0) then
      begin
        MovingItem.Item.Dura := OrgCount;
      end;
      if ItemMoving then
        CancelItemMoving;
    end;
  end;
  ArrangeItemBag;

end;

procedure TFrmDlg.DMakeitemGridGridMouseMove(Sender: TObject; X, Y: integer; ACol, ARow: Integer; Shift: TShiftState);
var
  idx: integer;
begin
  idx := ACol + ARow * DMakeitemGrid.ColCount;
  if idx in [0..5] then
  begin
    MouseItem := MakeItemArr[idx];
  end;
end;

procedure TFrmDlg.DItemMarketDlgDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);

  function sx(x: integer): integer;
  begin
    Result := DItemMarketDlg.SurfaceX(DItemMarketDlg.Left + x);
  end;

  function sy(y: integer): integer;
  begin
    Result := DItemMarketDlg.SurfaceY(DItemMarketDlg.Top + y);
  end;

var
  i, lh, k, m, n, menuline: integer;
  d, TempSurface: TAsphyreLockableTexture;
  pg: PTMarketITem;
  year, mon, day, hour, min, datestr: string;
  targdate: TDateTime;
  iname, d0, d1, d2, d3, d4, pagestr: string;
  useable: Boolean;
  MouseItemTemp: TClientItem;
  FColor: TColor;
begin
  i := 0;
  pg := nil;

  with dsurface do
  begin
    with DItemMarketDlg do
    begin
      d := DItemMarketDlg.WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
    end;

      //SetBkMode (g_DXCanvas.Handle, TRANSPARENT);
      //SetBkMode (Handle, TRANSPARENT);
//      Font.Color := clWhite;

    lh := MAKETLINEHEIGHT;
    menuline := _MIN(MAXMENU, g_Market.Count - MenuTop);

    if g_Market.GetUserMode = 1 then
    begin
      TextOut(sx(186), sy(16), clWhite, '拍卖商品城');
      DMarketMemo.Visible := True;
    end
    else if g_Market.GetUserMode = 2 then
    begin
      TextOut(sx(186), sy(16), clWhite, '我的商品城');
      DMarketMemo.Visible := False;
    end;

    TextOut(sx(373), sy(16), clWhite, format('%4d', [(MenuTop + 10) div 10]));
    if g_Market.RecvMaxPage < 1 then
      TextOut(sx(403), sy(16), clWhite, '/ ' + '1')
    else
      TextOut(sx(403), sy(16), clWhite, '/ ' + IntToStr(g_Market.RecvMaxPage));
//      TextOut (SX(504), SY(16), GetGoldStr(Myself.Gold));

    TextOut(sx(41), sy(46), clWhite, '商品');
    TextOut(sx(200), sy(46), clWhite, '价格');
    if g_Market.GetUserMode = 2 then
      TextOut(sx(360), sy(46), clWhite, '状态')
    else
      TextOut(sx(360), sy(46), clWhite, '卖家');

    for i := MenuTop to MenuTop + menuline - 1 do
    begin
      m := i - MenuTop;
      pg := g_Market.GetItem(i);

      if i = MenuIndex then
      begin
        FColor := clRed;
        TextOut(sx(34), sy(70 + m * lh), clRed, char(7));
        MemoCharID := pg.SellWho;
      end
      else if pg.SellState = 2 then
        FColor := clYellow
      else if pg.UpgCount > 0 then
        FColor := clAqua
      else
        FColor := clWhite;

      if pg <> nil then
      begin
        TextOut(sx(41), sy(70 + MAKETLINEHEIGHT * m), FColor, pg.Item.S.Name);
        TextOut(sx(170), sy(70 + MAKETLINEHEIGHT * m), FColor, format('%15s', [GetGoldStr(pg.SellPrice)]));
        if g_Market.GetUserMode = 2 then
        begin
          if pg.SellState = 1 then
            TextOut(sx(360), sy(70 + MAKETLINEHEIGHT * m), FColor, '正在销售')
          else if pg.SellState = 2 then
            TextOut(sx(360), sy(70 + MAKETLINEHEIGHT * m), FColor, '完成销售');
        end
        else
          TextOut(sx(360), sy(70 + MAKETLINEHEIGHT * m), FColor, pg.SellWho);
      end;
    end;
//      Font.Color := clWhite;
    if (MenuIndex >= 0) and (MenuIndex < g_Market.Count) then
    begin
      pg := g_Market.GetItem(MenuIndex);
      year := Copy(pg.Selldate, 1, 2);
      mon := Copy(pg.Selldate, 3, 2);
      day := Copy(pg.Selldate, 5, 2);
      hour := Copy(pg.Selldate, 7, 2);
      min := Copy(pg.Selldate, 9, 2);
      datestr := '20' + year + '-' + mon + '-' + day + ' ' + hour + ':' + min;
      TextOut(sx(21), sy(275), clWhite, '上架日期: ' + datestr);
      targdate := EncodeDate(StrToInt(year) + 2000, StrToInt(mon), StrToInt(day)) + EncodeTime(StrToInt(hour), StrToInt(min), 0, 0);
      targdate := targdate + 100;
      TextOut(sx(21), sy(292), clWhite, '过期日期: ' + FormatDateTime('YYYY-MM-DD', targdate));
    end;

    if (MenuIndex >= 0) and (MenuIndex < g_Market.Count) then
    begin
      MouseItemTemp := MouseItem;
      MouseItem := pg.item;
      with DItemMarketDlg do
      begin
        GetMouseItemInfo(iname, d0, d1, d2, d3, d4, useable, FALSE);
        MouseItem := MouseItemTemp;
            //SetBkMode (Handle, TRANSPARENT);

        if iname <> '' then
        begin
          TextOut(sx(228), sy(268), clYellow, iname);
          n := FontManager.Default.TextWidth(iname);
          FColor := clWhite;
          TextOut(sx(228) + n, sy(268), clWhite, d0);
          TextOut(sx(228), sy(268 + 14), clWhite, d1);
          TextOut(sx(228), sy(268 + 14 * 2), clWhite, d2);
          if not useable then
            FColor := clRed;
          n := FontManager.Default.TextWidth(d2);
          TextOut(sx(228) + n, sy(268 + 14 * 2), FColor, d3);
        end;
      end;
    end;

      //Release;
  end;

  if (MenuIndex >= 0) and (MenuIndex < g_Market.Count) then
  begin
    pg := g_Market.GetItem(MenuIndex);
    TempSurface := WBagItem.Images[pg.Item.S.Looks];
    if TempSurface <> nil then
      dsurface.Draw(sx(172) + (36 - TempSurface.Width) div 2, sy(274) + (32 - TempSurface.Height) div 2, TempSurface.ClientRect, TempSurface, TRUE);
//         dsurface.Draw (SX(173), SY(275), TempSurface.ClientRect, TempSurface, TRUE);
  end;

  if (ItemSearchEdit.Left <> sx(13)) or (ItemSearchEdit.Top <> sy(328)) then
  begin
    ItemSearchEdit.Left := sx(13);
    ItemSearchEdit.Top := sy(328);
  end;

//   DScreen.ClearHint(True);
//   MouseStateItem.S.Name := '';

end;

procedure TFrmDlg.DItemMarketDlgClick(Sender: TObject; X, Y: Integer);
var
  lx, ly, idx: integer;
  pg: PTMarketITem;
begin

  pg := nil;
  lx := DItemMarketDlg.LocalX(X) - DItemMarketDlg.Left;
  ly := DItemMarketDlg.LocalY(Y) - DItemMarketDlg.Top;
  if (lx >= 10) and (lx <= 459) and (ly >= 65) and (ly <= 256) then
  begin
    idx := (ly - 70) div MAKETLINEHEIGHT + MenuTop;
    if idx < g_Market.Count then
    begin
      PlaySound(s_glass_button_click);
      MenuIndex := idx;
    end;
  end;

  if (MenuIndex >= 0) and (MenuIndex < g_Market.Count) then
  begin
    pg := g_Market.GetItem(MenuIndex);
    if pg.SellState = 1 then
      MItemSellState := 1 // 销售中
    else if pg.SellState = 2 then
      MItemSellState := 2; // 销售完毕
  end;

end;

procedure TFrmDlg.DItemMarketDlgMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
begin
  if BoInRect then
  begin
     // DItemMarketDlg.SpotX := X;
     // DItemMarketDlg.SpotY := Y;
  end;
//   DScreen.ClearHint(True);
end;

procedure TFrmDlg.DItemListPrevClick(Sender: TObject; X, Y: Integer);
begin

  MenuIndex := -1;
  if MenuTop > 0 then
  begin
    Dec(MenuTop, MAXMENU);
    if MenuTop < 0 then
      MenuTop := 0;
  end;
  MenuIndex := MenuTop;
  DItemMarketDlgClick(DItemMarketDlg, 0, 0);
end;

procedure TFrmDlg.DItemListNextClick(Sender: TObject; X, Y: Integer);
var
  MaxNum: integer;
begin

  MenuIndex := -1;
  MaxNum := (g_Market.RecvMaxPage) * 10;
  if (MaxNum >= g_Market.Count) and (MaxNum >= (MenuTop + 19)) then
  begin
    Inc(MenuTop, MAXMENU);
    if g_Market.Count <= MenuTop then
      FrmMain.SendGetMarketPageList(CurMerchant, 1, '')
  end;
  MenuIndex := MenuTop;
  DItemMarketDlgClick(DItemMarketDlg, 0, 0);
end;

procedure TFrmDlg.DItemBuyClick(Sender: TObject; X, Y: Integer);
var
  pg: PTMarketITem;
  MsgResult: integer;
begin
  if GetTickCount < LastestClickTime then
    exit; //经常点击不限制
  DScreen.ClearHint(True);
  if (MenuIndex >= 0) and (MenuIndex < g_Market.Count) then
  begin
    ItemSearchEdit.Visible := False;
    pg := g_Market.GetItem(MenuIndex);
    if Myself.Gold < pg.SellPrice then
    begin
      MsgResult := DMessageDlg('钱不够.', [mbOk, mbCancel]);
      Exit;
    end;
    MsgResult := DMessageDlg(pg.Item.S.Name + ' 购买商品 ' + IntToStr(pg.SellPrice) + '金币？', [mbOk, mbCancel]);

    if MsgResult = mrOk then
    begin
      FrmMain.SendBuyMarket(CurMerchant, pg.Index);
      DItemBag.Show; //包背刷新
    end
    else if MsgResult = mrCancel then
    begin
    end;
  end;
end;

procedure TFrmDlg.DItemMarketCloseClick(Sender: TObject; X, Y: Integer);
begin
   // 委托列表窗口关闭系统复位及关闭了服务器上
  g_Market.Clear;
  FrmMain.SendMarketClose;

  ItemSearchEdit.Visible := FALSE;
  DItemMarketDlg.Visible := FALSE;
  DItemMarketClose.Downed := False;

//   PlayScene.EdChat.SetFocus;
  LocalLanguage := imChinese;  //imSAlpha
//  SetImeMode(PlayScene.EdChat.Handle, LocalLanguage);
  LastestClickTime := GetTickCount;

  MemoCharID := '';

end;

procedure TFrmDlg.DMGoldDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  if Myself = nil then
    exit;
  if DMGold.Visible then
  begin
    with DMGold do
    begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
    end;
  end;
end;

procedure TFrmDlg.DItemMarketDlgKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);
begin
  if Key = 27 then
    if DItemMarketDlg.Visible then
      CloseItemMarketDlg;

  if Key = 13 then
    DItemFindClick(DItemFind, 0, 0);

  DScreen.ClearHint(True);
  case Key of
    VK_UP:
      begin
        if (MenuTop <= (MenuIndex - 1)) and (MenuIndex <> -1) then
        begin
          Dec(MenuIndex, 1);
          DItemMarketDlgClick(DItemMarketDlg, 0, 0);
        end;
      end;
    VK_DOWN:
      begin
        if (MenuTop + MAXMENU > (MenuIndex + 1)) and (MenuIndex <> -1) and ((MenuIndex + 1) < g_Market.Count) then
        begin
          Inc(MenuIndex, 1);
          DItemMarketDlgClick(DItemMarketDlg, 0, 0);
        end;
      end;
    VK_LEFT:
      begin
        DItemListPrevClick(DItemListPrev, 0, 0);
      end;
    VK_RIGHT:
      begin
        DItemListNextClick(DItemListNext, 0, 0);
      end;
  else

  end;

end;

procedure TFrmDlg.DItemListRefreshClick(Sender: TObject; X, Y: Integer);
begin
  if GetTickCount < LastestClickTime then
  begin
    DScreen.AddChatBoardString('几秒钟后才可以按下这个按钮', clYellow, clRed);
    exit; //点击经常不限制
  end;
  DScreen.ClearHint(True);
  MenuIndex := -1;
  MenuTop := 0;
  MenuTopLine := 0;
  FrmMain.SendGetMarketPageList(CurMerchant, 0, '');
  LastestClickTime := GetTickCount + 5000;

end;

procedure TFrmDlg.DItemSellCancelClick(Sender: TObject; X, Y: Integer);
var
  pg: PTMarketITem;
  MsgResult: integer;
begin
  if GetTickCount < LastestClickTime then
    exit; //经常点击不限制
  DScreen.ClearHint(True);
  if (MenuIndex >= 0) and (MenuIndex < g_Market.Count) then
  begin
    ItemSearchEdit.Visible := False;
    pg := g_Market.GetItem(MenuIndex);
    if pg.SellState = 1 then
    begin
      MsgResult := DMessageDlg('你想取消上架提供的 ' + pg.Item.S.Name + ' ？', [mbOk, mbCancel]);
      if MsgResult = mrOk then
      begin
        FrmMain.SendCancelMarket(CurMerchant, pg.Index);
        DItemBag.Show;
      end;
    end
    else if pg.SellState = 2 then
    begin
      MsgResult := DMessageDlg('尊敬的卖家:\    感谢您使用拍卖系统，请问您想取出您的销售收益吗？ \我们将收取1%的佣金，佣金将自动从销售金额中扣除.', [mbOk, mbCancel]);
      if MsgResult = mrOk then
        FrmMain.SendGetPayMarket(CurMerchant, pg.Index);
    end;
    MItemSellState := 0;
  end;
end;

procedure TFrmDlg.DItemFindClick(Sender: TObject; X, Y: Integer);
var
  findstr: string;
begin

  if GetTickCount < LastestClickTime then
    exit; //努腐阑 磊林 给窍霸 力茄

//   DMessageDlg ('要搜索的物品名称.', [mbOk, mbAbort]);
//   GetValidStrVal (DlgEditText, findstr, [' ']);
//   findstr := trim(findstr);
  findstr := trim(ItemSearchEdit.Text);
  findstr := Copy(findstr, 1, 14);
  ItemSearchEdit.Visible := False;
  if findstr <> '' then
    FrmMain.SendGetMarketPageList(CurMerchant, 2, findstr);
  LastestClickTime := GetTickCount + 5000;
//   DScreen.AddChatBoardString ('SendGetMarketPageList (CurMerchant, 2, ' +findstr + ')',  clYellow, clRed);

end;

procedure TFrmDlg.DItemSellCancelMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
begin
{   if g_Market.GetUserMode = 1 then begin
   end else if g_Market.GetUserMode = 2 then begin
      if MItemSellState = 1 then
         DScreen.ShowHint (DItemMarketDlg.Left+ DItemMarketDlg.SurfaceX(330-40), DItemMarketDlg.Top+DItemMarketDlg.SurfaceY(322+25),//(269+40),
                           '困殴茄 酒捞袍阑 秒家 钦聪促.', clYellow, FALSE)
      else if MItemSellState = 2 then
         DScreen.ShowHint (DItemMarketDlg.Left+DItemMarketDlg.SurfaceX(330-40), DItemMarketDlg.Top+DItemMarketDlg.SurfaceY(322+25),//(269+40),
                           '困殴陛阑 雀荐 钦聪促.', clYellow, FALSE);
   end;}
end;

procedure TFrmDlg.DItemCancelMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
begin
//   DScreen.ShowHint (DItemMarketDlg.SurfaceX(586-30), DItemMarketDlg.SurfaceY(269+45),//(269+40),
//                     '困殴魄概芒阑 摧嚼聪促.', clYellow, FALSE)
end;

procedure TFrmDlg.DItemBagClick(Sender: TObject; X, Y: Integer);
begin
  ItemSearchEdit.Visible := False;
end;

procedure TFrmDlg.DMemoClick(Sender: TObject; X, Y: Integer);
begin
  ItemSearchEdit.Visible := False;
end;

procedure TFrmDlg.DMailDlgClick(Sender: TObject; X, Y: Integer);
begin
  ItemSearchEdit.Visible := False;
end;

procedure TFrmDlg.DItemMarketDlgMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  with DItemMarketDlg do
//      if (X < SurfaceX(Left+9)) or (X > SurfaceX(Left+Width-3)) or (Y < SurfaceY(Top+155)) or (Y > SurfaceY(Top+Height-125)) then begin
    if (X < SurfaceX(Left + 9)) or (X > SurfaceX(Left + Width - 3)) or (Y < SurfaceY(Top + 65)) or (Y > SurfaceY(Top + Height - 131)) then
    begin
      BoInRect := False;
    end
    else
    begin
      BoInRect := True;
    end;
//   DScreen.ClearHint(True);
//   MouseStateItem.S.Name := '';
  if g_Market.GetUserMode = 1 then
  begin
    with DItemMarketDlg do
      if (X > SurfaceX(Left + 34)) and (X < SurfaceX(Left + 16 + ItemSearchEdit.Width)) and (Y > SurfaceY(Top + 323)) and (Y < SurfaceY(Top + 347)) then
      begin
        DItemMarketDlg.EnableFocus := True;
        ItemSearchEdit.Visible := TRUE;
        ItemSearchEdit.SetFocus;
      end
      else
        ItemSearchEdit.Visible := False;
  end;

end;

procedure TFrmDlg.SetChatFocus;
begin
  ItemSearchEdit.Visible := False;
  FrmDlg.DEdChat.Visible := TRUE;
  FrmDlg.DEdChat.SetFocus;
end;

procedure TFrmDlg.DJangwonListDlgDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);

  function sx(x: integer): integer;
  begin
    Result := DJangwonListDlg.SurfaceX(DJangwonListDlg.Left + x);
  end;

  function sy(y: integer): integer;
  begin
    Result := DJangwonListDlg.SurfaceY(DJangwonListDlg.Top + y);
  end;

var
  i, menuline: integer;
  d: TAsphyreLockableTexture;
  pj: PTClientJangwon;
  FColor: TColor;
begin
  i := 0;
  pj := nil;

  with dsurface do
  begin
    with DJangwonListDlg do
    begin
      d := DJangwonListDlg.WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
    end;

      //SetBkMode (g_DXCanvas.Handle, TRANSPARENT);
      //SetBkMode (Handle, TRANSPARENT);
    FColor := clWhite;
    menuline := _MIN(MAXMENU, JangwonList.Count);

    TextOut(sx(15), sy(32), FColor, '编号');
    TextOut(sx(68), sy(32), FColor, '行会的名称');
    TextOut(sx(223), sy(32), FColor, '行会管理员'); //(SX(191)
    TextOut(sx(383), sy(32), FColor, '销售价格'); //SX(271)
    TextOut(sx(463), sy(32), FColor, '状态');      //SX(355)

//      for i:=MenuTop to MenuTop+menuline-1 do begin
    for i := 0 to menuline - 1 do
    begin
//         m := i-MenuTop;
      pj := PTClientJangwon(JangwonList[i]);

      if i = MenuIndex then
        FColor := clRed
      else
        FColor := clWhite;

      if pj <> nil then
      begin
        TextOut(sx(19), sy(51 + LISTLINEHEIGHT2 * i), FColor, format('%2s', [IntToStr(pj.Num)]));
        TextOut(sx(58), sy(51 + LISTLINEHEIGHT2 * i), FColor, pj.GuildName);
        TextOut(sx(160), sy(51 + LISTLINEHEIGHT2 * i), FColor, pj.CaptaineName1);
        TextOut(sx(260), sy(51 + LISTLINEHEIGHT2 * i), FColor, ', ' + pj.CaptaineName2);
        TextOut(sx(355), sy(51 + LISTLINEHEIGHT2 * i), FColor, format('%14s', [GetGoldStr(pj.SellPrice)])); //SX(249)
        TextOut(sx(461), sy(51 + LISTLINEHEIGHT2 * i), FColor, pj.SellState); //SX(348)
      end;
    end;


      //Release;
  end;
end;

procedure TFrmDlg.DJangwonListDlgClick(Sender: TObject; X, Y: Integer);
var
  lx, ly, idx: integer;
  pj: PTClientJangwon;
begin

  pj := nil;
  lx := DJangwonListDlg.LocalX(X) - DJangwonListDlg.Left;
  ly := DJangwonListDlg.LocalY(Y) - DJangwonListDlg.Top;
  if (lx >= 9) and (lx <= 511) and (ly >= 48) and (ly <= 190) then
  begin
//      idx := (ly-51) div LISTLINEHEIGHT2 + MenuTop;
    idx := (ly - 51) div LISTLINEHEIGHT2;
    if idx < JangwonList.Count then
    begin
      PlaySound(s_glass_button_click);
      MenuIndex := idx;
    end;
  end;

  if (MenuIndex >= 0) and (MenuIndex < JangwonList.Count) then
  begin
    pj := PTClientJangwon(JangwonList[MenuIndex]);
  end;

end;

procedure TFrmDlg.DJangListPrevClick(Sender: TObject; X, Y: Integer);
begin
  MenuIndex := -1;
  if MenuTop = 10 then
    FrmMain.SendGetJangwonList(1);
end;

procedure TFrmDlg.DJangListNextClick(Sender: TObject; X, Y: Integer);
begin
  MenuIndex := -1;
  if MenuTop = 0 then
    FrmMain.SendGetJangwonList(2);
end;

procedure TFrmDlg.DJangwonCloseClick(Sender: TObject; X, Y: Integer);
begin
  DJangwonListDlg.Visible := False;
  BoMemoJangwon := False;
end;

procedure TFrmDlg.DJangMemoClick(Sender: TObject; X, Y: Integer);
var
  pj: PTClientJangwon;
begin
  if MenuIndex < 0 then
    Exit;
  pj := nil;

  ViewWindowNo := VIEW_MAILSEND;
  ViewWindowData := CurrentMail;
  DMemoB1.SetImgIndex(WProgUse, 546);
  DMemoB2.SetImgIndex(WProgUse, 538);
  DMemoB1.Visible := true;
  MemoMail.Clear;
//   MemoMail.ReadOnly := false;

  pj := PTClientJangwon(JangwonList[MenuIndex]);
  MemoCharID := pj.CaptaineName1;
  MemoCharID2 := pj.CaptaineName2;

  DMemo.Left := 410;
  DMemo.Top := 198;
  Memo.Clear;
  BoMemoJangwon := True;
  ShowEditMail;

end;

procedure TFrmDlg.DDealJangwonDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with DDealJangwon do
  begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
    with dsurface do
    begin
         //SetBkMode (Handle, TRANSPARENT);
//         Font.Color := clWhite;
//         Font.Size := 12;
//         Font.Style := [fsBold];
      TextOut(SurfaceX(Left + 50), SurfaceY(Top + 9), clWhite, '行会领土交易');
//         Font.Size := 9;
//         Font.Style := [];
         //Release;
    end;
  end;
end;

procedure TFrmDlg.DGABoardListDlgDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);

  function sx(x: integer): integer;
  begin
    Result := DGABoardListDlg.SurfaceX(DGABoardListDlg.Left + x);
  end;

  function sy(y: integer): integer;
  begin
    Result := DGABoardListDlg.SurfaceY(DGABoardListDlg.Top + y);
  end;

var
  i, menuline: integer;
  d, TempSurface: TAsphyreLockableTexture;
  pb: PTClientGABoard;
  TempTitleMsg: string[36];
  FColor: TColor;
begin
  i := 0;
  pb := nil;

  with dsurface do
  begin
    with DGABoardListDlg do
    begin
      d := DGABoardListDlg.WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
    end;

      //SetBkMode (g_DXCanvas.Handle, TRANSPARENT);
      //SetBkMode (Handle, TRANSPARENT);
    FColor := clWhite;
    menuline := _MIN(MAXMENU, GABoardList.Count);

    i := (142 - FontManager.Default.TextWidth(GABoard_GuildName)) div 2;
    TextOut(sx(118 + i), sy(15), FColor, GABoard_GuildName);
    TextOut(sx(45), sy(46), FColor, '作者');
    TextOut(sx(234), sy(46), FColor, '主旨');

    TextOut(sx(343), sy(15), FColor, format('%2d', [GABoard_CurPage]));
    if GABoard_MaxPage < 1 then
      TextOut(sx(360), sy(15), FColor, '/ ' + '1')
    else
      TextOut(sx(360), sy(15), FColor, '/ ' + IntToStr(GABoard_MaxPage));

    for i := 0 to menuline - 1 do
    begin
      pb := PTClientGABoard(GABoardList[i]);

      if i in [0, 1, 2] then
        FColor := clYellow
      else
        FColor := clWhite;

      if i in [0, 1, 2] then
        pb.ReplyCount := 0;
      if pb <> nil then
      begin
        if pb.ReplyCount > 0 then
        begin
          TextOut(sx(20), sy(68 + MAKETLINEHEIGHT * i), FColor, pb.WrigteUser);
          if pb.ReplyCount > 2 then
          begin
            TempTitleMsg := pb.TitleMsg;
            TextOut(sx(124 + (pb.ReplyCount * REPLYIMGPOS)), sy(68 + MAKETLINEHEIGHT * i), FColor, TempTitleMsg)
          end
          else
            TextOut(sx(124 + (pb.ReplyCount * REPLYIMGPOS)), sy(68 + MAKETLINEHEIGHT * i), FColor, pb.TitleMsg);
        end
        else
        begin
          TextOut(sx(20), sy(68 + MAKETLINEHEIGHT * i), FColor, pb.WrigteUser);
          TextOut(sx(124), sy(68 + MAKETLINEHEIGHT * i), FColor, pb.TitleMsg);
        end;
      end;

    end;

      //Release;
  end;

  for i := 0 to menuline - 1 do
  begin
    pb := PTClientGABoard(GABoardList[i]);

    if i in [0, 1, 2] then
      pb.ReplyCount := 0;
    if pb <> nil then
    begin
      if pb.ReplyCount > 0 then
        DGABoardReplyVisibleOk(i, pb.ReplyCount, dsurface);
    end;
  end;

end;

procedure TFrmDlg.DGABoardListCloseClick(Sender: TObject; X, Y: Integer);
begin
  GABoardList.Clear;
  DGABoardListDlg.Visible := False;
end;

procedure TFrmDlg.DGABoardOkClick(Sender: TObject; X, Y: Integer);
begin
  DGABoardListDlg.Visible := False;
end;

procedure TFrmDlg.DGABoardReplyVisibleOk(Index, ReplyCount: Integer; dsurface: TAsphyreCanvas);

  function sx(x: integer): integer;
  begin
    Result := DGABoardListDlg.SurfaceX(DGABoardListDlg.Left + x);
  end;

  function sy(y: integer): integer;
  begin
    Result := DGABoardListDlg.SurfaceY(DGABoardListDlg.Top + y);
  end;

var
  d: TAsphyreLockableTexture;
begin
  d := WProgUse.Images[690];
  if d <> nil then
    dsurface.Draw(sx(109 + (ReplyCount * REPLYIMGPOS)), sy(65 + MAKETLINEHEIGHT * Index), d.ClientRect, d, TRUE);
end;

procedure TFrmDlg.DGABoardListDlgDblClick(Sender: TObject);
var
  lx, ly, idx: integer;
  pb: PTClientGABoard;
  SendStr: string;
begin

  GABoard_BoWrite := 0;
  GABoard_BoReply := 0;
  pb := nil;
  lx := DGABoardListDlg.LocalX(GABoard_X) - DGABoardListDlg.Left;
  ly := DGABoardListDlg.LocalY(GABoard_Y) - DGABoardListDlg.Top;
  if (lx >= 13) and (lx <= 411) and (ly >= 65) and (ly <= 253) then
  begin
    idx := (ly - (64)) div MAKETLINEHEIGHT;
    if idx < GABoardList.Count then
    begin
      PlaySound(s_glass_button_click);
      MenuIndex := idx;
    end;

    if (MenuIndex >= 0) and (MenuIndex < GABoardList.Count) then
    begin
      pb := PTClientGABoard(GABoardList[MenuIndex]);
      SendStr := IntToStr(pb.IndexType1) + '/' + IntToStr(pb.IndexType2) + '/' + IntToStr(pb.IndexType3) + '/' + IntToStr(pb.IndexType4);
      if (Trim(pb.WrigteUser) = Trim(Myself.UserName)) then
        Memo.ReadOnly := False
      else
        Memo.ReadOnly := True;
      FrmMain.SendGABoardRead(SendStr);
    end;
  end;

end;

procedure TFrmDlg.DGABoardListDlgMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  GABoard_X := X;
  GABoard_Y := Y;
end;

procedure TFrmDlg.DGABoardDlgDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with DGABoardDlg do
  begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

    with dsurface do
    begin
         //SetBkMode (Handle, TRANSPARENT);
//         FColor := clWhite;//clSilver;

      TextOut(Left + 16, Top + 13, clWhite, GABoard_UserName);
      TextOut (Left+18, Top+291, clWhite, GABoard_Edit);
//         TextOut (Left+18, Top+291, GABoard_Edit);
         //Release;
    end;
  end;
end;

procedure TFrmDlg.DGABoardCloseClick(Sender: TObject; X, Y: Integer);
begin
  GABoard_Notice.Clear;
  DGABoardDlg.Visible := FALSE;
  Memo.ReadOnly := False;
  Memo.Visible := FALSE;
//   DMsgDlg.DialogResult := mrCancel;
end;

procedure TFrmDlg.DGABoardOk2Click(Sender: TObject; X, Y: Integer);
var
  data: string;
  i: Integer;
begin
  for i := 0 to Memo.Lines.Count - 1 do
  begin
    if Memo.Lines[i] = '' then
      data := data + Memo.Lines[i] + ' '#13
    else
      data := data + Memo.Lines[i] + #13;
  end;
  if Length(StrToSqlSafe(data)) >= 500 then
  begin
    Memo.Visible := False;
    DMessageDlg('文字的总数超过了限制，请重新编辑一遍。', [mbOk]);
    DGABoardDlg.ShowModal;
    Memo.Visible := True;
    Exit;
  end;

  DGABoardCloseClick(self, 0, 0);
//   DScreen.AddChatBoardString ('====SendGABoardOkProg====;', clYellow, clRed);
//   DMsgDlg.DialogResult := mrOk;
  SendGABoardOkProg;
end;

procedure TFrmDlg.DGABoardWriteClick(Sender: TObject; X, Y: Integer);
begin
  GABoard_BoWrite := 1;
  GABoard_BoNotice := 1;
  GABoard_BoReply := 0;
  Memo.ReadOnly := False;
  GABoard_UserName := Myself.UserName;
  GABoard_Notice.Clear;
  if DGABoardDlg.Visible then
    DGABoardCloseClick(DGABoardClose, 0, 0);
  ShowGABoardReadDlg;
end;

procedure TFrmDlg.DGABoardNoticeClick(Sender: TObject; X, Y: Integer);
begin
  if GetTickCount < LastestClickTime then
    Exit;
  FrmMain.SendGABoardNoticeCheck;
  LastestClickTime := GetTickCount + 3000;
end;

procedure TFrmDlg.DGABoardReplyClick(Sender: TObject; X, Y: Integer);
begin
  if MenuIndex in [0, 1, 2] then
  begin
    GABoard_BoReply := 0;
    DScreen.AddChatBoardString('你不能发贴回复通知', clYellow, clRed);
    Exit;
  end
  else
    GABoard_BoReply := 1;

  if DGABoardDlg.Visible then
    DGABoardCloseClick(DGABoardClose, 0, 0);
  ShowGABoardReadDlg;
end;

procedure TFrmDlg.DGABoardDlgKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);
begin
  if Key = 27 then
  begin
    if DGABoardDlg.Visible then
      DGABoardCloseClick(DGABoardClose, 0, 0);
  end;
end;

procedure TFrmDlg.DGABoardListPrevClick(Sender: TObject; X, Y: Integer);
begin
  if 1 < GABoard_CurPage then
    FrmMain.SendGetGABoardList(GABoard_CurPage - 1);
end;

procedure TFrmDlg.DGABoardListNextClick(Sender: TObject; X, Y: Integer);
begin
  if GABoard_MaxPage > GABoard_CurPage then
    FrmMain.SendGetGABoardList(GABoard_CurPage + 1);
end;

procedure TFrmDlg.DGABoardListRefreshClick(Sender: TObject; X, Y: Integer);
begin
  FrmMain.SendGetGABoardList(1);
end;

procedure TFrmDlg.DGABoardMemoClick(Sender: TObject; X, Y: Integer);
begin

  if (MenuIndex < 0) or (MenuIndex > 10) or (GABoard_UserName = '') or (GABoard_UserName = MySelf.UserName) then
    Exit;
  if DGABoardDlg.Visible then
    DGABoardCloseClick(DGABoardClose, 0, 0);
  ViewWindowNo := VIEW_MAILSEND;
  ViewWindowData := CurrentMail;
  DMemoB1.SetImgIndex(WProgUse, 546);
  DMemoB2.SetImgIndex(WProgUse, 538);
  DMemoB1.Visible := true;
  MemoMail.Clear;

  MemoCharID := GABoard_UserName;

  DMemo.Left := 410;
  DMemo.Top := 198;
  BoMemoJangwon := False;
  Memo.Clear;
  ShowEditMail;

end;

procedure TFrmDlg.DGABoardDelClick(Sender: TObject; X, Y: Integer);
var
  SendStr: string;
  MsgResult: integer;
begin

  if (Trim(GABoard_UserName) = Trim(Myself.UserName)) and (GABoard_BoWrite = 0) and (GABoard_BoReply = 0) then
  begin
    Memo.Visible := False;
    MsgResult := DMessageDlg('你确定要删除内容吗？', [mbOk, mbCancel]);
    DGABoardDlg.ShowModal;
    Memo.Visible := True;
    if MsgResult = mrCancel then
      Exit
    else if MsgResult = mrOk then
    begin
      if DGABoardDlg.Visible then
        DGABoardCloseClick(DGABoardClose, 0, 0);
      SendStr := IntToStr(GABoard_IndexType1) + '/' + IntToStr(GABoard_IndexType2) + '/' + IntToStr(GABoard_IndexType3) + '/' + IntToStr(GABoard_IndexType4);
   //      DScreen.AddChatBoardString ('SendGABoardDel=> ' + SendStr, clYellow, clRed);
      FrmMain.SendGABoardDel(GABoard_CurPage, SendStr);
    end;
  end;
//   else if DGABoardDel.Visible then DGABoardDel.Visible   := False;
end;

procedure TFrmDlg.SendGABoardOkProg;
var
  data: string;
  i: Integer;
begin
  if (Trim(GABoard_UserName) <> Trim(Myself.UserName)) and (GABoard_BoWrite = 0) and (GABoard_BoReply = 0) then
  begin
    DGABoardOk2.Visible := False;
//      DScreen.AddChatBoardString ('读状态!!!!', clYellow, clRed);
  end
  else
  begin //if DMsgDlg.DialogResult = mrOk then begin

    data := '';
    for i := 0 to Memo.Lines.Count - 1 do
    begin
      if Memo.Lines[i] = '' then
        data := data + Memo.Lines[i] + ' '#13
      else
        data := data + Memo.Lines[i] + #13;
    end;
    if Length(StrToSqlSafe(data)) > 500 then
    begin
//            data := Copy (data, 1, 500);
      DMessageDlg('文字的总数超过了限制', [mbOk]);
//            DScreen.AddChatBoardString ('字母的总数超过了限制', clWhite, clRed);
      Exit;
    end;

    if (Trim(GABoard_UserName) = Trim(Myself.UserName)) and (GABoard_BoWrite = 0) and (GABoard_BoReply = 0) then
    begin
      data := IntToStr(GABoard_IndexType1) + '/' + IntToStr(GABoard_IndexType2) + '/' + IntToStr(GABoard_IndexType3) + '/' + IntToStr(GABoard_IndexType4) + '/' + StrToSqlSafe(data);
      FrmMain.SendGABoardModify(GABoard_CurPage, data);
//   DScreen.AddChatBoardString ('修改发送!!', clYellow, clRed);
      Memo.Clear;
      Exit;
    end
    else if GABoard_BoReply = 1 then
    begin
      data := IntToStr(GABoard_IndexType1) + '/' + IntToStr(GABoard_IndexType2) + '/' + IntToStr(GABoard_IndexType3) + '/' + IntToStr(GABoard_IndexType4) + '/' + StrToSqlSafe(data);
//      DScreen.AddChatBoardString ('文章发送!!', clYellow, clRed);
    end
    else
    begin
//      DScreen.AddChatBoardString ('写作发送!!', clYellow, clRed);
      data := '0/0/0/0/' + StrToSqlSafe(data);
    end;

//     DScreen.AddChatBoardString (data, clYellow, clRed);
    FrmMain.SendGABoardUpdateNotice(GABoard_BoNotice, GABoard_CurPage, data);
    Memo.Clear;
    DMsgDlg.DialogResult := mrCancel;
  end;

end;

procedure TFrmDlg.SendGABoardNoticeOk;
begin
  GABoard_BoWrite := 1;
  GABoard_BoNotice := 0;
  GABoard_BoReply := 0;
  Memo.ReadOnly := False;
  GABoard_UserName := Myself.UserName;
  GABoard_Notice.Clear;
  if DGABoardDlg.Visible then
    DGABoardCloseClick(DGABoardClose, 0, 0);
  ShowGABoardReadDlg;
end;

procedure TFrmDlg.DGADecorateDlgDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);

  function sx(x: integer): integer;
  begin
    Result := DGADecorateDlg.SurfaceX(DGADecorateDlg.Left + x);
  end;

  function sy(y: integer): integer;
  begin
    Result := DGADecorateDlg.SurfaceY(DGADecorateDlg.Top + y);
  end;

var
  i, m, menuline, ImgX, ImgY: integer;
  d, TempSurface: TAsphyreLockableTexture;
  pd: PTClientGADecoration;
  FColor: TColor;
begin
  i := 0;
  pd := nil;

  with dsurface do
  begin
    with DGADecorateDlg do
    begin
      d := DGADecorateDlg.WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
    end;

      //SetBkMode (g_DXCanvas.Handle, TRANSPARENT);
      //SetBkMode (Handle, TRANSPARENT);
    FColor := clWhite;
    menuline := _MIN(DECOMAXMENU, GADecorationList.Count - MenuTop);
//      DScreen.AddChatBoardString ('GADecorationList.Count=> ' +IntToStr(GADecorationList.Count), clYellow, clRed);

    TextOut(sx(93), sy(15), FColor, '装饰品列表');
    TextOut(sx(513), sy(16), FColor, format('%3d', [(MenuTop + 12) div 12]));
    if GADecorationList.Count < 13 then
      TextOut(sx(538), sy(16), FColor, '/ ' + '1')
    else
      TextOut(sx(538), sy(16), FColor, '/ ' + IntToStr((GADecorationList.Count div 12) + 1));

//      TextOut (SX(15),  SY(32), '编号');
    TextOut(sx(61), sy(47), FColor, '名称');
    TextOut(sx(183), sy(47), FColor, '价格'); //SX(271)

    for i := MenuTop to MenuTop + menuline - 1 do
    begin
//      for i:=0 to menuline-1 do begin
      m := i - MenuTop;
      pd := PTClientGADecoration(GADecorationList[i]);

      if i = MenuIndex then
        FColor := clRed
      else
        FColor := clWhite;

      if pd <> nil then
      begin
//            TextOut (SX(19),  SY(70 + MAKETLINEHEIGHT * i), format('%2s',[IntToStr(pd.Num)]));
        TextOut(sx(26), sy(70 + MAKETLINEHEIGHT * m), FColor, pd.Name);
        TextOut(sx(158), sy(70 + MAKETLINEHEIGHT * m), FColor, format('%14s', [GetGoldStr(pd.Price)])); //SX(249)
      end;
    end;

    FColor := clWhite;
    if (MenuIndex >= 0) and (MenuIndex < GADecorationList.Count) then
    begin
      pd := PTClientGADecoration(GADecorationList[MenuIndex]);
      if pd.CaseNum = 1 then
        TextOut(sx(17), sy(306), FColor, '可以套内')
      else if pd.CaseNum = 2 then
        TextOut(sx(17), sy(306), FColor, '可以放到外面')
      else if pd.CaseNum = 3 then
        TextOut(sx(17), sy(306), FColor, '可以设置内、外');
    end;
      //Release;
  end;

  if (MenuIndex >= 0) and (MenuIndex < GADecorationList.Count) then
  begin
    pd := PTClientGADecoration(GADecorationList[MenuIndex]);

    if pd.Num = 140 then
      pd.ImgIndex := 300
    else if pd.Num = 141 then
      pd.ImgIndex := 301
    else if pd.Num = 156 then
      pd.ImgIndex := 302
    else if pd.Num = 157 then
      pd.ImgIndex := 303
    else if pd.Num = 163 then
      pd.ImgIndex := 304
    else if pd.Num = 165 then
      pd.ImgIndex := 305
    else if pd.Num = 185 then
      pd.ImgIndex := 306;

    TempSurface := WDecoImg.Images[pd.ImgIndex];
    if TempSurface <> nil then
      ImgX := 285 + ((312 - TempSurface.Width) div 2);
    ImgY := 72 + ((285 - TempSurface.Height) div 2);

    dsurface.Draw(sx(ImgX), sy(ImgY), TempSurface.ClientRect, TempSurface, TRUE);
  end;

end;

procedure TFrmDlg.DGADecorateCloseClick(Sender: TObject; X, Y: Integer);
begin
  DGADecorateDlg.Visible := False;
end;

procedure TFrmDlg.DGADecorateCancelClick(Sender: TObject; X, Y: Integer);
begin
  DGADecorateDlg.Visible := False;
end;

procedure TFrmDlg.DGADecorateBuyClick(Sender: TObject; X, Y: Integer);
var
  pd: PTClientGADecoration;
begin
  if (MenuIndex >= 0) and (MenuIndex < GADecorationList.Count) then
  begin
    pd := PTClientGADecoration(GADecorationList[MenuIndex]);
    FrmMain.SendBuyDecoItem(CurMerchant, pd.Num);
    if not DItemBag.Visible then
    begin
      DItemBag.Left := 440;
      DItemBag.Top := 0;
      DItemBag.Visible := TRUE;
    end;
  end;
end;

procedure TFrmDlg.DGADecorateDlgClick(Sender: TObject; X, Y: Integer);
var
  lx, ly, idx: integer;
  pd: PTClientGADecoration;
begin

  pd := nil;
  lx := DGADecorateDlg.LocalX(X) - DGADecorateDlg.Left;
  ly := DGADecorateDlg.LocalY(Y) - DGADecorateDlg.Top;
  if (lx >= 11) and (lx <= 275) and (ly >= 64) and (ly <= 294) then
  begin
    idx := (ly - 70) div MAKETLINEHEIGHT + MenuTop;
    if idx < GADecorationList.Count then
    begin
      PlaySound(s_glass_button_click);
      MenuIndex := idx;
    end;
  end;

  if (MenuIndex >= 0) and (MenuIndex < GADecorationList.Count) then
  begin
    pd := PTClientGADecoration(GADecorationList[MenuIndex]);
  end;
end;

procedure TFrmDlg.DGADecorateDlgKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);
begin
  if Key = 27 then
    if DGADecorateDlg.Visible then
      DGADecorateDlg.Visible := False;

//   DScreen.ClearHint(True);
  case Key of
    VK_UP:
      begin
        if (MenuTop <= (MenuIndex - 1)) and (MenuIndex <> -1) then
        begin
          Dec(MenuIndex, 1);
          DGADecorateDlgClick(DGADecorateDlg, 0, 0);
        end;
      end;
    VK_DOWN:
      begin
        if (MenuTop + DECOMAXMENU > (MenuIndex + 1)) and (MenuIndex <> -1) and ((MenuIndex + 1) < GADecorationList.Count) then
        begin
          Inc(MenuIndex, 1);
          DGADecorateDlgClick(DGADecorateDlg, 0, 0);
        end;
      end;
    VK_LEFT:
      begin
        DGADecorateListPrevClick(DGADecorateListPrev, 0, 0);
      end;
    VK_RIGHT:
      begin
        DGADecorateListNextClick(DGADecorateListNext, 0, 0);
      end;
  else

  end;

end;

procedure TFrmDlg.DGADecorateListNextClick(Sender: TObject; X, Y: Integer);
var
  MaxNum: Integer;
begin
  MenuIndex := -1;
  MaxNum := ((GADecorationList.Count div 12) + 1) * 12;
  if (MaxNum >= GADecorationList.Count) and (MaxNum >= (MenuTop + 23)) then
  begin
    Inc(MenuTop, DECOMAXMENU);
  end;
  MenuIndex := MenuTop;
  DGADecorateDlgClick(DGADecorateDlg, 0, 0);

end;

procedure TFrmDlg.DGADecorateListPrevClick(Sender: TObject; X, Y: Integer);
begin
  MenuIndex := -1;
  if MenuTop > 0 then
  begin
    Dec(MenuTop, DECOMAXMENU);
    if MenuTop < 0 then
      MenuTop := 0;
  end;
  MenuIndex := MenuTop;
  DGADecorateDlgClick(DGADecorateDlg, 0, 0);
end;

procedure TFrmDlg.SafeCloseDlg;
begin
  if DMakeItemDlg.Visible then
    DMakeItemDlgOkClick(DMakeItemDlgCancel, 0, 0);
  if DItemMarketDlg.Visible then
    CloseItemMarketDlg;
  if DJangwonListDlg.Visible then
    DJangwonCloseClick(DJangwonClose, 0, 0);
  if DGABoardListDlg.Visible then
    DGABoardListCloseClick(FrmDlg.DGABoardListClose, 0, 0);
  if DGABoardDlg.Visible then
    DGABoardCloseClick(FrmDlg.DGABoardClose, 0, 0);
  if DGADecorateDlg.Visible then
    DGADecorateCloseClick(DGADecorateClose, 0, 0);
end;

function TFrmDlg.DecoItemDesc(Dura: word; var str: string): string;
var
  pd: PTClientGADecoration;
begin
  if (Dura >= 0) and (Dura < GADecorationList.Count) then
  begin
    pd := PTClientGADecoration(GADecorationList[Dura]);
    if pd.CaseNum = 1 then
      str := '可以套内'
    else if pd.CaseNum = 2 then
      str := '可以放到外面'
    else if pd.CaseNum = 3 then
      str := '可以设置内、外';
    Result := '图像: ' + pd.Name;
  end;
end;

procedure TFrmDlg.DEditIDKeyPress(Sender: TObject; var Key: Char);
begin
  LoginScene.EdLoginIdKeyPress(Sender, Key);
end;

procedure TFrmDlg.DEditIDMouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
var
  i: Integer;
  DC: TDControl;
  dp: TDEdit;
  cStr: string;
begin
  if not (Sender is TDEdit) then Exit;
  dp := Sender as TDEdit;
  if dp.IsHotKey or dp.NomberOnly then Exit;

  if (Button = mbLeft) then begin
    if (LastMenuControl <> nil) then begin
      for i := LastMenuControl.DControls.Count - 1 downto 0 do begin
        DC := TDControl(LastMenuControl.DControls[i]);
        if DC.Visible and (DC is TDHint) then begin
          DC.Visible := False;
          Break;
        end;
      end;
    end;
    Exit;
  end;

  //-------------
  DHint.ParentControl := nil;
  if (LastMenuControl <> nil) then begin
    if (LastMenuControl <> dp) then begin
      for i := LastMenuControl.DControls.Count - 1 downto 0 do begin
        DC := TDControl(LastMenuControl.DControls[i]);
        if DC is TDHint then begin
          LastMenuControl.DControls.Delete(i);
          Break;
        end;
      end;
    end;
    LastMenuControl.DHint := nil;
  end;

  for i := 0 to DHint.Items.Count - 1 do begin
    case i of
      0, 1, 3: begin
          if (dp.Caption <> '') and (dp.SelStart > -1) and (dp.SelEnd > -1) and (dp.SelStart <> dp.SelEnd) then
            DHint.Items.Objects[i] := TObject(Integer(0))
          else
            DHint.Items.Objects[i] := TObject(Integer(1));
        end;
      2: begin
          FrmDlg.EditTemp.SelectAll;
          FrmDlg.EditTemp.PasteFromClipboard;
          cStr := FrmDlg.EditTemp.Text;
          if cStr <> '' then begin
            DHint.Items.Objects[i] := TObject(Integer(0))
          end else
            DHint.Items.Objects[i] := TObject(Integer(1));
        end;
      4: begin
          if dp.Caption <> '' then begin
            DHint.Items.Objects[i] := TObject(Integer(0))
          end else
            DHint.Items.Objects[i] := TObject(Integer(1));
        end;
    end;
  end;

  if (LastMenuControl = nil) or (LastMenuControl <> dp) then begin
    DHint.DParent := dp;
    dp.AddChild(DHint);
  end;
  if (LastMenuControl <> nil) and (LastMenuControl <> dp) then begin
    if not dp.IsHotKey and (dp.Caption <> '') then begin
      dp.SelStart := 0;
      dp.SelEnd := AnsiTextLength(dp.Caption);
      dp.ChangeCurPos(dp.SelEnd, True);
    end;
  end;
  LastMenuControl := dp;

  DHint.Left := X - dp.Left;
  DHint.Top := Y - dp.Top - DHint.Height;
  DHint.ParentControl := dp;
  DHint.Visible := True;
  dp.DHint := DHint;
end;

procedure TFrmDlg.DEditPassKeyPress(Sender: TObject; var Key: Char);
begin
  LoginScene.EdLoginPasswdKeyPress(Sender, Key);
end;

procedure TFrmDlg.DEditPtHpLeave(Sender: TObject);
begin
  if DEditPtHp.Text <> '' then
  g_NgConfigInfo.nHpPtEat := StrToInt(DEditPtHp.Text);
end;

procedure TFrmDlg.DEditPtHpTextChanged(Sender: TObject; sText: string);
begin
  if DEditPtHp.Text <> '' then
  g_NgConfigInfo.nHpPtEat := StrToInt(DEditPtHp.Text);
end;

procedure TFrmDlg.DEditPtHpTimeLeave(Sender: TObject);
begin
  if DEditPtHpTime.Text <> '' then
  g_NgConfigInfo.nwHpPtEat := StrToInt(DEditPtHpTime.Text);
end;

procedure TFrmDlg.DEditPtHpTimeTextChanged(Sender: TObject; sText: string);
begin
  if DEditPtHpTime.Text <> '' then
  g_NgConfigInfo.nwHpPtEat := StrToInt(DEditPtHpTime.Text);
end;

procedure TFrmDlg.DEditPtMpLeave(Sender: TObject);
begin
  if DEditPtMp.Text <> '' then
  g_NgConfigInfo.nMpPtEat := StrToInt(DEditPtMp.Text);
end;

procedure TFrmDlg.DEditPtMpTextChanged(Sender: TObject; sText: string);
begin
  if DEditPtMp.Text <> '' then
  g_NgConfigInfo.nMpPtEat := StrToInt(DEditPtMp.Text);
end;

procedure TFrmDlg.DEditPtMpTimeLeave(Sender: TObject);
begin
  if DEditPtMpTime.Text <> '' then
  g_NgConfigInfo.nwMpPtEat := StrToInt(DEditPtMpTime.Text);
end;

procedure TFrmDlg.DEditPtMpTimeTextChanged(Sender: TObject; sText: string);
begin
  if DEditPtMpTime.Text <> '' then
  g_NgConfigInfo.nwMpPtEat := StrToInt(DEditPtMpTime.Text);
end;

procedure TFrmDlg.DEditStoreItemPriceKeyPress(Sender: TObject; var Key: Char);
begin
  if (Key = #13) then begin
    ReleaseDFocus;
  end;
end;

procedure TFrmDlg.DEdtSdoExpFiltrateTextChanged(Sender: TObject; sText: string);
begin
  if DEdtSdoExpFiltrate.Text <> '' then
    g_NgConfigInfo.nExpShow := StrToInt(DEdtSdoExpFiltrate.Text);
end;

procedure TFrmDlg.DMasterDlgClick(Sender: TObject; X, Y: Integer);
begin
  ItemSearchEdit.Visible := False;
end;

procedure TFrmDlg.DMasterDlgDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  b: TAsphyreLockableTexture;
  lx, ly, n, t, l, ax, ay: integer;
  Rect: TRect;
  CurrentPage, maxPage, UpPage, DownPage: integer;
begin

  with (Sender as TDWindow) do
  begin
//    if fLover.GetEnable(RsState_Lover) = 1 then
//      DLover1.SetImgIndex(WProgUse, 602)
//    else
//      DLover1.SetImgIndex(WProgUse, 600);

    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

//    b := WProgUse.GetCachedImage(582, ax, ay);
//    dsurface.Draw(SurfaceX(Left + 5), SurfaceY(Top + 5), b.ClientRect, b, TRUE);
//    b := WProgUse.GetCachedImage(580, ax, ay); //恋爱
//    dsurface.Draw(SurfaceX(Left + 168), SurfaceY(Top + 136), b.ClientRect, b, TRUE);


    b := WProgUse.GetCachedImage(581, ax, ay); //师徒图片代码
    dsurface.Draw(SurfaceX(Left + 15), SurfaceY(Top + 21), b.ClientRect, b, TRUE);//15左边  20顶边



//    lx := SurfaceX(30) + Left;
//    ly := SurfaceY(32) + Top + (1 * 15);

//    g_DXCanvas.TextOutEx(lx, ly, clSilver, fLover.GetDisplay(0));       //师徒界面的字体
//
//    ly := SurfaceY(32) + Top + (3 * 15);
//    g_DXCanvas.TextOutEx(lx, ly, clSilver, fLover.GetDisplay(1));
//
//    ly := SurfaceY(32) + Top + (5 * 15);
//    g_DXCanvas.TextOutEx(lx, ly, clSilver, fLover.GetDisplay(2));




    if fMaster.GetMasterCount > 0 then begin      //徒弟显示信息

      lx := SurfaceX(30) + Left;//师徒文字左边
      ly := SurfaceY(65) + Top + (1 * 33); //师徒文字顶边

//      g_DXCanvas.TextOut(lx, ly, clSilver, 'fMaster.GetMasterCount='+IntToStr(fMaster.GetMasterCount));

      dsurface.TextOut(lx, ly, clSilver, fMaster.GetDisplay(0));

      ly := SurfaceY(65) + Top + (2 * 33);
      dsurface.TextOut(lx, ly, clSilver, fMaster.GetDisplay(1));

         ly := SurfaceY(65) + Top + (3 * 33);
      dsurface.TextOut(lx, ly, clSilver, fMaster.GetDisplay(2));

    end;


    if fPupil.GetPupilCount > 0 then begin       //师傅显示信息

      lx := SurfaceX(30) + Left; //文字左边

      ly := SurfaceY(65) + Top + (1 * 33);//师徒文字顶边
      dsurface.TextOut(lx, ly, clSilver, fPupil.GetDisplay(0));

      ly := SurfaceY(65) + Top + (2 * 33);
      dsurface.TextOut(lx, ly, clSilver, fPupil.GetDisplay(1));

      ly := SurfaceY(65) + Top + (3 * 33);
      dsurface.TextOut(lx, ly, clSilver, fPupil.GetDisplay(2));

      ly := SurfaceY(65) + Top + (4 * 33);
      dsurface.TextOut(lx, ly, clSilver, fPupil.GetDisplay(3));

      ly := SurfaceY(65) + Top + (5 * 33);
      dsurface.TextOut(lx, ly, clSilver, fPupil.GetDisplay(4));

    end;
  end;
end;

procedure TFrmDlg.DMasterDlgMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
begin
  DScreen.ClearHint(True);
end;

procedure TFrmDlg.DLoveCloseClick(Sender: TObject; X, Y: Integer);
begin
ToggleShowLoveDlg;
end;

procedure TFrmDlg.DLoveDlgDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  b: TAsphyreLockableTexture;
  lx, ly, n, t, l, ax, ay: integer;
  Rect: TRect;
  CurrentPage, maxPage, UpPage, DownPage: integer;
begin

  with (Sender as TDWindow) do
  begin
    if fLover.GetEnable(RsState_Lover) = 1 then
      DLover1.SetImgIndex(WProgUse, 602)
    else
      DLover1.SetImgIndex(WProgUse, 600);

    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

//    b := WProgUse.GetCachedImage(582, ax, ay);
//    dsurface.Draw(SurfaceX(Left + 5), SurfaceY(Top + 5), b.ClientRect, b, TRUE);



    b := WProgUse.GetCachedImage(580, ax, ay); //恋爱图片代码
    dsurface.Draw(SurfaceX(Left + 15), SurfaceY(Top + 21), b.ClientRect, b, TRUE);

    lx := SurfaceX(30) + Left; //恋人文字左边
    ly := SurfaceY(65) + Top + (1 * 33); //恋人文字顶边

    dsurface.TextOut(lx, ly, clSilver, fLover.GetDisplay(0));       //恋人界面的字体

    ly := SurfaceY(65) + Top + (2 * 33);
    dsurface.TextOut(lx, ly, clSilver, fLover.GetDisplay(1));

    ly := SurfaceY(65) + Top + (3 * 33);
    dsurface.TextOut(lx, ly, clSilver, fLover.GetDisplay(2));

    ly := SurfaceY(65) + Top + (4 * 33);
    dsurface.TextOut(lx, ly, clSilver, fLover.GetDisplay(3));

    ly := SurfaceY(65) + Top + (5 * 33);
    dsurface.TextOut(lx, ly, clSilver, fLover.GetDisplay(4));
  end;
end;

procedure TFrmDlg.DLover1Click(Sender: TObject; X, Y: Integer);
var
  sendenable: integer;
begin
  if fLover.GetEnable(RsState_Lover) = 1 then
    sendenable := 0
  else
    sendenable := 1;

  FrmMain.SendLMOptionChange(1, sendenable);

end;

procedure TFrmDlg.DLover1MouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  lx, ly: integer;
  sx, sy: integer;
begin
  with DFrdAdd do
  begin
    lx := LocalX(X - Left);
    ly := LocalY(Y - Top);
    sx := SurfaceX(Left) + DMasterDlg.SurfaceX(DMasterDlg.Left) + lx + 8;
    sy := SurfaceY(Top) + DMasterDlg.SurfaceX(DMasterDlg.Top) + ly + 6;
    DScreen.ShowHint(sx, sy, '[允许/拒绝]结婚', clWhite, FALSE);
    DFriendDlg.hint := '';
  end;
end;

procedure TFrmDlg.DLover2Click(Sender: TObject; X, Y: Integer);
begin
  FrmMain.SendLMRequest(RsState_Lover, RsReq_WantToJoinOther);
end;

procedure TFrmDlg.DLover2MouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  lx, ly: integer;
  sx, sy: integer;
begin
  with DFrdAdd do
  begin
    lx := LocalX(X - Left);
    ly := LocalY(Y - Top);
    sx := SurfaceX(Left) + DMasterDlg.SurfaceX(DMasterDlg.Left) + lx + 8;
    sy := SurfaceY(Top) + DMasterDlg.SurfaceX(DMasterDlg.Top) + ly + 6;
    DScreen.ShowHint(sx, sy, '求婚', clWhite, FALSE);
    DFriendDlg.hint := '';
  end;

end;

procedure TFrmDlg.DLover3Click(Sender: TObject; X, Y: Integer);
var
  Name: string;
begin
  Name := fLover.GetName(RsState_Lover);
//     DScreen.AddSysMsg ( 'LOVER3_CLCIK:'+Name );
  if mrCancel = DMessageDlg('离婚？\需要支付150,0000金币赡养费\是否结束关系，继续？', [mbYes, mbCancel]) then
    Exit;
  if Name <> '' then
    FrmMain.SendLMSeparate(RsState_Lover, Name);

end;

procedure TFrmDlg.DLover3MouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  lx, ly: integer;
  sx, sy: integer;
begin
  with DFrdAdd do
  begin
    lx := LocalX(X - Left);
    ly := LocalY(Y - Top);
    sx := SurfaceX(Left) + DMasterDlg.SurfaceX(DMasterDlg.Left) + lx + 8;
    sy := SurfaceY(Top) + DMasterDlg.SurfaceX(DMasterDlg.Top) + ly + 6;
    DScreen.ShowHint(sx, sy, '离婚', clWhite, FALSE);
    DFriendDlg.hint := '';
  end;

end;

procedure TFrmDlg.ToggleShowMasterDlg;
begin
  DMasterDlg.Visible := not DMasterDlg.Visible;
  if DMasterDlg.Visible then begin
    //flover.MakeDisplay(10);
    fMaster.MakeDisplay(30);
    fPupil.MakeDisplay(40);
  end;
end;

procedure TFrmDlg.ToggleShowLoveDlg;
begin
  DLoveDlg.Visible := not DLoveDlg.Visible;
  if DLoveDlg.Visible then begin
    flover.MakeDisplay(10);
    //fMaster.MakeDisplay(30);
    //fPupil.MakeDisplay(40);
  end;
end;

procedure TFrmDlg.DMaster1Click(Sender: TObject; X, Y: Integer);
begin
  if MySelf.Abil.Level < 35 then FrmMain.SendLMRequest(RsState_Master, RsReq_WantToJoinOther)
  else FrmMain.SendLMRequest(RsState_Pupil, RsReq_WantToJoinOther);
end;

procedure TFrmDlg.DMaster1MouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var
  lx, ly: integer;
  sx, sy: integer;
  str: string;
begin
  if MySelf.Abil.Level < 35 then str := '拜师'
  else str := '收徒';
  with DMaster1 do begin
    lx := LocalX(X - Left);
    ly := LocalY(Y - Top);
    sx := SurfaceX(Left) + DMasterDlg.SurfaceX(DMasterDlg.Left) + lx + 8;
    sy := SurfaceY(Top) + DMasterDlg.SurfaceX(DMasterDlg.Top) + ly + 6;
    DScreen.ShowHint(sx, sy, str, clWhite, FALSE);
    DFriendDlg.hint := '';
  end;
end;

procedure TFrmDlg.DMaster2Click(Sender: TObject; X, Y: Integer);
begin
  FrmMain.SendRufuseMaster();
end;

procedure TFrmDlg.DMaster2MouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var
  lx, ly: integer;
  sx, sy: integer;
  str: string;
begin
    if MySelf.Abil.Level < 35 then
      str := '[允许/拒绝]拜师'
    else
      str := '[允许/拒绝]收徒';
  with DMaster1 do begin
    lx := LocalX(X - Left);
    ly := LocalY(Y - Top);
    sx := SurfaceX(Left) + DMasterDlg.SurfaceX(DMasterDlg.Left) + lx + 8;
    sy := SurfaceY(Top) + DMasterDlg.SurfaceX(DMasterDlg.Top) + ly + 6;
    DScreen.ShowHint(sx, sy, str, clWhite, FALSE);
    DFriendDlg.hint := '';
  end;
end;

procedure TFrmDlg.DMaster3Click(Sender: TObject; X, Y: Integer);
var
  Name: string;
  PupilInfo: TRelationShipInfo;
begin
  if fMaster.GetMasterCount > 0 then begin
    Name := fMaster.GetName(RsState_Master);
    if mrCancel = DMessageDlg('提示：你想与你的师傅脱离师徒关系吗？\如果提出脱离师徒关系，需要支付100,000金币作为脱离费！', [mbYes, mbCancel]) then
      Exit;
    if Name <> '' then
      FrmMain.SendLMSeparate(RsState_Master, Name);
  end;

  if fPupil.GetPupilCount > 0 then begin
    if mrOk = DMessageDlg('请输入你要逐出师门徒弟的名字：', [mbOk, mbCancel, mbAbort]) then
    begin
      Name := Trim (DlgEditText);
      if fPupil.GetInfo(Name, PupilInfo) then begin
        if mrOk = DMessageDlg('提示：你确定要将 ['+Name+'] 这个徒弟逐出师门吗？\不过你需要支付100,000金币作为脱离费！', [mbOk, mbCancel]) then begin
          FrmMain.SendLMSeparate(RsState_Pupil, Name);
        end;
      end else begin
        DMessageDlg('提示：['+Name+'] 不是你的徒弟，请输入正确的徒弟名字！', [mbOk]);
      end;
    end;
  end;
end;

procedure TFrmDlg.DMaster3MouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var
  lx, ly: integer;
  sx, sy: integer;
begin
  with DMaster3 do begin
    lx := LocalX(X - Left);
    ly := LocalY(Y - Top);
    sx := SurfaceX(Left) + DMasterDlg.SurfaceX(DMasterDlg.Left) + lx + 8;
    sy := SurfaceY(Top) + DMasterDlg.SurfaceX(DMasterDlg.Top) + ly + 6;
    DScreen.ShowHint(sx, sy, '脱离师徒关系', clWhite, FALSE);
    DFriendDlg.hint := '';
  end;
end;

procedure TFrmDlg.DMasterCloseClick(Sender: TObject; X, Y: Integer);
begin
  ToggleShowMasterDlg;
end;

procedure TFrmDlg.DMasterCloseDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with Sender as TDButton do
  begin
    if TDButton(Sender).Downed then
    begin
      d := WLib.Images[FaceIndex + 1];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
    end else
    begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
    end;
  end;
end;

procedure TFrmDlg.DHeartImgDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with DHeartImg do
  begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
  end;
end;

procedure TFrmDlg.DHeartImgUSDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with DHeartImgUS do
  begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
  end;
end;

procedure TFrmDlg.DHelpDlgCloseClick(Sender: TObject; X, Y: Integer);
begin
  DHelpDlg.Visible := False;
end;

procedure TFrmDlg.DHelpDlgCloseDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with Sender as TDButton do begin
    if Downed then
      d := WLib.Images[FaceIndex+2]
    else if Arrived then
      d := WLib.Images[FaceIndex+1]
    else
      d := WLib.Images[FaceIndex];

    if d <> nil then dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
  end;
end;

procedure TFrmDlg.DHelpDlgDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d, dd, e: TAsphyreLockableTexture;
  ax, ay, img: integer;
begin
  with DHelpDlg do begin

    if g_FScreenWidth = 1024 then img := 25
    else img := 0;

    case nHelpType of
      0: begin
        dd:= WLib.Images[293+img];
        e := WLib.Images[304];
        ax := 0;
        ay := g_FScreenHeight - e.Height;
      end;
      1: begin
        dd:= WLib.Images[294+img];
        if g_FScreenWidth = 1024 then e := WLib.Images[320]    //这个是1024的中间介绍
        else e := WLib.Images[305];
        ax := 68;
        ay := g_FScreenHeight - e.Height;
      end;
      2: begin
        dd:= WLib.Images[291+img];
        e := WLib.Images[306];
        ax := g_FScreenWidth - e.Width;
        ay := g_FScreenHeight - e.Height;
      end
      else begin
        dd:= WLib.Images[290+img];
        e := nil;
        ax := 0;
        ay := 0;
      end;
    end;
    if dd <> nil then dsurface.DrawAlpha(SurfaceX(Left), SurfaceY(Top), dd, 150);

    d := WLib.Images[FaceIndex+img];
    if d <> nil then dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);

    if e <> nil then dsurface.Draw(SurfaceX(Left + ax), SurfaceY(Top+ ay), e.ClientRect, e, True);
  end;
end;

procedure TFrmDlg.DHelpDlgLeftClick(Sender: TObject; X, Y: Integer);
begin
  with Sender as TDButton do begin
    if Tag = nHelpType then nHelpType := -1
    else nHelpType := Tag;
  end;
end;

procedure TFrmDlg.DHelpDlgLeftDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d, dd: TAsphyreLockableTexture;
  b : TDButton;
begin
  b := TDButton(Sender);
  with TDButton(Sender) do begin

    if b.Downed then
      d := WLib.Images[FaceIndex+2]
    else if b.Arrived then
      d := WLib.Images[FaceIndex+1]
    else
      d := WLib.Images[FaceIndex];

    if d <> nil then dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);

    if Tag = nHelpType then
      dd := WLib.Images[312]
    else
      dd := WLib.Images[311];

    if dd <> nil then dsurface.Draw(SurfaceX(Left) - 20, SurfaceY(Top), dd.ClientRect, dd, True);
  end;
end;

procedure TFrmDlg.DBotMaster1Click(Sender: TObject; X, Y: Integer);
begin
  if (Myself = nil) or not g_boOpenStallSystem then begin
    Exit;
  end;
  if DWHeroStore.Visible then begin
    if not Myself.m_StallMgr.OnSale then begin
      DBStoreCloseClick(nil, 0, 0);
      DItemBag.Visible := False;
    end else
      DWHeroStore.Visible := False;
  end else begin
    DWHeroStore.Visible := True;
    if not Myself.m_StallMgr.OnSale then begin
      DEditStoreName.Text := Format('[%s]的摊位', [frmMain.CharName]);
      if not DItemBag.Visible then
        OpenItemBag;
    end else begin
      DEditStoreName.Text := Myself.m_StallMgr.mBlock.StallName;
    end;
  end;
end;

procedure TFrmDlg.DBotMasterClick(Sender: TObject; X, Y: Integer);
begin
  ToggleShowMasterDlg;
end;

procedure TFrmDlg.DMarketMemoClick(Sender: TObject; X, Y: Integer);
begin
  if trim(MemoCharID) <> '' then
  begin
    ViewWindowNo := VIEW_MAILSEND;
    DMemoB1.SetImgIndex(WProgUse, 546);
    DMemoB2.SetImgIndex(WProgUse, 538);
    DMemoB1.Visible := true;
    memoMail.Clear;
    ShowEditMail;
  end
  else
    DMessageDlg('没有目标被选中.', [mbOk]);
end;

procedure TFrmDlg.DMemoKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);
begin
  if Key = 27 then
    if DMemo.Visible then
      DMemoCloseClick(DMemoClose, 0, 0);
end;

procedure TFrmDlg.DSkillBarOnDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  b: TDButton;
begin
  b := nil;
  b := TDButton(Sender);
  if b.Tag = 1 then
  begin
    with b do
    begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
    end;
  end;
end;

procedure TFrmDlg.DChFriendDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  b: TDButton;
begin
  b := nil;
  b := TDButton(Sender);
  with TDButton(Sender) do
  begin
    d := WLib.Images[FaceIndex];
    if (b.Downed) and (d <> nil) then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
  end;
end;

procedure TFrmDlg.DChGroupClick(Sender: TObject; X, Y: Integer);
begin
  if (GetTickCount > changegroupmodetime) and (GroupMembers.Count > 0) then
  begin
    if UserState1.UserName <> '' then
    begin
      changegroupmodetime := GetTickCount + 2000; //timeout 5檬 //DelayTime 5檬俊辑 2檬肺修正 //2004/11/18
      FrmMain.SendAddGroupMember(Trim(UserState1.UserName));
    end;
  end
  else if (GetTickCount > changegroupmodetime) and (GroupMembers.Count = 0) then
  begin
    if UserState1.UserName <> '' then
    begin
      changegroupmodetime := GetTickCount + 2000;
      FrmMain.SendCreateGroup(Trim(UserState1.UserName));
    end;
  end;
end;

procedure TFrmDlg.DCheckBoxHideShitiClick(Sender: TObject; X, Y: Integer);
begin
  g_NgConfigInfo.boNotDeath := DCheckBoxHideShiti.Checked;
end;

procedure TFrmDlg.DCheckBoxHideShitiDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
begin
  with Sender as TDCheckBox do
  begin
    if WLib <> nil then begin
      d := nil;
      if Checked and Enabled then begin
        d := WLib.Images[FaceIndex + 1];
      end else begin
        d := WLib.Images[FaceIndex];
      end;
      if d <> nil then
      begin
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
      end;
      if Arrived then
        dsurface.BoldTextOut(SurfaceX(Left + 20), SurfaceY(Top + 2), clWhite, clBlack, caption)
      else
        dsurface.BoldTextOut(SurfaceX(Left + 20), SurfaceY(Top + 2), $C5C5C5, clBlack, caption);
    end;
  end;
end;

procedure TFrmDlg.DCheckBoxTransClick(Sender: TObject; X, Y: Integer);
begin
  FrmMain.SendClientMessage(CM_SHOWTRANS, Byte(DCheckBoxTrans.Checked), 0, 0, 0);
end;

procedure TFrmDlg.DCheckBoxTransDirectPaint(Sender: TObject;
  DSurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
begin
  with Sender as TDCheckBox do
  begin
    if WLib <> nil then begin
      d := nil;
      if Checked and Enabled then begin
        d := WLib.Images[FaceIndex + 1];
      end else begin
        d := WLib.Images[FaceIndex];
      end;
      if d <> nil then
      begin
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
      end;
      if Arrived then
        dsurface.BoldTextOut(SurfaceX(Left + 20), SurfaceY(Top + 2), clWhite, clBlack, caption)
      else
        dsurface.BoldTextOut(SurfaceX(Left + 20), SurfaceY(Top + 2), $C5C5C5, clBlack, caption);
    end;
  end;
end;

procedure TFrmDlg.DCheckBox_AllPickupChange(Sender: TObject);
begin
  g_NgConfigInfo.boPickUpItemAll := DCheckBox_AllPickup.Checked;
end;

procedure TFrmDlg.DCheckBox_AllPickupClick(Sender: TObject; X, Y: Integer);
begin
  g_NgConfigInfo.boPickUpItemAll := DCheckBox_AllPickup.Checked;
end;

procedure TFrmDlg.DCheckMyHpClick(Sender: TObject; X, Y: Integer);
begin
  g_NgConfigInfo.boBrightShowHp := DCheckMyHp.Checked;
end;

procedure TFrmDlg.DCheckPtmfyChange(Sender: TObject);
begin
  g_NgConfigInfo.boMpPtEat := DCheckPtmfy.Checked;
end;

procedure TFrmDlg.DCheckPtmfyClick(Sender: TObject; X, Y: Integer);
begin
  g_NgConfigInfo.boMpPtEat := DCheckPtmfy.Checked;
end;

procedure TFrmDlg.DCheckPttlyChange(Sender: TObject);
begin
  g_NgConfigInfo.boHpPtEat := DCheckPttly.Checked;
end;

procedure TFrmDlg.DCheckPttlyClick(Sender: TObject; X, Y: Integer);
begin
  g_NgConfigInfo.boHpPtEat := DCheckPttly.Checked;
end;

procedure TFrmDlg.DCheckRanProtectClick(Sender: TObject; X, Y: Integer);
begin
  g_NgConfigInfo.boRanHP :=  DCheckRanProtect.Checked;
end;

procedure TFrmDlg.DCheckSdoAutoFireHitChange(Sender: TObject);
begin
  g_NgConfigInfo.boAutoFireHit := DCheckSdoAutoFireHit.Checked;
  if MySelf.Job <> 0 then g_NgConfigInfo.boAutoFireHit := False;
  DCheckSdoAutoFireHit.Checked := g_NgConfigInfo.boAutoFireHit;
end;

procedure TFrmDlg.DCheckSdoAutoFireHitClick(Sender: TObject; X, Y: Integer);
begin
  g_NgConfigInfo.boAutoFireHit := DCheckSdoAutoFireHit.Checked;
  if MySelf.Job <> 0 then g_NgConfigInfo.boAutoFireHit := False;
  DCheckSdoAutoFireHit.Checked := g_NgConfigInfo.boAutoFireHit;
end;

procedure TFrmDlg.DCheckSdoAutoHideChange(Sender: TObject);
begin
  g_NgConfigInfo.boAutoHide := DCheckSdoAutoHide.Checked;
  if MySelf.Job <> 2 then g_NgConfigInfo.boAutoHide := False;
  DCheckSdoAutoHide.Checked := g_NgConfigInfo.boAutoHide;
end;

procedure TFrmDlg.DCheckSdoAutoHldChange(Sender: TObject);
begin
  g_NgConfigInfo.boAutoHld := DCheckSdoAutoHld.Checked;
  if MySelf.Job <> 2 then g_NgConfigInfo.boAutoHld := False;
  DCheckSdoAutoHld.Checked := g_NgConfigInfo.boAutoHld;
end;

procedure TFrmDlg.DCheckSdoAutoJldChange(Sender: TObject);
begin
  g_NgConfigInfo.boAutoJld := DCheckSdoAutoJld.Checked;
  if MySelf.Job <> 2 then g_NgConfigInfo.boAutoJld := False;
  DCheckSdoAutoJld.Checked := g_NgConfigInfo.boAutoJld;
end;

procedure TFrmDlg.DCheckSdoAutoLongHitChange(Sender: TObject);
begin
  g_NgConfigInfo.boAutoLongHit := DCheckSdoAutoLongHit.Checked;
  if MySelf.Job <> 0 then g_NgConfigInfo.boAutoLongHit := False;
  DCheckSdoAutoLongHit.Checked := g_NgConfigInfo.boAutoLongHit;
end;


procedure TFrmDlg.DCheckSdoAutoHideClick(Sender: TObject; X, Y: Integer);
begin
  g_NgConfigInfo.boAutoHide := DCheckSdoAutoHide.Checked;
  if MySelf.Job <> 2 then g_NgConfigInfo.boAutoHide := False;
  DCheckSdoAutoHide.Checked := g_NgConfigInfo.boAutoHide;
end;

procedure TFrmDlg.DCheckSdoAutoHldClick(Sender: TObject; X, Y: Integer);
begin
  g_NgConfigInfo.boAutoHld := DCheckSdoAutoHld.Checked;
  if MySelf.Job <> 2 then g_NgConfigInfo.boAutoHld := False;
  DCheckSdoAutoHld.Checked := g_NgConfigInfo.boAutoHld;
end;

procedure TFrmDlg.DCheckSdoAutoJldClick(Sender: TObject; X, Y: Integer);
begin
  g_NgConfigInfo.boAutoJld := DCheckSdoAutoJld.Checked;
  if MySelf.Job <> 2 then g_NgConfigInfo.boAutoJld := False;
  DCheckSdoAutoJld.Checked := g_NgConfigInfo.boAutoJld;
end;

procedure TFrmDlg.DCheckSdoAutoLongHitClick(Sender: TObject; X, Y: Integer);
begin
  g_NgConfigInfo.boAutoLongHit := DCheckSdoAutoLongHit.Checked;
  if MySelf.Job <> 0 then g_NgConfigInfo.boAutoLongHit := False;
  DCheckSdoAutoLongHit.Checked := g_NgConfigInfo.boAutoLongHit;
end;

procedure TFrmDlg.DCheckSdoAutoMagicClick(Sender: TObject; X, Y: Integer);
begin
  g_NgConfigInfo.boAutoMagic :=  DCheckSdoAutoMagic.Checked;
  g_NgConfigInfo.nAutoMagicID := DCBPractice.tag;
end;

procedure TFrmDlg.DCheckSdoAutoMagicTimeLeave(Sender: TObject);
begin
  if DCheckSdoAutoMagicTime.Text <> '' then
    g_NgConfigInfo.nwAutoMagic := StrToIntDef(DCheckSdoAutoMagicTime.Text, 1);
end;

procedure TFrmDlg.DCheckSdoAutoMagicTimeTextChanged(Sender: TObject;
  sText: string);
begin
  if DCheckSdoAutoMagicTime.Text <> '' then
    g_NgConfigInfo.nwAutoMagic := StrToIntDef(DCheckSdoAutoMagicTime.Text, 1);
end;

procedure TFrmDlg.DCheckSdoAutoShieldChange(Sender: TObject);
begin
//  g_NgConfigInfo.boAutoShield := DCheckSdoAutoShield.Checked;
//  if MySelf.Job <> 1 then g_NgConfigInfo.boAutoShield := False;
//  DCheckSdoAutoShield.Checked := g_NgConfigInfo.boAutoShield;
end;

procedure TFrmDlg.DCheckSdoAutoShieldClick(Sender: TObject; X, Y: Integer);
begin
  g_NgConfigInfo.boAutoShield := DCheckSdoAutoShield.Checked;
  if MySelf.Job <> 1 then g_NgConfigInfo.boAutoShield := False;
  DCheckSdoAutoShield.Checked := g_NgConfigInfo.boAutoShield;
end;

procedure TFrmDlg.DCheckSdoAvoidShiftClick(Sender: TObject; X, Y: Integer);
begin
  g_NgConfigInfo.boNotNeedShift := DCheckSdoAvoidShift.Checked;
end;

procedure TFrmDlg.DCheckSdoDuraWarningClick(Sender: TObject; X, Y: Integer);
begin
  g_NgConfigInfo.boDuraWarning := DCheckSdoDuraWarning.Checked;
end;

procedure TFrmDlg.DCheckSdoExpFiltrateClick(Sender: TObject; X, Y: Integer);
begin
  g_NgConfigInfo.boExpShow := DCheckSdoExpFiltrate.Checked;
end;

procedure TFrmDlg.DCheckSdoMapDescClick(Sender: TObject; X, Y: Integer);
begin
  g_NgConfigInfo.boShowMap := DCheckSdoMapDesc.Checked;
end;

procedure TFrmDlg.DCheckSdoNameShowClick(Sender: TObject; X, Y: Integer);
begin
  g_NgConfigInfo.boShowName := DCheckSdoNameShow.Checked;
end;

procedure TFrmDlg.DCheckSdoNameShowMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
  var
   TemeStr: string;
begin
  with Sender as TDControl do
  begin
    x := SurfaceX(Left) + 5;
    y := Surfacey(Top) + Height;
    TemeStr := '';
    if Sender = DCheckSdoNameShow then
     TemeStr := '勾选此项将全屏显示玩家名字';
    if Sender = DCheckBoxHideShiti then
     TemeStr := '勾选此项将隐藏地上的尸体';
    if Sender = DCheckSdoDuraWarning then
     TemeStr := '勾选此项将再装备低持久时\进行提示';
    if Sender = DCheckSdoAvoidShift then
     TemeStr := '勾选此项将按下SHIFT键为\免SHIFT的开关键';
    if Sender = DCheckSdoExpFiltrate then
     TemeStr := '勾选此项将隐藏聊天框中低\于设置的经验增涨提示';
    if Sender = DCheckMyHp then
     TemeStr := '勾选此项将高亮自己的血条显示';
    if Sender = DCheckSdoMapDesc then
     TemeStr := '勾选此项将自动显示地图标识';
    if Sender = DCheckBox_AllPickup then
     TemeStr := '勾选此项将自动捡取地面掉\落的物品';
    if Sender = DCheckSdoAutoHld then
     TemeStr := '勾选此项道士使用施毒术时，将自己动切换红绿毒';
    if Sender = DCheckSdoAutoJld then
     TemeStr := '勾选此项道士使用施毒术时，将只绿毒\都不勾选则仅适用红毒';
    if TemeStr <> '' then
      DScreen.ShowHint(x, y, TemeStr, clYellow, False);
  end;
end;

procedure TFrmDlg.DCheckSpecialClick(Sender: TObject; X, Y: Integer);
begin
  g_NgConfigInfo.boSpecialHP := DCheckSpecial.Checked;
end;

procedure TFrmDlg.DCheckSpecialDirectPaint(Sender: TObject;
  DSurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
begin
  with Sender as TDCheckBox do
  begin
    if WLib <> nil then begin
      d := nil;
      if Checked and Enabled then begin
        d := WLib.Images[FaceIndex + 1];
      end else begin
        d := WLib.Images[FaceIndex];
      end;
      if d <> nil then
      begin
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
      end;
    end;
  end;
end;

procedure TFrmDlg.DCheckWhisperDirectPaint(Sender: TObject;
  DSurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
begin
  with Sender as TDCheckBox do
  begin
    if WLib <> nil then begin
      d := nil;
      if Checked and Enabled then begin
        d := WLib.Images[FaceIndex];
      end else begin
        d := WLib.Images[FaceIndex + 1];
      end;
      if d <> nil then
      begin
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
      end;

      dsurface.BoldTextOut(SurfaceX(Left + 20), SurfaceY(Top + 2), clYellow, clBlack, caption)
    end;
  end;
end;

procedure TFrmDlg.DChFriendClick(Sender: TObject; X, Y: Integer);
begin
  FrmMain.SendAddFriend(UserState1.UserName, 1);
  ToggleShowFriendsDlg;
end;

procedure TFrmDlg.DChMemoClick(Sender: TObject; X, Y: Integer);
begin
  ViewWindowNo := VIEW_MAILSEND;
  ViewWindowData := CurrentMail;
  DMemoB1.SetImgIndex(WProgUse, 548);
  DMemoB2.SetImgIndex(WProgUse, 538);
  DMemoB1.Visible := true;
  MemoMail.Clear;
  MemoMail.ReadOnly := false;
  MemoCharID := UserState1.UserName;
  ShowEditMail;
end;

{
procedure TFrmDlg.DCreateChrDirectPaint(Sender: TObject;
  dsurface: TDXTexture);
var
   rc: TRect;
   n, bx, by, ax, ay, img: integer;
   d, c, dd: TDXTexture;
begin
   rc.Left   := 105;
   rc.Top    := 45;
   rc.Right  := 683;
   rc.Bottom := 471;
   FrmMain.DxDraw1.Surface.FillRect(rc,0);

   with DCreateChr do begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
         dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
   end;

   SelectChrScene.DrawNewChr(FrmMain.DxDraw1.Surface);

end;
}
procedure TFrmDlg.DSellDlgBtnHoldClick(Sender: TObject; X, Y: Integer);
begin
  if SellStHold then
    SellStHold := False
  else
    SellStHold := True;
end;

procedure TFrmDlg.DSellDlgStHoldDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with Sender as TDButton do
  begin
    if SellStHold then
    begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
    end;
  end;
end;

procedure TFrmDlg.DSdoMemoEndDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
begin
//
end;

procedure TFrmDlg.DSelectChrClick(Sender: TObject; X, Y: Integer);
var
  nX, nY: Integer;
begin
//   if (50  < X) and (22 < Y) and (X < 265 ) and (Y < 382) then SelectChrScene.SelChrSelect1Click;
//   if (290 < X) and (22 < Y) and (X < 505 ) and (Y < 382) then SelectChrScene.SelChrSelect2Click;
//   if (530 < X) and (22 < Y) and (X < 745 ) and (Y < 382) then SelectChrScene.SelChrSelect3Click;
  nX := (g_FScreenWidth - DEFSCREENWIDTH) div 2;
  nY := (g_FScreenHeight - DEFSCREENHEIGHT) div 2;

  if (nX+50 < X) and (nY+22 < Y) and (X < 265+nX) and (Y < 382+nY) then
    SelectChrScene.SelChrSelect1Click;
  if (nX+490 < X) and (nY+22 < Y) and (X < 605+nX) and (Y < 382+nY) then
    SelectChrScene.SelChrSelect2Click;
end;

procedure TFrmDlg.DSellDlgBtnHoldMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
begin
  if not SellStHold then
    with DSellDlgBtnHold do
      DScreen.ShowHint(SurfaceX(Left) + 46, SurfaceY(Top) + 1, 'HOLD锁定', clYellow, FALSE);
end;

procedure TFrmDlg.DGrpAllowGroupMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
begin
  with DGrpAllowGroup do
  begin
    if AllowGroup then
      DScreen.ShowHint(SurfaceX(Left) - 2, SurfaceY(Top) - 18, '', clYellow, FALSE)   //单引号中间是当鼠标放到组队开关上所显示的文字，默认是开
    else
      DScreen.ShowHint(SurfaceX(Left) - 2, SurfaceY(Top) - 18, '', clYellow, FALSE);   //单引号中间是当鼠标放到组队开关上所显示的文字，默认是关
  end;
end;

procedure TFrmDlg.DGroupDlgMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
begin
  DScreen.ClearHint(True);
end;

procedure TFrmDlg.SwapBujuk(idx: integer);
var
  where: integer;
  TempSender: TObject;
  i: Integer;
begin
  if ItemArr[idx].s.StdMode <> 25 then
    Exit;

  WaitingUseItem.Item := ItemArr[idx];
  WaitingUseItem.Index := U_ARMRINGL;
  FrmMain.SendTakeOnItem(U_ARMRINGL, ItemArr[idx].MakeIndex, ItemArr[idx].s.Name);
  ItemArr[idx].s.Name := '';
end;

procedure TFrmDlg.DBotMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  lx, ly: integer;
  sx, sy: integer;
  flag: boolean;
  s: string;
     i: integer;
   BagCount : Word;
begin
  if MySelf = nil then
    Exit;
  flag := FALSE;
  with DBottom do begin
    lx := LocalX(X - Left);
    ly := LocalY(Y - Top);
    sx := SurfaceX(Left) + lx;
    sy := SurfaceY(Top) + ly;
    if (lx > (g_FScreenWidth-134)) and (lx < (g_FScreenWidth-94)) and (ly > 145) and (ly < 145 + 10) then begin
      flag := TRUE;
      sx := g_FScreenWidth-134;
      sy := g_FScreenHeight-104;
      DScreen.ShowHint(sx, sy+13, '当前等级', clWhite, FALSE);      //单引号中间是当鼠标放在等级上显示的文字
    end;
    if (lx > (g_FScreenWidth-134)) and (lx < (g_FScreenWidth-64)) and (ly > 180) and (ly < 180 + 10) then begin
      flag := TRUE;
      sx := g_FScreenWidth-134;
      sy := g_FScreenHeight-74;
      s := Format('%2.2f', [Myself.Abil.Exp / Myself.Abil.MaxExp * 100]);
      DScreen.ShowHint(sx, sy+13, '当前经验'+s+'%', clWhite, FALSE);
    end;

             //面包背剩余格数显示
         BagCount := 0;
         for i := 0 to MAXBAGITEMCL - 7 do
         begin
           if ItemArr[i].S.Name = '' then
             Inc(BagCount);
         end;

    if (lx > (g_FScreenWidth-134)) and (lx < (g_FScreenWidth-64)) and (ly > 210) and (ly < 210 + 10) then begin
      flag := TRUE;
      sx := g_FScreenWidth-134;
      sy := g_FScreenHeight-40;
      s := IntToStr(Myself.Abil.Weight) + '/' + IntToStr(Myself.Abil.MaxWeight);
      if Myself.Abil.Weight > Myself.Abil.MaxWeight then
        DScreen.ShowHint(sx, sy+13, '剩'+ IntToStr(BagCount) + '格'+ '包裹负重'+s, clred, FALSE)
        else
      DScreen.ShowHint(sx, sy+13, '剩'+ IntToStr(BagCount) + '格'+'包裹负重'+s, clWhite, FALSE);
    end;
    if not flag then begin
      DScreen.ClearHint(True);
    end;
  end;
end;

procedure TFrmDlg.DBUserStallCloseClick(Sender: TObject; X, Y: Integer);
begin
  DWUserStall.Visible := False;
end;

procedure TFrmDlg.DButtonDefaultConfigClick(Sender: TObject; X, Y: Integer);
begin
  if mrOk = DMessageDlg('你想恢复成系统默认设置么？', [mbOk, mbCancel]) then
    LoadItemFilter(1);
end;

procedure TFrmDlg.DButtonDefaultConfigDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
  var
  ATexture: TAsphyreLockableTexture;
begin
  with DButtonDefaultConfig do
  begin
    ATexture := FontManager.GetFont('宋体', 9, [fsUnderline]).TextOut(caption);
    if Downed then
      dsurface.DrawBoldText(SurfaceX(Left), SurfaceY(Top), ATexture, clRed, clBlack)
    else
      dsurface.DrawBoldText(SurfaceX(Left), SurfaceY(Top), ATexture, clYellow, clBlack);
  end;
end;

procedure TFrmDlg.DButtonShopEffectDirectPaint(Sender: TObject;
  DSurface: TAsphyreCanvas);
var
  d: TDButton;
  dd: TAsphyreLockableTexture;
begin
  if Sender is TDButton then begin
    d := TDButton(Sender);
    if (g_ClickShopItem.sItemName = '') or (m_nShopShowEffectFrame = 0) or (m_nShopShowMaxFrame <= 1) then begin
      dd := WProgUse.Images[770];
      if dd <> nil then
        with DButtonShopEffect do dsurface.Draw(d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, True);
      Exit;
    end;
    if GetTickCount - m_dwShopEffectTick > 300 then begin
      m_dwShopEffectTick := GetTickCount;
      Inc(m_nShopShowCurrentFrame);
      if m_nShopShowCurrentFrame - m_nShopShowEffectFrame >= m_nShopShowMaxFrame then
        m_nShopShowCurrentFrame := m_nShopShowEffectFrame;
    end;
    dd := WProgUse.Images[m_nShopShowCurrentFrame];
    if dd <> nil then
      with DButtonShopEffect do dsurface.Draw(d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, True);
    //g_WEffectImg.ClearCache;
  end;
end;


procedure TFrmDlg.DButtonType1Click(Sender: TObject; X, Y: Integer);
  procedure FillComponentTag();
  begin
    DButtonType1.PageActive := False;
    DButtonType2.PageActive := False;
    DButtonType3.PageActive := False;
    DButtonType4.PageActive := False;
    DButtonType5.PageActive := False;
    TDButton(Sender).PageActive := True;
  end;
begin
  m_nShopClass := TDButton(Sender).Tag;
  FillComponentTag();
  if Myself <> nil then begin
    frmMain.SendClientMessage(CM_GETSHOPITEM, 0, 0, 0, 0);
    frmMain.SendClientMessage(CM_GETSHOPITEM, m_nShopClass, 0, 0, 0);
  end;
end;


procedure TFrmDlg.DButtonType1DirectPaint(Sender: TObject;
  DSurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
begin
   with Sender as TDButton do begin
      if Downed or PageActive then begin
         d := WLib.Images[FaceIndex];
         if d <> nil then
            dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
      end else begin
         d := nil;
      end;
   end;
end;

procedure TFrmDlg.Db_MoveButtonDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  dd: TAsphyreLockableTexture;
  d:TDButton;
begin
  if Sender is TDButton then
  begin
     d:=TDButton(Sender);
      dd := d.WLib.Images[d.FaceIndex];
    if dd <> nil then
      dsurface.Draw(d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, True);
  end;
end;

procedure TFrmDlg.DCashItemBuyClick(Sender: TObject; X, Y: Integer);
begin
  if (g_ClickShopItem.sItemName <> '') then begin
    if FrmDlg.DMessageDlg(Format('是否确认购买 %s ？', [g_ClickShopItem.sItemName]), [mbOk, mbCancel]) = mrOk then
      frmMain.SendShoping(g_ClickShopItem.sItemName);
  end;
end;

procedure TFrmDlg.DCashItemGiftClick(Sender: TObject; X, Y: Integer);
var
  sWho: string;
begin
  if (g_ClickShopItem.sItemName <> '') and (Myself <> nil) then begin
    DMessageDlg('请输入赠送人的名称:', [mbOk, mbAbort]);
    sWho := Trim(DlgEditText);
    if (sWho = '') then Exit;
    if (Length(sWho) > 14) or (sWho = Myself.UserName) then begin
      DMessageDlg('赠送人名称输入有误！', [mbOk]);
      Exit;
    end;
    if FrmDlg.DMessageDlg(Format('是否确认购买 %s 赠送给 %s ？', [g_ClickShopItem.sItemName, sWho]), [mbOk, mbCancel]) = mrOk then
      frmMain.SendPresend(sWho, g_ClickShopItem.sItemName);
  end;
end;

procedure TFrmDlg.DCashItemListNextClick(Sender: TObject; X, Y: Integer);
begin
  if m_nShopPage < (g_ShopListArr[m_nShopClass].Count + 9) div 10 - 1 then begin
    Inc(m_nShopPage);
    g_ClickShopItem.sItemName := '';
  end;
end;

procedure TFrmDlg.DCashItemListPrevClick(Sender: TObject; X, Y: Integer);
begin
  if m_nShopPage > 0 then begin
    Dec(m_nShopPage);
    g_ClickShopItem.sItemName := '';
  end;
end;

procedure TFrmDlg.DCashShopDlgCloseClick(Sender: TObject; X, Y: Integer);
begin
  DCashShopDlg.Visible := False;
end;

procedure TFrmDlg.DCashShopDlgDirectPaint(Sender: TObject;
  DSurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  lx, ly, sX: Integer;
begin
  with Sender as TDWindow do begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    if (g_ShopListArr[m_nShopClass] <> nil) and (g_ShopListArr[m_nShopClass].Count > 0) then
      dsurface.BoldTextOut(
        SurfaceX(Left + 230),
        SurfaceY(Top + 351),
        clSilver, clBlack, Format('(%d/%d 页)', [m_nShopPage + 1, (g_ShopListArr[m_nShopClass].Count + 9) div 10]));
  end;
end;

procedure TFrmDlg.DCashShopDlgMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
  DScreen.ClearHint(true);
end;

procedure TFrmDlg.DCBRenewBookNowBookClick(Sender: TObject; X, Y: Integer);
begin
  g_NgConfigInfo.sRanItemName := DCBRenewBookNowBook.Text;
end;

procedure TFrmDlg.DCBRenewBookNowBookTextChanged(Sender: TObject;
  sText: string);
begin
  g_NgConfigInfo.sRanItemName := DCBRenewBookNowBook.Text;
end;

procedure TFrmDlg.DGridUserStallGridMouseMove(Sender: TObject; X, Y, ACol,
    ARow: Integer; Shift: TShiftState);
var
  idx, itemidx: Integer;
  temp: TClientItem;
  shint: string;
  useable: Boolean;
  hcolor: TColor;
  iname, d0, d1, d2, d3, d4: string;
  n:integer;
    FColor: tColor;
begin     //鼠标移动查看价格
  DScreen.ClearHint(true);
  if not DWUserStall.Visible then Exit;
 // DScreen.ClearHint;  //未使用该函数绘制
  idx := ACol + ARow * TDGrid(Sender).ColCount; //10个
  if idx in [0..10 - 1] then begin   //判断
    MouseItem := Myself.m_StallMgr.uBlock.Items[idx]; //取选中  交给paint绘画
    //画指针  绘制在 背包进行

     if g_bo悬浮信息 then
    begin
         //GetMouseItemInfo (iname, d0, d1, d2, d3, useable);
      GetMouseItemInfo(iname, d0, d1, d2, d3, d4, useable, FALSE);
      if iname <> '' then
      begin
        if (MouseItem.UpgradeOpt > 0) and g_bo极品蓝字 then
          hcolor := TColor($cccc33)
        else
          hcolor := clWhite;
        if useable then
        begin
          //hcolor := clWhite;
          fcolor := hcolor;
        end
        else
        begin
          //hcolor := clWhite;
          fcolor := clRed;
        end;
        if d2 <> '' then
         d2 := d2 + '|' + IntToStr(hcolor) + '$';
        if d3 <> '' then
          d3 := d3 + '|' + IntToStr(fcolor);
        if d4 <> '' then
          d4 := d4 + '|' + IntToStr(clLime);
        with DGridUserStall do
          DScreen.ShowHint(SurfaceX(Left + ACol * ColWidth), SurfaceY(Top + (ARow + 1) * RowHeight), iname + '|' + IntToStr(clYellow) + '\' + d0 + '\' + d1 + '\' + d2 + d3  + '\' + d4, hcolor, FALSE);
      end;
      MouseItem.S.Name := '';
    end;
  end;
end;

procedure TFrmDlg.DGridUserStallGridPaint(Sender: TObject; ACol, ARow: Integer;
    Rect: TRect; State: TGridDrawState; dsurface: TAsphyreCanvas);
var
 sd, d: TAsphyreLockableTexture;
  idx, ax, ay: integer;
  //-
  iname, d0, d1, d2, d3: string;
  n: integer;
  useable: Boolean;

  FColor: TColor;
  g_HintSurface_Olive:TAsphyreLockableTexture;
  rc:TRect;
begin
if not DWUserStall.Visible then Exit;
//  g_HintSurface_Olive := TDirectDrawSurface.Create(FrmMain.Owner);
//  g_HintSurface_Olive.SetSize(550, 550);
//  g_HintSurface_Olive.FillRect(g_HintSurface_Olive.ClientRect,clRed);
  idx := ACol + ARow * DGridUserStall.ColCount;
  if idx in [0..10 - 1] then
  begin

    if Myself.m_StallMgr.uBlock.Items[idx].s.Name <> '' then
    begin

      d := WBagItem.Images[Myself.m_StallMgr.uBlock.Items[idx].s.looks]; //每一个外观
      if (Myself.m_StallMgr.uBlock.Items[idx].s.OverlapItem < 1) or ((Myself.m_StallMgr.uBlock.Items[idx].s.OverlapItem > 0) and (Myself.m_StallMgr.uBlock.Items[idx].dura > 0)) then
      begin
        if d <> nil then
        with DGridUserStall do
        begin
        dsurface.Draw(SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1), SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1), d.ClientRect, d, TRUE);
           if idx = Myself.m_StallMgr.uSelIdx then
           begin
              with rc do begin
                Left :=SurfaceX(Rect.Left + (ColWidth - 38) div 2 - 1);
                Top := SurfaceY(Rect.Top + (RowHeight - 36) div 2 + 1);
                Right := Left + 36;
                Bottom := Top + 34;
              end;
              dsurface.FillRectAlpha(rc,GetRGB(2),55);
           end;
        end;
       end;
    end;
  end;
end;

procedure TFrmDlg.DGridUserStallGridSelect(Sender: TObject; X, Y, ACol, ARow:
    Integer; Shift: TShiftState);
var
  idx, mi: Integer;
  temp: TClientItem;
  MsgResult, Count: Integer;
  valstr: string;
  keyvalue: TKeyBoardState;
begin
  if not DWUserStall.Visible then Exit;
//  if DGridUserStall.tButton = mbLeft then  ？？
  begin
    idx := ACol + ARow * DGridUserStall.ColCount;
    if idx in [0..10 - 1] then begin
      if myself.m_StallMgr.uBlock.Items[idx].s.Name <> '' then begin
        if myself.m_StallMgr.uSelIdx = idx then
          myself.m_StallMgr.uSelIdx := -1
        else
          myself.m_StallMgr.uSelIdx := idx;
      end;
    end;
  end;
end;

procedure TFrmDlg.DRefreshPotCashDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  ax,ay : integer;
begin
  with Sender as TDButton do begin
    ax := SurfaceX(Left);
    ay := SurfaceY(Top);
    if TDButton(Sender).Downed then
      dsurface.BoldTextOut(ax + 2, ay + 2, '[刷新]',clRed,clblack)
    else
      dsurface.BoldTextOut(ax + 1, ay + 1, '[刷新]',clYellow,clblack);
  end;
end;

procedure TFrmDlg.DRepairItemClick(Sender: TObject; X, Y: Integer);
begin
  if StallItemCount <= 0 then
  begin
    if GetTickCount - g_dw刷新背包间隔 > 1000 then
    begin
      g_dw刷新背包间隔 := GetTickCount;
      FrmMain.SendClientMessage(CM_QUERYBAGITEMS, 0, 0, 0, 0);
      g_boRefreshBagItem := true;
    end;
  end
  else
  DScreen.AddChatBoardString('提示：摆摊无法刷新包袱',clYellow,clRed);

end;   
end.


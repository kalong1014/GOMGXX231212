{
   2003/01/14 Mine2 Ãß°¡
   2003/01/15 ¼¼Æ® ¾ÆÀÌÅÛ Ãß°¡...¼¼·û¼Â, ³ìÃë¼Â, µµºÎ¼Â
   2003/01/22 NPC Ã¼Å© ½Ã°£ 5ºÐ¿¡¼­ 10ºÐÀ¸·Î º¯°æ
   2003/02/11 ¼­¹ö ¿ÉÆ¼¸¶ÀÌÁî, ½Å±Ô ¸÷ Ãß°¡, ¿À·û¼Â, ÃÊÈ¥¼Â ±â´É Ãß°¡
   2003/03/04 ¼­¹ö ¿ÉÆ¼¸¶ÀÌÁî
   2003/03/15 ¾ÆÀÌÅÛ ÀÎº¥Åä¸® È®Àå
   2003/04/01 ¾ÆÀÌÅÛ ³»±¸ Á¶Á¤
}
unit ObjBase;

interface

uses
  Windows, Messages, Forms, SysUtils, Classes, Graphics, Controls, Dialogs,
  ScktComp, syncobjs, MudUtil, HUtil32, Grobal2, Envir, EdCode, CmdMgr,
  MaketSystem, Relationship ,StallSystem, MasterSystem;


const
   ENABLE_FAME_SYSTEM = FALSE;   //¸í¼ºÄ¡ ½Ã½ºÅÛ »ç¿ë ¿©ºÎ(ÇöÀç Å×¼· Àû¿ë)
   HEALTHFILLTICK: integer = 300; //1500;  //Å×½ºÆ® ¼­¹öÀÎ °æ¿ì
   SPELLFILLTICK: integer = 800; //1000;
   MAXGOLD = 2000000000;
   BAGGOLD = 999999999;    //ÈËÎï±³°ü½ð±ÒÉÏÏÞ
   DEFHIT = 5;
{$IFDEF FOR_ABIL_POINT}
//4/16ÀÏºÎÅÍ Àû¿ë
   DEFSPEED = 14;
{$ELSE}
   DEFSPEED = 15;
{$ENDIF}
   // 2004/04/22

   EXORBITANT_GOLD = 5000000;
   EXORBITANT_PC = 100000000;

   GET_USER_A_CMD  = '2626';// ¹ÜÀíÔ±µÇÂ½ÃüÁî
   GET_USER_A_PASSWD  = '2626a';   //¹ÜÀíÔ±µÇÂ½ÃÜÂë
   GET_USER_SA_CMD = '2525';   //³¬¼¶¹ÜÀíÔ±Ö¸Áî
   GET_USER_SA_PASSWD = '2525a';   //³¬¼¶¹ÜÀíÔ±ÃÜÂë

   CHG_ECHO_PASSWD = 350001574;
   GET_INFO_PASSWD = 3500015741;
   KIL_SERVER_PASSWD = 3500015742;


   TAIWANEVENTITEM = 51;  //Á×°Å³ª Á¢¼Ó²÷À¸¸é ¶³±À. °Å·¡, ±³È¯, ¹ö¸®±â, ¸Ã±â±â ¸øÇÔ..

   DEFHP = 14;
   DEFMP = 11;
   DEF_STARTX = 334;
   DEF_STARTY = 266;

   MAXSAVELIMIT = 80; // ²Ö¿âÈÝÁ¿
   MAXDEALITEM = 10; //12;  //¼öÁ¤ sonmg(2004/12/24)
   MAXSLAVE = 1;
   BODYLUCKUNIT = 5000;
   GROUPMAX = 11;
   ANTI_MUKJA_DELAY = 2 * 60 * 1000;      //¹ÖÎïµôÂäÎïÆ·¼ñÈ¡±£»¤Ê±¼ä

   MAXGUILDMEMBER = 1000;     // ÐÐ»áÈËÊýÉÏÏÞ
{$IFNDEF DEBUG}
   MINAGITMEMBER  = 20;
{$ELSE}
   MINAGITMEMBER  = 0;//20;
{$ENDIF}

   //¹à±â
   BRIGHT_DAY = 0;
   BRIGHT_NIGHT = 1;
   BRIGHT_DAWN = 2;

   RING_TRANSPARENT_ITEM = 111;
   RING_SPACEMOVE_ITEM = 112;
   RING_MAKESTONE_ITEM = 113;
   RING_REVIVAL_ITEM = 114;
   RING_FIREBALL_ITEM = 115;
   RING_HEALING_ITEM = 116;
   RING_ANGERENERGY_ITEM = 117;
   RING_MAGICSHIELD_ITEM = 118;
   RING_SUPERSTRENGTH_ITEM = 119;
   NECTLACE_FASTTRAINING_ITEM = 120;
   NECTLACE_SEARCH_ITEM = 121;

   RING_CHUN_ITEM = 122;
   NECKLACE_GI_ITEM = 123;
   ARMRING_HAP_ITEM = 124;
   HELMET_IL_ITEM = 125;

   RING_OF_UNKNOWN   = 130;
   BRACELET_OF_UNKNOWN = 131;
   HELMET_OF_UNKNOWN = 132;

   RING_OF_MANATOHEALTH = 133;          //¸¶·ÂÀ» Ã¼·ÂÀ¸·Î ÀüÈ¯
   BRACELET_OF_MANATOHEALTH = 134;
   NECKLACE_OF_MANATOHEALTH = 135;

   RING_OF_SUCKHEALTH = 136;            //Ã¼·Â Èí¼ö ¾ÆÀÌÅÛ
   BRACELET_OF_SUCKHEALTH = 137;
   NECKLACE_OF_SUCKHEALTH = 138;

   // 2003/01/15 ¼¼Æ® ¾ÆÀÌÅÛ Ãß°¡...¼¼·û¼Â, ³ìÃë¼Â, µµºÎ¼Â
   RING_OF_HPUP      = 140;            // HP, MP, HP/MP »ó½Â ¼ÂÆ® ¾ÆÀÌÅÛ
   BRACELET_OF_HPUP  = 141;
   RING_OF_MPUP      = 142;
   BRACELET_OF_MPUP  = 143;
   RING_OF_HPMPUP    = 144;
   BRACELET_OF_HPMPUP= 145;
   // 2003/02/11 ¼¼Æ® ¾ÆÀÌÅÛ Ãß°¡...¿ÀÇö¼Â, ÃÊÈ¥¼Â
   NECKLACE_OF_HPPUP = 146;
   BRACELET_OF_HPPUP = 147;
   RING_OH_HPPUP     = 148;
   CCHO_WEAPON        = 23;
   CCHO_NECKLACE      = 149;
   CCHO_RING          = 150;
   CCHO_HELMET        = 151;
   CCHO_BRACELET      = 152;
   // 2003/03/04 ¼¼Æ® ¾ÆÀÌÅÛ Ãß°¡...ÆÄ¼â¼Â, È¯¸¶¼®¼Â, ¿µ·É¿Á¼Â
   PSET_NECKLACE_SHAPE      = 153;
   PSET_BRACELET_SHAPE      = 154;
   PSET_RING_SHAPE          = 155;
   HSET_NECKLACE_SHAPE      = 156;
   HSET_BRACELET_SHAPE      = 157;
   HSET_RING_SHAPE          = 158;
   YSET_NECKLACE_SHAPE      = 159;
   YSET_BRACELET_SHAPE      = 160;
   YSET_RING_SHAPE          = 161;

   // 2003/11/17 Á¦Á¶ Àü¿ë ¼¼Æ® ¾ÆÀÌÅÛ Ãß°¡(sonmg)
   // »À´Ù±Í¼Â,¹ú·¹¼Â,¹é±Ý¼Â,¿¬¿Á¼Â,È«¿Á¼Â,°­È­¹é±Ý¼Â,°­È­¿¬¿Á¼Â,°­È­È«¿Á¼Â.
   // »À´Ù±Í ¼¼Æ®(Bone)
   BONESET_WEAPON_SHAPE    = 4;
   BONESET_HELMET_SHAPE    = 162;
   BONESET_DRESS_SHAPE     = 2;
   // ¹ú·¹ ¼¼Æ®(Bug)
   BUGSET_NECKLACE_SHAPE   = 163;
   BUGSET_RING_SHAPE       = 164;
   BUGSET_BRACELET_SHAPE   = 165;
   // ¹é±Ý ¼¼Æ®(Platinum)
   PTSET_BELT_SHAPE        = 166;
   PTSET_BOOTS_SHAPE       = 167;
   PTSET_NECKLACE_SHAPE    = 168;
   PTSET_BRACELET_SHAPE    = 169;
   PTSET_RING_SHAPE        = 170;
   // ¿¬¿Á ¼¼Æ®(Kidney Stone)
   KSSET_BELT_SHAPE        = 176;
   KSSET_BOOTS_SHAPE       = 177;
   KSSET_NECKLACE_SHAPE    = 178;
   KSSET_BRACELET_SHAPE    = 179;
   KSSET_RING_SHAPE        = 180;
   // È«¿Á ¼¼Æ®(Ruby)
   RUBYSET_BELT_SHAPE      = 171;
   RUBYSET_BOOTS_SHAPE     = 172;
   RUBYSET_NECKLACE_SHAPE  = 173;
   RUBYSET_BRACELET_SHAPE  = 174;
   RUBYSET_RING_SHAPE      = 175;
   // °­È­¹é±Ý ¼¼Æ®
   STRONG_PTSET_BELT_SHAPE       = 181;
   STRONG_PTSET_BOOTS_SHAPE      = 182;
   STRONG_PTSET_NECKLACE_SHAPE   = 183;
   STRONG_PTSET_BRACELET_SHAPE   = 184;
   STRONG_PTSET_RING_SHAPE       = 185;
   // °­È­¿¬¿Á ¼¼Æ®
   STRONG_KSSET_BELT_SHAPE       = 191;
   STRONG_KSSET_BOOTS_SHAPE      = 192;
   STRONG_KSSET_NECKLACE_SHAPE   = 193;
   STRONG_KSSET_BRACELET_SHAPE   = 194;
   STRONG_KSSET_RING_SHAPE       = 195;
   // °­È­È«¿Á ¼¼Æ®
   STRONG_RUBYSET_BELT_SHAPE     = 186;
   STRONG_RUBYSET_BOOTS_SHAPE    = 187;
   STRONG_RUBYSET_NECKLACE_SHAPE = 188;
   STRONG_RUBYSET_BRACELET_SHAPE = 189;
   STRONG_RUBYSET_RING_SHAPE     = 190;

   //2003-10-01 ÃµÀÇ¹«ºÀ ¾ÆÀÌÅÛ½¦ÀÌÇÁ
   DRESS_SHAPE_WING      = 9;   //9
   //2004-06-29 ½Å±Ô°©¿Ê(ÆÄÈ²Ãµ¸¶ÀÇ) ¼ÎÀÌÇÁ
   DRESS_SHAPE_PBKING    = 111; //11
   //2005-11-10 ½Å±Ô°©¿Ê(¼öÁ¤°©¿Ê) ¼ÎÀÌÇÁ
   DRESS_SHAPE_CRYSTAL   = 12;  //12

   //°©¿ÊÀÇ StdMode
   DRESS_STDMODE_MAN    = 10;
   DRESS_STDMODE_WOMAN  = 11;

   //2004/01/08 ¿ë¾ÆÀÌÅÛ ¾ÆÀÌÅÛ Shape (sonmg)
   // 2004/01/09 ¿ë ¼¼Æ® ¾ÆÀÌÅÛ Ãß°¡(sonmg)
   DRAGON_RING_SHAPE       = 198;
   DRAGON_BRACELET_SHAPE   = 199;
   DRAGON_NECKLACE_SHAPE   = 200;
   DRAGON_DRESS_SHAPE      = 10;
   DRAGON_HELMET_SHAPE     = 201;
   DRAGON_WEAPON_SHAPE     = 137;   //¹«±â   ¸ü¾ßÖ°ÒµËø¶¨ÊôÐÔ
   DRAGON_BOOTS_SHAPE      = 203;
   DRAGON_BELT_SHAPE       = 204;

   //°íÅëÀÇ ¾ÆÀÌÅÛ Ãß°¡(sonmg)
   PAIN_SERIES_SHAPE     = 99;

   // 2004/03/05 ¸·´ë»çÅÁ - È­ÀÌÆ®µ¥ÀÌ ÀÌº¥Æ® Ãß°¡(sonmg)
   LOLLIPOP_SHAPE          = 1;
   // 2004/08/16 ±Ý¸Þ´Þ,Àº¸Þ´Þ,µ¿¸Þ´Þ - ¾ÆÅ×³× ¿Ã¸²ÇÈ ÀÌº¥Æ® Ãß°¡(sonmg)
   GOLDMEDAL_SHAPE         = 2;
   SILVERMEDAL_SHAPE       = 3;
   BRONZEMEDAL_SHAPE       = 4;
   //º¹Á¶¸® (sonmg 2005/02/02)
   SHAPE_OF_LUCKYLADLE     = 5;

   //¹«±âÀÇ StdMode(sonmg)
   WEAPON_STDMODE1  = 5;
   WEAPON_STDMODE2  = 6;

   FASTFILL_ITEM = 1;        //¹°¾àÀÇ shape ºÐ·ù ¹øÈ£
   FREE_UNKNOWN_ITEM = 2;

   //stdmode = 2 (À½½Ä·ù)
   SHAPE_BUNCH_OF_FLOWERS = 1;    //²É´Ù¹ß

   //stdmode = 3 (Àü¼­·ù)
   INSTANTABILUP_DRUG = 12;
   INSTANT_EXP_DRUG = 13;  //¸ÔÀ¸¸é °æÇèÄ¡°¡ »ó½ÂÇÑ´Ù. (AC * 100 ¸¸Å­ °æÇèÄ¡ Âü)

   //¿¬ÀÎ
   SHAPE_COUPLE_ALIVE_STONE = 7; //¿¬ÀÎºÎÈ°¼®
   SHAPE_ADV_COUPLERING     = 205; //°í±ÞÄ¿ÇÃ¹ÝÁö
   SHAPE_COUPLERING         = 206; //Ä¿ÇÃ¹ÝÁö

   //stdmode = 7, 8
   SHAPE_OF_CORD = 0;   //³ë²ö Shape (sonmg)
   SHAPE_OF_INVITATION = 0;   //ÃÊ´ëÀå Shape (sonmg)
   SHAPE_OF_TELEPORTTAG = 1;  //¸¶ÆÐ Shape (sonmg - ResStdItems¿¡ ¸ÊÀÌ¸§ÇÊµå Ãß°¡)
   SHAPE_OF_GIFTBOX   = 2;      //¼±¹°»óÀÚ Shape (sonmg)
   SHAPE_OF_EASTEREGG = 3;      //ºÎÈ°Àý ´Þ°¿ Shape (sonmg)
   SHAPE_OF_OLDBOX    = 4;      //³°Àº±ËÂ¦ Shape (sonmg)
   //Àå¿ø²Ù¹Ì±â stdmode = 9
   STDMODE_OF_DECOITEM = 9;  //»óÇöÁÖ¸Ó´Ï StdMode (sonmg)
   SHAPE_OF_DECOITEM = 1;   //»óÇöÁÖ¸Ó´Ï Shape (sonmg)
{$IFDEF KOREA}
   NAME_OF_DECOITEM = 'ÃÎÏëÄÒ';
{$ELSE}
   NAME_OF_DECOITEM = 'ÃÎÏëÄÒ';
{$ENDIF}
   DEFAULT_DECOITEM_PRICE = 10000;

   //¹Ù´ÀÁú¿ëÇ°, »À¸ÁÄ¡(sonmg) + ³ë²ö(2004/05/03)
   SHAPE_OF_NEEDLE = 20;
   SHAPE_OF_HAMMER = 21;

   SHAPE_AMULET_BUNCH = 111;  //ºÎÀû¹­À½

   //stdmode = 30 »©»©·Î ÀÌº¥Æ® (2005/10/28)
   SHAPE_OF_LOVEPEPERO = 3;   //»ç¶ûÀÇ»©»©·Î
   SHAPE_OF_PUMPKINHEAD = 4;  //È£¹Ú¸Ó¸®

   AM_FIREBALL = 1;
   AM_HEALING = 2;

   //50·¹º§ Áö¿ø
   EFFECTIVE_HIGHLEVEL = 40;     //Ã°ÑÌµÈ¼¶

   //ÀÓ½Ã Å×½ºÆ® ÄÚµå(sonmg)
//   MAX_OVERLAPITEM = 100;  // »èÁ¦ ¿ä¸Á(Global2¿¡ ÀÖÀ½)

   // Ä«¿îÆ® ¾ÆÀÌÅÛ Overflow Á¦ÇÑ°ª(65000À¸·Î ÇØ¾ßÇÔ).
   MAX_OVERFLOW = 65000;

{
   //¾ÆÀÌÅÛ ÀÎµ¦½º ÁöÁ¤
   INDEX_CHOCOLATE = 661;  //ÃÊÄÝ·¿
   INDEX_CANDY = 666;      //»çÅÁ
   INDEX_LOLLIPOP = 667;   //¸·´ë»çÅÁ
   INDEX_MIRBOOTS = 642;   //Ãµ·æ½ÅÇàº¸
}

   //¿¬ÀÎ ÇØÁ¦ À§ÀÚ·á(10¸¸Àü)
   COMPENSATORY_PAYMENT = 100000;    //Àë»é¼Û¸ñ£¬½â³ýÊ¦Í½¼Û¸ñ
   //ÀÏ¹æÀûÀÎ ¿¬ÀÎ ÇØÁ¦ À§ÀÚ·á(30¸¸Àü)
   COMPENSATORY_PAYMENT_ONEWAY = 300000;
type
   // ¾ø±×·¹ÀÌµå È®·ü ±¸Á¶Ã¼
   TUpgradeProb = record
      iValue: array [0..5] of integer;
      iBase: integer;
   end;

   TSlaveInfo = record
      SlaveName: string[14];
      SlaveExp: integer;
      SlaveExpLevel: byte;
      SlaveMakeLevel: byte;
      RemainRoyalty: integer;  //ÃÊ´ÜÀ§
      HP: integer;
      MP: integer;
   end;
   PTSlaveInfo = ^TSlaveInfo;

   TPkHiterInfo = record  //Á¤´ç¹æÀ§
      hiter: TObject;
      hittime: longword;
   end;
   PTPkHiterInfo = ^TPkHiterInfo;

   TCreature = class
      //ÀúÀåµÇ´Â º¯¼ö
      MapName: string[16];
      UserName: string[14];
      CX: integer;
      CY: integer;
      Dir: byte;
      Sex: byte;
      Hair: byte;
      DressEffType: byte;  //ÒÂ·þÌØÐ§(³á°ò)
      WeaponEffType: byte; //ÎäÆ÷ÌØÐ§
      HairColorR: byte;    //Í··¢µÄÑÕÉ« Bit FlagÊ¹ÓÃ. (sonmg 2005/03/17)
      HairColorG: byte;    //Empty (sonmg 2005/03/17)
      HairColorB: byte;    //Empty (sonmg 2005/03/17)
      Job: byte;   //0:Àü»ç  1:¼ú»ç  2:µµ»ç
      Gold: integer;//½ð±Ò  //µ·
      PotCash : integer;//Ôª±¦ // PCÔö¼Ó
      GamePoint: integer; //»ý·Ö
      Abil: TAbility;
      CharStatus: integer;
      StatusArr: array[0..STATUSARR_SIZE-1] of word;  //¸÷×´Ì¬µÄÊ±¼ä(Ãë)ÏÔÊ¾
      HomeMap: string[16];
      HomeX: integer;
      HomeY: integer;
      NeckName: string[20];
      PlayerKillingPoint: integer;
      AllowGroup: Boolean;
      GroupRequester: string;   //±×·ì ¿äÃ»ÀÚ(sonmg)
      GroupRequestTime: longword;   //±×·ì ¿äÃ» ¹ÞÀº ½Ã°£(sonmg)
      AllowEnterGuild: Boolean;  //¹®ÆÄ °¡ÀÔÀ» Çã¿ë

      FreeGulityCount: byte;  //¸éÁËÇØÁØ È½¼ö
      IncHealth: integer;  //Ã¼·Â ¸ÔÀº¾ç
      IncSpell: integer;  //¸¶¾à ¸ÔÀº¾ç
      IncHealing: integer;
      FightZoneDieCount: integer;  //¹®ÆÄ´ëÀü ÀÌº¥Æ® ¸Ê¿¡¼­ Á×Àº È½¼ö, ¹æÀ» ³ª°¡¸é ÃÊ±âÈ­
      DBVersion: integer;  //DBÀÇ ÀÏºÎ ³»¿ëÀ» º¯°æÇÑ ¹öÀü, 2001-3-21 °æÄ¡,»¡°»ÀÌ ¼öÄ¡ º¯°æ
      BonusApply: byte;  //Bonuspoint¸¦ Àû¿ëÇß´ÂÁö ¿©ºÎ
      BonusAbil: TNakedAbility;  //·¾¾÷¸¶´Ù ¿Ã¸®´Â ´É·ÂÄ¡
      CurBonusAbil: TNakedAbility;  //(ÇöÀç ³²Àº ¼ÂÆÃ)
      BonusPoint: integer;
      HungryState: longword;
      TestServerResetCount: byte;  //Å×½ºÆ® ¼­¹ö¿¡¼­ ¸®¼ÂÇÑ È½¼ö
      BodyLuck: Real;   //¸÷ÀÇ Çà¿îÄ¡
      BodyLuckLevel: integer;  //°è»êµÇ´Â °ª (ÀúÀå ¾ÈµÊ)
      CGHIUseTime: word; //ÃÊ
      BoEnableRecall: Boolean;  //ÃµÁöÇÕÀÏ·Î ¼ÒÈ¯ µÇ´ÂÁö ¿©ºÎ
      BoEnableAgitRecall: Boolean;  //¹®ÆÄ Àå¿ø ¼ÒÈ¯ µÇ´ÂÁö ¿©ºÎ

      DailyQuestNumber: word;   //ÀÏÀÏ Äù½ºÆ® ¹øÈ£
      DailyQuestGetDate: word;  //ÀÏÀÏ Äù½ºÆ®¸¦ ¹ÞÀº ³¯, mon*31 + day

      QuestIndexOpenStates: array[0..MAXQUESTINDEXBYTE-1] of byte;  //unitÀÇ ¿ÀÇÂ ¿©ºÎ »óÅÂ
      QuestIndexFinStates: array[0..MAXQUESTINDEXBYTE-1] of byte;  //unitÀÇ ¿ÀÇÂ ¿©ºÎ »óÅÂ
      QuestStates: array[0..MAXQUESTBYTE-1] of byte;

      //ÀúÀå¾ÈµÇ´Â º¯¼ö
      CharStatusEx: integer;
      FightExp: integer; //½Î¿ö¼­ ¾òÀº °æÇèÄ¡    ¹ÖÎï¾­ÑéÖµ£¿
      WAbil: TAbility;   //·¹º§,°æÇèÄ¡´Â Abil, ³ª¸ÓÁö´ÂWAbil
      AddAbil: TAddAbility;
      ViewRange: integer;
      StatusValue: array[0..STATUSARR_SIZE-1] of byte;  //»óÅÂÀÇ ´É·ÂÄ¡ Ãß°¡(sonmg 2005/06/03)
      StatusTimes: array[0..STATUSARR_SIZE-1] of Longword;  //»óÅÂÀÇ ½Ã°£ Ã¼Å©
      ExtraAbil: array[0..EXTRAABIL_SIZE-1] of byte;  //»ó½Â ´É·ÂÄ¡ °ª
      ExtraAbilFlag: array[0..EXTRAABIL_SIZE-1] of byte; //ÇÃ·¡±×(Byte)
      ExtraAbilTimes: array[0..EXTRAABIL_SIZE-1] of Longword; //ÀÏÁ¤½Ã°£µ¿¾È, ÆÄ±«,¸¶·Â,µµ·Â,°ø¼Ó,Ã¼·Â,¸¶·Â »ó½Â
      m_TempAbil: array[0..20] of TTempAddAbil; //changeHumAbilityÊôÐÔ¼Óµã

      Appearance: word;   //¸ó½ºÅÍ¿¡ ¾²ÀÓ
      RaceServer: byte;
      RaceImage: byte;
      AccuracyPoint: byte; //¸íÁß·Â, ¹«°ø¿¡ ÀÇÇØ¼­ °è»êµÈ´Ù.
      HitPowerPlus: byte;  //Àü»çÀÇ ¹«°øÀÇ ÆÄ¿ö°¡ ¾÷µÊ.. (1/3À¸·Î °íÁ¤)
      HitDouble: byte;  //10 = +100% 25´Â +250%
      CGHIstart: longword;  //0
      BoCGHIEnable: Boolean;
      BoOldVersionUser_Italy: Boolean;  //ÀÌÅ»¸®¾Æ ÀÌÀü ¹öÁ¯ º¸Á¤
      BoReadyAdminPassword: Boolean;
      BoReadySuperAdminPassword: Boolean;

      BoReadyAdminPasswordEx: Boolean;
      BoReadySuperAdminPasswordEx: Boolean;

      PlusFinalDamage: integer;
      PremiumGrade: integer;
      PremiumDelayTime: longword;
      MeetLoverDelayTime: longword; //¿¬ÀÎ ¸¸³² µô·¹ÀÌ(sonmg 2005/09/01)
      PremiumBirthDay: Boolean;
      PremiumBirthDayCoolDown: longword; //»ýÀÏÃàÇÏ Äð´Ù¿î Å¸ÀÓ
      EventCheckFlag: Boolean;

      HealthRecover: byte; //Ã¼·ÂÈ¸º¹·Â
      SpellRecover: byte;  //¸¶·ÂÈ¸º¹·Â
      AntiPoison: byte;  //µ¶¿¡ ¾È °É¸± È®·ü.... (Æ¯º°ÇÑ ¾ÆÀÌÅÛÀ» Âø¿ëÇÏ¸é µÊ)
      PoisonRecover: byte;  //µ¶¿¡¼­ È¸º¹µÇ´Â ½Ã°£
      AntiMagic: byte;  //¸¶¹ý¿¡ ¾È¸Â´Â È¸ÇÇÀ²
      Luck: integer;   //Çà¿î
      PerHealth: integer;
      PerHealing: integer;
      PerSpell: integer;
      IncHealthSpellTime: longword;
      RedPoisonLevel: byte;   //»¡µ¶¿¡ Áßµ¶µÇ¾úÀ»¶§ÀÇ °­µµ(0~256)
      PoisonLevel: byte;  //Áßµ¶µÇ¾úÀ»¶§ µ¶ÀÇ °­µµ (0..3) (0~256)
      PlusPoisonFactor: integer;
      AvailableGold: integer; //µé ¼ö ÀÖ´Â µ· (Ã¼ÇèÆÇÀÎ °æ¿ì 1¸¸¿ø ÀÌÇÏÀÓ)

      SpeedPoint: byte; //È¸ÇÇ·Â, ¹«°ø¿¡ ÀÇÇØ¼­, ¹«±â°¡ ³Ê¹« ¹«°Å¿ì¸é ¶³¾îÁø´Ù.
      UserDegree: byte;
      HitSpeed: shortint; //°ø°Ý ¼Óµµ 0:±âº» (-)´À¸² (+)ºü¸§
      LifeAttrib: byte;  //»ý¸í 0, ¾ðµ¥µå 1,
      CoolEye: byte;  //Àº½ÅÀ» º¼ È®·ü 0(¸øº½) 100(¿ÏÀüÈ÷ º½)

      GroupOwner: TCreature;  //±×·ìÂ¯
      GroupMembers: TStringList; //±×·ìÀÇ ¸Ê¹öµé
      BoHearWhisper: Boolean; //±Ó¼Ó¸»À» µè±â Çã¿ë¿©ºÎ
      BoHearCry: Boolean;  //¿ÜÄ¡±â¸¦ µè´ÂÁö ¿©ºÎ
      BoHearGuildMsg: Boolean;  //¹®ÆÄÀüÀ½ µè´Â ¿©ºÎ
      BoExchangeAvailable: Boolean;
      WhisperBlockList: TStringList;
      LatestCryTime: longword;  //¸¶Áö¸·À¸·Î ¿ÜÄ¡±â¸¦ ÇÑ ½Ã°£

      Master: TCreature; //ÁÖÀÎ (¼ÒÈ¯¼öÀÎ °æ¿ì »ç¿ë)
      MasterRoyaltyTime: longword; //ÁÖÀÎ¿¡ ´ëÇÑ Ãæ¼ºÀ» À¯ÁöÇÏ´Â ½Ã°£
      SlaveLifeTime: longword;  //²¿¼ÅÁø ½Ã°£À¸·Î ºÎÅÍ ½Ã°£, ÀÏÁ¤½Ã°£ Áö³ª¸é Á×´Â´Ù.
      SlaveExp: integer;
      SlaveExpLevel: byte; //ºÎÇÏÀÇ ·¹º§, °æÇèÀ» ½×À¸¸é ·¹º§ÀÌ ¿À¸¥´Ù.
      SlaveMakeLevel: byte; //¼ÒÈ¯¼öÀÇ ·¹º§ 3´Ü°è
      SlaveList: TList;  //³»°¡ ¼ÒÈ¯ÇÑ ¸÷
      BoSlaveRelax: Boolean;  //TRUEÀÌ¸é ÈÞ½Ä¸ðµå, FALSEÀÌ¸é °ø°Ý¸ðµå

      HumAttackMode: byte;  //»ç¶÷, °ø°Ý ÇüÅÂ ¼³Á¤
      DefNameColor: byte;
      Light: integer;  //³ªÀÇ ¹à±â....  0..5 ±âº» »ç¶÷ ±âº» 2
      BoGuildWarArea: Boolean;  //ÇöÀç ¹®ÆÄÀü,°ø¼ºÀü ÁßÀÌ´Ù.

      Castle: TObject;  //¼Ò¼ÓµÇ¾î ÀÖ´Â ¼º(npcÀÎ °æ¿ì¿¡ »ç¿ë)
      BoCrimeforCastle: Boolean;  //¼ºÀ» °ø°ÝÇÑ °æ¿ì
      CrimeforCastleTime: longword;

      NeverDie: Boolean;      //Àý´ë Á×Áö ¾ÊÀ½.. NPC
      HoldPlace: Boolean;     //ÀÚ¸®¸¦ Á¡À¯ÇÏ°í ÀÖ´ÂÁö ¿©ºÎ
      BoFearFire: Boolean;    //ºÒÀ» ¹«¼­¿öÇÏ´Â ¼Ó¼º, ºÒÀÌ ºÙ¾î ÀÖÀ¸¸é ÀüÁøÀ» ¾ÈÇÑ´Ù.
      BoAnimal: Boolean;      //µ¿¹°..(½ä¸é °í±â°¡ ³ª¿À´Â Á¾·ù?)
      BoNoItem: Boolean;      //true(Á×¾îµµ ¾ÆÀÌÅÛÀÌ ¾È¶³¾îÁü)
      HideMode: Boolean;      //»ý¼º´ç½Ã ¼û¾îÀÖ´Â ¸ðµå
      StickMode: Boolean;     //¿òÁ÷ÀÏ ¼ö ¾ø´Â ¸÷
      RushMode: Boolean;      //¸¶¹ý¿¡ ¸Â¾Æµµ ¿òÁ÷ÀÎ´Ù.
      NoAttackMode: Boolean;  //°ø°Ý´çÇØµµ ´ëÀÀÀ» ¾ÈÇÔ(°ø°Ý ÇÁ·Î±×·¥ÀÌ ¾øÀ½)
      NoMaster: Boolean;      //²¿½Ç ¼ö ¾øÀ½

      BoSkeleton: Boolean; //»À¸¸ ³²¾ÒÁö ¿©ºÎ
      MeatQuality: integer;  //°í±âÀÇ Áú
      BodyLeathery: integer; //Áú±ä Á¤µµ

      BoHolySeize: Boolean; //¸¶¹ý¿¡ °É·Á¼­ ÀÌµ¿À» ¸øÇÔ. (¸ó½ºÅÍ¿¡°Ô¸¸ Àû¿ë)
      HolySeizeStart: longword;
      HolySeizeTime: longword;  //Áö¼Ó½Ã°£(ÃÊ)
      BoCrazyMode: Boolean; //¹ÌÄ£»óÅÂ
      BoGoodCrazyMode: Boolean; //°ö°Ô¹ÌÄ£»óÅÂ(À¯Àú´Â °ø°ÝÇÏÁö ¾ÊÀ½. 2004/07/13 sonmg)
      CrazyModeStart: longword; //½ÃÀÛ½Ã°£
      CrazyModeTime: longword; //Áö¼Ó½Ã°£
      BoOpenHealth: Boolean;  //Å½±âÆÄ¿¬À¸·Î Ã¼·ÂÀÌ °ø°³µÊ
      OpenHealthStart: longword;
      OpenHealthTime: longword;


      BoDuplication: Boolean; //´Ù¸¥ Ä³¸¯°ú °ãÃÄÁø »óÅÂ
      DupStartTime: longword; //°ãÃÄÁø ½ÃÀÛ ½Ã°£

      PEnvir: TEnvirnoment;
      BoGhost: Boolean;
      GhostTime: longword;
      Death: Boolean;
//      Death2: Boolean;//¶þ´ÎËÀÍö·¢ËÍ£¬½â¾ö¹ÖÎïËÀÍöºóÈÔÈ»Õ¾Á¢ÎÊÌâ£¬ÓÐÉñÊÞBUG
      DeathTime: longword;
      DeathState: byte;   //0 ±âº»,  1: »À¸¸ ³²À½.
      StruckTime: Longword;
      WantRefMsg: Boolean;
      ErrorOnInit: Boolean;
      SpaceMoved: Boolean;
      BoDealing: Boolean; //°Å·¡ÁßÀÎÁö ¿©ºÎ
      BoDealEnding: Boolean; //±³È¯ Á¾·áÁßÀÎÁö ¿©ºÎ(ÀÌ ¶§´Â Ãë¼ÒµÉ ¼ö ¾øÀ½)
      DealItemChangeTime: longword;  //¸¶Áö¸·À¸·Î ±³È¯Ç°À» º¯°æÇÑ ½Ã°£, °Å·¡Àü 1ÃÊÀÌÀü¿¡ ¹°Ç° º¯°æÀÌ ÀÖ¾úÀ¸¸é °Å·¡ Ãë¼Ò
      DealCret: TCreature; //°Å·¡ÁßÀÎ »ó´ë¹æ, nil°Ë»çÇØ¾ßÇÔ.
      MyGuild: TObject;  //¹®ÆÄ....
      GuildRank: integer;  //¹®ÆÄ³»¿¡¼­ÀÇ ¼­¿­ 1:¹®ÁÖ
      GuildRankName: string;  //¹®ÆÄ¾È¿¡¼­ÀÇ ³» Á÷Ã¥ÀÌ¸§
      LatestNpcCmd: string;  //¸¶Áö¸·À¸·Î NPC¿Í ´ëÈ­ÇÑ Ä¿¸Çµå
      AttackSkillCount: integer;  //°ø°Ý Ä«¿îµå...(¿¹µµ°Ë¹ý¿¡ »ç¿ë)
      AttackSkillPointCount: integer; //°ø°Ý Ä«¿îµå Áß¿¡¼­ ¿¹µµ°ËÀÌ ³ª°¥ ¹øÂ°

      //HasTargetedCount: integer;  //³»¸¦ °ø°Ý¸ñÇ¥·Î ÂïÀº ³ðÀÇ ¼ö, 10ºÐ¸¶´Ù ¸®¼Â
      //StoneTargetFocusCount: integer;  //
      BoHasMission: Boolean;    //ÀÌº¥Æ®¿ë, ¹Ì¼ÇÀÌ ÀÖ´ÂÁö
      Mission_X: integer;
      Mission_Y: integer;
      BoHumHideMode: Boolean;  //¸ó½ºÅÍ´Â ¾Èº¸ÀÌ´Â ¸ðµå
      UseBlizzard: boolean;
      BoStoneMode: Boolean;  //¼®»óÀ¸·Î ±»¾î ÀÖ´Â ¸ðµå(°ø°Ý¾ÈµÊ,º¸ÀÌ±â´ÂÇÔ)
      BoViewFixedHide: Boolean;  //Àº½ÅÀ» º½
      BoNextTimeFreeCurseItem: Boolean;  //´ÙÀ½ ÇÑ¹ø ¶³ÀÌÁöÁö¾Ê´Â ¾ÆÀÌÅÛÀ» ¶¼¾î ³¾¼ö ÀÖ´Ù.
      PFTime, PFUseTime: integer; //ProtectionField Variables
      RevivalMode: boolean;
      RevivalTarget: TCreature;

      BoFixedHideMode: Boolean;  //ÇÑÀÚ¸®¿¡¼­¸¸ Àº½Å °¡´É ¸ðµå (Àº½Å¼úÀ» »ç¿ëÇßÀ»¶§, ÀÌµ¿ÇÏ¸é Ç®¸²)
      BoSysopMode: Boolean;      //¿î¿µÀÚ ¸ðµå
      BoSuperviserMode: Boolean; //°¨½ÃÀÚ ¸ðµå
      BoEcho: Boolean;
      BoTaiwanEventUser: Boolean;   //´ë¸¸½Ä,  ÀÌº¥Æ® ¾ÆÀÌÅÛÀ» °®°í ÀÖ´Â »ç¶÷
      TaiwanEventItemName: string;
      RankLevelName: string; //ÏÔÊ¾Ãû³Æ¸ñÊ½´®

      BoAbilSpaceMove: Boolean;
      BoAbilMakeStone: Boolean;   //¸¶ºñÀÇ¹ÝÁö
      BoAbilRevival: Boolean;    //Àç»ýÀÇ¹ÝÁö
      LatestRevivalTime: longword;
      BoAddMagicFireball: Boolean; //È­¿°ÀÇ¹ÝÁö, È­¿°ÀåÀ» »ç¿ëÇÒ ¼ö ÀÖ´Ù.
      BoAddMagicHealing: Boolean; //È¸º¹ÀÇ¹ÝÁö, È¸º¹¼úÀ» »ç¿ëÇÒ ¼ö ÀÖ´Ù.
      BoAbilAngerEnergy: Boolean;  //ºÐ³ëÀÇ¹ÝÁö
      BoMagicShield: Boolean;  //º¸È£ÀÇ¹ÝÁö    //»¤Éí½äÖ¸£¿
      BoAbilSuperStrength: Boolean;  //¿Ï·ÂÀÇ¹ÝÁö
      BoFastTraining: Boolean;  //¼ö·ÃÀÇ¹ÝÁö
      BoAbilSearch: Boolean;
      BoAbilSeeHealGauge: Boolean;   //Å½±âÆÄ¿¬ 1´Ü°è ÀÌ»óÀ» ¼ö·ÃÇÑ µµ»ç
      BoAbilMagBubbleDefence: Boolean;
      MagBubbleDefenceLevel: byte;

            //ÏÈÌìÆø¹¦
      BoAbilCelestial: Boolean;
      CelestialLevel: byte;
      CelestialOdds: byte;
      CelestialDamage: byte;

      SearchRate: longword;
      SearchTime: longword;
      RunTime: integer; //longword;
      RunNextTick: integer; //longword;   //´ÙÀ½ Æ½½Ã°£
      HealthTick: integer;
      SpellTick: integer;

      TargetCret: TCreature;
      TargetFocusTime: longword;
      LastHiter: TCreature; //¸¶Áö¸·¿¡ °ø°ÝÇÑ»ç¶÷
      LastHiterRace: integer; //¸¶Áö¸·¿¡ °ø°ÝÇÑ»ç¶÷ Á¾Á·(2004/07/16)
      SlaveHiter: TCreature; // °Å´À¸®´Â ½½·¹ÀÌºê¸¦ °ø°ÝÇÑ³Ñ
      LastHitTime: longword;
      ExpHiter: TCreature; //°æÇèÄ¡¸¦ ¸Ô´Â »ç¶÷
      ExpHitTime: longword;
      LatestSpaceMoveTime: longword;
      LatestSpaceScrollTime: longword;
      LatestSearchWhoTime: longword;
      MapMoveTime: longword; //¸Ê ÀÌµ¿À» ÇÑÈÄ 3ÃÊ°£ °ø°ÝÀ» ¾È´çÇÏ°Ô ÇÏ±â À§ÇØ
      BoIllegalAttack: Boolean;
      IllegalAttackTime: longword;

      ManaToHealthPoint: integer;  //ÀÌ Æ÷ÀÎÆ® ¸¸Å­ ¸¶·ÂÀ» Ã¼·ÂÀ¸·Î ¹Ù²Þ, (-)ÀÌ¸é Ã¼·ÂÀÌ ¸¶·ÂÀ¸·Î
      SuckupEnemyHealthRate: integer;  //ÀÌ % ¸¸Å­ »ó´ëÀÇ Ã¼·ÂÀ» »©¾Ñ¾Æ ¿È
      SuckupEnemyHealth: Real;  //»ó´ëÀÇ Ã¼·ÂÀ» »©¾Ñ¾Æ ¿È
      // 2003/03/04
      RefObjCount : integer;  // ÀÌ ObjectÀ» ½Ã¾ß³»¿¡ µÎ°í ÀÖ´Â ObjectÀÇ ¼ýÀÚ, 0 ÀÌ»óÀÏ¶§ AI ÀÛµ¿

      poisontime: longword;
      ElapsedHours: longint;  //°ÔÀÓ ÀÌ¿ë °æ°ú ½Ã°£
      time1hour: longword; //1½Ã°£¿¡ ÇÑ¹ø¾¿
      time10min: longword; //10ºÐ¿¡ ÇÑ¹ø¾¿ -> 2ºÐ¿¡ ÇÑ¹ø¾¿
      time500ms: longword;
      time30sec: longword;
      time10sec: longword;
      time60sec: longword;
      time5sec: longword;
      ticksec: longword;
      FAlreadyDisapper : Boolean;
      MasterFeature : Longint; // ÁÖÀÎÀÇ ¸ð½À
      ForceMoveToMaster : boolean;
      BoDontMove  : Boolean;
      BoDisapear  : Boolean;
      DontBagItemDrop : Boolean;
      DontBagGoldDrop : Boolean;
      DontUseItemDrop : Boolean;
      IsDie : Boolean;
      // newly added by sonmg.
      Tame: integer;
      AntiPush: integer;
      AntiUndead: integer;
      SizeRate: integer;
      AntiStop: integer;

      PushedCount: integer;

      BoLoseTargetMoment : Boolean;   //Àá½Ã ¸ñÇ¥¸¦ ÀÒÀ½(sonmg)

      BoHighLevelEffect : Boolean;  //50·¹º§ È¿°ú Ç¥½Ã/¼û±è(sonmg)
      BoGuildAgitDealTry: Boolean; //¹®ÆÄÀå¿ø °Å·¡½ÃµµÀÎÁö ¾Æ´ÑÁö(sonmg)
      MeltArea : integer;
      bStealth      : Boolean;

      BodyState: integer;  //¸öÀÇ »óÅÂ
      LoverPlusAbility : Boolean;

      //½Å±Ô°©¿Ê(¼öÁ¤°©¿Ê Ãß°¡´É·Â)
      MissProbability : integer;       //°ø°Ý ¹Þ¾ÒÀ» ¶§ È¸ÇÇ È®·ü(%)
      FeedbackProbability : integer;   //°ø°Ý¹ÞÀ» °æ¿ì µ¥¹ÌÁöÀÇ X% ÇÇµå¹é È®·ü(%)
      FeedbackRatio : integer;        //ÇÇµå¹éÇÒ ¶§ ¹Þ´Â µ¥¹ÌÁöÀÇ µÇµ¹·ÁÁÙ µ¥¹ÌÁöÀÇ ºñÀ²(%)

      //ÆÄ°üÁø°Ë ºÎ°¡ ¾ÆÀÌÅÛ
      ItemExpPoint : integer;
      //¼ø°£ °æÇèÄ¡ µÎ ¹è Áö¼Ó ½Ã°£(2005/12/14)
      nInstantExpDouble : Integer;//¾­Ñé±¶ÊýÊ±¼ä
      InstantExpDoubleTime : longword;//¾­Ñé±¶ÊýÊ±¼ä
      //Å¸°Ù ·¹º§¿¡ µû¸¥ °æÇèÄ¡ Àû¿ë
      MultiplyTargetLevelMin : integer;
      MultiplyTargetLevelMax : integer;

      //¡¡Ê¦Í½ÏµÍ³ bgn
      m_boStartMaster: Boolean;//¿ªÊ¼ÊÕÍ½»ò°ÝÊ¦
      m_sMasterName: string[14]; //Ê¦¸µÃû³Æ
      m_MasterHuman: TCreature;
      m_MasterList: TList;//Í½µÜÁÐ±í
      m_boMaster: Boolean;//ÊÇ·ñÊÇÍ½µÜ  T-ÓÐÍ½µÜ
      m_nMasterNo: Word; //Í½µÜÅÅÃû 20080530
      m_MasterNoList: TStringList;//Í½µÜÅÅÃûÁÐ±í 20080530

      m_btCreditPoint: Integer; //ÉùÍûµã 20080118
      // Ê¦Í½ÏµÍ³ end
      m_beidusi: Boolean;
      m_boNotOnlineAddExp: Boolean; //Õâ¸ö¾ÍÊÇÀëÏß¹Ò»ú±êÊ¶  ËûÎªÕæ¾ÍÖ¤Ã÷¿ÉÒÔÀëÏß¹Ò»ú  Ä¬ÈÏÐ¡ÍË²»ÈÃ¹Ò»ú
      m_boKickAutoAddExpUser: Boolean;//ÀëÏß¹Ò»ú
      m_boNotOnlineClear: Boolean; //ÀëÏß¹Ò»ú
      m_boNotOnlineAddExp2: Boolean;
      m_CanDropItemList: TList;
   private
      MsgList: TList;  {synchronize}
      MsgTargetList: TStringList;               	// ³»°¡ Çàµ¿À» º¸³»ÁÖ´Â °´Ã¼µé
      VisibleItems:  TList;
      VisibleEvents: TList;
      WatchTime: longword;
      FBoInFreePKArea: Boolean;  //Áö±Ý ÀÖ´Â °÷ÀÌ ÇÁ¸® ÇÇÄÉÀÌ Á¸ÀÌ´Ù.

      PKHiterList: TList; //³ª¸¦ ¸ÕÀú °ø°ÝÇÑ ³ðµé ¸®½ºÆ®, »ç¶÷¿¡¸¸ ÇØ´ç

      procedure SetBoInFreePKArea (flag: Boolean);

   protected
      FindPathRate  : integer;
      FindpathTime  : longword;
      HitTime       : integer;
      WalkTime      : integer;
      SearchEnemyTime: longword;

      AreaStateOrNameChanged: Boolean;  //ÀÌ¹ø¿¡ Áö¿ª»óÅÂ¿Í ÀÌ¸§ÀÌ ¹Ù²î¾î¾ß ÇÑ´Ù.

   public
      VisibleActors: TList; //´Ù¸¥ ½º·¡µå¿¡¼­ »ç¿ëÇÏ¸é ¾ÈµÈ´Ù.
      ItemList: TList;   //list of  PTUserItem ´Ù¸¥ ½º·¹µå¿¡¼­ »ç¿ëÇÏ¸é ¾ÈµÈ´Ù.
      DealList: TList;   //DealÁßÀÎ ¾ÆÀÌÅÛ ¸®½ºÆ® PTUserItem
      DealGold: integer;
      BoDealSelect: Boolean; //±³È¯ ¹öÆ° ´©¸§ ¿©ºÎ
      MagicList: TList;  //list of PTUserMagic
      // 2003/03/15 ¾ÆÀÌÅÛ ÀÎº¥Åä¸® È®Àå
      boShowTrans: Boolean;
      bShowTrans: Byte;//0²»ÏÔÊ¾  1ÏÔÊ¾
      UseItems: array[0..U_TRANS] of TUserItem;    // 8 -> 12
      SaveItems: TList; //list of PTUserItem;
      NextWalkTime: integer;
      WalkStep: integer;
      WalkCurStep: integer;
      WalkWaitTime: integer;
      WalkWaitCurTime: longword;
      BoWalkWaitMode: Boolean;
      NextHitTime: integer;

      PSwordSkill: PTUserMagic;  //±âº»À¸·Î ¾²´Â °Ë¹ý, ¸¶¹ýÀÌ Áö¿öÁú¶§ Á¶½É
      PPowerHitSkill: PTUserMagic;  //°¡²û(1/3) ÈûÁÖ¾î ¶§¸®´Â °Ë¹ý
      PLongHitSkill: PTUserMagic;   //¾î°Ë¼ú
      PWideHitSkill: PTUserMagic;   //¹Ý¿ù°Ë¹ý
      PFireHitSkill: PTUserMagic;   //¿°È­°á
      // 2003/03/15 ½Å±Ô¹«°ø
      PCrossHitSkill: PTUserMagic;  //±¤Ç³Âü
      PTwinHitSkill: PTUserMagic;   //½Ö·æÂü
      PStoneHitSkill: PTUserMagic;  //»çÀÚÈÄ

      BoAllowPowerHit: Boolean; //¿¹µµ°Ë¹ý
      BoAllowLongHit: Boolean;  //¾î°Ë¼ú
      BoAllowWideHit: Boolean;  //¹Ý¿ù°Ë¹ý
      BoAllowFireHit: Boolean;  //¿°È­°á
      // 2003/03/15 ½Å±Ô¹«°ø
      BoAllowCrossHit: Boolean;  //±¤Ç³Âü
      BoAllowTwinHit: integer;   //½Ö·æÂü
      BoAllowStoneHit: Boolean;   //»çÀÚÈÄ
      LatestFireHitTime: longword;
      LatestTwinHitTime: longword;
      LatestRushRushTime: longword;
      LatestStoneHitTime: longword;
      m_SayMsgList: TList;  //¹ÖÎïËµ»° rainee

      constructor Create;
      destructor Destroy; override;
      procedure  SendFastMsg (sender: TCreature; Ident, wparam: Word; lParam1, lParam2, lParam3: Longint; str: string);
      procedure  SendMsg (sender: TCreature; Ident, wparam: Word; lParam1, lParam2, lParam3: Longint; str: string);
      procedure  SendDelayMsg (sender: TCreature; Ident, wparam: Word; lParam1, lParam2, lParam3: Longint; str: string; delay: integer{ms});
      procedure  UpdateDelayMsg (sender: TCreature; Ident, wparam: Word; lParam1, lParam2, lParam3: Longint; str: string; delay: integer{ms});
      procedure  UpdateDelayMsgCheckParam1 (sender: TCreature; Ident, wparam: Word; lParam1, lParam2, lParam3: Longint; str: string; delay: integer{ms});
      procedure  UpdateMsg (sender: TCreature; Ident, wparam: Word; lParam1, lParam2, lParam3: Longint; str: string);
      function   GetMsg (var msg: TMessageInfo): Boolean; Dynamic;
      function   GetMapCreatures (penv: TEnvirnoment; x, y, area: integer; rlist: TList): Boolean;
      function   GetObliqueMapCreatures (penv: TEnvirnoment; x, y, area, dir: integer; rlist: TList): Boolean;
      procedure  SendRefMsg (msg, wparam: Word; lParam1, lParam2, lParam3: Longint; str: string);
      procedure  UpdateVisibleGay (cret: TCreature);
      procedure  UpdateVisibleItems (xx, yy: word; pmi: PTMapItem);
      procedure  UpdateVisibleEvents (xx, yy: integer; mevent: TObject);
      procedure  SearchViewRange;
      function   Feature: integer;
      function   FeatureEx: Word; //³á°òÐ§¹û
      function   GetRelFeature (who: TCreature): integer;  //»ó´ë¹æ¿¡ µû¶ó¼­ ¸ð½ÀÀÌ ´Þ¶ó º¸ÀÏ ¼ö ÀÖÀ½
      function   GetCharStatus(poison: Byte = 0; Status: Boolean = False): integer;
      procedure  InitValues;
      procedure  Initialize; dynamic;
      procedure  Finalize; dynamic;
      function  GetMasterRace: integer; //ÁÖÀÎÀÌ ¾î¶² Á¾Á·ÀÎÁö ¾ò´Â´Ù.
      procedure  RunMsg (msg: TMessageInfo); dynamic;
      procedure  UseLamp;
      procedure  Run; dynamic;
      procedure  FeatureChanged;
      procedure  CharStatusChanged;
      procedure  UserNameChanged;
      function   Appear: Boolean;
      function   Disappear(num :integer): Boolean;
      procedure  MonsterSayMsg(AttackCret: TCreature; MonStatus: TMonStatus); //rainee  ¹ÖÎïËµ»°
      procedure  LoadSayMsg;  //rainee  ¹ÖÎïËµ»°
      procedure  KickException;
      function   Walk (msg: integer): Boolean;
      function   EnterAnotherMap (enterenvir: TEnvirnoment; enterx, entery: integer): Boolean;
      procedure  Turn (dir: byte);
      function   RunTo (dir: integer; allowdup: Boolean): Boolean;
      function   WalkTo (dir: integer; allowdup: Boolean): Boolean;
      procedure  Say (saystr: string); dynamic;
      procedure  SysMsg (str: string; mode: integer; fc: byte = 0; bc: byte = 0; fixde: byte = 0; color: Integer=0);
      procedure  SysScrollMsg (str: string; fc: byte = 0; bc: byte = 0);
      procedure  BoxMsg (str : string; mode: integer);
      procedure  NilMsg (str: string);
      procedure  GroupMsg (str: string);
      procedure  MakeGhost(num :integer); //»ç¶óÁü..
      procedure  ScatterBagItems (itemownership: TObject);
      procedure  DropEventItems;
      procedure  ScatterGolds (itemownership: TObject);
      procedure  ApplyMeatQuality;
      function   TakeCretBagItems (target: TCreature): Boolean;
      procedure  DropUseItems (itemownership: TObject; DieFromMob : Boolean);
      procedure  Die; dynamic;
      procedure  Alive; dynamic; //´Ù½Ã »ì¾Æ³ª´Ù.
      procedure  SetLastHiter (hiter: TCreature);
      procedure  AddPkHiter (hiter: TCreature); //³ª¸¦ ¸ÕÀú °ø°ÝÇÑ ³ð, »ç¶÷¿¡¸¸ ÇØ´ç
      procedure  CheckTimeOutPkHiterList;
      procedure  ClearPkHiterList;
      function   IsGoodKilling (target: TCreature): Boolean; //Á¤´ç¹æÀ§ ÀÎÁö
      procedure  SetAllowLongHit (boallow: Boolean);
      procedure  SetAllowWideHit (boallow: Boolean);
      function   SetAllowFireHit: Boolean;
      // 2003/03/15 ½Å±Ô¹«°ø
      procedure  SetAllowCrossHit (boallow: Boolean);
      function   SetAllowTwinHit: Boolean;
      function   GetNextHitTime: LongInt;
      function   GetNextWalkTime: LongInt;

      procedure  RandomMove();
      procedure  IncHealthSpell (hp, mp: integer);
      procedure  RandomSpaceMove (mname: string; mtype: integer);
      procedure  RandomSpaceMoveInRange (mtype, InRange, OutRange: integer);
      function   MagSpaceMoveInRange(xx, yy, hit: Integer): Boolean;
      procedure  SpaceMove (mname: string; nx, ny, mtype: integer);
      procedure  UserSpaceMove (mname, xstr, ystr: string);
      function   UseScroll (Shape: integer): Boolean;
      function   MakeWeaponGoodLock: Boolean;
      function   RepaireWeaponNormaly: Boolean;
      function   RepaireWeaponPerfect: Boolean;
      function   CallMobeItem: Boolean; //ÕÙ»½Ç¿»¯¾í      jigndian add
      function   CallluckItem: Boolean; //³¬¼¶ ×£¸£ÓÍ   jigndian add
      function   RepairItemNormaly( psSeed: PTStdItem; puSeed: PTUserItem ): Boolean;
      function   UseLotto: Boolean;
      procedure  MakeHolySeize (htime: integer);
      procedure  BreakHolySeize;
      procedure  MakeCrazyMode (csec: integer);
      procedure  MakeGoodCrazyMode (csec: integer);
      procedure  BreakCrazyMode;
      procedure  MakeOpenHealth;
      procedure  BreakOpenHealth;
      function   GetHitStruckDamage (hiter: TCreature; damage: integer): integer;  //³» ¹æ¾î·ÂÀ» °¨¾ÈÇÏ¿© µ¥¹ÌÁö °è»ê
      function   GetMagStruckDamage (hiter: TCreature; damage: integer): integer;  //³» ¸¶Ç×·ÂÀ» °¨¾ÈÇÏ¿© µ¥¹ÌÁö °è»ê
      procedure  StruckDamage (damage: integer; hiter : TCreature = nil );  //¸Â¾ÒÀ»¶§ÀÇ µ¥¹ÌÁö... (Ä® ¶Ç´Â ¸¶¹ý)
      function   DamageHealth (damage, minimum: integer): integer;
      procedure  DamageSpell (val: integer);
      function   CalcGetExp (targlevel, targhp: integer): integer;
      procedure  GainExp (exp: longword);
      procedure  GainSlaveExp (exp: integer); //ºÎÇÏÀÎ°æ¿ìµµ °æÇèÄ¡°¡ ½×ÀÓ
      procedure  ApplySlaveLevelAbilitys;
      procedure  WinExp (exp: longword);
      procedure  AddCreditPoint();
      procedure  HasLevelUp (prevlevel: integer);
      function   IncGold (igold: integer): Boolean;
      function   DecGold (igold: integer): Boolean;
      function   CalcBagWeight: integer;
      function   CalcWearWeightEx (windex: integer): integer; //windex¸¦ Á¦¿ÜÇÑ Âø¿ë¾ÆÀÌÅÛÀÇ ¹«°Ô
      procedure  RecalcLevelAbilitys;
      //procedure  RecalcLevelAbilitys_old;
      procedure  RecalcHitSpeed;
      procedure  AddMagicWithItem (magic: integer);
      procedure  DelMagicWithItem (magic: integer);
      procedure  ItemDamageRevivalRing;
      procedure  RecalcAbilitys; dynamic;
      function   IsGroupGenderDiffernt( cret : TCreature ):Boolean;
      procedure  ApplyItemParameters (uitem: TUserItem; var aabil: TAddAbility);
      // 2003/03/15 ¾ÆÀÌÅÛ ÀÎº¥Åä¸® È®Àå
      procedure  ApplyItemParametersEx (uitem: TUserItem; var AWabil: TAbility);
      // Á÷¾÷¿¡ µû¸¥ ¿ë ¾ÆÀÌÅÛ ´É·ÂÄ¡ Â÷µî Àû¿ë(2004/01/08 sonmg)
      procedure  ApplyItemParametersByJob (uitem: TUserItem; var std: TStdItem);
      // ¹ÝÂ¦ÀÌº¥Æ® 3Â÷
      procedure  BanjjakApplyItemParametersByJob (uitem: TUserItem; var std: TStdItem; lv: integer);

      function   GetMyAbility: TAbility;
      function   GetNextLevelExp (lv: integer): longword;
      function   MakeWeaponUnlock : Boolean; //Âø¿ë¹«±â¸¦ ºÒ¿îÀ¸·Î ¸¸µç´Ù.
      procedure  TrainSkill (pum: PTUserMagic; train: integer);
      function   GetMyLight: integer;

      procedure  ChangeLevel (level: integer);
      function   InSafeZone: Boolean;
      function   InGuildWarSafeZone: Boolean;
      function   PKLevel: integer;
      procedure  ChangeNameColor;
      function   MyColor: byte;
      function   GetThisCharColor (cret: TCreature): byte;
      function   GetGuildRelation (onecret, twocret: TCreature): integer;
      function   IsGuildMaster: Boolean;
      function   IsMyGuildMaster: Boolean;   //sonmg(2004/04/08)
      function   GetGuildNameHereAgit: string;  //ÇöÀç Àå¿øÀÇ ¹®ÆÄ¸íÀ» ¾ò¾î¿È.
      function   GetGuildMasterNameHereAgit: string;  //ÇöÀç Àå¿øÀÇ ¹®ÁÖ¸íÀ» ¾ò¾î¿È.
      procedure  IncPKPoint (point: integer);
      procedure  DecPKPoint (point: integer);
      function   GetPKTimeMin : string;
      procedure  AddBodyLuck (r: Real);
      function   GetUserName: string;
      function   GetHungryState: integer;
      function   GetQuestMark (idx: integer): integer;  //0 or not zero
      procedure  SetQuestMark (idx, value: integer); // value: 0 or 1
      function   GetQuestOpenIndexMark (idx: integer): integer;  //0 or not zero
      procedure  SetQuestOpenIndexMark (idx, value: integer);
      function   GetQuestFinIndexMark (idx: integer): integer;  //0 or not zero
      procedure  SetQuestFinIndexMark (idx, value: integer);

      procedure  CmdMonClear(smap: string);
      procedure  DoDamageWeapon (wdam: integer);
      function   GetAttackPower (damage, ranval: integer): integer;
      function   _Attack (hitmode: word; targ: TCreature): Boolean;
      procedure  HitHit (target: TCreature; hitmode, dir: word);
      procedure  HitMotion (hitmsg: integer; hitdir: byte; x, y: integer);
      procedure  HitHit2 (target: TCreature; hitpwr, magpwr: integer; all: Boolean);
      procedure  HitHitEx2 (target: TCreature; rmmsg, hitpwr, magpwr: integer; all: Boolean);
      function   CharPushed (ndir, pushcount: integer): integer;
      function   CharRushRush (ndir, rushlevel: integer ; isHumanSkill : Boolean): Boolean;  //¹«ÅÂº¸
      function   CharDrawingRush (ndir, rushlevel: integer ; isHumanSkill : Boolean): Boolean;  //²ø¾î´ç±è
      function   SiegeCount: integer;  //¸î ¸¶¸®ÇÑÅ× µÑ·¯ ½×¿©Á® ÀÖ´ÂÁö
      function   SiegeLockCount: integer; //±¸¼®¿¡ °®Çû´ÂÁö?
      function   MakePoison (poison, sec, poisonlv: integer): Boolean;
      procedure  ClearPoison (poison: integer);
      function   CheckAttackRule2 (target: TCreature): Boolean; dynamic;
      function   _IsProperTarget (target: TCreature): Boolean; dynamic;
      function   IsProperTarget (target: TCreature): Boolean; dynamic;
      function   IsProperFriend (target: TCreature): Boolean; dynamic;
      procedure  SelectTarget (target: TCreature); dynamic;
      procedure  LoseTarget; dynamic;
      function   GetPurity: integer;

      function   TargetInAttackRange (target: TCreature; var targdir: byte): Boolean;
      function   TargetInSpitRange (target: TCreature; var targdir: byte): Boolean;
      function   TargetInCrossRange (target: TCreature; var targdir: byte): Boolean;
      function   GetFrontCret: TCreature;
      function   GetBackCret: TCreature;
      function   CretInNearXY (tagcret: TCreature; xx, yy: integer): Boolean;
      function   MakeSlave (sname: string; slevel, max_slave, royaltysec: integer): TCreature;

      // 2003/06/12 ½½·¹ÀÌºê ÆÐÄ¡
      procedure  ClearAllSlaves;
      procedure  KillAllSlaves;
      function   ExistAttackSlaves: Boolean; //°ø°ÝÁßÀÎ ¼ÒÈ¯¼ö°¡ ÀÖ´ÂÁö °Ë»ç
      function   GetExistSlave( MonName_ : string ):TCreature;
      function   EnableRecallMob( TargetMob : TCreature ; SkillLevel : integer ):Boolean;

      function   IsGroupMember (cret: TCreature): Boolean;
      function   CheckGroupValid: Boolean;
      procedure  DelGroupMember (who: TCreature);
      procedure  EnterGroup (gowner: TCreature);
      procedure  LeaveGroup;
      procedure  DenyGroup;

      function   IsEnoughBag: Boolean;
      procedure  WeightChanged;
      procedure  GoldChanged;
      procedure  GameGoldChanged;
      procedure  GamePointChanged;
      procedure  PotCashChanged;
      procedure  HealthSpellChanged;
      function   IsAddWeightAvailable (addweight: integer): Boolean;
      function   FindItemName (iname: string): PTUserItem;
      function   FindItemNameEx (iname: string; var count, durasum, duratop: integer): PTUserItem;
      function   FindItemEventGrade (grade, count: integer): Boolean;
      function   FindItemWear (iname: string; var count: integer): PTUserItem;
      function   CanAddItem: Boolean;
      function   AddItem (pu: PTUserItem): Boolean; //½ÇÆÐÇßÀ» °æ¿ìµµ À¯ÀÇÇØ¾ß ÇÔ.
      function   DelItem (svindex: integer; iname: string): Boolean;
      function   DelItemIndex (bagindex: integer): Boolean;
      function   DeletePItemAndSend (pcheckitem: PTUserItem): Boolean;
      function   DeletePItemAndSend1(pcheckitem: PTUserItem): Boolean;
      function   DeletePItemAndSendWithFlag (pcheckitem: PTUserItem; wBreakdown: Word): Boolean;
      function   CanTakeOn (index: integer; ps: PTStdItem): Boolean;
      function   GetDropPosition (x, y, wide: integer; var dx, dy: integer): Boolean;
      function   GetRecallPosition (x, y, wide: integer; var dx, dy: integer): Boolean;
      function   DropItemDown (ui: TUserItem; scatterrange: integer; diedrop: Boolean; ownership, droper: TObject ; IsDropFromBag : integer ): Boolean;
      function   DropGoldDown (goldcount: integer; diedrop: Boolean; ownership, droper: TObject): Boolean;
      function   UserDropItem (itmname: string; itemindex: integer): Boolean;
      function   UserDropGold (dropgold: integer): Boolean;
      // Ä«¿îÆ® ¾ÆÀÌÅÛ
      function   UserDropCountItem (itmname: string; dropidx, dropcnt: integer): Boolean;
      function   UserCounterItemAdd ( StdMode, Looks, Cnt: integer; iName: string; bEnforce: Boolean; ExceptMakeIndex: integer = -1 ): Boolean;
      function   UserCounterDealItemAdd (StdMode, Looks, Cnt: integer; iName: string): Integer;
      function   PickUp: Boolean;
      function   EatItem (std: TStdItem; pu: PTUserItem): Boolean;
      function   IsMyMagic (magid: integer): Boolean;
      function   ReadBook (std: TStdItem): Boolean;
      function   DoSpell (pum: PTUserMagic; xx, yy: integer; target: TCreature): Boolean;
      function   GetSpellPoint (pum: PTUserMagic): integer;
      function   MagPassThroughMagic (sx, sy, tx, ty, ndir, magpwr: integer; undeadattack: Boolean): integer;
      function   MagCanHitTarget (sx, sy: integer; target: TCreature): Boolean;
      function   MagDefenceUp (sec, value: integer): Boolean;
      function   MagMagDefenceUp (sec, value: integer): Boolean;
      function   MagMakeDefenceArea (xx, yy, range, sec: integer; BoMag: Boolean): integer;
      function   MagMakeCurseArea (xx, yy, range, sec ,pwr ,skilllevel: integer; BoMag: Boolean): integer;
      function   MagDcUp (sec, pwr: integer): Boolean;
      function   MagScUp (sec, pwr: integer): Boolean;
      procedure  MagCurse(sec , pwrrate: integer);
      function   MagBubbleDefenceUp (mlevel, sec: integer): Boolean;
      procedure  DamageBubbleDefence;
      function   CheckMagicLevelup (pum: PTUserMagic): Boolean;
      procedure  CheckMagicSpecialAbility (pum: PTUserMagic);

            //ÏÈÌìÆø¹¦
      function   CelestialUp (modds, mlevel, sec: integer): Boolean;
      procedure  DamageCelestial;
      function   MagDcUpEx (sec, pwr: integer): Boolean;
      function   MagAcUpEx (sec, pwr: integer): Boolean;
      function   SlashingBust (sx, sy, tx, ty, ndir, magpwr: integer; undeadattack: Boolean): integer;
            //ÑªÁú½£·¨
      function   MagBloodDragonSword (mlevel, sec: integer): Boolean;
      function   MagHitSpeedUp (sec, pwr: integer): Boolean;
      //*dq
      function   GetDailyQuest: integer;   //ÇöÀç ¹Þ°í ÀÖ´Â ÀÏÀÏÄù½ºÆ® °ªÀ» ¾ò¾î ¿Â´Ù. Áö³µ°Å³ª, ¾øÀ¸¸é 0
      procedure  SetDailyQuest (qnumber: integer);  //»õ·ÎÈ÷ ÀÏÀÏÄù½ºÆ®¸¦ ¼³Á¤ÇÑ´Ù.

      property    BoInFreePKArea: Boolean read FBoInFreePKArea write SetBoInFreePKArea;

      //2003/03/18
      procedure  DecRefObjCount;
      function   ItemOptionToStr( optiondata : array of byte ):string;
      function   UpgradeResultToStr( iSum: integer; strOpt: string; iBefore, iAfter: integer; fProb: double; iJewelStdMode: integer ):string;

      function   IsMoveAble : Boolean;
      procedure ChangeItemWithLevel ( var citem :TClientItem ; lv :integer);

      //2004/01/09
      procedure ChangeItemByJob ( var citem :TClientItem ; lv :integer );
      //¹ÝÂ¦ÀÌº¥Æ® 3Â÷
      procedure BanjjakChangeItemByJob ( var citem :TClientItem ; lv :integer );

      //2004/05/03(sonmg)
      function  CheckUnbindItem (itemname: string): Boolean;
      procedure DeleteItemFromBag(psDel : PTStdItem; puDel : PTUserItem);
      //2004/03/17(sonmg)
      function  FindItemToBindFromBag (count: integer; itemname: string; var dellist: TStringList): integer;

      // ÃÊ´ëÀå ¾ÆÀÌÅÛ ¼ÂÆÃ.
      function GuildAgitInvitationItemSet( pu: PTUserItem ): Boolean;
      // ÃÊ´ëÀå À¯È¿±â°£ Ã¼Å©.
      function GuildAgitInvitationTimeOutCheck( pu: PTUserItem ): Boolean;

      // »óÇöÁÖ¸Ó´Ï ¾ÆÀÌÅÛ ¼ÂÆÃ.
      function GuildAgitDecoItemSet( pu: PTUserItem; Number: integer ): Boolean;

      //¸í¼ºÄ¡½Ã½ºÅÛ
      function IncFamePoint(point : integer; onlyFameCur : Boolean = FALSE) : Boolean;
      function DecFamePoint(point : integer) : Boolean;
      procedure ZeroFamePoint;
      function  UseCurrentFamePoint(usepoint : integer) : Boolean;
      procedure DecWeaponBadLuck;

      //¼±¹°»óÀÚ
      procedure GetGiftFromBox;
      //ºÎÈ°Àý ´Þ°¿
      procedure GetGiftFromEgg;
      //³°Àº±ËÂ¦
      procedure GetGiftFromOldBox;
      procedure RepairAllItem(DureCount: Integer; boDec: Boolean);//ÐÞÀíËùÓÐÎïÆ·
      Function RepairAllItemDura:Integer;//È«²¿ÐÞ¸´,ÐèÒªµÄ³Ö¾ÃÖµ
      //¼ø°£ ´É·ÂÄ¡ »ó½Â
      procedure EnhanceExtraAbility( kind, amount: integer; min, sec: DWORD );
      // ·¢ËÍ½â°ü
      procedure SendUnBind();
      procedure SendCreditPoint();
   end;

   TAnimal = class (TCreature)
   private
   public
      TargetX: integer;
      TargetY: integer;
      BoRunAwayMode: Boolean; //´Þ¾Æ³ª´Â ¸ðµå
      RunAwayStart: longword;
      RunAwayTime: integer;
      constructor Create;
      procedure RunMsg (msg: TMessageInfo); override;
      procedure Run; override;
      function  GetNearMonster : TCreature;   //°¡Àå °¡±î¿î »ý¹°Ã¼ ¾ò¾î¿À±â...
      procedure MonsterNormalAttack;
      procedure MonsterDetecterAttack;
      procedure SetTargetXY (x, y: integer); dynamic;
      procedure GotoTargetXY; dynamic;
      procedure Wondering; dynamic;
      procedure Attack (target: TCreature; dir: byte); dynamic;
      procedure Struck (hiter: TCreature); dynamic;
      procedure LoseTarget; override;
   end;

   TUserHuman = class (TAnimal)
       m_StallMgr: TStallMgr;
   private

      SendBuffers: TList;

      LatestSayStr: string;  //µµ¹è ±ÝÁö
      BombSayCount: integer;
      BombSayTime: longword;
      BoShutUpMouse: Boolean;
      ShutUpMouseTime: longword;
      operatetime: longword;
      operatetime_30sec: longword;
      operatetime_sec: longword;
      operatetime_500m: longword;
      boGuildwarsafezone: Boolean;

      FirstClientTime: longword;
      FirstServerTime: longword;

      //À§Å¹»óÁ¡°ü·Ã µ¥ÀÌÅÍ.
      FUserMarket   : TMarketItemManager;
      FMarketNpc    : TCreature;
      BoFlagUserMarket : Boolean;  // À§Å¹ ±â´ÉÀ» ÇÑ²¨¹ø¿¡ ¿©·¯ ¹ø ¿äÃ» ÇÒ ¼ö ¾øµµ·Ï Flag¼³Á¤(sonmg 2005/01/31)
      FlagReadyToSellCheck : Boolean;  // À§Å¹ °¡´ÉÇÑÁö Ã¼Å©ÇßÀ» ¶§ Flag¼³Á¤(sonmg 2005/08/10)

      m_dwBuyShopItemTick: LongWord;
      m_btGetShopItem: array[0..5] of Byte;

      function  TurnXY (x, y, dir: integer): Boolean;
      function  WalkXY (x, y: integer): Boolean;
      function  RunXY (x, y: integer): Boolean;
      procedure GetRandomMineral;
      procedure GetRandomGems;
      procedure GetRandomMineral3;
      function  DigUpMine (x, y: integer): Boolean;
//      function  TargetInSwordLongAttackRange: Boolean;
      function  HitXY (hitid, x, y, dir: integer): Boolean;
      function  GetMagic (mid: integer): PTUserMagic;
      function  SpellXY (magid, targetx, targety, targcret: integer): Boolean;
      function  SitdownXY (x, y, dir: integer): Boolean;


      procedure GetQueryUserName (target: TCreature; x, y: integer);
      procedure ServerSendAdjustBonus;
      procedure ServerGetOpenDoor (dx, dy: integer);
      procedure ServerGetTakeOnItem (where: byte; svindex: integer; itmname: string);
      procedure ServerGetTakeOffItem (where: byte; svindex: integer; itmname: string);
      function BindPotionUnit( iShape, iCount: integer ): Boolean;
      function UseStdmodeFunItem(ps: PTStdItem): Boolean;
      procedure ServerGetEatItem (svindex: integer; itmname: string);
      procedure ServerGetButch (animal: TCreature; x, y, ndir: integer);
      procedure ServerGetMagicKeyChange (magid, key: integer);
      procedure ServerGetClickNpc (clickid: integer);
      procedure ServerGetMerchantDlgSelect (npcid: integer; clickstr: string);
      procedure ServerGetMerchantQuerySellPrice (npcid, itemindex: integer; itemname: string);
      procedure ServerGetMerchantQueryRepairPrice (npcid, itemindex: integer; itemname: string);
      procedure ServerGetUserSellItem (npcid, itemindex, sellcnt: integer; itemname: string);
      procedure ServerGetUserRepairItem (npcid, itemindex: integer; itemname: string);
      procedure ServerSendStorageItemList (npcid: integer);

//--°ÚÌ¯
    function CretInNearXYEx(nX, nY: Integer): Boolean;
    procedure ClientStallOnOpening(MsgBuff: string; nCount: Integer);
    procedure SendStallItems(RecvObject: TUserHuman);
//--°ÚÌ¯

      procedure ServerGetUserStorageItem (npcid, itemindex, count: integer; itemname: string);
      procedure ServerGetMakeDrug (npcid: integer; itemname: string);
      procedure ServerGetMakeItemSel (npcid: integer; itemname: string);
      procedure ServerGetMakeItem (npcid: integer; itemname: string);
      procedure ServerGetUserMenuBuy (msg, npcid, MakeIndex, menuindex: integer; itemname: string);
      procedure RefreshGroupMembers;
      procedure ServerGetCreateGroup (withwho: string);
      procedure ServerGetCreateGroupRequestOk (withwho: string);
      procedure ServerGetCreateGroupRequestFail;
      procedure ServerGetCreateGroupRequestFail1;
      procedure ServerGetAddGroupMember (withwho: string);
      procedure ServerGetAddGroupMemberRequestOk (withwho: string);
      procedure ServerGetAddGroupMemberRequestFail;
       procedure ServerGetCreateGroupRequestFail2;
      procedure ServerGetDelGroupMember (withwho: string);
      procedure ServerGetDealTry (withwho: string);
      procedure ServerGetDealAddItem (iidx, count: integer; iname: string);
      procedure ServerGetDealDelItem (iidx: integer; iname: string);
      procedure ServerGetDealChangeGold (dgold: integer);
      procedure ServerGetDealEnd;
      procedure ServerGetTakeBackStorageItem (npcid, itemserverindex, TakeBackCnt: integer; iname: string);
      procedure ServerGetWantMiniMap;
      procedure SendChangeGuildName;
      procedure ServerGetQueryUserState (who: TCreature; xx, yy: integer);
      procedure ServerGetOpenGuildDlg;
      procedure ServerGetGuildHome;
      procedure ServerGetGuildMemberList;
      procedure ServerGetGuildAddMember (who: string);
      procedure ServerGetGuildDelMember (who: string);
      procedure ServerGetGuildUpdateNotice (body: string);
      procedure ServerGetGuildUpdateRanks (body: string);
      procedure ServerGetAdjustBonus (remainbonus: integer; bodystr: string);
      procedure ServerGetGuildMakeAlly;
      procedure ServerGetGuildBreakAlly (gname: string);

      procedure RmMakeSlaveProc (pslave: PTSlaveInfo);
      // Ä«¿îÆ® ¾ÆÀÌÅÛ
      procedure ServerSendItemCountChanged (mindex, icount, increase: integer; itmname: string);
      procedure ServerGetSumCountItem(org_mindex, ex_mindex: integer; itmnames: string);
      // ¾÷±×·¹ÀÌµå¿ë ³»ºÎÇÔ¼ö(sonmg)
      function  GetTotalValueOfOption( pu: PTUserItem; pstd, psJewelry: PTStdItem; var strResult, strEtc: string ) : integer;

      procedure SendLoginNotice;
      procedure ServerGetNoticeOk;
      // RelationShip ....
      procedure ServerGetRelationOptionChange( OptionType : integer ; Enable : integer );
      procedure ServerGetRelationRequest( ReqType : integer ; ReqSeq : integer );
      procedure ServerGetRelationDelete( ReqType : integer ; OtherName : String );
      procedure ServerGetRelationDeleteRequestOk( ReqType : integer ; OtherName : String );
      procedure ServerGetRelationDeleteRequestFail( ReqType : integer ; OtherName : String );
      procedure ServerSetRelationDBWantList( body : String );
      procedure ServerSetRelationDBAdd     ( body : String );
      procedure ServerSetRelationDBEdit    ( body : String );
      procedure ServerSetRelationDBEdit2    ( body : String );
      procedure ServerSetRelationDBDelete  ( body : String );
      procedure ServerGetRelationDBGetList ( body : String );
      procedure ServerGetLoverLogout;
      procedure ServerSetFameDBAdd         ( body : String );
      function  GetCharMapInfo( charname : string ) : String;
      // User Market À§Å¹ÆÇ¸Å
      procedure ServerGetMarketList   ( MarketNpc : TCreature; page_ : integer ; body : string);
      procedure ServerGetMarketSell   ( MarketNpc: TCreature; count_: integer; makeindex_: integer; body: String );
      procedure ServerGetMarketBuy    ( MarketNpc : TCreature; SellIndex_ : integer );
      procedure ServerGetMarketCancel ( MarketNpc : TCreature; SellIndex_ : integer );
      procedure ServerGetMarketGetPay ( MarketNpc : TCreature; SellIndex_ : integer );
      procedure ServerGetMarketClose;

      // ¹®ÆÄÀå¿ø
      procedure ServerGetGuildAgitList ( page : integer );  //Àå¿ø ¸ñ·Ï
      function ServerGetGuildAgitTag ( who: TCreature; body : string ):Boolean; // Àå¿ø ÂÊÁö
      function ExecuteGuildAgitTrade : integer; //Àå¿ø °Å·¡ ¼º»ç.
      // Àå¿ø°Ô½ÃÆÇ
      procedure ServerGetGaBoardList ( page : integer );  //Àå¿ø°Ô½ÃÆÇ ¸ñ·Ï
      procedure ServerGetGaBoardRead ( NumSeries : string );
      procedure ServerGetGaBoardAdd ( nKind, nCurPage : integer; body : string );
      procedure ServerGetGaBoardDel ( nCurPage: integer; body : string );
      procedure ServerGetGaBoardDelAll ( nCurPage: integer; body : string );
      procedure ServerGetGaBoardEdit ( nCurPage: integer; body : string );
      procedure ServerGetGaBoardNoticeCheck;
      // Àå¿ø²Ù¹Ì±â
      procedure ServerGetDecoItemBuy (msg, npcid, itemindex: integer; itemname: string);

//      procedure ServerGetCashRefesh;
      procedure ServerGetDeath(who: TCreature);
      procedure GetSaleItemListEx(pmsg: pTMessageInfo);
      procedure BuySaleItemListEx(pmsg: pTMessageInfo);
      procedure PresendItem(pmsg: pTMessageInfo);
      procedure ServerGetTrans (page : integer );  //Àå¿ø°Ô½ÃÆÇ ¸ñ·Ï
   public
      Def: TDefaultMessage;
      UserId: string[20];
      UserAddress: string;
      UserHandle: integer;
      UserGateIndex: integer;  //Gate¿¡¼­ÀÇ UserIndex °ÔÀÌÆ®ÀÇ ¼Óµµ Çâ»óÀ» À§ÇØ
      //SocData: string;
      LastSocTime: longword;
      GateIndex: integer;
      ClientVersion: integer;
      LoginClientVersion: integer;
      ClientCheckSum: integer;
      LoginDateTime: TDateTime;  //ÃÖÃÊ Á¢¼Ó ½Ã°£
      LoginTime: longword;  //ÃÖ¼Ò Á¢¼Ó ½Ã°£

      ServerShiftTime: longword; //¼­¹ö ÀÌµ¿ Å¬·°(sonmg 2005/05/02)

      ReadyRun: Boolean;
      Certification: integer;
      ApprovalMode: integer;  //1:Ã¼ÇèÆÇ»ç¿ëÀÚ 2:Á¤½Ä»ç¿ëÀÚ 3:¹«·á»ç¿ëÀÚ
      AvailableMode: integer; //1:°³ÀÎÁ¤¾× 2:°³ÀÎÁ¤·® 3:°×¹æÁ¤¾× 4:°×¹æÁ¤·® 5:¹«·á»ç¿ëÀÚ 6:¹Ì¸£2Á¤·®»ç¿ëÀÚ
                              //7:¹Ì¸£3Á¤·® 8:¹«·áÅëÇÕÁ¤·® 9:¹«·á¹Ì¸£2Á¤·® 10:¹«·á¹Ì¸£3Á¤·®(2004/06/10ÀÌÈÄ Ãß°¡)

      UserConnectTime: longword;
      ChangeToServerNumber: integer;
      EmergencyClose: Boolean;  //°­Á¦·Î Á¢¼ÓÀÌ ²÷¾îÁ®¾ß ÇÏ´Â°æ¿ì
      UserSocketClosed: Boolean;  //»ç¿ëÀÚ°¡ °­Á¦·Î Á¢¼ÓÀ» ²÷Àº°æ¿ì (ÀüÅõÁßÀÌ¸é 5ÃÊµ¿¾È Ä³¸¯ÀÌ ³²´Â´Ù)
      UserRequestClose: Boolean;
      SoftClosed: Boolean;
      BoSaveOk: Boolean;
      // 2003/06/12 ½½·¹ÀÌºê ÆÐÄ¡
      PrevServerSlaves: TList;  //list of PTSlaveInfo;
      TempStr: string;
      BoChangeServerOK: Boolean;

      BoChangeServer: Boolean;
      WriteChangeServerInfoCount: integer;
      ChangeMapName: string;
      ChangeCX, ChangeCY: integer;
      BoChangeServerNeedDelay: Boolean;
      ChangeServerDelayTime: Longword;

      HumStruckTime: longword;
      ClientMsgCount: integer;
      ClientSpeedHackDetect: integer;
      LatestSpellTime: longword;
      LatestSpellDelay: integer;
      LatestHitTime: longword;
      LatestWalkTime: longword;
      LatestDropTime: longword;  //¸¶Áö¸·À¸·Î ¾ÆÀÌÅÛ ¶Ç´Â ±ÝÀüÀ» ¶³±º ½Ã°£.(¼­¹ö ·¢ ¾ÆÀÌÅÛ º¹»ç °ü·Ã sonmg)
      HitTimeOverCount: integer;
      HitTimeOverSum: integer;
      SpellTimeOverCount: integer;
      WalkTimeOverCount: integer;
      WalkTimeOverSum: integer;
      SpeedHackTimerOverCount: integer;
      MustRandomMove: Boolean;  //ÀçÁ¢ÇÒ¶§ ¸Ê¿¡¼­ ¾Æ¹«°÷¿¡¼­³ª ¶³¾îÁö°Ô..

      CurQuest: pointer;  //PTQuestRecord;
      CurQuestNpc: TCreature;
      CurSayProc: pointer;
      QuestParams: array[0..99] of integer;
      DiceParams: array[0..99] of integer;
      m_nSval: array[0..99] of string;

      BoTimeRecall: Boolean;  //½Ã°£ÀÌ µÇ¸é ¿øÀ§Ä¡·Î µ¹¾Æ¿À¿È
      BoTimeRecallGroup: Boolean;  //½Ã°£ÀÌ µÇ¸é ±×·ì ÀüÃ¼°¡ ¿øÀ§Ä¡·Î µ¹¾Æ¿È
      TimeRecallEnd: longword;
      TimeRecallMap: string;
      TimeRecallX, TimeRecallY: integer;

      PriviousCheckCode: byte;
      CrackWanrningLevel: integer;
      LastSaveTime: longword;
      Bright: integer;  //¸ÊÀÇ ¹à±â,
      FirstTimeConnection: Boolean;  //Ä³¸¯ÅÍ¸¦ Ã³À½ ¸¸µé¾î¼­ Á¢¼ÓÇÔ,
      BoSendNotice: Boolean;
      LoginSign: Boolean;
      BoServerShifted: Boolean;  //¼­¹ö ÀÌµ¿À¸·Î ÀçÁ¢
      BoAccountExpired: Boolean;

      LineNoticeTime: longword;
      LineNoticeNumber: integer;

      NotReadTag      : integer;
      // ¿¬ÀÎ »çÁ¦
      fLover    : TRelationShipMgr;
      fMaster   : TMasterMgr;

      FExpireTime  : LongWord; // TEST integer;
      FExpireCount : integer;

      TimeLabelList: TList; //ÑÓÊ±ÁÐ±í

      FirstGold: integer;
      FirstGoldCount: integer;
      RufuseMaster: boolean;
      latestuseitem : string;
      UseItemStdMode : integer;
      UseItemShape : integer;

      iDay: integer;
      iHours: Integer;
      SecondsCard : integer;
      iHoursTime: LongWord;
      bStorageType: Byte;
      constructor Create;
      destructor Destroy; override;
      procedure Initialize; override;
      procedure Finalize; override;
      procedure ResetCharForRevival;  //Á×Àº °æ¿ì »óÅÂ ¸®¼Â
      procedure Clear_5_9_bugitems;
      procedure Reset_6_28_bugitems;
      function  GetUserMassCount: integer;
      procedure WriteConLog;
      procedure SendSocket (pmsg: PTDefaultMessage; body: string);
      procedure SendDefMessage (msg, recog, param, tag, series: integer; addstr: string);
      procedure GuildRankChanged (rank: integer; rname: string);
      //¿î¿µÀÚ ¸í·É¾î
      procedure ChangeSkillLevel (magname: string; lv: byte);
      procedure CmdMakeFullSkill (magname: string; lv: byte);
      procedure CmdMakeOtherChangeSkillLevel (who, magname: string; lv: byte);
      function  CmdDeletePKPoint (whostr: string) : Boolean;
      procedure CmdSendPKPoint (whostr: string ; value : integer);
      procedure CmdChangeJob (jobname: string);
      procedure CmdChangeHair (value: integer);
      procedure CmdChangeSex;
      procedure CmdCallMakeMonster (monname, param: string);
      procedure CmdCallMakeSlaveMonster (monname, param: string; makelv, explv: byte);
      procedure CmdMissionSetting (xstr, ystr: string);
      procedure CmdCallMakeMonsterXY (xstr, ystr, monname, countstr: string);
      procedure CmdMakeItem (itmname: string; count: integer);
      procedure CmdSmakeItem (nWhere, nValueType, nValue: Integer);
      procedure CmdRefineWeapon (dc, mc, sc, acc: integer);
      procedure CmdDeleteUserGold (whostr, goldstr: string);
      procedure CmdStartQuest(Cmd, sQuestName: string);
      procedure CmdAddUserGold (whostr, goldstr: string);
      procedure RCmdUserChangeGoldOk (whostr: string; igold: integer);
      procedure CmdGameGold(whostr, sctr: string; ival: integer);
      procedure CmdFreeSpaceMove (map, xstr, ystr: string);
      procedure CmdCharSpaceMove (CharName_: string);
      function  CmdLoverCharSpaceMove (CharName_: string): Boolean;
      procedure CmdBreakLoverRelation;
      procedure CmdStealth;
      procedure CmdCharMove( CharName_ : string ; MapName: string);
      procedure CmdRushAttack;
      procedure CmdManLevelChange (man: string; level: integer);
      procedure CmdManExpChange (man: string; exp: integer);
      procedure CmdEraseItem (itmname, countstr: string);
      procedure CmdRecallMan (man, map: string);
      procedure CmdRecallMap (MapFrom: string);
      procedure GuildMasterRecallMan (man: string; bPersonal: Boolean);  //Àå¿ø ¼ÒÈ¯(2004/04/13)
      procedure CmdReconnection (saddr, sport: string);
      function  ProcessUserCmd(sCmd: string): Boolean;
      procedure CmdReloadGuild (gname: string);
      procedure CmdReloadGuildAll (gname: string);
      procedure CmdReloadGuildAgit;
      procedure CmdKickUser (uname: string);
      procedure CmdTingUser (uname: string);
      procedure CmdTingRangeUser (uname, rangestr: string);
      procedure CmdCreateGuild (gname, mastername: string);
      procedure CmdDeleteGuild (gname: string);
      procedure CmdGetGuildMatchPoint (gname: string);
      procedure CmdStartGuildMatch;
      procedure CmdEndGuildMatch;
      procedure CmdAnnounceGuildMembersMatchPoint (gname: string);
      procedure CmdViewAllCharacterList(mapname: string);
      function  GetLevelInfoString (cret: TCreature): string;
      procedure CmdSendUserLevelInfos (whostr: string);
      procedure CmdSendMonsterLevelInfos;
      procedure CmdSendKingMonsterInfos(monname :string);  //sonmg(2004/02/06)
      procedure CmdChangeUserCastleOwner (gldname: string; pass: Boolean);
      procedure CmdReloadNpc (cmdstr: string);
      procedure CmdReloadNpc2 (cmdstr: string);
      procedure CmdOpenCloseUserCastleMainDoor (cmdstr: string);
      procedure CmdAddShutUpList (whostr, minstr: string; pass: Boolean);
      procedure CmdDelShutUpList (whostr: string; pass: Boolean);
      procedure CmdSendShutUpList;
      procedure CmdOneKillMob;
      procedure CmdAgitDecoMonCount( agitnum : integer );
      procedure CmdAgitDecoMonCountHere;
      procedure CmdAdjustFamePoint (strFameCur, strFameBase : string);
      procedure CmdGetFameName (whostr: string);
      procedure CmdUserMarketDebug (strParam : string);
      procedure CmdGamePoint(whostr, sctr: string; ival: integer);    //»ý·Ö
      // TEST_TIME
      procedure CmdTestTimeDebug (num : integer);
      procedure CmdSetCryWide (num : integer);
      // 2003/09/15 Ã¤ÆÃ·Î±× °ü·Ã ¸í·É¾î Ãß°¡
      procedure CmdAddChatLogList (whostr: string; pass: Boolean);
      procedure CmdDelChatLogList (whostr: string; pass: Boolean);
      procedure CmdSendChatLogList;
      // ¹®ÆÄÀå¿ø °ü·Ã ¿î¿µÀÚ ¸í·É¾î(sonmg)
      procedure CmdGuildAgitRegistration;
      procedure CmdGuildAgitAutoMove;
      procedure CmdGuildAgitDelete;
      procedure CmdGuildAgitExtendTime (count : integer);
      procedure CmdGuildAgitRemainTime;
      procedure CmdGuildAgitRecall (man : string; WholeRecall : Boolean);
      procedure CmdGuildAgitFreeMove( AgitNum : integer );
      // ¹®ÆÄÀå¿ø ÆÇ¸Å°ü·Ã
      procedure CmdGuildAgitSale (StrForSaleGold: string);
      procedure CmdGuildAgitSaleCancel;
      procedure CmdGuildAgitBuy (page : integer);
      procedure CmdTryGuildAgitTrade;
      // ¹®ÆÄÀå¿ø ÀÚ±â ÀÚ½Å Ãß¹æ(sonmg)
      procedure CmdGuildAgitExpulsionMyself;
      // Àå¿ø ±âºÎ±Ý
      procedure CmdGuildAgitDonate (goldstr: string);
      procedure CmdGuildAgitViewDonation;
      function  GetGuildAgitDonation : integer;
      function  DecGuildAgitDonation (igold : integer) : Boolean;
      // Àå¿ø ÆÄÀÏ ¹öÀü
      procedure CmdGetGuildAgitFileVersion;

      //°øÅë ¸í·É¾î
      procedure CmdEraseMagic (magname: string);
      procedure CmdThisManEraseMagic (whostr, magname: string);
      function  GuildDeclareWar (gname: string): Boolean;


      //Send??
      procedure SendAddItem (ui: TUserItem); //¾ÆÀÌÅÛÀÌ Ãß°¡µÊ
      procedure SendUpdateItem (ui: TUserItem);
      procedure SendUpdateItemWithLevel (ui: TUserItem ; lv :Integer);
      // ¿ë¾ÆÀÌÅÛ(sonmg)
      procedure SendUpdateItemByJob (ui: TUserItem ; lv : Integer);

      procedure SendDelItem (ui: TUserItem);
      procedure SendDelItemWithFlag (ui: TUserItem; wBreakdown: Word);
      procedure SendDelItems (ilist: TStringList);
      procedure SendBagItems;
      procedure SendUseItems;
      procedure SendAddMagic (pum: PTUserMagic);
      procedure SendDelMagic (pum: PTUserMagic);
      procedure SendMyMagics;

      procedure SendMaaList;
      //**
      procedure Whisper (whostr, saystr: string);
      procedure LoverWhisper (whostr, saystr: string);
      procedure WhisperRe (saystr: string; IsGM: Boolean);
      procedure LoverWhisperRe (saystr: string);
      procedure BlockWhisper (whostr: string);
      function  IsBlockWhisper (whostr: string): Boolean;
      procedure Say (saystr: string); override;
      procedure ThinkEtc;
      procedure ReadySave;
      procedure SendLogon;
      procedure SendAreaState;
      procedure DoStartupQuestNow;
      procedure Operate;
      procedure RunNotice;
      procedure GetGetNotices;
      function  GetStartX: integer;
      function  GetStartY: integer;
      procedure CheckHomePos;
      procedure GuildSecession;
      procedure CmdSendTestQuestDiary (unitnum: integer);

      procedure ResetDeal;
      procedure StartDeal (who: TUserHuman);
      procedure BrokeDeal;
      procedure ServerGetDealCancel;
      procedure AddDealItem (uitem: TUserItem; remain: integer);
      procedure DelDealItem (uitem: TUserItem);
      // Ä«¿îÆ® ¾ÆÀÌÅÛ.
      procedure AddDealCounterItem (uitem: TUserItem; remain: integer);
      procedure DelDealCounterItem (uitem: TUserItem);

      function  IsReservedMakingSlave: Boolean;  //¼­¹öÀÌµ¿À¸·Î RM_MAKE_SLAVE°¡ ¿¹¾àµÇ¾î ÀÖ´ÂÁö ¿©ºÎ
      // RelationShip
      function RelationShipDeleteOther( ReqType : integer ; OtherName : String):Boolean;

      //////////////////////////
      // ¿î¿µÀÚ ¸í·É¾î added by sonmg.2003/10/02
      function CheckSeedItem (psSeed, psJewelry: PTStdItem) : Integer;
      function CheckJewelryItem (iStdMode: integer) : Boolean;
      function SumOfOptions(puSeedItem: PTUserItem; psSeedItem: PTStdItem) : integer;
      function CalcUpgradeProbability(puSeedItem, puJewelryItem: PTUserItem; psSeedItem, psJewelryItem: PTStdItem; iExecCount: Integer; var iRetSum: integer; var fRetProb: Double) : integer;
      procedure CmdUpgradeItem (seedname, jewelryname: string; seedindex, jewelryindex, ExecCount : integer);
      procedure CmdMakeAllJewelryItem (nSelect : integer);
      function  DoUpgradeItem( puSeed: PTUserItem; psSeed, psJewelry: PTStdItem ): integer;
      procedure CmdLetterColor( strColor : string );
      //////////////////////////

      function  SetExpiredTime( min_ : integer ):Boolean;
      procedure CheckExpiredTime;

      // À§Å¹»óÁ¡---------------------------------------------------------------

      // À§Å¹»óÁ¡¿¡ ¿äÃ»
      procedure RequireLoadRefresh;
      procedure RequireLoadUserMarket  ( MarketName : string ; ItemType :integer ; UserMode : integer; OtherName : string ; ItemName_:string);
      procedure RequireSellUserMarket  ( MakeIndex_ : Integer ; SellCount_ : integer; SellPrice_ : integer );
      procedure RequireBuyUserMarket   ( MarketNpc : TCreature ; SellIndex_ : Integer );
      procedure RequireCancelUserMarket( MarketNpc : TCreature ; SellIndex_ : integer );
      procedure RequireGetPayUserMarket( MarketNpc : TCreature ; SellIndex_ : integer );

      // Å¬¸®ÀÌ¾ðÆ®¿¡ ¿äÃ»
      function  IsExistBagItem( makeindex_ : integer ): PTUserItem;
      function  IsFullBagCount : Boolean;
      function  IsEnableUseMarket : Boolean;
      function  DeleteFromBagItem( MakeIndex_ :integer ; SellCount_:integer):Boolean;
      function  AddToBagItem( UserItem_ : TUserItem  ):Boolean;
      function  GetMarketName : String;
      procedure SendUserMarketSellReady( MarketNpc : TCreature);
      procedure SendUserMarketCloseMsg;

      // ½ÇÁ¦·Î ¾ÆÀÌÅÛ º¯°æ
      procedure GetMarketData      ( pInfo       : PTSearchSellItem);
      procedure SendUserMarketList ( NextPage    : integer);
      procedure SellUserMarket     ( pSellItem   : PTMarketLoad );
      procedure ReadyToSellUserMarket( pReadyItem: PTMarketLoad );
      procedure BuyUserMarket      ( pBuyItem    : PTMarketLoad );
      procedure CancelUserMarket   ( pCancelItem : PTMarketLoad );
      procedure GetPayUserMarket   ( pGetpayItem : PTMarketLoad );

      //Àå¿ø°Ô½ÃÆÇ--------------------------------------------------------------

      // Àå¿ø°Ô½ÃÆÇ ¿äÃ»
      procedure CmdReloadGaBoardList ( gname : string; nPage : integer );
      procedure CmdGaBoardList ( nPage : integer );
      procedure CmdGaBoardDelAll;


      function DeathFunc: Boolean;
      function KillHumFunc: Boolean;
      function DeathAndKillsFunc(): Boolean;
            //Àå¿ø²Ù¹Ì±â--------------------------------------------------------------
      procedure CmdBuyDecoItem( nObjNum : integer );
      procedure SendDecoItemList;

      //¸í¼ºÄ¡--------------
      function GetFameName( var nGrade: integer ) : string;
      procedure UserUnifyItem (npcid: integer; itemkind: string);
      procedure ClearTimeLabel(); //Çå³ýÑÓÊ±ÁÐ±í
      procedure ClearAllDelayLabel; //Çå³ýÈ«²¿ÑÓÊ±ÁÐ±í
      //PC¼Ó¼õ
      function IncPotCash(igold: integer): Boolean;
      function DecPotCash(igold: integer): Boolean;
      function LeftMarry:Boolean;
      procedure CmdShowEffect(cmdstr, effectstr: string); //ÑÌ»¨
   end;


implementation

uses
   svMain, M2Share, ObjNpc, Magic, LocalDB, Guild, UsrEngn, Event,
   IdSrvClient , usermgr,sqlengn, DBSQL;


procedure InitializeObjBase;
begin
end;

constructor TCreature.Create;
begin
   BoGhost := FALSE;
   GhostTime := 0;
   Death := FALSE;
//   Death2 := False;
   DeathTime := 0;
   WatchTime := GetTickCount;
   Dir := DR_DOWN;
   RaceServer := RC_ANIMAL;
   RaceImage := 0;
   Hair := 0;
   Job := 0; //Àü»ç 1:¼ú»ç  2: µµ»ç
   Gold := 0;  //°¡Áö°í ÀÖ´Â µ·
   GamePoint   := 0;    //ÓÎÏ·µã
   Appearance := 0;
   HoldPlace := TRUE;
   ViewRange := 5;
   HomeMap := '0'; //±âº»¸Ê
   NeckName:= '';
   UserDegree := 0;
   Light := 0;
   DefNameColor := 255;
   HitPowerPlus := 0;
   HitDouble := 0;
   BodyLuck := 0;
   CGHIUseTime := 0;
   CGHIstart := GetTickCount;
   BoCGHIEnable := FALSE;
   BoOldVersionUser_Italy := FALSE;
   BoReadyAdminPassword := FALSE;
   BoReadySuperAdminPassword := FALSE;
   BoReadyAdminPasswordEx := FALSE;
   BoReadySuperAdminPasswordEx := FALSE;

   PlusFinalDamage := 0;
   PremiumGrade := 0;
   PremiumDelayTime := 0;
   MeetLoverDelayTime := 0;
   PremiumBirthDay := FALSE;
   PremiumBirthDayCoolDown := GetTickCount;
   EventCheckFlag := FALSE;

   BoFearFire := FALSE;
   BoAbilSeeHealGauge := FALSE;

   BoAllowPowerHit := FALSE;  //true: ´ÙÀ½¿¡ ÇÑ¹ø HitPowerPlus°¡ °¡´ÉÇÔ
   BoAllowLongHit := FALSE;
   BoAllowWideHit := FALSE;
   BoAllowFireHit := FALSE;
   // 2003/03/15 ½Å±Ô¹«°ø
   BoAllowCrossHit := FALSE;
   BoAllowTwinHit  := 0;
   BoAllowStoneHit := FALSE;

   AccuracyPoint := DEFHIT;
   SpeedPoint := DEFSPEED;
   HitSpeed := 0;
   LifeAttrib := LA_CREATURE; //ÀÏ¹Ý »ý¸íÀÖ´Â ¸ó½ºÅÍ
   AntiPoison := 0;
   PoisonRecover := 0;
   HealthRecover := 0;
   SpellRecover := 0;
   AntiMagic := 0;
   Luck := 0;
   IncSpell := 0;
   IncHealth := 0;
   IncHealing := 0;
   PerHealth := 5;
   PerHealing := 5;
   PerSpell := 5;
   IncHealthSpellTime := GetTickCount;
   RedPoisonLevel := 0;
   PoisonLevel := 0;
   PlusPoisonFactor := 0;
   FightZoneDieCount := 0;
   AvailableGold := BAGGOLD;

   CharStatus := 0;
   CharStatusEx := 0;
   FillChar (StatusArr, sizeof(word)*STATUSARR_SIZE, #0);
   FillChar (StatusValue, sizeof(byte)*STATUSARR_SIZE, #0);
   FillChar (BonusAbil, sizeof(TNakedAbility), #0);
   FillChar (CurBonusAbil, sizeof(TNakedAbility), #0);
   FillChar (ExtraAbil, sizeof(byte) * EXTRAABIL_SIZE, #0);
   FillChar (ExtraAbilFlag, sizeof(byte) * EXTRAABIL_SIZE, #0);
   FillChar (ExtraAbilTimes, sizeof(longword) * EXTRAABIL_SIZE, #0);

   AllowGroup := FALSE;
   GroupRequester := '';
   AllowEnterGuild := FALSE;
   FreeGulityCount := 0;

   HumAttackMode := HAM_ALL;
   FBoInFreePKArea := FALSE;
   BoGuildWarArea := FALSE;
   BoCrimeforCastle := FALSE;

   NeverDie := FALSE;
   BoSkeleton := FALSE;  //Á×¾î¼­ »À¸¸ ³²¾Ò´ÂÁö ¿©ºÎ
   RushMode := FALSE;
   BoHolySeize := FALSE;
   BoCrazyMode := FALSE;
   BoGoodCrazyMode := FALSE;
   BoOpenHealth := FALSE;

   BoDuplication := FALSE;

   //µ¿¹°ÀÎ°æ¿ì Àâ¾Æ¼­ °í±â°¡ ³ª¿Â´Ù.
   BoAnimal := FALSE;
   BoNoItem := FALSE;
   BodyLeathery := 50; //±âº»°ª
   HideMode := FALSE;
   StickMode := FALSE;
   NoAttackMode := FALSE;
   NoMaster := FALSE;
   BoIllegalAttack := FALSE;

   ManaToHealthPoint := 0;
   SuckupEnemyHealthRate := 0;
   SuckupEnemyHealth := 0;

   FillChar (AddAbil, sizeof(TAddAbility), 0);
   FillChar(m_TempAbil, SizeOf(TTempAddAbil) * 21, 0); //changeHumAbilityÊôÐÔ¼Óµã

   MsgList := TList.Create;
   MsgTargetList := TStringList.Create;
   PKHiterList := TList.Create;

   VisibleActors := TList.Create;
   VisibleItems  := TList.Create;
   VisibleEvents := TList.Create;
   ItemList := TList.Create;
   DealList := TList.Create;
   DealGold := 0;
   MagicList := TList.Create;
   SaveItems := TList.Create;
   boShowTrans := True;
   bShowTrans := 0;
   FillChar (UseItems, sizeof(UseItems), #0);   // 9->13

   PSwordSkill := nil;
   PPowerHitSkill := nil;
   PLongHitSkill := nil;
   PWideHitSkill := nil;
   PFireHitSkill := nil;
   // 2003/03/15 ½Å±Ô¹«°ø
   PCrossHitSkill:= nil;
   PTwinHitSkill := nil;
   PStoneHitSkill:= nil;
   m_SayMsgList := nil;
   GroupOwner := nil;
   Castle := nil;

   Master := nil;
   SlaveExp := 0;
   SlaveExpLevel := 0;
   BoSlaveRelax := FALSE; //±âº» »óÅÂ, º¸ÀÌ¸é °ø°Ý ¸ðµå

   GroupMembers := TStringList.Create;
   BoHearWhisper := TRUE;
   BoHearCry := TRUE;
   BoHearGuildMsg := TRUE;
   BoExchangeAvailable := TRUE;
   BoEnableRecall := FALSE;
   BoEnableAgitRecall := FALSE;
   DailyQuestNumber := 0;  ///¼³Á¤ ¾ÈµÇ¾úÀ½    //*dq
   DailyQuestGetDate := 0;

   WhisperBlockList := TStringList.Create;
   SlaveList := TList.Create;
   FillChar (QuestStates, sizeof(QuestStates), #0);
   FillChar (QuestIndexOpenStates, sizeof(QuestIndexOpenStates), #0);
   FillChar (QuestIndexFinStates, sizeof(QuestIndexFinStates), #0);

   with Abil do begin
      Level := 1;
      AC    := 0;
      MAC   := 0;
      DC    := MakeWord(1,4);  //µ¿¹°ÀÇ ±âº» °ø°Ý
      MC    := MakeWord(1,2);
      SC    := MakeWord(1,2);
      MP    := 15;
      HP    := 15;
      MaxHP := 15;
      MaxMP := 15;
      Exp   := 0;
      MaxExp := 50;
      Weight := 0;
      MaxWeight := 100;
   end;

   WantRefMsg := FALSE;
   BoDealing := FALSE;
   BoDealEnding := FALSE;
   DealCret := nil;
   MyGuild := nil;
   GuildRank := 0;
   GuildRankName := '';
   LatestNpcCmd := '';

   BoHasMission := FALSE;
   BoHumHideMode := FALSE;
   BoStoneMode := FALSE;
   BoViewFixedHide := FALSE;
   BoNextTimeFreeCurseItem := FALSE;

   BoFixedHideMode := FALSE;
   BoSysopMode := FALSE;
   BoSuperviserMode := FALSE;
   BoEcho := TRUE;
   BoTaiwanEventUser := FALSE;

   RunTime := GetCurrentTime + Random (1500);
   RunNextTick := 250;
   SearchRate := 500 + longword(Random (500));
   SearchTime := GetTickCount;
   ElapsedHours := 0;
   time1hour := GetTickCount;
   time10min := GetTickCount;
   time500ms := GetTickCount;
   poisontime := GetTickCount;
   time30sec := GetTickCount;
   time10sec := GetTickCount;
   time60sec := GetTickCount;
   time5sec := GetTickCount;
   ticksec := GetTickCount;
   LatestCryTime := 0; //GetTickCount;
   LatestSpaceMoveTime := 0;
   LatestSpaceScrollTime := 0;
   LatestSearchWhoTime := 0;
   MapMoveTime := GetTickCount;
   SlaveLifeTime := 0;

   NextWalkTime := 1400;
   NextHitTime := 3000;
   WalkCurStep := 0;
   WalkWaitCurTime := GetTickCount;
   BoWalkWaitMode := FALSE;

   HealthTick := 0;
   SpellTick := 0;

   RankLevelName := '';

   TargetCret := nil;
   LastHiter := nil;
   LastHiterRace := -1;
   SlaveHiter := nil;
   ExpHiter := nil;
   // 2003/03/04
   RefObjCount := 0;
   FAlreadyDisapper := FALSE;

   ForceMoveToMaster := FALSE;
   BoDontMove  := FALSE;
   BoDisapear  := FALSE;
   DontBagItemDrop := false;
   DontBagGoldDrop := false;
   DontUseItemDrop := false;
   IsDie := false;
   MasterFeature := 0;
   bStealth := FALSE;

   BodyState := 0;
   LoverPlusAbility := FALSE;

   MissProbability := 0;
   FeedbackProbability := 0;
   FeedbackRatio := 0;

   ItemExpPoint := 0;
   nInstantExpDouble := 100;
   InstantExpDoubleTime := 0;
   MultiplyTargetLevelMin := 0;
   MultiplyTargetLevelMax := 0;

   BoLoseTargetMoment := FALSE; //sonmg
   PushedCount := 0;

   BoHighLevelEffect := TRUE;   //50·¹º§ È¿°ú Ç¥½Ã/¼û±è(sonmg)
   BoGuildAgitDealTry := FALSE;

   MeltArea := 2;
   m_beidusi := False;
   m_boNotOnlineAddExp := False; //³õÊ¼»¯Õæ¾ÍÊÇÖ»ÒªÉÏÏß¾ÍÊÇ¿ÉÒÔÀëÏß¹Ò»úµÄ  ÄãÒÔºóÖ»Òª°ÑÕâ¸ö±íÊ¾¸ÄÎªÕæ¾ÍÐÐ   ±ÈÈçÄãÓÐÎïÆ·´¥·¢  ÈÃÕâ¸öÎïÆ·´¥·¢¸Ä¶¯Õâ¸öÖµ¾Í¿ÉÒÔ
                               //»òm2ÉÏ×ö¿ª¹Ø¶¼¿ÉÒÔ
   m_boKickAutoAddExpUser := False;
   m_boNotOnlineClear:= False; //ÀëÏß¹Ò»ú
   m_CanDropItemList := nil;
end;

destructor TCreature.Destroy;
var
   i    : integer;
begin
   try
      for i:=0 to MsgList.Count-1 do begin
         //¸Þ¸ð¸®¸¦ Ãß°¡·Î ÇØÁ¦ÇØ¾ß ÇÏ´Â °æ¿ì
         if PTMessageInfoPtr(MsgList[i]).Ident = RM_DELITEMS then
            if PTMessageInfoPtr(MsgList[i]).lparam1 <> 0 then
               TStringList (PTMessageInfoPtr(MsgList[i]).lparam1).Free;
         if PTMessageInfoPtr(MsgList[i]).Ident = RM_MAKE_SLAVE then
            if PTMessageInfoPtr(MsgList[i]).lparam1 <> 0 then
               Dispose (PTSlaveInfo(PTMessageInfoPtr(MsgList[i]).lparam1));
         if PTMessageInfoPtr(MsgList[i]).descptr <> nil then
            FreeMem (PTMessageInfoPtr(MsgList[i]).descptr);
         Dispose (PTMessageInfoPtr (MsgList[i]));
      end;
      MsgList.Free;
      MsgTargetList.Free;
      for i:=0 to PKHiterList.Count-1 do
         Dispose (PTPkHiterInfo (PKHiterList[i]));
      PKHiterList.Free;
      // 2003/03/18
      i := 0;
      while TRUE do begin
         if i >= VisibleActors.Count then break;
         {
         if RaceServer = RC_USERHUMAN then begin
         try
            if(PTVisibleActor(VisibleActors[i]).cret <> nil) then
               TCreature (PTVisibleActor(VisibleActors[i]).cret).DecRefObjCount;
         except
            MainOutMessage ('[Exception] TCreatre.Destroy : Visible Actor Dec RefObjCount');
            end;
         end;
         }
         Dispose (PTVisibleActor (VisibleActors[i]));
         VisibleActors.Delete(i);
//       Inc(i);
      end;
      VisibleActors.Free;
      for i:=0 to VisibleItems.Count-1 do
         Dispose (PTVisibleItemInfo (VisibleItems[i]));
      VisibleItems.Free;
      VisibleEvents.Free;

      for i:=0 to ItemList.Count-1 do
         Dispose (PTUserItem (ItemList[i]));
      ItemList.Free;
      for i:=0 to DealList.Count-1 do
         Dispose (PTUserItem (DealList[i]));
      DealList.Free;
      for i:=0 to MagicList.Count-1 do
         Dispose (PTUserMagic (MagicList[i]));
      MagicList.Free;
      for i:=0 to SaveItems.Count-1 do
         Dispose (PTUserItem (SaveItems[i]));
      SaveItems.Free;
      GroupMembers.Free;
      WhisperBlockList.Free;
      SlaveList.Free;
   except
      MainOutMessage ('[Exception] TCreature.Destroy ' + UserName );
   end;

   inherited Destroy;
end;

procedure TCreature.SetBoInFreePKArea (flag: Boolean);
begin
   if FBoInFreePKArea <> flag then begin
      FBoInFreePKArea := flag;
      AreaStateOrNameChanged := TRUE;
   end;
end;

function TCreature.GetNextHitTime: LongInt;
begin
    if StatusArr[POISON_SLOW] > 0 then
        result := NextHitTime + NextHitTime div 2
    else result := NextHitTime;
end;

function TCreature.GetNextWalkTime: LongInt;
begin
    if StatusArr[POISON_SLOW] > 0 then
        result := NextWalkTime + NextWalkTime div 2
    else result := NextWalkTime;
end;

// ¿òÁ÷ÀÏ¼ö ÀÖ³ª Ã¼Å©ÇÔ
function  TCreature.IsMoveAble : Boolean;
begin

   if (not BoGhost)                 and // ¸Ê»ó¿¡ ÀÖ°í
      (not Death)                   and // Á×Áö ¾Ê°í
      (StatusArr[POISON_STONE] = 0) and // »óÅÂ ÀÌ»óÀÌ ¾Æ´Ï°í
      (StatusArr[POISON_ICE]   = 0) and
      (StatusArr[POISON_STUN]  = 0) and
      (StatusArr[POISON_DONTMOVE]  = 0)
   then ResulT := TRUE
   else Result := FALSE;

end;

procedure TCreature.ChangeItemWithLevel ( var citem :TClientItem ; lv : integer);
var
   ItemIndex : integer;
begin
   ItemIndex := UserEngine.GetStdItemIndex(citem.S.Name);   //¹ÝÂ¦

   //ÃµÀÇ¹«ºÀÀÌ¸é
   if ( citem.s.Shape = DRESS_SHAPE_WING) and
      (( citem.S.StdMode = DRESS_STDMODE_MAN ) or ( citem.S.StdMode = DRESS_STDMODE_WOMAN )) then
   begin

     //-------------------------------
     //¹ÝÂ¦ÀÌº¥Æ®2Â÷ (2004/08/13)
//     if (ItemIndex = 700) or (ItemIndex = 701) then begin
//      if Lv >= 20 then // ·¹º§¿¡µû¸¥ °ª º¯°æ
//      begin
//         //¹ÝÂ¦ÃµÀÇ
//         if ( lv < 30 ) then // 20 ~ 29
//         begin
//         // ±âº»°ªÀ¸·Î ¼³Á¤
//         end
//         else if ( lv < 40 ) then // 30 ~ 39
//         begin
//            citem.S.DC  := citem.S.DC  + MakeWord(0,1); // °ø°Ý
//            citem.S.MC  := citem.S.MC  + MakeWord(0,2); // ¸¶·Â
//            citem.S.SC  := citem.S.SC  + MakeWord(0,2); // µµ·Â
//            citem.S.AC  := citem.S.AC  + MakeWord(2,4); // ¹æ¾î
//            citem.S.MAC := citem.S.MAC + MakeWord(1,3); // ¸¶¹æ
//         end
//         else// 40~
//         begin
//            citem.S.DC  := citem.S.DC  + MakeWord(0,2); // °ø°Ý
//            citem.S.MC  := citem.S.MC  + MakeWord(0,4); // ¸¶·Â
//            citem.S.SC  := citem.S.SC  + MakeWord(0,4); // µµ·Â
//            citem.S.AC  := citem.S.AC  + MakeWord(5,7); // ¹æ¾î
//            citem.S.MAC := citem.S.MAC + MakeWord(2,4); // ¸¶¹æ
//         end;
//
//      end;
//     end else begin
//
//      if Lv >= 40 then // ·¹º§¿¡µû¸¥ °ª º¯°æ
//      begin
//
//         if ( lv < 46 ) then // 20 ~ 29
//         begin
//         // ±âº»°ªÀ¸·Î ¼³Á¤
//         end
//         else if ( lv > 45 )and( lv < 48 ) then // 30 ~ 39
//         begin
//            citem.S.DC  := citem.S.DC  + MakeWord(1,2); // °ø°Ý
//            citem.S.MC  := citem.S.MC  + MakeWord(1,2); // ¸¶·Â
//            citem.S.SC  := citem.S.SC  + MakeWord(1,2); // µµ·Â
//            citem.S.AC  := citem.S.AC  + MakeWord(1,2); // ¹æ¾î
//            citem.S.MAC := citem.S.MAC + MakeWord(1,2); // ¸¶¹æ
//         end
//
//         else if ( lv > 47 )and( lv < 50 ) then // 30 ~ 39
//         begin
//            citem.S.DC  := citem.S.DC  + MakeWord(2,4); // °ø°Ý
//            citem.S.MC  := citem.S.MC  + MakeWord(2,4); // ¸¶·Â
//            citem.S.SC  := citem.S.SC  + MakeWord(2,4); // µµ·Â
//            citem.S.AC  := citem.S.AC  + MakeWord(2,4); // ¹æ¾î
//            citem.S.MAC := citem.S.MAC + MakeWord(2,4); // ¸¶¹æ
//         end
//         else if ( lv > 49 )and ( Lv < 52 ) then  // 40 ~ 49
//         begin
//            citem.S.DC  := citem.S.DC  + MakeWord(3,6); // °ø°Ý
//            citem.S.MC  := citem.S.MC  + MakeWord(3,6); // ¸¶·Â
//            citem.S.SC  := citem.S.SC  + MakeWord(3,6); // µµ·Â
//            citem.S.AC  := citem.S.AC  + MakeWord(3,6); // ¹æ¾î
//            citem.S.MAC := citem.S.MAC + MakeWord(3,6); // ¸¶¹æ
//         end
//         else// 50~
//         begin
//            citem.S.DC  := citem.S.DC  + MakeWord(4,8); // °ø°Ý
//            citem.S.MC  := citem.S.MC  + MakeWord(4,8); // ¸¶·Â
//            citem.S.SC  := citem.S.SC  + MakeWord(4,8); // µµ·Â
//            citem.S.AC  := citem.S.AC  + MakeWord(4,8); // ¹æ¾î
//            citem.S.MAC := citem.S.MAC + MakeWord(4,8); // ¸¶¹æ
//         end;
//
//      end;
//     end;//¹ÝÂ¦


      if (Lv >= 42)and ( citem.s.AniCount =15 ) or ( citem.s.AniCount =16 )  then // ·¹º§¿¡µû¸¥ °ª º¯°æ
      begin

      if (lv < 43) then // 20 ~ 29
      begin
         // ±âº»°ªÀ¸·Î ¼³Á¤
       // citem.S.DC := citem.S.DC + MakeWord(0, 1); // °ø°Ý
          //  citem.S.MC  := citem.S.MC  + MakeWord(0,2); // ¸¶·Â
           // citem.S.SC  := citem.S.SC  + MakeWord(0,2); // µµ·Â
//        citem.S.AC := citem.S.AC + MakeWord(2, 2); // ¹æ¾î
//        citem.S.MAC := citem.S.MAC + MakeWord(0, 2); // ¸¶¹æ
         end
         else if ( lv < 44 ) then // 30 ~ 39
         begin
            citem.S.DC  := citem.S.DC  + MakeWord(0,1); // °ø°Ý
          //  citem.S.MC  := citem.S.MC  + MakeWord(0,2); // ¸¶·Â
           // citem.S.SC  := citem.S.SC  + MakeWord(0,2); // µµ·Â
            citem.S.AC  := citem.S.AC  + MakeWord(2,3); // ¹æ¾î
            citem.S.MAC := citem.S.MAC + MakeWord(0,2); // ¸¶¹æ
         end
         else if ( Lv < 45 ) then  // 40 ~ 49
         begin
            citem.S.DC  := citem.S.DC  + MakeWord(0,3); // °ø°Ý
          //  citem.S.MC  := citem.S.MC  + MakeWord(0,4); // ¸¶·Â
          //  citem.S.SC  := citem.S.SC  + MakeWord(0,4); // µµ·Â
            citem.S.AC  := citem.S.AC  + MakeWord(5,5); // ¹æ¾î
            citem.S.MAC := citem.S.MAC + MakeWord(1,2); // ¸¶¹æ
         end
         else// 50~
         begin
            citem.S.DC  := citem.S.DC  + MakeWord(0,5); // °ø°Ý
          //  citem.S.MC  := citem.S.MC  + MakeWord(0,6); // ¸¶·Â
          //  citem.S.SC  := citem.S.SC  + MakeWord(0,6); // µµ·Â
            citem.S.AC  := citem.S.AC  + MakeWord(9,7); // ¹æ¾î
            citem.S.MAC := citem.S.MAC + MakeWord(2,4); // ¸¶¹æ
         end;

      end;

       if (Lv >= 42)and ( citem.s.AniCount =5 ) or ( citem.s.AniCount =6 )  then // ·¹º§¿¡µû¸¥ °ª º¯°æ
      begin

         if ( lv < 43 ) then // 20 ~ 29
         begin
         // ±âº»°ªÀ¸·Î ¼³Á¤
         end
         else if ( lv < 44 ) then // 30 ~ 39
         begin
//            citem.S.DC  := citem.S.DC  + MakeWord(0,1); // °ø°Ý
            citem.S.MC  := citem.S.MC  + MakeWord(0,2); // ¸¶·Â
//            citem.S.SC  := citem.S.SC  + MakeWord(0,2); // µµ·Â
            citem.S.AC  := citem.S.AC  + MakeWord(2,3); // ¹æ¾î
            citem.S.MAC := citem.S.MAC + MakeWord(0,2); // ¸¶¹æ
         end
         else if ( Lv < 45 ) then  // 40 ~ 49
         begin
//            citem.S.DC  := citem.S.DC  + MakeWord(0,3); // °ø°Ý
            citem.S.MC  := citem.S.MC  + MakeWord(0,4); // ¸¶·Â
          //  citem.S.SC  := citem.S.SC  + MakeWord(0,4); // µµ·Â
            citem.S.AC  := citem.S.AC  + MakeWord(5,5); // ¹æ¾î
            citem.S.MAC := citem.S.MAC + MakeWord(1,2); // ¸¶¹æ
         end
         else// 50~
         begin
         //   citem.S.DC  := citem.S.DC  + MakeWord(0,5); // ¹¥»÷
            citem.S.MC  := citem.S.MC  + MakeWord(0,6); // Ä§·¨
          //  citem.S.SC  := citem.S.SC  + MakeWord(0,6); // µÀÊõ
            citem.S.AC  := citem.S.AC  + MakeWord(9,7); // ·ÀÓù
            citem.S.MAC := citem.S.MAC + MakeWord(2,4); // Ä§Óò
         end;

      end;

        if (Lv >= 42)and ( citem.s.AniCount =1 ) or ( citem.s.AniCount =2 )  then // ·¹º§¿¡µû¸¥ °ª º¯°æ
      begin

         if ( lv < 43 ) then // 20 ~ 29
         begin
         // ±âº»°ªÀ¸·Î ¼³Á¤
         end
         else if ( lv < 44 ) then // 30 ~ 39
         begin
            citem.S.DC  := citem.S.DC  + MakeWord(0,1); // °ø°Ý
          //  citem.S.MC  := citem.S.MC  + MakeWord(0,2); // ¸¶·Â
            citem.S.SC  := citem.S.SC  + MakeWord(0,2); // µµ·Â
            citem.S.AC  := citem.S.AC  + MakeWord(2,3); // ¹æ¾î
            citem.S.MAC := citem.S.MAC + MakeWord(0,2); // ¸¶¹æ
         end
         else if ( Lv < 45 ) then  // 40 ~ 49
         begin
            citem.S.DC  := citem.S.DC  + MakeWord(0,3); // °ø°Ý
          //  citem.S.MC  := citem.S.MC  + MakeWord(0,4); // ¸¶·Â
            citem.S.SC  := citem.S.SC  + MakeWord(0,4); // µµ·Â
            citem.S.AC  := citem.S.AC  + MakeWord(5,5); // ¹æ¾î
            citem.S.MAC := citem.S.MAC + MakeWord(1,2); // ¸¶¹æ
         end
         else// 50~
         begin
            citem.S.DC  := citem.S.DC  + MakeWord(0,5); // ¹¥»÷
          //  citem.S.MC  := citem.S.MC  + MakeWord(0,6); // Ä§·¨
            citem.S.SC  := citem.S.SC  + MakeWord(0,6); // µÀÊõ
            citem.S.AC  := citem.S.AC  + MakeWord(9,7); // ·ÀÓù
            citem.S.MAC := citem.S.MAC + MakeWord(2,4); // Ä§Óò
         end;

      end;

   end else if (citem.S.StdMode = WEAPON_STDMODE1) or (citem.S.StdMode = WEAPON_STDMODE2) then begin
      //-------------------------------
      //¹ÝÂ¦ÀÌº¥Æ® (2004/08/09)
      if ItemIndex = 692 then begin
         //»¡°»ÀÌ´Â ÀúÁÖ ºÙÀ½.
         if PKLevel >= 2 then begin
            citem.S.MAC := citem.S.MAC + MakeWord(10,0);  //ÀúÁÖ
         end;
         //¹ÝÂ¦¹¬Ã»
         if ( lv < 30 ) then // 20 ~ 29
         begin
         // ±âº»°ªÀ¸·Î ¼³Á¤
         end
         else if ( lv < 40 ) then // 30 ~ 39
         begin
            citem.S.Weight := citem.S.Weight + 25;
            citem.S.DC  := citem.S.DC  + MakeWord(1,4); // °ø°Ý
         end
         else// 40~
         begin
            citem.S.Weight := citem.S.Weight + 50;
            citem.S.DC  := citem.S.DC  + MakeWord(2,7); // °ø°Ý
         end;
      end else if ItemIndex = 693 then begin
         //»¡°»ÀÌ´Â ÀúÁÖ ºÙÀ½.
         if PKLevel >= 2 then begin
            citem.S.MAC := citem.S.MAC + MakeWord(10,0);  //ÀúÁÖ
         end;
         //¹ÝÂ¦»ç°¢µµ
         if ( lv < 30 ) then // 20 ~ 29
         begin
         // ±âº»°ªÀ¸·Î ¼³Á¤
            //½Å¼º ¾ø¾Ú
            citem.S.SpecialPwr := citem.S.SpecialPwr + 1;
         end
         else if ( lv < 40 ) then // 30 ~ 39
         begin
            citem.S.Weight := citem.S.Weight + 8;
            citem.S.DC  := citem.S.DC  + MakeWord(0,2); // °ø°Ý
            citem.S.SC  := citem.S.SC  + MakeWord(1,1); // µµ·Â
         end
         else// 40~
         begin
            citem.S.Weight := citem.S.Weight + 16;
            citem.S.DC  := citem.S.DC  + MakeWord(1,5); // °ø°Ý
            citem.S.SC  := citem.S.SC  + MakeWord(2,1); // µµ·Â
         end;
      end else if ItemIndex = 694 then begin
         //»¡°»ÀÌ´Â ÀúÁÖ ºÙÀ½.
         if PKLevel >= 2 then begin
            citem.S.MAC := citem.S.MAC + MakeWord(10,0);  //ÀúÁÖ
         end;
         //¹ÝÂ¦ÃµÇü¸ñ
         if ( lv < 30 ) then // 20 ~ 29
         begin
         // ±âº»°ªÀ¸·Î ¼³Á¤
         end
         else if ( lv < 40 ) then // 30 ~ 39
         begin
            citem.S.Weight := citem.S.Weight + 6;
            citem.S.DC  := citem.S.DC  + MakeWord(1,1); // °ø°Ý
            citem.S.MC  := citem.S.MC  + MakeWord(0,2); // ¸¶·Â
         end
         else// 40~
         begin
            citem.S.Weight := citem.S.Weight + 10;
            citem.S.DC  := citem.S.DC  + MakeWord(2,2); // °ø°Ý
            citem.S.MC  := citem.S.MC  + MakeWord(0,3); // ¸¶·Â
         end;
      //-------------------------------
      //¹ÝÂ¦ÀÌº¥Æ®2Â÷ (2004/08/13)
      end else if ItemIndex = 697 then begin
         //»¡°»ÀÌ´Â ÀúÁÖ ºÙÀ½.
         if PKLevel >= 2 then begin
            citem.S.MAC := citem.S.MAC + MakeWord(10,0);  //ÀúÁÖ
         end;
         //¹ÝÂ¦µ¶°í
         if ( lv < 30 ) then // 20 ~ 29
         begin
         // ±âº»°ªÀ¸·Î ¼³Á¤
         end
         else if ( lv < 40 ) then // 30 ~ 39
         begin
            citem.S.Weight := citem.S.Weight + 36;
            citem.S.DC  := citem.S.DC  + MakeWord(1,4); // °ø°Ý
         end
         else// 40~
         begin
            citem.S.Weight := citem.S.Weight + 57;
            citem.S.DC  := citem.S.DC  + MakeWord(2,10); // °ø°Ý
         end;
      end else if ItemIndex = 698 then begin
         //»¡°»ÀÌ´Â ÀúÁÖ ºÙÀ½.
         if PKLevel >= 2 then begin
            citem.S.MAC := citem.S.MAC + MakeWord(10,0);  //ÀúÁÖ
         end;
         //¹ÝÂ¦ÅÂ±Ø
         if ( lv < 30 ) then // 20 ~ 29
         begin
         // ±âº»°ªÀ¸·Î ¼³Á¤
            //½Å¼º 2 ÁÙÀÓ
            citem.S.SpecialPwr := citem.S.SpecialPwr + 2;
         end
         else if ( lv < 40 ) then // 30 ~ 39
         begin
            citem.S.Weight := citem.S.Weight + 9;
            citem.S.DC  := citem.S.DC  + MakeWord(1,4); // °ø°Ý
            citem.S.SC  := citem.S.SC  + MakeWord(1,2); // µµ·Â
         end
         else// 40~
         begin
            citem.S.Weight := citem.S.Weight + 24;
            citem.S.DC  := citem.S.DC  + MakeWord(2,8); // °ø°Ý
            citem.S.SC  := citem.S.SC  + MakeWord(2,3); // µµ·Â
         end;
      end else if ItemIndex = 699 then begin
         //»¡°»ÀÌ´Â ÀúÁÖ ºÙÀ½.
         if PKLevel >= 2 then begin
            citem.S.MAC := citem.S.MAC + MakeWord(10,0);  //ÀúÁÖ
         end;
         //¹ÝÂ¦¿µ»ç
         if ( lv < 30 ) then // 20 ~ 29
         begin
         // ±âº»°ªÀ¸·Î ¼³Á¤
         end
         else if ( lv < 40 ) then // 30 ~ 39
         begin
            citem.S.Weight := citem.S.Weight + 5;
            citem.S.DC  := citem.S.DC  + MakeWord(1,1); // °ø°Ý
            citem.S.MC  := citem.S.MC  + MakeWord(0,2); // ¸¶·Â
         end
         else// 40~
         begin
            citem.S.Weight := citem.S.Weight + 9;
            citem.S.DC  := citem.S.DC  + MakeWord(2,2); // °ø°Ý
            citem.S.MC  := citem.S.MC  + MakeWord(0,4); // ¸¶·Â
         end;
      end;

   end;
end;

//Á÷¾÷¿¡ µû¸¥ ´É·ÂÄ¡ Àû¿ë(sonmg)
procedure TCreature.ChangeItemByJob ( var citem :TClientItem ; lv :integer );
begin
   // ÁÖÀÇ : ApplyItemParametersByJob °ú µ¿ÀÏÇÑ °ªÀ» °¡Á®¾ß ÇÔ(sonmg)

      //////////////////////////////////////
      //--------------
      //¹ÝÁö
      if (citem.S.StdMode = 22) and (citem.S.Shape = DRAGON_RING_SHAPE) then begin
         case Job of
         0: //Àü»ç
            begin
               citem.S.DC := MakeWord (Lobyte(citem.S.DC), _MIN(255, Hibyte(citem.S.DC) + 4));   //ÇÏµåÄÚµù
               citem.S.MC := 0;
               citem.S.SC := 0;
            end;
         1: //¼ú»ç
            begin
               citem.S.DC := 0;
//±×´ë·Î               citem.S.MC := 0;
               citem.S.SC := 0;
            end;
         2: //µµ»ç
            begin
//               citem.S.DC := 0;
               citem.S.MC := 0;
//               citem.S.SC := 0;
            end;
         end;//case
      //--------------
      //ÆÈÂî26
      end else if (citem.S.StdMode = 26) and (citem.S.Shape = DRAGON_BRACELET_SHAPE) then begin
         case Job of
         0: //Àü»ç
            begin
               citem.S.DC := MakeWord (Lobyte(citem.S.DC) + 1, _MIN(255, Hibyte(citem.S.DC) + 2));   //ÇÏµåÄÚµù
               citem.S.MC := 0;
               citem.S.SC := 0;
               citem.S.AC := MakeWord (Lobyte(citem.S.AC), _MIN(255, Hibyte(citem.S.AC) + 1));   //ÇÏµåÄÚµù
            end;
         1: //¼ú»ç
            begin
               citem.S.DC := 0;
//               citem.S.MC := 0;
               citem.S.SC := 0;
               citem.S.AC := MakeWord (Lobyte(citem.S.AC), _MIN(255, Hibyte(citem.S.AC) + 1));   //ÇÏµåÄÚµù
            end;
         2: //µµ»ç
            begin
//               citem.S.DC := 0;
               citem.S.MC := 0;
//               citem.S.SC := 0;
//               citem.S.AC := 0;
            end;
         end;//case
      //--------------
      //¸ñ°ÉÀÌ
      end else if (citem.S.StdMode = 19) and (citem.S.Shape = DRAGON_NECKLACE_SHAPE) then begin
         case Job of
         0: //Àü»ç
            begin
//               citem.S.DC := 0;
               citem.S.MC := 0;
               citem.S.SC := 0;
            end;
         1: //¼ú»ç
            begin
               citem.S.DC := 0;
//               citem.S.MC := 0;
               citem.S.SC := 0;
            end;
         2: //µµ»ç
            begin
               citem.S.DC := 0;
               citem.S.MC := 0;
//               citem.S.SC := 0;
            end;
         end;//case
      //--------------
      //¿Ê
      end else if ((citem.S.StdMode = 10) or (citem.S.StdMode = 11)) and (citem.S.Shape = DRAGON_DRESS_SHAPE) then begin
         case Job of
         0: //Àü»ç
            begin
//               citem.S.DC := 0;
               citem.S.MC := 0;
               citem.S.SC := 0;
            end;
         1: //¼ú»ç
            begin
               citem.S.DC := 0;
//               citem.S.MC := 0;
               citem.S.SC := 0;
            end;
         2: //µµ»ç
            begin
               citem.S.DC := 0;
               citem.S.MC := 0;
//               citem.S.SC := 0;
            end;
         end;//case
      //--------------
      //Åõ±¸
      end else if (citem.S.StdMode = 15) and (citem.S.Shape = DRAGON_HELMET_SHAPE) then begin
         case Job of
         0: //Àü»ç
            begin
//               citem.S.DC := 0;
               citem.S.MC := 0;
               citem.S.SC := 0;
            end;
         1: //¼ú»ç
            begin
               citem.S.DC := 0;
//               citem.S.MC := 0;
               citem.S.SC := 0;
            end;
         2: //µµ»ç
            begin
               citem.S.DC := 0;
               citem.S.MC := 0;
//               citem.S.SC := 0;
            end;
         end;//case
      //--------------
      //¹«±â   ¸ü¾ßÖ°ÒµËø¶¨ÊôÐÔ
      end else if ((citem.S.StdMode = 5) or (citem.S.StdMode = 6)) and (citem.S.Shape = DRAGON_WEAPON_SHAPE) then begin
         case Job of
         0: //Àü»ç
            begin
               citem.S.DC := MakeWord (Lobyte(citem.S.DC) + 1, _MIN(255, Hibyte(citem.S.DC) + 28));   //ÇÏµåÄÚµù
               citem.S.MC := 0;
               citem.S.SC := 0;
               // Çà¿î¿¡¼­ 2¸¦ »«´Ù. Áï, Lo(AC)¿¡¼­ 2¸¦ »«´Ù.
               citem.S.AC := MakeWord(LOBYTE(citem.S.AC) -2, HIBYTE(citem.S.AC));

               // Çà¿îÀ» °ø¼ÓÀ¸·Î ¹Ù²Ù°í Çà¿îÀ» ¾ø¾Ø´Ù.
               // Lo(AC)¸¦ Hi(MAC)¿¡ Áý¾î ³Ö´Â´Ù.
//               std.MAC := MakeWord(LOBYTE(std.MAC), LOBYTE(std.AC) + 10);
//               std.AC := MakeWord(0, HIBYTE(std.AC));
            end;
         1: //¼ú»ç
            begin
//               citem.S.DC := 0;
//               citem.S.MC := 0;
               citem.S.SC := 0;
               // °ø¼Ó¿¡¼­ 12¸¦ »©°í Çà¿î°ªÀº ¹Ý¿µÇÑ´Ù.
               if HIBYTE(citem.S.MAC) > 12 then
                  citem.S.MAC := MakeWord(LOBYTE(citem.S.MAC), HIBYTE(citem.S.MAC) - 12)
               else
                  citem.S.MAC := MakeWord(LOBYTE(citem.S.MAC), 0);

            end;
         2: //µµ»ç
            begin
               citem.S.DC := MakeWord (Lobyte(citem.S.DC) + 2, _MIN(255, Hibyte(citem.S.DC) + 10));   //ÇÏµåÄÚµù
               citem.S.MC := 0;
//               citem.S.SC := 0;
               // Çà¿î¿¡¼­ 2¸¦ »«´Ù. Áï, Lo(AC)¿¡¼­ 2¸¦ »«´Ù.
               citem.S.AC := MakeWord(LOBYTE(citem.S.AC) -2, HIBYTE(citem.S.AC));

               // Çà¿îÀ» °ø¼ÓÀ¸·Î ¹Ù²Ù°í Çà¿îÀ» ¾ø¾Ø´Ù.
               // Lo(AC)¸¦ Hi(MAC)¿¡ Áý¾î ³Ö´Â´Ù.
//               std.MAC := MakeWord(LOBYTE(std.MAC), LOBYTE(std.AC) + 10);
//               std.AC := MakeWord(0, HIBYTE(std.AC));
            end;
         end;//case
      //--------------
      //¼öÈ£¼®(¸·´ë»çÅÁ)
      end else if (citem.S.StdMode = 53) then begin
         if (citem.S.Shape = LOLLIPOP_SHAPE) then begin
            case Job of
            0: //Àü»ç
               begin
                  citem.S.DC := MakeWord (Lobyte(citem.S.DC), _MIN(255, Hibyte(citem.S.DC) + 2));  //ÇÏµåÄÚµù
                  citem.S.MC := 0;
                  citem.S.SC := 0;
               end;
            1: //¼ú»ç
               begin
                  citem.S.DC := 0;
                  citem.S.MC := MakeWord (Lobyte(citem.S.MC), _MIN(255, Hibyte(citem.S.MC) + 2));  //ÇÏµåÄÚµù
                  citem.S.SC := 0;
               end;
            2: //µµ»ç
               begin
                  citem.S.DC := 0;
                  citem.S.MC := 0;
                  citem.S.SC := MakeWord (Lobyte(citem.S.SC), _MIN(255, Hibyte(citem.S.SC) + 2));  //ÇÏµåÄÚµù
               end;
            end;//case
         end else if (citem.S.Shape = GOLDMEDAL_SHAPE) or (citem.S.Shape = SILVERMEDAL_SHAPE) or (citem.S.Shape = BRONZEMEDAL_SHAPE) then begin
            case Job of
            0: //Àü»ç
               begin
                  citem.S.DC := MakeWord (Lobyte(citem.S.DC), _MIN(255, Hibyte(citem.S.DC)));
                  citem.S.MC := 0;
                  citem.S.SC := 0;
               end;
            1: //¼ú»ç
               begin
                  citem.S.DC := 0;
                  citem.S.MC := MakeWord (Lobyte(citem.S.MC), _MIN(255, Hibyte(citem.S.MC)));
                  citem.S.SC := 0;
               end;
            2: //µµ»ç
               begin
                  citem.S.DC := 0;
                  citem.S.MC := 0;
                  citem.S.SC := MakeWord (Lobyte(citem.S.SC), _MIN(255, Hibyte(citem.S.SC)));
               end;
            end;//case
         end;
      end;//if series
      //////////////////////////////////////
      // 2004-06-29 ½Å±Ô°©¿Ê(ÆÄÈ²Ãµ¸¶ÀÇ) Á÷¾÷º° ´É·ÂÄ¡
      if ((citem.S.StdMode = 10) or (citem.S.StdMode = 11)) and (citem.S.Shape = DRESS_SHAPE_PBKING) then begin
         case Job of
         0: //Àü»ç
            begin
               citem.S.DC := MakeWord (Lobyte(citem.S.DC), _MIN(255, Hibyte(citem.S.DC) + 2));   //ÇÏµåÄÚµù
               citem.S.MC := 0;
               citem.S.SC := 0;
               citem.S.AC := MakeWord (Lobyte(citem.S.AC) + 2, _MIN(255, Hibyte(citem.S.AC) + 4));   //ÇÏµåÄÚµù
//               citem.S.MAC := 0;
               citem.S.MpAdd := citem.S.MpAdd + 30;   //ÇÏµåÄÚµù
            end;
         1: //¼ú»ç
            begin
               citem.S.DC := 0;
//               citem.S.MC := 0;
               citem.S.SC := 0;
//               citem.S.AC := 0;
               citem.S.MAC := MakeWord (Lobyte(citem.S.MAC) + 1, _MIN(255, Hibyte(citem.S.MAC) + 2));   //ÇÏµåÄÚµù
               citem.S.HpAdd := citem.S.HpAdd + 30;   //ÇÏµåÄÚµù
            end;
         2: //µµ»ç
            begin
               citem.S.DC := MakeWord (Lobyte(citem.S.DC) + 1, _MIN(255, Hibyte(citem.S.DC)));   //ÇÏµåÄÚµù
               citem.S.MC := 0;
//               citem.S.SC := 0;
               citem.S.AC := MakeWord (Lobyte(citem.S.AC) + 1, _MIN(255, Hibyte(citem.S.AC)));   //ÇÏµåÄÚµù
               citem.S.MAC := MakeWord (Lobyte(citem.S.MAC) + 1, _MIN(255, Hibyte(citem.S.MAC)));   //ÇÏµåÄÚµù
               citem.S.HpAdd := citem.S.HpAdd + 20;   //ÇÏµåÄÚµù
               citem.S.MpAdd := citem.S.MpAdd + 10;   //ÇÏµåÄÚµù
            end;
         end;//case
      end;

end;

procedure TCreature.BanjjakChangeItemByJob ( var citem :TClientItem ; lv :integer );
begin
   // ÁÖÀÇ : BanjjakApplyItemParametersByJob °ú µ¿ÀÏÇÑ °ªÀ» °¡Á®¾ß ÇÔ(sonmg)

{
      //////////////////////////////////////
      //--------------
      //¹ÝÁö
      if (citem.S.StdMode = 22) and (citem.S.Shape = DRAGON_RING_SHAPE) then begin
         case Job of
         0: //Àü»ç
            begin
               citem.S.DC := MakeWord (Lobyte(citem.S.DC), _MIN(255, Hibyte(citem.S.DC) + 4));   //ÇÏµåÄÚµù
               citem.S.MC := 0;
               citem.S.SC := 0;
            end;
         1: //¼ú»ç
            begin
               citem.S.DC := 0;
//±×´ë·Î               citem.S.MC := 0;
               citem.S.SC := 0;
            end;
         2: //µµ»ç
            begin
//               citem.S.DC := 0;
               citem.S.MC := 0;
//               citem.S.SC := 0;
            end;
         end;//case
      //--------------
      //ÆÈÂî26
      end else if (citem.S.StdMode = 26) and (citem.S.Shape = DRAGON_BRACELET_SHAPE) then begin
         case Job of
         0: //Àü»ç
            begin
               citem.S.DC := MakeWord (Lobyte(citem.S.DC) + 1, _MIN(255, Hibyte(citem.S.DC) + 2));   //ÇÏµåÄÚµù
               citem.S.MC := 0;
               citem.S.SC := 0;
               citem.S.AC := MakeWord (Lobyte(citem.S.AC), _MIN(255, Hibyte(citem.S.AC) + 1));   //ÇÏµåÄÚµù
            end;
         1: //¼ú»ç
            begin
               citem.S.DC := 0;
//               citem.S.MC := 0;
               citem.S.SC := 0;
               citem.S.AC := MakeWord (Lobyte(citem.S.AC), _MIN(255, Hibyte(citem.S.AC) + 1));   //ÇÏµåÄÚµù
            end;
         2: //µµ»ç
            begin
//               citem.S.DC := 0;
               citem.S.MC := 0;
//               citem.S.SC := 0;
//               citem.S.AC := 0;
            end;
         end;//case
      //--------------
      //¸ñ°ÉÀÌ
      end else if (citem.S.StdMode = 19) and (citem.S.Shape = DRAGON_NECKLACE_SHAPE) then begin
         case Job of
         0: //Àü»ç
            begin
//               citem.S.DC := 0;
               citem.S.MC := 0;
               citem.S.SC := 0;
            end;
         1: //¼ú»ç
            begin
               citem.S.DC := 0;
//               citem.S.MC := 0;
               citem.S.SC := 0;
            end;
         2: //µµ»ç
            begin
               citem.S.DC := 0;
               citem.S.MC := 0;
//               citem.S.SC := 0;
            end;
         end;//case
      //--------------
      //Åõ±¸
      end else if (citem.S.StdMode = 15) and (citem.S.Shape = DRAGON_HELMET_SHAPE) then begin
         case Job of
         0: //Àü»ç
            begin
//               citem.S.DC := 0;
               citem.S.MC := 0;
               citem.S.SC := 0;
            end;
         1: //¼ú»ç
            begin
               citem.S.DC := 0;
//               citem.S.MC := 0;
               citem.S.SC := 0;
            end;
         2: //µµ»ç
            begin
               citem.S.DC := 0;
               citem.S.MC := 0;
//               citem.S.SC := 0;
            end;
         end;//case
      //--------------
      //¿Ê
      end else } if ((citem.S.StdMode = 10) or (citem.S.StdMode = 11)) and (citem.S.Shape = DRAGON_DRESS_SHAPE) then begin
         //¹ÝÂ¦ÀÌº¥Æ® 3Â÷
         case Job of
         0: //Àü»ç
            begin
               //°øÅëÀû¿ë
               citem.S.MC := 0;
               citem.S.SC := 0;

               //50ÀÌÇÏ °øÅë Àû¿ë
               if lv < 50 then begin
                  // HPÈ¸º¹·®, MPÈ¸º¹·® ±â´É »èÁ¦
                  if citem.S.EffType1 > 0 then begin
                     case citem.S.EffType1 of
                        EFFTYPE_HP_MP_ADD: //HP È¹º¹·®, MP È¸º¹·®
                        begin
                           //±â´É ÀÚÃ¼¸¦ ¾ø¾Ú
                           citem.S.EffType1 := 0;
                           //HP È¹º¹·®
                           citem.S.EffRate1 := 0;
                           //MP È¹º¹·®
                           citem.S.EffValue1 := 0;
                        end;
                     end;
                  end;
                  if citem.S.EffType2 > 0 then begin
                     case citem.S.EffType2 of
                        EFFTYPE_HP_MP_ADD: //HP È¹º¹·®, MP È¸º¹·®
                        begin
                           //±â´É ÀÚÃ¼¸¦ ¾ø¾Ú
                           citem.S.EffType2 := 0;
                           //HP È¹º¹·®
                           citem.S.EffRate2 := 0;
                           //MP È¹º¹·®
                           citem.S.EffValue2 := 0;
                        end;
                     end;
                  end;
               end;

               //·¹º§º° Àû¿ë
               if lv < 30 then begin
                  //±âº»°ª
               end else if lv < 40 then begin
                  citem.S.DC := MakeWord (Lobyte(citem.S.DC), _MIN(255, Hibyte(citem.S.DC) + 1));   //ÇÏµåÄÚµù
                  citem.S.AC := MakeWord (Lobyte(citem.S.AC) + 2, _MIN(255, Hibyte(citem.S.AC) + 3));   //ÇÏµåÄÚµù
                  citem.S.MAC := MakeWord (Lobyte(citem.S.MAC) + 1, _MIN(255, Hibyte(citem.S.MAC) + 3));   //ÇÏµåÄÚµù
               end else if lv < 50 then begin
                  citem.S.DC := MakeWord (Lobyte(citem.S.DC) + 1, _MIN(255, Hibyte(citem.S.DC) + 2));   //ÇÏµåÄÚµù
                  citem.S.AC := MakeWord (Lobyte(citem.S.AC) + 5, _MIN(255, Hibyte(citem.S.AC) + 6));   //ÇÏµåÄÚµù
                  citem.S.MAC := MakeWord (Lobyte(citem.S.MAC) + 2, _MIN(255, Hibyte(citem.S.MAC) + 4));   //ÇÏµåÄÚµù
               end else begin
                  citem.S.DC := MakeWord (Lobyte(citem.S.DC) + 1, _MIN(255, Hibyte(citem.S.DC) + 3));   //ÇÏµåÄÚµù
                  citem.S.AC := MakeWord (Lobyte(citem.S.AC) + 8, _MIN(255, Hibyte(citem.S.AC) + 9));   //ÇÏµåÄÚµù
                  citem.S.MAC := MakeWord (Lobyte(citem.S.MAC) + 2, _MIN(255, Hibyte(citem.S.MAC) + 7));   //ÇÏµåÄÚµù
               end;
            end;
         1: //¼ú»ç
            begin
               //°øÅëÀû¿ë
               citem.S.DC := 0;
               citem.S.SC := 0;

               //50ÀÌÇÏ °øÅë Àû¿ë
               if lv < 50 then begin
                  // HPÈ¸º¹·®, MPÈ¸º¹·® ±â´É »èÁ¦
                  if citem.S.EffType1 > 0 then begin
                     case citem.S.EffType1 of
                        EFFTYPE_HP_MP_ADD: //HP È¹º¹·®, MP È¸º¹·®
                        begin
                           //±â´É ÀÚÃ¼¸¦ ¾ø¾Ú
                           citem.S.EffType1 := 0;
                           //HP È¹º¹·®
                           citem.S.EffRate1 := 0;
                           //MP È¹º¹·®
                           citem.S.EffValue1 := 0;
                        end;
                     end;
                  end;
                  if citem.S.EffType2 > 0 then begin
                     case citem.S.EffType2 of
                        EFFTYPE_HP_MP_ADD: //HP È¹º¹·®, MP È¸º¹·®
                        begin
                           //±â´É ÀÚÃ¼¸¦ ¾ø¾Ú
                           citem.S.EffType2 := 0;
                           //HP È¹º¹·®
                           citem.S.EffRate2 := 0;
                           //MP È¹º¹·®
                           citem.S.EffValue2 := 0;
                        end;
                     end;
                  end;
               end;

               //·¹º§º° Àû¿ë
               if lv < 30 then begin
                  //±âº»°ª
               end else if lv < 40 then begin
                  citem.S.MC := MakeWord (Lobyte(citem.S.MC), _MIN(255, Hibyte(citem.S.MC) + 2));   //ÇÏµåÄÚµù
                  citem.S.AC := MakeWord (Lobyte(citem.S.AC) + 2, _MIN(255, Hibyte(citem.S.AC) + 3));   //ÇÏµåÄÚµù
                  citem.S.MAC := MakeWord (Lobyte(citem.S.MAC) + 1, _MIN(255, Hibyte(citem.S.MAC) + 3));   //ÇÏµåÄÚµù
               end else if lv < 50 then begin
                  citem.S.MC := MakeWord (Lobyte(citem.S.MC) + 1, _MIN(255, Hibyte(citem.S.MC) + 4));   //ÇÏµåÄÚµù
                  citem.S.AC := MakeWord (Lobyte(citem.S.AC) + 5, _MIN(255, Hibyte(citem.S.AC) + 6));   //ÇÏµåÄÚµù
                  citem.S.MAC := MakeWord (Lobyte(citem.S.MAC) + 2, _MIN(255, Hibyte(citem.S.MAC) + 4));   //ÇÏµåÄÚµù
               end else begin
                  citem.S.MC := MakeWord (Lobyte(citem.S.MC) + 1, _MIN(255, Hibyte(citem.S.MC) + 6));   //ÇÏµåÄÚµù
                  citem.S.AC := MakeWord (Lobyte(citem.S.AC) + 8, _MIN(255, Hibyte(citem.S.AC) + 9));   //ÇÏµåÄÚµù
                  citem.S.MAC := MakeWord (Lobyte(citem.S.MAC) + 2, _MIN(255, Hibyte(citem.S.MAC) + 7));   //ÇÏµåÄÚµù
               end;
            end;
         2: //µµ»ç
            begin
               //°øÅëÀû¿ë
               citem.S.DC := 0;
               citem.S.MC := 0;

               //50ÀÌÇÏ °øÅë Àû¿ë
               if lv < 50 then begin
                  // HPÈ¸º¹·®, MPÈ¸º¹·® ±â´É »èÁ¦
                  if citem.S.EffType1 > 0 then begin
                     case citem.S.EffType1 of
                        EFFTYPE_HP_MP_ADD: //HP È¹º¹·®, MP È¸º¹·®
                        begin
                           //±â´É ÀÚÃ¼¸¦ ¾ø¾Ú
                           citem.S.EffType1 := 0;
                           //HP È¹º¹·®
                           citem.S.EffRate1 := 0;
                           //MP È¹º¹·®
                           citem.S.EffValue1 := 0;
                        end;
                     end;
                  end;
                  if citem.S.EffType2 > 0 then begin
                     case citem.S.EffType2 of
                        EFFTYPE_HP_MP_ADD: //HP È¹º¹·®, MP È¸º¹·®
                        begin
                           //±â´É ÀÚÃ¼¸¦ ¾ø¾Ú
                           citem.S.EffType2 := 0;
                           //HP È¹º¹·®
                           citem.S.EffRate2 := 0;
                           //MP È¹º¹·®
                           citem.S.EffValue2 := 0;
                        end;
                     end;
                  end;
               end;

               //·¹º§º° Àû¿ë
               if lv < 30 then begin
                  //±âº»°ª
               end else if lv < 40 then begin
                  citem.S.SC := MakeWord (Lobyte(citem.S.SC), _MIN(255, Hibyte(citem.S.SC) + 2));   //ÇÏµåÄÚµù
                  citem.S.AC := MakeWord (Lobyte(citem.S.AC) + 2, _MIN(255, Hibyte(citem.S.AC) + 3));   //ÇÏµåÄÚµù
                  citem.S.MAC := MakeWord (Lobyte(citem.S.MAC) + 1, _MIN(255, Hibyte(citem.S.MAC) + 3));   //ÇÏµåÄÚµù
               end else if lv < 50 then begin
                  citem.S.SC := MakeWord (Lobyte(citem.S.SC) + 1, _MIN(255, Hibyte(citem.S.SC) + 4));   //ÇÏµåÄÚµù
                  citem.S.AC := MakeWord (Lobyte(citem.S.AC) + 5, _MIN(255, Hibyte(citem.S.AC) + 6));   //ÇÏµåÄÚµù
                  citem.S.MAC := MakeWord (Lobyte(citem.S.MAC) + 2, _MIN(255, Hibyte(citem.S.MAC) + 4));   //ÇÏµåÄÚµù
               end else begin
                  citem.S.SC := MakeWord (Lobyte(citem.S.SC) + 1, _MIN(255, Hibyte(citem.S.SC) + 6));   //ÇÏµåÄÚµù
                  citem.S.AC := MakeWord (Lobyte(citem.S.AC) + 8, _MIN(255, Hibyte(citem.S.AC) + 9));   //ÇÏµåÄÚµù
                  citem.S.MAC := MakeWord (Lobyte(citem.S.MAC) + 2, _MIN(255, Hibyte(citem.S.MAC) + 7));   //ÇÏµåÄÚµù
               end;
            end;
         end;//case
      //--------------
      //¹«±â
      end else if ((citem.S.StdMode = 5) or (citem.S.StdMode = 6)) and (citem.S.Shape = DRAGON_WEAPON_SHAPE) then begin
         //»¡°»ÀÌ´Â ÀúÁÖ ºÙÀ½.
         if PKLevel >= 2 then begin
            citem.S.MAC := citem.S.MAC + MakeWord(10,0);  //ÀúÁÖ
         end;
         //¹ÝÂ¦ÀÌº¥Æ® 3Â÷
         case Job of
         0: //Àü»ç
            begin
               //°øÅëÀû¿ë
               citem.S.MC := 0;
               citem.S.SC := 0;
               // Çà¿î¿¡¼­ 2¸¦ »«´Ù. Áï, Lo(AC)¿¡¼­ 2¸¦ »«´Ù.
               citem.S.AC := MakeWord(LOBYTE(citem.S.AC) -2, HIBYTE(citem.S.AC));

               //50ÀÌÇÏ °øÅë Àû¿ë
               if lv < 50 then begin
                  // °ø¼Ó¿¡¼­ 12¸¦ »«´Ù.
                  if HIBYTE(citem.S.MAC) > 12 then
                     citem.S.MAC := MakeWord(LOBYTE(citem.S.MAC), HIBYTE(citem.S.MAC) - 12)
                  else
                     citem.S.MAC := MakeWord(LOBYTE(citem.S.MAC), 0);
               end;

               //·¹º§º° Àû¿ë
               if lv < 30 then begin
                  citem.S.DC := MakeWord (Lobyte(citem.S.DC) - 1, _MIN(255, Hibyte(citem.S.DC) + 11));   //ÇÏµåÄÚµù
               end else if lv < 40 then begin
                  citem.S.DC := MakeWord (Lobyte(citem.S.DC), _MIN(255, Hibyte(citem.S.DC) + 17));   //ÇÏµåÄÚµù
               end else if lv < 50 then begin
                  citem.S.DC := MakeWord (Lobyte(citem.S.DC) + 1, _MIN(255, Hibyte(citem.S.DC) + 24));   //ÇÏµåÄÚµù
               end else begin
                  citem.S.DC := MakeWord (Lobyte(citem.S.DC) + 2, _MIN(255, Hibyte(citem.S.DC) + 32));   //ÇÏµåÄÚµù
               end;
            end;
         1: //¼ú»ç
            begin
               //°øÅëÀû¿ë
               citem.S.SC := 0;
               // °ø¼Ó¿¡¼­ 12¸¦ »«´Ù.
               if HIBYTE(citem.S.MAC) > 12 then
                  citem.S.MAC := MakeWord(LOBYTE(citem.S.MAC), HIBYTE(citem.S.MAC) - 12)
               else
                  citem.S.MAC := MakeWord(LOBYTE(citem.S.MAC), 0);

               //50ÀÌÇÏ °øÅë Àû¿ë
               if lv < 50 then begin
                  // Çà¿î¿¡¼­ 2¸¦ »«´Ù. Áï, Lo(AC)¿¡¼­ 2¸¦ »«´Ù.
                  citem.S.AC := MakeWord(LOBYTE(citem.S.AC) -2, HIBYTE(citem.S.AC));
               end;

               //·¹º§º° Àû¿ë
               if lv < 30 then begin
                  //±âº»°ª
               end else if lv < 40 then begin
                  citem.S.DC := MakeWord (Lobyte(citem.S.DC) + 1, _MIN(255, Hibyte(citem.S.DC) + 1));   //ÇÏµåÄÚµù
                  citem.S.MC := MakeWord (Lobyte(citem.S.MC) + 1, _MIN(255, Hibyte(citem.S.MC) + 2));  //ÇÏµåÄÚµù
               end else if lv < 50 then begin
                  citem.S.DC := MakeWord (Lobyte(citem.S.DC) + 2, _MIN(255, Hibyte(citem.S.DC) + 2));   //ÇÏµåÄÚµù
                  citem.S.MC := MakeWord (Lobyte(citem.S.MC) + 1, _MIN(255, Hibyte(citem.S.MC) + 4));  //ÇÏµåÄÚµù
               end else begin
                  citem.S.DC := MakeWord (Lobyte(citem.S.DC) + 3, _MIN(255, Hibyte(citem.S.DC) + 4));   //ÇÏµåÄÚµù
                  citem.S.MC := MakeWord (Lobyte(citem.S.MC) + 2, _MIN(255, Hibyte(citem.S.MC) + 7));  //ÇÏµåÄÚµù
               end;
            end;
         2: //µµ»ç
            begin
               //°øÅëÀû¿ë
               citem.S.MC := 0;
               // Çà¿î¿¡¼­ 2¸¦ »«´Ù. Áï, Lo(AC)¿¡¼­ 2¸¦ »«´Ù.
               citem.S.AC := MakeWord(LOBYTE(citem.S.AC) -2, HIBYTE(citem.S.AC));

               //50ÀÌÇÏ °øÅë Àû¿ë
               if lv < 50 then begin
                  // °ø¼Ó¿¡¼­ 12¸¦ »«´Ù.
                  if HIBYTE(citem.S.MAC) > 12 then
                     citem.S.MAC := MakeWord(LOBYTE(citem.S.MAC), HIBYTE(citem.S.MAC) - 12)
                  else
                     citem.S.MAC := MakeWord(LOBYTE(citem.S.MAC), 0);
               end;

               //·¹º§º° Àû¿ë
               if lv < 30 then begin
                  citem.S.DC := MakeWord (Lobyte(citem.S.DC) + 1, _MIN(255, Hibyte(citem.S.DC) - 2));   //ÇÏµåÄÚµù
               end else if lv < 40 then begin
                  citem.S.DC := MakeWord (Lobyte(citem.S.DC) + 2, _MIN(255, Hibyte(citem.S.DC) + 2));   //ÇÏµåÄÚµù
                  citem.S.SC := MakeWord (Lobyte(citem.S.SC), _MIN(255, Hibyte(citem.S.SC) + 2));  //ÇÏµåÄÚµù
               end else if lv < 50 then begin
                  citem.S.DC := MakeWord (Lobyte(citem.S.DC) + 3, _MIN(255, Hibyte(citem.S.DC) + 6));   //ÇÏµåÄÚµù
                  citem.S.SC := MakeWord (Lobyte(citem.S.SC) + 1, _MIN(255, Hibyte(citem.S.SC) + 3));  //ÇÏµåÄÚµù
               end else begin
                  citem.S.DC := MakeWord (Lobyte(citem.S.DC) + 4, _MIN(255, Hibyte(citem.S.DC) + 12));   //ÇÏµåÄÚµù
                  citem.S.SC := MakeWord (Lobyte(citem.S.SC) + 2, _MIN(255, Hibyte(citem.S.SC) + 6));  //ÇÏµåÄÚµù
               end;
            end;
         end;//case
{
      //--------------
      //¼öÈ£¼®(¸·´ë»çÅÁ)
      end else if (citem.S.StdMode = 53) then begin
         if (citem.S.Shape = LOLLIPOP_SHAPE) then begin
            case Job of
            0: //Àü»ç
               begin
                  citem.S.DC := MakeWord (Lobyte(citem.S.DC), _MIN(255, Hibyte(citem.S.DC) + 2));  //ÇÏµåÄÚµù
                  citem.S.MC := 0;
                  citem.S.SC := 0;
               end;
            1: //¼ú»ç
               begin
                  citem.S.DC := 0;
                  citem.S.MC := MakeWord (Lobyte(citem.S.MC), _MIN(255, Hibyte(citem.S.MC) + 2));  //ÇÏµåÄÚµù
                  citem.S.SC := 0;
               end;
            2: //µµ»ç
               begin
                  citem.S.DC := 0;
                  citem.S.MC := 0;
                  citem.S.SC := MakeWord (Lobyte(citem.S.SC), _MIN(255, Hibyte(citem.S.SC) + 2));  //ÇÏµåÄÚµù
               end;
            end;//case
         end else if (citem.S.Shape = GOLDMEDAL_SHAPE) or (citem.S.Shape = SILVERMEDAL_SHAPE) or (citem.S.Shape = BRONZEMEDAL_SHAPE) then begin
            case Job of
            0: //Àü»ç
               begin
                  citem.S.DC := MakeWord (Lobyte(citem.S.DC), _MIN(255, Hibyte(citem.S.DC)));
                  citem.S.MC := 0;
                  citem.S.SC := 0;
               end;
            1: //¼ú»ç
               begin
                  citem.S.DC := 0;
                  citem.S.MC := MakeWord (Lobyte(citem.S.MC), _MIN(255, Hibyte(citem.S.MC)));
                  citem.S.SC := 0;
               end;
            2: //µµ»ç
               begin
                  citem.S.DC := 0;
                  citem.S.MC := 0;
                  citem.S.SC := MakeWord (Lobyte(citem.S.SC), _MIN(255, Hibyte(citem.S.SC)));
               end;
            end;//case
         end;
      end;//if series
      //////////////////////////////////////
      // 2004-06-29 ½Å±Ô°©¿Ê(ÆÄÈ²Ãµ¸¶ÀÇ) Á÷¾÷º° ´É·ÂÄ¡
      if ((citem.S.StdMode = 10) or (citem.S.StdMode = 11)) and (citem.S.Shape = DRESS_SHAPE_PBKING) then begin
         case Job of
         0: //Àü»ç
            begin
               citem.S.DC := MakeWord (Lobyte(citem.S.DC), _MIN(255, Hibyte(citem.S.DC) + 2));   //ÇÏµåÄÚµù
               citem.S.MC := 0;
               citem.S.SC := 0;
               citem.S.AC := MakeWord (Lobyte(citem.S.AC) + 2, _MIN(255, Hibyte(citem.S.AC) + 4));   //ÇÏµåÄÚµù
//               citem.S.MAC := 0;
               citem.S.MpAdd := citem.S.MpAdd + 30;   //ÇÏµåÄÚµù
            end;
         1: //¼ú»ç
            begin
               citem.S.DC := 0;
//               citem.S.MC := 0;
               citem.S.SC := 0;
//               citem.S.AC := 0;
               citem.S.MAC := MakeWord (Lobyte(citem.S.MAC) + 1, _MIN(255, Hibyte(citem.S.MAC) + 2));   //ÇÏµåÄÚµù
               citem.S.HpAdd := citem.S.HpAdd + 30;   //ÇÏµåÄÚµù
            end;
         2: //µµ»ç
            begin
               citem.S.DC := MakeWord (Lobyte(citem.S.DC) + 1, _MIN(255, Hibyte(citem.S.DC)));   //ÇÏµåÄÚµù
               citem.S.MC := 0;
//               citem.S.SC := 0;
               citem.S.AC := MakeWord (Lobyte(citem.S.AC) + 1, _MIN(255, Hibyte(citem.S.AC)));   //ÇÏµåÄÚµù
               citem.S.MAC := MakeWord (Lobyte(citem.S.MAC) + 1, _MIN(255, Hibyte(citem.S.MAC)));   //ÇÏµåÄÚµù
               citem.S.HpAdd := citem.S.HpAdd + 20;   //ÇÏµåÄÚµù
               citem.S.MpAdd := citem.S.MpAdd + 10;   //ÇÏµåÄÚµù
            end;
         end;//case
}
      end;

end;

function TCreature.CheckUnbindItem (itemname: string): Boolean;
var
   i : integer;
begin
   Result := FALSE;

   for i:=0 to UnbindItemList.Count-1 do begin
      if CompareText(itemname, UnbindItemList[i]) = 0 then begin
         Result := TRUE;
         break;
      end;
   end;
end;

procedure TCreature.DeleteItemFromBag(psDel : PTStdItem; puDel : PTUserItem);
var
   i, j : integer;
   ps : PTStdItem;
   pu : PTUserItem;
   hum : TUserHuman;
begin
   for i:=0 to Itemlist.Count-1 do begin
      if PTUserItem(ItemList[i]).MakeIndex = puDel.MakeIndex then begin
         ps := UserEngine.GetStdItem (PTUserItem(Itemlist[i]).Index);
         pu := PTUserItem(Itemlist[i]);

         //°¹¼ö ¾ÆÀÌÅÛÀÎ °æ¿ì
         if ps.OverlapItem >= 1 then begin
            if pu.Dura > 0 then begin
               pu.Dura := pu.Dura - 1;

               if pu.Dura <= 0 then begin
                  if RaceServer = RC_USERHUMAN then begin
                     hum := TUserHuman(self);
                     hum.SendDelItem (PTUserItem(ItemList[i])^);
                  end;
                  Dispose(PTUserItem(ItemList[i]));
                  ItemList.Delete (i);
               end else begin
                  SendMsg(self, RM_COUNTERITEMCHANGE, 0, pu.MakeIndex, pu.Dura, 0, ps.Name);
               end;
            end else begin
               if RaceServer = RC_USERHUMAN then begin
                  hum := TUserHuman(self);
                  hum.SendDelItem (PTUserItem(ItemList[i])^);
               end;
               Dispose (PTUserItem(ItemList[i]));
               ItemList.Delete (i);
            end;
         end else begin
            //°¹¼ö ¾ÆÀÌÅÛÀÌ ¾Æ´Ñ °æ¿ì.
            if RaceServer = RC_USERHUMAN then begin
               hum := TUserHuman(self);
               hum.SendDelItem (PTUserItem(ItemList[i])^);
            end;
            Dispose (PTUserItem(ItemList[i]));
            ItemList.Delete (i);
         end;
         break;
      end;
   end;

   WeightChanged;
end;

// 2004/03/17 (sonmg)
function TCreature.FindItemToBindFromBag (count: integer; itemname: string; var dellist: TStringList): integer;
var
   i, j, k: integer;
   pu: PTUserItem;
   pstd: PTStdItem;
   itemcount, delcount: integer;
   strItemName: string;
   hum: TUserHuman;
begin
   Result := -1;
   dellist := nil;

   if itemname <> '' then begin
      if CheckUnbindItem( itemname ) = FALSE then begin
         exit;
      end;
   end;

   try
      // UnbindItemList¿¡ ÇØ´çÇÏ´Â ¾ÆÀÌÅÛÀÌ ¸î °³ ÀÖ´ÂÁö °¡¹æÃ¢¿¡¼­ °Ë»ç.
      for i:=0 to UnbindItemList.Count-1 do begin
         if itemname <> '' then begin
            if CompareText(itemname, UnbindItemList[i]) <> 0 then continue;
         end;

         itemcount := 0;
         for j:=0 to Itemlist.Count-1 do begin
            pstd := UserEngine.GetStdItem (PTUserItem(Itemlist[j]).Index);
            if pstd <> nil then begin
               if CompareText(pstd.Name, UnbindItemList[i]) = 0 then begin
                  Inc(itemcount);
               end;
            end;
         end;
         // BindÇÒ ¾ÆÀÌÅÛ °³¼ö¸¦ ÃæÁ·ÇÏ¸é...
         if itemcount >= count then begin
            strItemName := UnbindItemList[i];
            Result := Integer(UnbindItemList.Objects[i]);
            break;
         end;
      end;

      // BindÇÒ ¾ÆÀÌÅÛ »èÁ¦.
      if Result >= 0 then begin
         delcount := 0;
         for i:=0 to ItemList.Count-1 do begin
            pu := PTUserItem(ItemList[i]);
            if CompareText (UserEngine.GetStdItemName (pu.Index), strItemName) = 0 then begin
               if RaceServer = RC_USERHUMAN then begin
                  if dellist = nil then dellist := TStringList.Create;
                  //¶³¾î¶ß¸° ¾ÆÀÌÅÛÀ» Å¬¶óÀÌ¾ðÆ®¿¡ ¾Ë¸².
                  dellist.AddObject(UserEngine.GetStdItemName (pu.Index), TObject(pu.MakeIndex));
               end;
               Inc(delcount);
               if delcount >= count then
                  break;
            end;
         end;
      end;
   except
      MainOutMessage('[Exception] TUserHuman.FindItemToBindFromBag');
   end;
end;

function TCreature.GuildAgitInvitationItemSet( pu: PTUserItem ): Boolean;
var
   ayear, amon, aday, ahour, amin, asec, amsec: word;
   nowdate : TDateTime;
   AgitNum : integer;
   gname : string;
   guildagit, myguildagit : TGuildAgit;
begin
   Result := FALSE;
   AgitNum := 0;

   gname := GetGuildNameHereAgit;
   guildagit := GuildAgitMan.GetGuildAgit( gname );
   if guildagit = nil then exit;

   // ¿î¿µÀÚ°¡ ¾Æ´Ï¸é Àå¿øÀÌ ÀÏÄ¡ÇÏ´ÂÁö °Ë»çÇÑ´Ù.
   if UserDegree < UD_ADMIN then begin
      // ÀÏ¹Ý À¯Àú´Â ÇØ´ç Àå¿ø¿¡¼­¸¸ ÃÊ´ëÀåÀ» ¾òÀ» ¼ö ÀÖ´Ù.
      if MyGuild = nil then exit;
      myguildagit := GuildAgitMan.GetGuildAgit( TGuild(MyGuild).GuildName );
      if myguildagit = nil then exit;

      //ÇöÀç ¸ÊÀÌ ÇÒ´çµÈ Àå¿øÀÌ ¾ø°Å³ª ÀÚ½ÅÀÇ ¹®ÆÄ°¡ Àå¿øÀ» ¼ÒÀ¯ÇÏ°í ÀÖÁö ¾ÊÀ¸¸é...
      if (guildagit.GuildAgitNumber <= 0) or (myguildagit.GuildAgitNumber <= 0) then exit;

      //ÇöÀç ¸ÊÀÇ Àå¿ø¹øÈ£¿Í ÀÚ½ÅÀÇ ¹®ÆÄ Àå¿ø¹øÈ£°¡ ÀÏÄ¡ÇÏÁö ¾ÊÀ¸¸é ¾òÀ» ¼ö ¾ø´Ù.
      if guildagit.GuildAgitNumber <> myguildagit.GuildAgitNumber then exit;
   end;

   // Àå¿ø¹øÈ£ ÇÒ´ç.
   AgitNum := guildagit.GuildAgitNumber;

   // ÇöÀç ½Ã°¢
   nowdate := Now;
   DecodeDate (nowdate, ayear, amon, aday);
   DecodeTime (nowdate, ahour, amin, asec, amsec);

   // Àå¿ø ¹øÈ£¸¦ ±â·ÏÇÑ´Ù.
   pu.Dura := AgitNum;

   // »ý¼º ÀÏ½Ã(³â¿ùÀÏ½Ã)¸¦ ±â·ÏÇÑ´Ù.
   pu.DuraMax := ayear;
   pu.Desc[0] := amon;
   pu.Desc[1] := aday;
   pu.Desc[2] := ahour;

   Result := TRUE;
end;

function TCreature.GuildAgitDecoItemSet( pu: PTUserItem; Number: integer ): Boolean;
var
   nowdate : TDateTime;
   gname : string;
   guildagit : TGuildAgit;
begin
   Result := FALSE;

   // Number¸¦ ¼³Á¤ÇÑ´Ù.
   pu.Dura := Number;

   Result := TRUE;
end;

function TCreature.GuildAgitInvitationTimeOutCheck( pu: PTUserItem ): Boolean;
var
   nowdate : TDateTime;
   exdate, extime, exdatetime : TDateTime;
   cYear, cMon, cDay, cHour, cMin, cSec, cMSec: word;
begin
   Result := FALSE;

   try
      // ÇöÀç ½Ã°¢
      nowdate := Now;

      // »ý¼ºÀÏ½Ã ÀÔ·Â.
      cYear := pu.DuraMax;
      cMon := MakeWord(pu.Desc[0], 0);
      cDay := MakeWord(pu.Desc[1], 0);
      cHour := MakeWord(pu.Desc[2], 0);
      cMin := 0;
      cSec := 0;
      cMSec := 0;

      // ¿¡·¯
      if (cMon = 0) or (cDay = 0) then exit;

      // ¸¶°¨ ½Ã°£ = »ý¼ºÀÏ½Ã + 1ÀÏ.
      exdate := Trunc(EncodeDate(cYear, cMon, cDay));
      extime := EncodeTime(cHour, cMin, cSec, cMSec);
      exdatetime := exdate + extime + 1;

      // ºñ±³
      if nowdate <= exdatetime then begin
         Result := TRUE;
      end;
   except
      MainOutMessage('[Exception]TCreature.GuildAgitInvitationTimeOutCheck');
   end;
end;

//2003/03/18
procedure TCreature.DecRefObjCount;
var i : integer;
   pva: PTVisibleActor;
begin
{
   //2003/04/21
   if RaceServer = RC_USERHUMAN then exit;
   try
      Dec(RefObjCount);
      if(RefObjCount <= 0) then begin
         RefObjCount := 0;
         if(VisibleActors.Count > 0) then begin
            i := 0;
            while TRUE do begin
               if i >= VisibleActors.Count then break;
               pva := PTVisibleActor(VisibleActors[i]);
               VisibleActors.Delete (i);
               Dispose (pva);
//             Inc(i);
               continue;
            end;
         end;
      end;
   except
      MainOutMessage ('[Exception] TCreatre.DecRefObjCount ('+UserName+'/'+IntToStr(RefObjCount)+')');
   end;
}
end;

function TCreature.ItemOptionToStr( optiondata : array of byte ):string;
var
    i   :integer;
    rtstr : string;
begin
    rtstr := '';
    try
      for i := 0 to 13 do
      begin
          rtstr := rtstr + intTostr(optiondata[i]);
      end;
    except
      MainOutMessage('DO NOT MAKE STRING ITEMOPTION');
    end;
    result := rtstr;
end;

function TCreature.UpgradeResultToStr( iSum: integer; strOpt: string; iBefore, iAfter: integer; fProb: double; iJewelStdMode: integer ):string;
var
   rtstr : string[20];
   strJewelType: string;
begin
   rtstr := '';
   if iJewelStdMode = 60 then begin
      {$IFDEF KOREA}
      strJewelType := '±¦Ê¯';
      {$ELSE}
      strJewelType := 'GEM';
      {$ENDIF}
   end else if iJewelStdMode = 61 then begin
      {$IFDEF KOREA}
      strJewelType := '±¦Öé';
      {$ELSE}
      strJewelType := 'ORB';
      {$ENDIF}
   end;

   try
      rtstr := IntToStr(iSum) + ',' + strJewelType + ',' + strOpt + ',' + IntToStr(iBefore) + ','+ IntToStr(iAfter) + ',' + FloatToStr(fProb);

{$IFDEF DEBUG} //sonmg
      // For Debug
      SysMsg(rtstr, 0);
{$ENDIF}
   except
      MainOutMessage('[Exception!] TCreature.UpgradeResultToStr Cannot Make Log String');
   end;
   Result := rtstr;
end;
//°ÚÌ¯²å¶Ó
procedure TCreature.SendFastMsg (sender: TCreature; Ident, wparam: Word; lParam1, lParam2, lParam3: Longint; str: string);
var
	pmsg: PTMessageInfoPtr;
  ansistr: AnsiString;
begin
   try
      csObjMsgLock.Enter;
      if not BoGhost then begin
         new (pmsg);
         pmsg.Ident 	:= Ident;
         pmsg.wparam  := wparam;
         pmsg.lparam1 := lparam1;
         pmsg.lparam2 := lparam2;
         pmsg.lParam3 := lparam3;
         pmsg.sender	:= sender;
         ansistr := AnsiString(str);
         if ansistr <> '' then begin
            try
               GetMem (pmsg.descptr, Length(ansistr) + 1);
               Move (ansistr[1], pmsg.descptr^, Length(ansistr)+1);
            except
               pmsg.descptr := nil;
            end;
         end else
            pmsg.descptr := nil;
         MsgList.Insert (0, pmsg);
      end;
   finally
      csObjMsgLock.Leave;
   end;
end;
 //°ÚÌ¯²å¶Ó
procedure TCreature.SendMsg (sender: TCreature; Ident, wparam: Word; lParam1, lParam2, lParam3: Longint; str: string);
var
	pmsg: PTMessageInfoPtr;
  ansistr: AnsiString;
begin
   try
      csObjMsgLock.Enter;
      if not BoGhost then begin
         new (pmsg);
         pmsg.Ident 	:= Ident;
         pmsg.wparam  := wparam;
         pmsg.lparam1 := lparam1;
         pmsg.lparam2 := lparam2;
         pmsg.lParam3 := lparam3;
         pmsg.deliverytime := 0;
         pmsg.sender	:= sender;
         ansistr := AnsiString(str);
         if ansistr <> '' then begin
            try
               GetMem (pmsg.descptr, Length(ansistr) + 1);
               Move (ansistr[1], pmsg.descptr^, Length(ansistr)+1);
            except
               pmsg.descptr := nil;
            end;
         end else
            pmsg.descptr := nil;
         MsgList.Add (pmsg);
      end;
   finally
      csObjMsgLock.Leave;
   end;
end;
//°ÚÌ¯²å¶Ó
procedure  TCreature.SendDelayMsg (sender: TCreature; Ident, wparam: Word; lParam1, lParam2, lParam3: Longint; str: string; delay: integer{ms});
var
	pmsg: PTMessageInfoPtr;
  ansistr: AnsiString;
begin
   try
      csObjMsgLock.Enter;
      if not BoGhost then begin
         new (pmsg);
         pmsg.Ident 	:= Ident;
         pmsg.wparam  := wparam;
         pmsg.lparam1 := lparam1;
         pmsg.lparam2 := lparam2;
         pmsg.lParam3 := lparam3;
         pmsg.deliverytime := GetTickCount + longword(delay);
         pmsg.sender	:= sender;
         ansistr := AnsiString(str);
         if ansistr <> '' then begin
            try
               GetMem (pmsg.descptr, Length(ansistr) + 1);
               Move (ansistr[1], pmsg.descptr^, Length(ansistr)+1);
            except
               pmsg.descptr := nil;
            end;
         end else
            pmsg.descptr := nil;
         MsgList.Add (pmsg);
      end;
   finally
      csObjMsgLock.Leave;
   end;
end;
  //°ÚÌ¯²å¶Ó
procedure TCreature.UpdateDelayMsg (sender: TCreature; Ident, wparam: Word; lParam1, lParam2, lParam3: Longint; str: string; delay: integer{ms});
var
  i: integer;
	pmsg: PTMessageInfoPtr;
begin
   csObjMsgLock.Enter;
   try
      i := 0;
      while TRUE do begin
      	if i >= MsgList.Count then break;
      	if PTMessageInfoPtr (MsgList[i]).Ident = Ident then begin
            pmsg := PTMessageInfoPtr (MsgList[i]);
            MsgList.Delete (i);
            if pmsg.descptr <> nil then
               FreeMem (pmsg.descptr);
            Dispose (pmsg);
         end else
         	Inc (i);
      end;
	finally
      csObjMsgLock.Leave;
	end;
   SendDelayMsg (sender, Ident, wparam, lParam1, lParam2, lParam3, str, delay);
end;
  //°ÚÌ¯²å¶Ó
procedure TCreature.UpdateDelayMsgCheckParam1 (sender: TCreature; Ident, wparam: Word; lParam1, lParam2, lParam3: Longint; str: string; delay: integer{ms});
var
   i: integer;
	pmsg: PTMessageInfoPtr;
begin
   csObjMsgLock.Enter;
   try
      i := 0;
      while TRUE do begin
      	if i >= MsgList.Count then break;
      	if (PTMessageInfoPtr (MsgList[i]).Ident = Ident) and (PTMessageInfoPtr (MsgList[i]).lparam1 = lparam1) then begin
            pmsg := PTMessageInfoPtr (MsgList[i]);
            MsgList.Delete (i);
            if pmsg.descptr <> nil then
               FreeMem (pmsg.descptr);
            Dispose (pmsg);
         end else
         	Inc (i);
      end;
	finally
      csObjMsgLock.Leave;
	end;
   SendDelayMsg (sender, Ident, wparam, lParam1, lParam2, lParam3, str, delay);
end;
     //°ÚÌ¯²å¶Ó

procedure TCreature.UpdateMsg (sender: TCreature; Ident, wparam: Word; lParam1, lParam2, lParam3: Longint; str: string);
var
   i: integer;
	pmsg: PTMessageInfoPtr;
begin
   csObjMsgLock.Enter;
   try
      i := 0;
      while TRUE do begin
      	if i >= MsgList.Count then break;
      	if PTMessageInfoPtr (MsgList[i]).Ident = Ident then begin
            pmsg := PTMessageInfoPtr (MsgList[i]);
            MsgList.Delete (i);
            if pmsg.descptr <> nil then
               FreeMem (pmsg.descptr);
            Dispose (pmsg);
         end else
         	Inc (i);
      end;
	finally
      csObjMsgLock.Leave;
	end;
   SendMsg (sender, Ident, wparam, lParam1, lParam2, lParam3, str);
end;

function TCreature.GetMsg (var msg: TMessageInfo): Boolean;
var
	pmsg: PTMessageInfoPtr;
   n: integer;
begin
	Result := FALSE;
   try
      csObjMsgLock.Enter;
      n := 0;
      msg.Ident := 0;
      while MsgList.Count > n do begin
         pmsg := MsgList[n];
         if pmsg.deliverytime <> 0 then begin
            if GetTickCount < pmsg.deliverytime then begin
               Inc (n);
               continue;
            end;
         end;
         MsgList.Delete (n);
         msg.Ident := pmsg.Ident;
         msg.wparam  := pmsg.wparam;
         msg.lparam1 := pmsg.lparam1;
         msg.lparam2 := pmsg.lparam2;
         msg.lParam3 := pmsg.lparam3;
         msg.sender	:= pmsg.sender;
         if pmsg.descptr <> nil then begin
            msg.Description := StrPas (pmsg.descptr);
            FreeMem (pmsg.descptr);
         end else
            msg.Description := '';
         Dispose (pmsg);
         Result := TRUE;
         break;
      end;
	finally
      csObjMsgLock.Leave;
	end;
end;


function  TCreature.GetMapCreatures (penv: TEnvirnoment; x, y, area: integer; rlist: TList): Boolean;
var
	i, j, k, stx, sty, enx, eny: integer;
   cret: TCreature;
   pm: PTMapInfo;
   inrange: Boolean;
begin
   Result := FALSE;
   if rlist = nil then exit;
   try
      stx := x-area;
      enx := x+area;
      sty := y-area;
      eny := y+area;

      for i:=stx to enx do begin
         for j:=sty to eny do begin
            inrange := PEnvir.GetMapXY (i, j, pm);
            if inrange then begin
               if pm.ObjList <> nil then begin
                  for k:=pm.ObjList.Count-1 downto 0 do begin
                     //creature//
                     if pm.ObjList[k] <> nil then begin
                        if PTAThing (pm.ObjList[k]).Shape = OS_MOVINGOBJECT then begin
                           cret := TCreature (PTAThing (pm.ObjList[k]).AObject);
                           if cret <> nil then begin
                              if (not cret.BoGhost) then begin
                                 rlist.Add (cret);
                              end;
                           end;
                        end;
                     end;
                  end;
               end;
            end;
         end;
      end;
   except
      MainOutMessage ('[TCreature] GetMapCreatures exception');
   end;
   Result := TRUE;
end;

// ´ë°¢¼± ¹æÇâÀÇ ¸Ê¿¡¼­ »ý¹°Ã¼ ¾ò¾î³»±â.
function  TCreature.GetObliqueMapCreatures (penv: TEnvirnoment; x, y, area, dir: integer; rlist: TList): Boolean;
var
	i, j, k, stx, sty, enx, eny: integer;
   cret: TCreature;
   pm: PTMapInfo;
   inrange: Boolean;
begin
   Result := FALSE;
   if rlist = nil then exit;
   try
      case dir of
      1:
         begin
            stx := x-area -area;
            enx := x+area;
            sty := y-area;
            eny := y+area +area;
         end;
      3:
         begin
            stx := x-area -area;
            enx := x+area;
            sty := y-area -area;
            eny := y+area;
         end;
      5:
         begin
            stx := x-area;
            enx := x+area +area;
            sty := y-area -area;
            eny := y+area;
         end;
      7:
         begin
            stx := x-area;
            enx := x+area +area;
            sty := y-area;
            eny := y+area +area;
         end;
      else
         //¹æÇâÀÌ ´ë°¢¼±ÀÌ ¾Æ´Ò¶§...
         exit;
      end;//case

      for i:=stx to enx do begin
         for j:=sty to eny do begin
            if ((dir in [3,7]) and (abs((x-i)-(y-j)) <= area)) or
               ((dir in [1,5]) and (abs((x-i)+(y-j)) <= area)) then begin
               inrange := PEnvir.GetMapXY (i, j, pm);
               if inrange then begin
                  if pm.ObjList <> nil then begin
                     for k:=pm.ObjList.Count-1 downto 0 do begin
                        //creature//
                        if pm.ObjList[k] <> nil then begin
                           if PTAThing (pm.ObjList[k]).Shape = OS_MOVINGOBJECT then begin
                              cret := TCreature (PTAThing (pm.ObjList[k]).AObject);
                              if cret <> nil then begin
                                 if (not cret.BoGhost) then begin
                                    rlist.Add (cret);
                                 end;
                              end;
                           end;
                        end;
                     end;
                  end;
               end;
            end;
         end;
      end;
   except
      MainOutMessage ('[TCreature] GetObliqueMapCreatures exception');
   end;
   Result := TRUE;
end;


{%%%%%%%%%%%%%%%%%%% *SendRefMsg* %%%%%%%%%%%%%%%%%%%%}

procedure TCreature.SendRefMsg (msg, wparam: Word; lParam1, lParam2, lParam3: Longint; str: string);
var
	i, j, k, stx, sty, enx, eny: integer;
   cret: TCreature;
   pm: PTMapInfo;
   inrange: Boolean;
   objshape : Byte;
begin
   if BoSuperviserMode or HideMode then begin
      exit;
   end;
   objshape := 0;

//   csSendMsgLock.Enter;
//   try
      if (GetTickCount - WatchTime >= 500) or (MsgTargetList.Count = 0) then begin  //Í»È»±¨´í
         WatchTime := GetTickCount;
         MsgTargetList.Clear;
//         stx := CX-12;
//         enx := CX+12;
//         sty := CY-12;
//         eny := CY+12;

        stx := _MAX(0, CX - 12);//ÕâÀï
        enx := _MIN(PEnvir.MapWidth, CX + 12);
        sty := _MAX(0, CY - 12);
        eny := _MIN(PEnvir.MapHeight, CY + 12);


         for i:=stx to enx do begin
            for j:=sty to eny do begin
               inrange := PEnvir.GetMapXY (i, j, pm);
               if inrange then begin
                  if pm.ObjList <> nil then begin
                     for k:=pm.ObjList.Count-1 downto 0 do begin
                        //creature//
                        if pm.ObjList[k] <> nil then begin

                           try // ¹®Á¦°¡ ÀÖ´Â ¸Þ¸ð¸®´Â ³Ñ¾î°¡ÀÚ..
                            objshape := PTAThing (pm.ObjList[k]).Shape;
                           except
                            MainOutMessage ('[Exception] Memory Check Error - SendRefMsg');
                            continue;
                           end;

                           if objshape = OS_MOVINGOBJECT then begin
                              if not TCreature (PTAThing (pm.ObjList[k]).AObject).m_boNotOnlineAddExp and (GetTickCount - PTAThing (pm.ObjList[k]).ATime >= 5 * 60 * 1000) then begin
                                 //ÀÜ»ó °Ë»çÇÏ¿© Áö¿î´Ù.
                                 try // 2003-08-21 PDS - ¸Þ¸ð¸®»èÁ¦½Ã ¿¡·¯³­ °æ¿ì
                                 Dispose (PTAThing (pm.ObjList[k]));
                                 except
                                 MainOutMessage ('[Exception] Dispose Error - SendRefMsg');
                                 end;
                                 pm.ObjList.Delete(k);
                                 if pm.ObjList.Count <= 0 then begin
                                    pm.ObjList.Free;
                                    pm.ObjList := nil;
                                    break;
                                 end;
                              end else begin
                                 try
                                    cret := TCreature (PTAThing (pm.ObjList[k]).AObject);
                                    if cret <> nil then begin
                                       if (not cret.BoGhost) then begin
                                          if cret.RaceServer = RC_USERHUMAN then begin
                                             cret.SendMsg (self, msg, wparam, lparam1, lparam2, lparam3, str);
                                             MsgTargetList.AddObject ('', cret); //cashing..
                                          end else begin
                                             if cret.WantRefMsg then
                                                if (msg = RM_STRUCK) or (msg = RM_HEAR) or (msg = RM_DEATH) then begin
                                                   cret.SendMsg (self, msg, wparam, lparam1, lparam2, lparam3, str);
                                                   MsgTargetList.AddObject ('', cret); //cashing..
                                                end;
                                          end;
                                       end;
                                    end;
                                 except
                                    pm.ObjList.Delete (k);
                                    if pm.ObjList.Count <= 0 then begin
                                       pm.ObjList.Free;
                                       pm.ObjList := nil;
                                    end;
                                    MainOutMessage ('[Exception] TCreatre.SendRefMsg');
                                    break;
                                 end;
                              end;
                           end;
                        end;
                     end;
                  end;
               end;
            end;
         end;
      end else begin
      	if MsgTargetList.Count > 0 then
            for i:=0 to MsgTargetList.Count-1 do begin
               cret := TCreature (MsgTargetList.Objects[i]);
               try

                 if not cret.BoGhost then begin
                    if (cret.MapName = self.MapName) and (Abs(cret.CX - self.CX) <= 12) and (Abs(cret.CY - self.CY) <= 12) then begin
                       if cret.RaceServer = RC_USERHUMAN then begin
                         cret.SendMsg (self, msg, wparam, lparam1, lparam2, lparam3, str);
                       end else begin
                          if cret.WantRefMsg and ((msg = RM_STRUCK) or (msg = RM_HEAR) or (msg = RM_DEATH)) then
                             cret.SendMsg (self, msg, wparam, lparam1, lparam2, lparam3, str);
                       end;
                    end;
                 end;

               except
               // Å¸°Ù¸®½ºÆ®ÀÇ ¿ÀºêÁ§Æ®°¡ ±úÁø°æ¿ì »èÁ¦ÇÑ´Ù.
               // ¸Þ¸ð¸®°¡ »èÁ¦µÈ³ÑÀ» °¡Áö°í ÀÖÀ» °æ¿ìµµ ÀÖÀ¸´Ï ¸Þ¸ð¸® »èÁ¦´Â ÇÏÁö¸»°í
               // ¸®½ºÆ®¿¡¼­¸¸ »èÁ¦
               // ·çÇÁ°¡ ±úÁú¼ö ÀÖÀ¸´Ï.. ±×³É Break ·Î ³Ñ¾î°¡ÀÚ ( ¸Þ¼¼Áö Àü¼ÛÀÌ ¾ÈµÉ¼ö ÀÖÀ½. )
               // 2003-08-07 : PDS
                  MainOutMessage ('[Exception] TCreatre.SendRefMsg : Target Wrong :'+Self.UserName);
                  MsgTargetList.Delete(i);
                  break;
               end;

            end; // for end...
      end;
//	finally
//      csSendMsgLock.Leave;
//	end;
end;

procedure TCreature.UpdateVisibleGay (cret: TCreature);
var
	i: integer;
   flag: Boolean;
   va: PTVisibleActor;
begin
   flag := FALSE;
   try
      for i:=0 to VisibleActors.Count-1 do
         if cret = TCreature (PTVisibleActor(VisibleActors[i]).cret) then begin
            PTVisibleActor (VisibleActors[i]).check := 1;  //update
            flag := TRUE;
            break;
         end;
   except
      MainOutMessage ('[TCreature] UpdateVisibleGay exception');
   end;
   try
      if not flag then begin
         new (va);
         va.check := 2;
         va.cret := cret;
         VisibleActors.Add (va);    // '2' : new
         // 2003/04/21 ÇÃ·¹ÀÌ¾î´Â Á¦¿Ü
         if (cret.RaceServer <> RC_USERHUMAN) and (not cret.Death) then
         // 2003/03/18
            Inc(cret.RefObjCount);
      end;
   except
      MainOutMessage ('[TCreature] UpdateVisibleGay-2 exception');
   end;
end;

procedure TCreature.UpdateVisibleItems (xx, yy: word; pmi: PTMapItem);
var
   i: integer;
   pvitem: PTVisibleItemInfo;
   flag: Boolean;
begin
   flag := FALSE;
   for i:=0 to VisibleItems.Count-1 do begin
      pvitem := PTVisibleItemInfo (VisibleItems[i]);
      if (pvitem.Id = Longint(pmi)) then begin
         pvitem.check := 1; //update mark
         flag := TRUE;
         break;
      end;
   end;
   if not flag then begin
      New (pvitem);
      pvitem.check := 2;  //new mark
      pvitem.x := xx;
      pvitem.y := yy;
      pvitem.Id := Longint(pmi);
      pvitem.Name := pmi.Name;
      pvitem.looks := pmi.Looks;
      VisibleItems.Add (pvitem);
   end;
end;

procedure TCreature.UpdateVisibleEvents (xx, yy: integer; mevent: TObject);
var
   i: integer;
   event: TEvent;
   flag: Boolean;
begin
   flag := FALSE;
   for i:=0 to VisibleEvents.Count-1 do begin
      event := TEvent(VisibleEvents[i]);
      if event = mevent then begin
         event.check := 1;  //update mark
         flag := TRUE;
         break;
      end;
   end;
   if not flag then begin
      TEvent(mevent).check := 2; //new
      TEvent(mevent).X := xx;
      TEvent(mevent).Y := yy;
      VisibleEvents.Add (mevent);
   end;
end;

procedure TCreature.SearchViewRange;
var
	stx, enx, sty, eny, i, j, k, down: integer;
	rstx, renx, rsty, reny : integer;
   pm: PTMapInfo;
   pvi: PTVisibleItemInfo;
   pva: PTVisibleActor;
   pmi: PTMapEventInfo;
   pmapitem: PTMapItem;
   pd: PTDoorInfo;
   event: TEvent;
   cret: TCreature;
   inrange: Boolean;
   uname: string;
   // 2004/04/21 AI º¯°æ
   hmcount : integer;      // ½Ã¾ß³» »ç¿ëÀÚ ÄÉ¸¯ÅÍÀÇ ¼ö
   hmcheck : boolean;
   ObjShape : Byte;
   pvacheck : integer;
   ps : PTStdItem;
label
   err_exception;
begin
   down    := 0;
   objshape := 0;
	if PEnvir = nil then begin
   	MainOutMessage ('nil PEnvir');
   	exit;
	end;

   stx := CX-ViewRange;
   enx := CX+ViewRange;
   sty := CY-ViewRange;
   eny := CY+ViewRange;

   // 2003/02/11 SearchView Optimize
   // 1. ÀÏ´Ü °Ë»ö¹üÀ§Áß ¸Ê¹üÀ§¸¦ ³Ñ¾î°¡´Â ºÎºÐÀº °Ë»öÇÏÁö ¾Êµµ·Ï ÇÑ´Ù...¸Ê°æ°è½Ã¿¡ ÀÌµæ
   if(stx < 0) then stx := 0;
   if(enx > PEnvir.MapWidth-1)  then enx := PEnvir.MapWidth-1;
   if(sty < 0) then sty := 0;
   if(eny > PEnvir.MapHeight-1) then eny := PEnvir.MapHeight-1;

   // 2004/04/21 ½Ã¾ß ¹üÀ§ 10¹ø¿¡ 1¹ø²Ã·Î ÀüÃ¼È­¸éÀ¸·Î È®´ë
   hmcount := 0;
   hmcheck := FALSE;
{
   if RaceServer <> RC_USERHUMAN then begin
      if RefObjCount > 10 then begin
         hmcheck := TRUE;
         RefObjCount := 1;
         // ½Ã¾ß¹üÀ§ È®´ë
         rstx := stx;   stx := CX-12;
         renx := enx;   enx := CX+12;
         rsty := sty;   sty := CY-12;
         reny := eny;   eny := CY+12;
         if(stx < 0) then stx := 0;
         if(enx > PEnvir.MapWidth-1)  then enx := PEnvir.MapWidth-1;
         if(sty < 0) then sty := 0;
         if(eny > PEnvir.MapHeight-1) then eny := PEnvir.MapHeight-1;
      end else
         Inc(RefObjCount);
   end;
}
   try
      for i:=0 to VisibleItems.Count-1 do PTVisibleItemInfo (VisibleItems[i]).Check := 0;    //'0' -> mark

      for i:=0 to VisibleEvents.Count-1 do TEvent(VisibleEvents[i]).Check := 0;    //'0' -> mark

      // 2004/04/21 ½Ã¾ß ¹üÀ§ È®´ë°Ë»ö½Ã¿¡´Â ÃÊ±âÈ­ ¹× Ãß°¡ÇÏÁö ¾ÊÀ½
      if not hmcheck then
         for i:=0 to VisibleActors.Count-1 do PTVisibleActor(VisibleActors[i]).Check := 0;
   except
      MainOutMessage ('ObjBase SearchViewRange 0');
      KickException;
   end;

   try
      for i:=stx to enx do begin
         for j:=sty to eny do begin
            inrange := PEnvir.GetMapXY (i, j, pm);
            if inrange then begin
               if pm.ObjList <> nil then begin
                  down := 1;
                  k := 0;
                  while TRUE do begin
                     if k >= pm.ObjList.Count then break; //-1 do begin //downto 0 do begin
                     if pm.ObjList[k] <> nil then begin
                        // Check Object wrong Memory 2003-09-15 PDS
                        try
                            // ¸Þ¸ð¸®¿¡¼­ ¿¡·¯°¡ ÀÖÀ¸¸é ÀÍ¼Á¼Ç °É¸®±¸
                            ObjShape := PTAThing (pm.ObjList[k]).Shape;
                        except
                            // ¿ÀºêÁ§Æ®¿¡¼­ »©¹ö¸®ÀÚ.
                            MainOutMessage ('DELOBJ-WRONG MEMORY:'+ MapName + ',' + IntToStr(CX) + ',' + IntToStr(CY));
                            pm.ObjList.delete(k);
                            continue;
                        end;
                        {creature}
                        if ObjShape = OS_MOVINGOBJECT then begin

                           // ÀÜ»ó °Ë»çÇÏ¿© Áö¿î´Ù.
                           // 2003/01/22 ½Ã°£ 5ºÐ¿¡¼­ 10ºÐÀ¸·Î º¯°æ...NPC ±ô¹ÚÀÓ ¹æÁö
                           if not TCreature (PTAThing (pm.ObjList[k]).AObject).m_boNotOnlineAddExp and (GetTickCount - PTAThing (pm.ObjList[k]).ATime >= 10 * 60 * 1000) then begin
                              try
                              Dispose (PTAThing(pm.ObjList[k]));
                              finally
                              pm.ObjList.Delete(k);
                              end;

                              down := 2;
                              if pm.ObjList.Count <= 0 then begin
                                 down := 3;
                                 pm.ObjList.Free;
                                 pm.ObjList := nil;
                                 break;
                              end;
                              continue;

                           end;

                           cret := TCreature (PTAThing (pm.ObjList[k]).AObject);
                           down := 4;
                           if (cret <> nil) and
                              (not cret.BoGhost) and
                              (not cret.HideMode) and
                              (not cret.BoSuperviserMode)
                           then begin
                              down := 5;
                              //¸ó½ºÅÍ´Â Á¦¿Ü ½ÃÅ²´Ù.
                              if (RaceServer < RC_ANIMAL) or   //¸÷ÀÌ ¾Æ´Ï°Å³ª
                                 (Master <> nil) or            //ÁÖÀÎÀÌ ÀÖ°Å³ª
                                 (BoCrazyMode) or              //ÆøÁÖ»óÅÂ°Å³ª
                                 (BoGoodCrazyMode) or            //°ö°Ô¹ÌÄ£»óÅÂ°Å³ª
                                 (WantRefMsg) or               //¸Þ¼¼Áö°¡ ÇÊ¿äÇÔ
                                 ((cret.Master <> nil) and (abs(cret.CX-CX) <= 3) and (abs(cret.CY-CY) <= 3)) or  //ÁÖÀÎÀÖ´Â ¸÷Àº ´Ù º»´Ù.(»ç¶÷Ã³·³ °£ÁÖ)
                                 (cret.RaceServer = RC_USERHUMAN)  //»ç¶÷Àº ´Ù º»´Ù
                                 // 2004/04/21 È®´ë½Ã¾ß °Ë»çÁß¿¡´Â Ãß°¡ÇÏÁö ¾Ê´Â´Ù
                                 and (not hmcheck)
                              then
                                 UpdateVisibleGay (cret);
                              if cret.RaceServer = RC_USERHUMAN then Inc(hmcount);
                           end;
                        end;

                        if RaceServer = RC_USERHUMAN then begin

                           {item}
                           down := 6;
                           if PTAThing (pm.ObjList[k]).Shape = OS_ITEMOBJECT then begin
                              down := 7;
                              if GetTickCount - PTAThing (pm.ObjList[k]).ATime > 5 * 60 * 1000 then begin   //ÎïÆ·µØÃæÏûÊ§Ê±¼ä£¬µÚÒ»¸öÊý×Ö¾ÍÊÇ·ÖÖÓ
                                 //Àå¿ø²Ù¹Ì±â ¾ÆÀÌÅÛÀº °Çµå¸®Áö ¾Ê´Â´Ù.
                                 pmapitem := PTMapItem (PTAThing (pm.ObjList[k]).AObject);
                                 ps := UserEngine.GetStdItem(pmapitem.UserItem.Index);
                                 if ps <> nil then begin
                                    if (ps.StdMode = STDMODE_OF_DECOITEM) and (ps.Shape = SHAPE_OF_DECOITEM) then begin
                                       if pmapitem <> nil then begin
                                          UpdateVisibleItems (i, j, pmapitem);
                                          //´ÙÀ½ ¾ÆÀÌÅÛÀ¸·Î ³Ñ¾î°¨...
                                          Inc (k);
                                          continue;
                                       end;
                                    end;
                                 end;

                                 //¹ö¸°Áö 1½Ã°£ÀÌ Áö³­°Ç ¾ø¾Ø´Ù. -PDS Àß¸øµÉ °¡´É¼º ÀÖÀ½
                                 // Dispose (PTMapItem (PTAThing (pm.ObjList[k]).AObject));

                                 Dispose (PTAThing(pm.ObjList[k]));
                                 pm.ObjList.Delete(k);
                                 down := 8;
                                 if pm.ObjList.Count <= 0 then begin
                                    down := 9;
                                    pm.ObjList.Free;
                                    pm.ObjList := nil;
                                    break;
                                 end;
                                 continue;
                              end else begin
                                 down := 10;
                                 pmapitem := PTMapItem (PTAThing (pm.ObjList[k]).AObject);
                                 if pmapitem <> nil then begin
                                    UpdateVisibleItems (i, j, pmapitem);
                                    if (pmapitem.Ownership <> nil) or (pmapitem.Droper <> nil) then begin
                                       if GetTickCount - pmapitem.Droptime > ANTI_MUKJA_DELAY then begin
                                          pmapitem.Ownership := nil;
                                          pmapitem.Droper := nil;
                                       end else begin
                                          //{ÁÖÀÇ} ¸ÔÀÚ º¸È£ ½Ã°£ÀÌ 5ºÐ(Á×Àº Ä³¸¯ free À¯¿¹½Ã°£)À» ÃÊ°úÇÏ¸é
                                          //ÀÌ ºÎºÐ¿¡¼­ ¹ö±×°¡ ¹ß»ýÇÑ´Ù.
                                          if pmapitem.Ownership <> nil then
                                             if TCreature (pmapitem.Ownership).BoGhost then
                                                pmapitem.Ownership := nil;
                                          if pmapitem.Droper <> nil then
                                             if TCreature (pmapitem.Droper).BoGhost then
                                                pmapitem.Droper := nil;
                                       end;
                                    end;
                                 end;
                              end;
                           end;

                           {event}
                           down := 11;
                           if PTAThing (pm.ObjList[k]).Shape = OS_EVENTOBJECT then begin
                              event := TEvent (PTAThing (pm.ObjList[k]).AObject);
                              if event.Visible then
                                 UpdateVisibleEvents (i, j, TObject (event));
                           end;
                        end;
                     end;

                     Inc (k);

                  end;
               end;
            end;
         end;
      end;
   except
      MainOutMessage (UserName + ' ' + MapName + ',' + IntToStr(CX) + ',' + IntToStr(CY) + ' SearchViewRange 1-' + IntToStr(down));
      KickException;
   end;

   //ÒÔÏÂ´úÂë¼ÙËÀÐÞ¸´
   try
      i := 0;
      while TRUE do begin
         if i >= VisibleActors.Count then break;
         pva := PTVisibleActor(VisibleActors[i]);

         try // ¸Þ¸ð¸® Ã¼Å© 2003-09-23 PDS
           pvacheck := pva.check;
         except
           VisibleActors.Delete(i);
           MainOutMessage ('DELOBJ-WRONG2 MEMORY:'+ MapName + ',' + IntToStr(CX) + ',' + IntToStr(CY));
           continue;
         end;

         if pva.check = 0 then begin
            if RaceServer = RC_USERHUMAN then begin
               cret := TCreature(pva.cret);
               if(Assigned(cret)) then begin
                  if not cret.HideMode  and (not cret.m_boNotOnlineAddExp) then //HideModeÀÎ °ÍÀº RM_DIGDOWN ¸Þ¼¼Áö¸¦ º¸³½´Ù....
                     SendMsg (cret, RM_DISAPPEAR, 0, 0, 0, 0, '');
                  // 2003/03/18
                  // 2003/04/01 ÇÑ¹ø È°¼ºÈ­µÈ ¸÷ÀÇ °æ¿ì SearchViewRange ³»¿¡¼­´Â °¨¼Ò½ÃÅ°Áö ¾Ê´Â´Ù
                  // 2003/04/21
//                cret.DecRefObjCount;
//                SendMsg (cret, RM_DECREFOBJCOUNT, 0, 0, 0, 0, '');
               end;
            end;
            VisibleActors.Delete (i);
            Dispose (pva);
            continue;
         end else begin
            if RaceServer = RC_USERHUMAN then begin
               if pva.check = 2 then begin // new enterance creature
                  cret := TCreature (pva.cret);
                  if cret <> self then begin
                     if cret.Death  then begin
                        if cret.BoSkeleton then
                           SendMsg (cret, RM_SKELETON, cret.Dir, cret.CX, cret.CY, 0, '')
                        else SendMsg (cret, RM_DEATH, cret.Dir, cret.CX, cret.CY, 0, '');
                     end else begin
                        uname := cret.GetUserName;
                        SendMsg (cret, RM_TURN, cret.Dir, cret.CX, cret.CY, 0, uname);  //Ã³À½º¸´Â Ä³¸¯ÀÎ °æ¿ì

                        //ºñ¿ùÃµÁÖ »óÅÂ º¯È­(sonmg 2005/08/19)
                        if cret.RaceServer = RC_FOXBEAD then begin
                           SendMsg (cret, RM_FOXSTATE, cret.Dir, cret.CX, cret.CY, cret.BodyState, uname);
                        end;
                     end;
                     //SendMsg (cret, RM_USERNAME, 0, 0, 0, 0, cret.UserName);
                  end;
               end;
            end;
         end;
         Inc (i);
      end;
   except
      MainOutMessage (MapName + ',' + IntToStr(CX) + ',' + IntToStr(CY) + ' SearchViewRange 2');
      KickException;
   end;

   try
      if RaceServer = RC_USERHUMAN then begin  // »ç¿ëÀÚ ÇÑÅ×¸¸ Àü´Þ
         i := 0;
         while TRUE do begin
            if i >= VisibleItems.Count then break;
            if PTVisibleItemInfo(VisibleItems[i]).check = 0 then begin //»ç¶óÁü
               pvi := PTVisibleItemInfo (VisibleItems[i]);
               SendMsg (self, RM_ITEMHIDE, 0, pvi.Id, pvi.x, pvi.y, '');
               VisibleItems.Delete (i);
               Dispose (pvi);
            end else begin
               if PTVisibleItemInfo(VisibleItems[i]).check = 2 then begin // new visible item
                  pvi := PTVisibleItemInfo (VisibleItems[i]);
                  SendMsg (self, RM_ITEMSHOW, pvi.looks, pvi.Id, pvi.x, pvi.y, pvi.Name);
               end;
               Inc (i);
            end;
         end;

         i := 0;
         while TRUE do begin
            try
               if i >= VisibleEvents.Count then break;

               try
                  event := TEvent(VisibleEvents.Items[i]);
               except
                  VisibleEvents.Delete(I);
                  if VisibleEvents.Count > 0 then Continue;
                  Break;
               end;
               if event <> nil then begin
                  if event.Check = 0 then begin
                     SendMsg (self, RM_HIDEEVENT, 0, integer(event), event.X, event.Y, '');
                     VisibleEvents.Delete (i);
                     if VisibleEvents.Count > 0 then Continue;
                  end else if event.Check = 1 then begin
                     event.Check := 0;
                  end else begin
                     if event.Check = 2 then begin
                        SendMsg (self, RM_SHOWEVENT, event.EventType, integer(event), MakeLong(event.x, event.EventParam), event.y, '');
                     end;
                  end;
               end;
            except
               Break;
            end;
            Inc (i);
         end;
      end;
   except
      MainOutMessage (MapName + ',' + IntToStr(CX) + ',' + IntToStr(CY) + ' SearchViewRange 3');
      KickException;
   end;
  //¼ÙËÀ´úÂë½ØÖÁ
end;

function  TCreature.Feature: integer;
begin
   Result := GetRelFeature (nil);
end;
//jingdian add  Ìí¼Ó³á°òµÄÖ§³Ö
function TCreature.FeatureEx: Word;
begin
  Result := MakeWord(WeaponEffType, DressEffType);
end;

function  TCreature.GetRelFeature (who: TCreature): integer;
var
   dress, weapon, face, r, a: integer;
   ps: PTStdItem;
   booldversion: Boolean;
begin
   bShowTrans := 0;
   if RaceServer = RC_USERHUMAN then begin
      dress := 0;
      if UseItems[U_DRESS].Index > 0 then begin
         ps := UserEngine.GetStdItem (UseItems[U_DRESS].Index);
         if ps <> nil then begin
            dress := ps.Shape * 2;  //³²ÀÚ¿Ê ¿©ÀÚ¿ÊÀÌ µû·Î ÀÖÀ½
         end;
      end;
      dress := dress + Sex;
      weapon := 0;
      if UseItems[U_WEAPON].Index > 0 then begin
         ps := UserEngine.GetStdItem (UseItems[U_WEAPON].Index);
         if ps <> nil then begin
            weapon := ps.Shape * 2;
         end;
      end;
      weapon := weapon + Sex;
      face := Hair * 2 + Sex;
      if boShowTrans and (UseItems[U_TRANS].Index > 0) then begin
         ps := UserEngine.GetStdItem (UseItems[U_TRANS].Index);
         if ps <> nil then begin
            dress := ps.Shape;
            bShowTrans := 1;
         end;
      end;
      Result := MakeFeature (Sex, Dress, Weapon, Face);
   end else begin
      booldversion := FALSE;
      // 2003/02/11 ¾µ¸ð¾ø´Â ·ÎÁ÷ »èÁ¦...
{
      if who <> nil then begin
         if who.BoOldVersionUser_Italy then
            booldversion := TRUE;
      end;
      if booldversion then begin
         //ÀÌÅ»¸®¾Æ¼­¹ö ÀÌÀü ¹öÁ¯ »ç¿ëÀÚ Á¢¼ÓÀÌ °¡´ÉÇÏµµ·Ï
         r := RaceImage;
         a := Appearance;
         case a of
            160: //´ß
               begin
                  r := 10;
                  a := 0;
               end;
            161: //»ç½¿
               begin
                  r := 10;
                  a := 1;
               end;
            163: //Ä§°Å¹Ì
               begin
                  r := 11;
                  a := 3;
               end;
            0: //°æºñº´
               begin
                  r := 12;
                  a := 5;
               end;
            162: //¿é
               begin
                  r := 11;
                  a := 6;
               end;
            1: //¹¶ÄÚ
               begin
                  r := 11;
                  a := 9;
               end;
         end;
         Result := MakeFeatureAp (r, DeathState, a);
      end else
}

         if ( RaceServer = RC_CLONE) then // ºÐ½ÅÀÌ¸é »ç¶÷ÀÇ ¸ð½ÀÀ» ³»·ÁÁÜ
         begin
             Result := MasterFeature
         end
         else
         begin
             Result := MakeFeatureAp (RaceImage, DeathState, Appearance);
         end;
   end;
end;

{function   TCreature.GetCharStatus(poison: byte; Status: Boolean): integer; //È¡µÃ×´Ì¬   £¬±»¸Ä¹ýµÄ
var
   i, s: integer;
begin
   s := 0;
   for i:=0 to STATUSARR_SIZE-1 do begin
      if StatusArr[i] > 0 then
      begin
         s := longword(s) or ($80000000 shr i);
         if (poison = i) and Status then
           Break
      end;
   end;
   Result := s or (CharStatusEx and $0000FFFF); // sonmg ¼öÁ¤(2004/03/29)
end;   }

function   TCreature.GetCharStatus(poison: byte; Status: Boolean): integer;           //¾­µäÔ­°æµÄÊ©¶¾ºó×´Ì¬2021.12.19
var
   i, s: integer;
begin
   s := 0;
   for i:=0 to STATUSARR_SIZE-1 do begin
      if StatusArr[i] > 0 then
         s := longword(s) or ($80000000 shr i);
   end;
   Result := s or (CharStatusEx and $0000FFFF); // sonmg ÐÞÕý(2004/03/29)
end;

procedure  TCreature.InitValues;
begin
   //´É·ÂÄ¡
   WAbil := Abil;
end;

procedure  TCreature.Initialize;
var
   i, n: integer;
begin
   InitValues;
   //¸¶¹ý °Ë»ç
   for i:=0 to MagicList.Count-1 do begin
      n := PTUserMagic (MagicList[i]).Level;
      if not (n in [0..3]) then
         PTUserMagic (MagicList[i]).Level := 0;
   end;
   //¸Ê¿¡ µîÀå
   ErrorOnInit := TRUE;
   if PEnvir.CanWalk (CX, CY, TRUE{°ãÄ§Çã¿ë}) then begin
      if Appear then begin
         ErrorOnInit := FALSE;
      end;
   end;
   CharStatus := GetCharStatus;
   AddBodyLuck (0);
   //¹ÖÎïËµ»° rainee
   if (RaceServer >= RC_ANIMAL) then
    LoadSayMsg;
   //MonsterSayMsg(nil, s_MonGen);
end;

procedure  TCreature.Finalize;
begin

end;

function  TCreature.GetMasterRace: integer; //ÁÖÀÎÀÌ ¾î¶² Á¾Á·ÀÎÁö ¾ò´Â´Ù.
begin
   Result := -1;  // ÁÖÀÎÀÌ ¾øÀ½

   if Master <> nil then begin
      // ÁÖÀÎÀÌ ÀÖÀ¸¸é Á¾Á· ¹øÈ£¸¦ ¸®ÅÏÇÔ.
      Result := Master.RaceServer;
   end;
end;

procedure  TCreature.FeatureChanged;
begin
   //SendRefMsg (RM_FEATURECHANGED, 0, Feature, 0, 0, '');   ³á°òÏûÏ¢ÐÞ¸Ä
   SendRefMsg(RM_FEATURECHANGED, FeatureEx, Feature, bShowTrans, 0, '');
end;

procedure  TCreature.CharStatusChanged;
begin
   SendRefMsg (RM_CHARSTATUSCHANGED, HitSpeed{wparam}, CharStatus, 0, 0, '');
end;

function   TCreature.Appear: Boolean;
var
   outofrange: pointer;
begin
   outofrange := PEnvir.AddToMap (CX, CY, OS_MOVINGOBJECT, self);
   if outofrange = nil then begin
      Result := FALSE;
   end else
      Result := TRUE;
   if not HideMode then
      SendRefMsg (RM_TURN, Dir, CX, CY, 0, '');
   //·¹º§¿¡ ¸Â°Ô ÀÔÀåÇÒ ¼ö ÀÖ´Â ¸ÊÀÎÁö Ã¼Å© ÇØ¾ß ÇÔ
end;

function   TCreature.Disappear(num :integer): Boolean;
var
    rtn : integer;
begin
   // ¼­¹ö°£ ÀÌµ¿½Ã¿¡´Â ¸ÕÀú »ç¶óÁö±â ¶§¹®¿¡.. ¶Ç´Ù½Ã ºÒ¸®Áö ¾Ê°Ô Ã³¸®ÇÑ´Ù.
   // 2003-09-25
   if FAlreadyDisapper then
   begin
     Result := true;
     Exit;
   end;

   rtn := PEnvir.DeleteFromMap (CX, CY, OS_MOVINGOBJECT, self);
   if rtn <> 1 then
   begin
     MainOutMessage ('DeleteFromMapError['+IntToStr(Rtn)+']'+PEnvir.MapName+','+IntTostr(CX)+','+IntToStr(CY)+':'+IntToStr(num));
     Result := false;
   end
   else
   begin
       SendRefMsg (RM_DISAPPEAR, 0, 0, 0, 0, '');
       Result := TRUE;
   end;
end;

//È¡µÃ¹ÖÎïËµ»°ÐÅÏ¢ÁÐ±í
procedure  TCreature.LoadSayMsg;
var
  I: Integer;
begin
  for I := 0 to g_MonSayMsgList.Count - 1 do begin
    if CompareText(g_MonSayMsgList.Strings[I], UserName) = 0 then begin
      m_SayMsgList := TList(g_MonSayMsgList.Objects[I]);
      Break;
    end;
  end;
end;

procedure  TCreature.MonsterSayMsg(AttackCret: TCreature; MonStatus: TMonStatus);
  function AnsiReplaceText(const AText, AFromText, AToText: string): string;
  begin
    Result := StringReplace(AText, AFromText, AToText, [rfReplaceAll, rfIgnoreCase]);
  end;
  function FilterShowName(sName: string): string;
  var
    I: Integer;
    SC: string;
    bo11: Boolean;
  begin
    Result := '';
    SC := '';
    bo11 := False;
    for I := 1 to Length(sName) do begin
      if ((sName[I] >= '0') and (sName[I] <= '9')) or (sName[I] = '-') then begin
        Result := Copy(sName, 1, I - 1);
        SC := Copy(sName, I, Length(sName));
        bo11 := True;
        Break;
      end;
    end;
    if not bo11 then Result := sName;
  end;

var
  I: Integer;
  nMsgColor: Integer;
  sMsg: string;
  MonSayMsg: pTMonSayMsg;
  sAttackName: string;
begin
  if m_SayMsgList = nil then Exit;
  if (AttackCret <> nil) then begin
    if (AttackCret.RaceServer <> RC_USERHUMAN) and (AttackCret.Master = nil) then begin
      Exit;
    end;
    if AttackCret.Master <> nil then sAttackName := AttackCret.Master.UserName
    else sAttackName := AttackCret.UserName;
  end;
  for I := 0 to m_SayMsgList.Count - 1 do begin
    MonSayMsg := m_SayMsgList.Items[I];
    if MonSayMsg = nil then Continue;
    sMsg := AnsiReplaceText(MonSayMsg.sSayMsg, '%s', FilterShowName(UserName));
    sMsg := AnsiReplaceText(sMsg, '%d', sAttackName);
    if (MonSayMsg.State = MonStatus) and (Random(MonSayMsg.nRate) = 0) then begin
      if MonStatus = s_MonGen then begin
        //UserEngine.SendBroadCastMsg(sMsg, t_Mon);
        UserEngine.SysMsgAll(sMsg);
        Break;
      end;
      if MonSayMsg.Color = 0 then begin
        //ProcessSayMsg(sMsg);
        Say(sMsg);
      end else begin
        AttackCret.SysMsg(sMsg, 5, MonSayMsg.Color);
      end;
      Break;
    end;
  end;
end;


procedure  TCreature.KickException;
var
   hum: TUserHuman;
begin
   if RaceServer = RC_USERHUMAN then begin
      MapName := HomeMap;
      CX := HomeX;
      CY := HomeY;
      hum := TUserHuman(self);
      hum.EmergencyClose := TRUE;
   end else begin  //
      Death := TRUE;
      DeathTime := GetTickCount;
      MakeGhost(3);
   end;
end;

// mode = 0  walk
//        1  run
function  TCreature.Walk (msg: integer): Boolean;
var
   i: integer;
   pm: PTMapInfo;
   pat: PTAThing;
   pgate: PTGateInfo;
   inrange: Boolean;
   newenv: TEnvirnoment;
   newmap: string;
   hum: TUserHuman;
   event: TEvent;
   down : integer;
label
   needholefinish;
begin
   Result := TRUE;
   down   := 0;
   try
      inrange := PEnvir.GetMapXY (CX, CY, pm);
      pgate := nil;
      event := nil;
      if inrange then begin
         down   := 1;
         if pm.ObjList <> nil then begin
            down   := 2;
            for i:=0 to pm.ObjList.Count-1 do begin
               down   := 3;
               pat := pm.ObjList[i];
               if pat.Shape = OS_GATEOBJECT then begin
                  down   := 4;
                  pgate := PTGateInfo (pat.AObject);
               end;
               if pat.Shape = OS_EVENTOBJECT then begin
                  down   := 5;
                  if TEvent(pat.AObject).OwnCret <> nil then
                     event := TEvent (pat.AObject);
                  continue;
               end;
               if pat.Shape = OS_MAPEVENT then begin
                  {???}
               end;
               if pat.Shape = OS_DOOR then begin
               end;
               if pat.Shape = OS_ROON then begin
               //   proon := PTRoonInfo (pat.AObject);
               end;

            end;
         end;
      end;

      down   := 10;
      if event <> nil then begin
         down   := 11;
         if event.OwnCret.IsProperTarget (self) then begin
            down   := 12;
            SendMsg (event.OwnCret, RM_MAGSTRUCK_MINE, 0, event.Damage, 0, 0, '');
         end;
      end;

      down   := 20;
      if Result and (pgate <> nil) then begin
         down   := 21;
         if RaceServer = RC_USERHUMAN then begin //npc ´Â ¹®¹ÛÀ¸·Î ¾È ³ª°¨
            if PEnvir.AroundDoorOpened (CX, CY) then begin
               //±¸¿ïÀÇ¹æ ÀÎ°æ¿ì, Á»ºñ°¡ ³ª¿Â ±¸¸ÛÀÌ ÀÖ¾î¾ß µé¾î °£´Ù.
               if TEnvirnoment (pgate.EnterEnvir).NeedHole then begin
                  if EventMan.FindEvent (PEnvir, CX, CY, ET_DIGOUTZOMBI) = nil then
                     goto needholefinish;
               end;
               if ServerIndex = TEnvirnoment(pgate.EnterEnvir).Server then begin
                  if not EnterAnotherMap (TEnvirnoment(pgate.EnterEnvir), pgate.EnterX, pgate.EnterY) then
                     Result := FALSE;
               end else begin
                  hum := TUserHuman(self);
                  if GetTickCount - hum.LatestDropTime > 1000 then begin
                     //¼­¹ö ÀÌµ¿ check disappear
                     if Disappear(1) = true then
                     begin
                        SpaceMoved := TRUE;
                        hum := TUserHuman (self);
                        hum.ChangeMapName := TEnvirnoment(pgate.EnterEnvir).MapName;
                        hum.ChangeCX := pgate.EnterX;
                        hum.ChangeCY := pgate.EnterY;
                        hum.BoChangeServer := TRUE;
                        hum.ChangeToServerNumber := TEnvirnoment(pgate.EnterEnvir).Server;
                        //UserEngine.UserServerChange (hum, TEnvirnoment(pgate.EnterEnvir).Server);
                        hum.EmergencyClose := TRUE;
                        hum.SoftClosed := TRUE;  //CertifycationÀ» ¸¸·á½ÃÅ°Áö ¾Ê´Â´Ù.
                        hum.FAlreadyDisapper :=TRUE;
                     end
                     else
                        Result := FALSE;
                  end else begin
                     Result := FALSE;
                  end;

               end;
               needholefinish:
            end; //¹®ÀÌ Àá±è Result=true Á¤»ó
         end else
            Result := FALSE; // npc°¡ ¹®À» ¸·´Â°ÍÀ» ¹æÁöÇÏ±â À§ÇØ¼­
      end else begin
         down   := 22;
         if Result then
            SendRefMsg (msg, Dir, CX, CY, 0, '');
      end;
   except
      MainOutMessage ('[TCreature] Walk exception ' + MapName + ' ' + IntToStr(CX) + ':' + IntToStr(CY) + '>' + IntToStr(down) );
   end;
end;

function  TCreature.EnterAnotherMap (enterenvir: TEnvirnoment; enterx, entery: integer): Boolean;
var
   i, oldx, oldy: integer;
   pm: PTMapInfo;
   oldpenvir: TEnvirnoment;
begin
   Result := FALSE;

   if enterenvir = nil then
   begin
      MainOutMessage('ERROR! EnterAnotherMap Enviroment is NIL');
      exit;
   end;

   try
      //1) µé¾î °¥ ¼ö ÀÖ´ÂÁö, ÀûÇÕÇÑÁö
      if Abil.Level < enterenvir.NeedLevel then exit;


      if enterenvir.MapQuest <> nil then begin
         TMerchant (enterenvir.MapQuest).UserCall (self);
      end;

      if enterenvir.NeedSetNumber >= 0 then begin
         if GetQuestMark (enterenvir.NeedSetNumber) <> enterenvir.NeedSetValue then
            exit;
      end;

      if not enterenvir.GetMapXY (enterx, entery, pm) then exit;

      if enterenvir = UserCastle.CorePEnvir then begin //»çºÏ¼ºÀÇ ³»¼ºÀÎ °æ¿ì
         if RaceServer = RC_USERHUMAN then
            if not UserCastle.CanEnteranceCoreCastle (CX, CY, TUserHuman(self)) then  //
               exit;  //µé¾î°¥ ¼ö ¾øÀ½.
      end;

      oldpenvir := PEnvir;
      oldx := CX;
      oldy := CY;

      //2) Áö±Ý ¸Ê¿¡¼­ ¶°³², º¯¼ö ÃÊ±âÈ­
      // ¸¸¾à »ç¶óÁöÁö ¾Ê´Â´Ù¸é ±×³É ³ª°£´Ù.
      // if Disappear(2) = false then   Exit;
      Disappear(2);

      try
         MsgTargetList.Clear;
      except
         MainOutMessage ('[Exception] MsgTargetList.Clear');
      end;
      try
      for i:=0 to VisibleItems.Count-1 do
         Dispose (PTVisibleItemInfo (VisibleItems[i]));
      except
         MainOutMessage ('[Exception] VisbleItems Dispose(..)');
      end;
      try
         VisibleItems.Clear;
      except
         MainOutMessage ('[Exception] VisbleItems.Clear');
      end;
      try
         VisibleEvents.Clear;
      except
         MainOutMessage ('[Exception] VisbleEvents.Clear');
      end;
      if (enterenvir.TimeMap <> '') and (StrToDateTime(enterenvir.TimeMap) > Now) then begin
        TUserHuman(Self).SysMsg('´ËµØÍ¼ÔÝÎ´¿ª·Å,¿ª·ÅÊ±¼ä: '+enterenvir.TimeMap, 0);
        Result := FALSE;
        exit;
      end;

      // 2003/03/18
      try
         i := 0;
         while TRUE do begin
            if i >= VisibleActors.Count then break;
            {
            if RaceServer = RC_USERHUMAN then begin
            try
               if(PTVisibleActor(VisibleActors[i]).cret <> nil) then
                  TCreature (PTVisibleActor(VisibleActors[i]).cret).DecRefObjCount;
            except
               MainOutMessage ('[Exception] TCreatre.Destroy : Visible Actor Dec RefObjCount');
            end;
            end;
            }
            Dispose (PTVisibleActor(VisibleActors[i]));
            VisibleActors.Delete(i);
//          Inc(i);
         end;
      except
         MainOutMessage ('[Exception] VisbleActors Dispose(..)');
      end;
      try
         VisibleActors.Clear;
      except
         MainOutMessage ('[Exception] VisbleActors.Clear');
      end;

      SendMsg (self, RM_CLEAROBJECTS, 0, 0, 0, 0, '');

      //3) »õ¸Ê¿¡ µîÀå
      PEnvir := enterenvir;
      MapName := enterenvir.MapName;
      CX := enterx;
      CY := entery;
      SendMsg (self, RM_CHANGEMAP, 0, 0, 0, 0, enterenvir.GetGuildAgitRealMapName);
        if TUserHuman(Self).iHours <> 0 then
       begin
          FrmIDSoc.SendRechargeInfo (UserName, TUserHuman(Self).UserId, TUserHuman(Self).Certification);
       end;

        if boSecondCardSystem then
        begin
          if (Abil.Level > g_nExpErienceLevel) then
          begin
            if (TUserHuman(self).iDay <= 0) then
            begin
               if (TUserHuman(self).SecondsCard <= 0) and (PEnvir.MapName <> g_sRechargingMap) then begin
                 SysMsg ('[ÕË»§ÐÅÏ¢]µ±Ç°ÕË»§³äÖµÊ±¼äÒÑµ½ÆÚ', 0);
                 if RaceServer = RC_USERHUMAN   then begin
                 if GrobalEnvir.GetEnvir (g_sRechargingMap) <> nil then begin
                   SendRefMsg (RM_SPACEMOVE_HIDE, 0, 0, 0, 0, '');
                   RandomSpaceMove (g_sRechargingMap, 0); //¹«ÀÛÀ§ °ø°£ÀÌµ¿
                 end;
               end;
            end;
          end;
        end;
      end;


      if Appear then begin
         MapMoveTime := GetTickCount;
         SpaceMoved := TRUE; //WalkTo°¡ ½ÇÆÐÇÏÁö ¾Ê°Ô ÇÏ·Á°í..
         Result := TRUE;
      end else begin
         MapName := oldpenvir.MapName;
         PEnvir := oldpenvir;   //»øÆÐÇÑ°æ¿ì
         CX := oldx;
         CY := oldy;
         if ( nil = PEnvir.AddToMap (CX, CY, OS_MOVINGOBJECT, self)) then
         begin
            MainOutMessage('ERROR NOT ADDTOMAP EnterAnotherMap:'+
            MapName+','+IntTostr(CX)+','+IntTOStr(CY));
         end;
      end;

      //¹®ÆÄ´ëÀüÀåÀ» µé¾î°¡°Å³ª ³ª°¥ ¶§
      if PEnvir.Fight3Zone and (PEnvir.Fight3Zone <> oldpenvir.Fight3Zone) then
         UserNameChanged;  //ÀÌ¸§ »ö º¯°æ

   except
      MainOutMessage ('[TCreature] EnterAnotherMap exception');
   end;
end;

procedure TCreature.Turn (dir: byte);
begin
   self.Dir := dir;
   SendRefMsg (RM_TURN, Dir, CX, CY, 0, '');
end;

procedure TCreature.Say (saystr: string);
begin
	SendRefMsg (RM_HEAR, 0, clBlack, clWhite, 0, UserName + ': ' + saystr);
end;


procedure  TCreature.SysScrollMsg (str: string; fc: byte; bc: byte);
begin
   if RaceServer <> RC_USERHUMAN then begin
      exit;
   end;

   if (fc <> 0) or (bc <> 0) then begin
      SendMsg (self, RM_SYSSCROLLMESSAGE, 0, fc, bc, 0, str);
      exit;
   end;
end;

procedure  TCreature.SysMsg (str: string; mode: integer; fc: byte; bc: byte; fixde: byte; color: Integer);
begin
   if RaceServer <> RC_USERHUMAN then begin
      //¸ó½ºÅÍ¿¡°Ôµµ ½Ã½ºÅÛ ¸Þ½ÃÁö°¡ Àü¼ÛµÇ´Â °ÍÀ» ¸·À½(sonmg 2005/01/24)
//      MainOutMessage('TCreature.SysMsg : not Human ' + IntToStr(RaceServer) + ', ' + IntToStr(mode) );
      exit;
   end;

   if (fc <> 0) or (bc <> 0) then begin
      SendMsg (self, RM_SYSMESSAGECOLOR, 0, 0, fc, bc, str);
      exit;
   end;

   case mode of
      1:   SendMsg (self, RM_SYSMESSAGE2, 0, 0, 0, 0, str);
      2:   SendMsg (self, RM_SYSMSG_BLUE, 0, 0, 0, 0, str);
      3:   SendMsg (self, RM_SYSMESSAGE3, 0, 0, 0, 0, str);
      4:   SendMsg (self, RM_SYSMSG_REMARK, 0, 0, 0, 0, str);
      5:   SendMsg (self, RM_SYSMSG_PINK, 0, 0, 0, 0, str);
      6:   SendMsg (self, RM_SYSMSG_GREEN, 0, 0, 0, 0, str);
      7:   SendMsg (self, RM_SYSMSG_USE, 0, 0, 0, 0, str);
      8:   SendMsg (self, RM_SYSMSG_USE_HORN, fixde, 0, 0, 0, str);
      9:   SendMsg (self, RM_SYSMESSAGE, 0, MakeWord(color, 255), 0, 0, str); //¹ÖÎïËµ»° rainee
      10:   SendMsg (self, RM_SYSMSG_REMARK2, 0, 0, 0, 0, str);
      11:   SendMsg (self, RM_SYSMSG_REMARK3, 0, 0, 0, 0, str);
      else SendMsg (self, RM_SYSMESSAGE, 0, 0, 0, 0, str);     //SendMsg (self, RM_SYSMESSAGE, 0, 0, 0, 0, str);
   end;
end;

procedure TCreature.BoxMsg( str : string; mode: integer);
begin
   if RaceServer <> RC_USERHUMAN then begin
      //¸ó½ºÅÍ¿¡°Ô´Â ¸Þ½ÃÁö¸¦ Àü¼ÛÇÏÁö ¾Ê´Â´Ù.(sonmg 2005/01/24)
      MainOutMessage('TCreature.BoxMsg : not Human');
      exit;
   end;

   SendMsg (self, RM_MENU_OK, 0, integer(self), 0, 0, str);
end;

procedure  TCreature.GroupMsg (str: string);
var
   i: integer;
begin
   if GroupOwner <> nil then begin
      for i:=0 to GroupOwner.GroupMembers.Count-1 do begin
         TCreature(GroupOwner.GroupMembers.Objects[i]).SendMsg (self, RM_GROUPMESSAGE, 0, 0, 0, 0, '-' + str);
      end;
   end;
end;

procedure  TCreature.NilMsg (str: string);
begin
   SendMsg (nil, RM_HEAR, 0, 0, 0, 0, str);
end;

procedure TCreature.MakeGhost( num :integer);     //¿ÏÀüÈ÷ Á×À½, »ç¶óÁú ¿¹Á¤
begin
   BoGhost := TRUE;
   GhostTime := GetTickCount;
   if Disappear(3) = false then
   begin
       MainOutMessage(  'Not MakeGhost: '+self.UserName+','+self.MapName+','+
                        IntTostr(self.cx)+','+intTostr(self.cy)+':'+IntToStr(num));
   end
   else
   begin
        self.FAlreadyDisapper := true;
   end;
end;

procedure TCreature.ApplyMeatQuality;  //µ¿¹°(»ç½¿)ÀÎ °æ¿ì °í±âÇ°Áú..
var
   i: integer;
   pstd: PTStdItem;
begin
   for i:=0 to ItemList.Count-1 do begin
      pstd := UserEngine.GetStdItem (PTUserItem(ItemList[i]).Index);
      if pstd <> nil then begin
         if pstd.Stdmode = 40 then begin //°í±âµ¢¾î¸®ÀÎ °æ¿ì
            PTUserItem(ItemList[i]).Dura := MeatQuality;
         end;
      end;
   end;
end;

//Ä¿±êÖ»¶Ô¹ÖÎïÊ¹ÓÃ
function  TCreature.TakeCretBagItems (target: TCreature): Boolean; //½«ËùÓÐÎïÆ··ÅÔÚ¶Ô·½µÄ±³°üÖÐ¡£
var
   i: integer;
   hum: TUserHuman;
   ps: PTStdItem;
   IsAddNew: Boolean;
   countstr: string;
begin
   Result := FALSE;
   countstr := '';
   while TRUE do begin
      if target.ItemList.Count <= 0 then break;

      ps := UserEngine.GetStdItem(PTUserItem(target.ItemList[0]).Index); //pu.Index);   // gadget: Ä«¿îÆ®¾ÆÀÌÅÛ
      if ps <> nil then begin
         IsAddNew := TRUE;
         if ps.OverlapItem >= 1 then begin
            if PTUserItem(target.ItemList[0]).Dura > 0 then begin
               countstr := '(' + IntToStr(PTUserItem(target.ItemList[0]).Dura) + ')';  //·Î±×¸¦ À§ÇÑ ¾ÆÀÌÅÛ °³¼ö(sonmg 2005/10/27)
               if UserCounterItemAdd(ps.StdMode, ps.Looks, PTUserItem(target.ItemList[0]).Dura, ps.Name, FALSE) then begin
                  IsAddNew := FALSE;

                  //·Î±×³²±è
                  if not IsCheapStuff (ps.StdMode) then begin
                     AddUserLog ('4'#9 + //ÁÝ±â_
                                 MapName + ''#9 +
                                 IntToStr(CX) + ''#9 +
                                 IntToStr(CY) + ''#9 +
                                 UserName + ''#9 +
                                 ps.Name + ''#9 +
                                 IntToStr(PTUserItem(target.ItemList[0]).MakeIndex) + ''#9 +
                                 '0'#9 + //½ä¾î¼­ ¾ò±â
                                 '0' + countstr);  //°³¼ö·Î±×(sonmg 2005/01/07)
                  end;

                  target.ItemList.Delete(0);
                  Result := TRUE;
               end;
            end else begin
               PTUserItem(target.ItemList[0]).Dura := 1; //sonmg
            end;
         end;
         if IsAddNew then begin
            if AddItem(PTUserItem(target.ItemList[0])) then begin
               if RaceServer = RC_USERHUMAN then begin
                  if self is TUserHuman then begin
                     hum := TUserHuman(self);
                     TUserHuman(hum).SendAddItem(PTUserItem(target.ItemList[0])^);

                     //·Î±×³²±è
                     if not IsCheapStuff (ps.StdMode) then begin
                        AddUserLog ('4'#9 + //ÁÝ±â_
                                    MapName + ''#9 +
                                    IntToStr(CX) + ''#9 +
                                    IntToStr(CY) + ''#9 +
                                    UserName + ''#9 +
                                    ps.Name + ''#9 +
                                    IntToStr(PTUserItem(target.ItemList[0]).MakeIndex) + ''#9 +
                                    '0'#9 + //½ä¾î¼­ ¾ò±â
                                    '0' + countstr);  //°³¼ö·Î±×(sonmg 2005/01/07)
                     end;

                     Result := TRUE;
                  end;
               end;
               target.ItemList.Delete(0);
            end else
               break;
         end;
      end else
         break;
   end;
end;

//ËÀÍöÎïÆ·µôÂä¹æÔò
//itemownershiop : ÎïÆ·¿ÉÒÔ´Ó¹ÖÊÞÁ÷³ö
//                 ¹ÖÊÞµÄÎïÆ·ÕÒÁËÕýÈ·µÄÓÃÍ¾Ê¹ÓÃ
procedure TCreature.ScatterBagItems (itemownership: TObject);
var
   i, dropwide: integer;
   drcount, icount: integer;
   pu, newpu: PTUserItem;
   pstd: PTStdItem;
   dellist: TStringList;
   boDropall: Boolean;
begin
   dellist := nil;

   if DontBagItemDrop then begin
      DontBagItemDrop := false;
      Exit;
   end;

   boDropall := TRUE;
   if RaceServer = RC_USERHUMAN then begin
      dropwide := 2;
      if PKLevel < 2 then boDropall := FALSE; //µô±³°üÈ«²¿ÎïÆ·. 1/3µÄ¼¸ÂÊµôÂä.
      //ºìÃûÈ«²¿µôÂä
   end else
      dropwide := 3;

   try
      for i:=ItemList.Count-1 downto 0 do begin
         pu := PTUserItem(ItemList[i]);
         pstd := UserEngine.GetStdItem (pu.Index);

         if pstd = nil then continue;
         //Á×¾úÀ»¶§ »óÇöÁÖ¸Ó´Ï´Â ¾È¶³±¸°Ô...(sonmg 2004/08/09)
         if (pstd.StdMode = STDMODE_OF_DECOITEM) and (pstd.Shape = SHAPE_OF_DECOITEM) then continue;
         if (RaceServer = RC_USERHUMAN) and ((pstd.UniqueItem and $04) <> 0) then continue; //UNIQUEITEM×Ö¶Î°üº¬000000£¨2½øÖÆ£©µÄ»°£¬ÎÞ·¨µôÂäµÄÎïÆ·£¨sonmg 2005/03/14£©

         //Ì¨Íå,
         //stdmode=51ºÅÊÇËÀµÄÊ±ºòÒ»¶¨»áµôÏÂÀ´..¡£¶øÇÒ¶ÏÁËÁ¬½ÓµÄÊ±ºòÒ²»áµôÏÂÀ´¡£
         if BoTaiwanEventUser then begin
            //Ì¨Íå»î¶¯£¬»î¶¯Íæ¼ÒËÀÍöÊ±Ö»ÓÐ»î¶¯µÀ¾ßµôÂä.
            //ÆäËûÎïÆ·²»»áµôÂä.
            if (pstd.StdMode = TAIWANEVENTITEM) then begin
               if DropItemDown (PTUserItem(ItemList[i])^, dropwide, TRUE, itemownership, self , 0) then begin
//                  pu := PTUserItem(ItemList[i]);
                  if RaceServer = RC_USERHUMAN then begin
                     if dellist = nil then dellist := TStringList.Create;
                     //½«µôÂäµÄÎïÆ·Í¨Öª¿Í»§¶Ë¡£
                     dellist.AddObject(UserEngine.GetStdItemName (pu.Index), TObject(pu.MakeIndex));
                  end;
                  Dispose(PTUserItem(ItemList[i]));
                  ItemList.Delete (i);
               end;
            end;
         end else begin
            if (Random((beibaobaolv)) = 0) or boDropall then begin  //ÈËÎïËÀÍö±³°üµôÂäÎïÆ·µÄ¼¸ÂÊ£¬ºóÃæµÄRANDOM  Ä¬ÈÏÊÇRandom(3) = 0
               //Èç¹ûÓÐ¶à¸öÎïÆ·£¬µÀ¾ßÖ»µôÒ»²¿·Ö¡£
               if pstd.OverlapItem >= 1 then begin
                  icount := pu.Dura;
                  drcount := _MAX(1, Random (icount div 2));  //¾ø¶Ô²»»áÈ«²¿µôÂä
                  icount := _MAX(0, icount - drcount); //¼öÁ¤(sonmg)
                  if drcount > 0 then begin
                     new (newpu);
                     if UserEngine.CopyToUserItemFromName(pstd.Name, newpu^) then begin
                        newpu.Dura := drcount;

                        if DropItemDown(newpu^, dropwide, TRUE, itemownership, self,0) then begin
                           pu.Dura := icount;

                           if pu.Dura <= 0 then begin
                              pu := PTUserItem(ItemList[i]);
                              if RaceServer = RC_USERHUMAN then begin
                                 if dellist = nil then dellist := TStringList.Create;
                                 //Í¨Öª¿Í»§¶ËÉ¾³ýÊ£ÓàÊýÁ¿Îª0µÄÎïÆ·¡£
                                 dellist.AddObject(UserEngine.GetStdItemName (pu.Index), TObject(pu.MakeIndex));
                              end;
                              Dispose(PTUserItem(ItemList[i]));
                              ItemList.Delete (i);
                           end else begin
                              SendMsg(self, RM_COUNTERITEMCHANGE, 0, pu.MakeIndex, pu.Dura, 0, pstd.Name);
                           end;
                        end;
                     end;

                     if newpu <> nil then Dispose( newpu );   // Memory Leak sonmg
                  end;
               end else begin
                  // ¹ÖÎïµôÂä¿óÊ¯´¿¶Èµ÷½Ú.
                  pu := PTUserItem(ItemList[i]);
                  if RaceServer <> RC_USERHUMAN then begin
                     if pstd.StdMode = 43 then begin
                        pu.Dura := GetPurity;
                     end;
                  end;

                  if DropItemDown (pu^, dropwide, TRUE, itemownership, self,0) then begin
//                     pu := PTUserItem(ItemList[i]);
                     if RaceServer = RC_USERHUMAN then begin
                        if dellist = nil then dellist := TStringList.Create;
                        //½«µôÂäµÄÎïÆ·Í¨Öª¿Í»§¶Ë.
                        dellist.AddObject(UserEngine.GetStdItemName (pu.Index), TObject(pu.MakeIndex));
                     end;
                     Dispose(PTUserItem(ItemList[i]));
                     ItemList.Delete (i);
                  end;
               end;
            end;
         end;
      end;

{
      //------------2005 Å©¸®½º¸¶½º ÀÌº¥Æ®(ÇÏµåÄÚµù)--------------
      //¸ðµç ¸ó½ºÅÍ¿¡¼­ ±¤¼®°ú µ·À» ÀÏÁ¤È®·ü·Î µå·Ó(³ª¹«·ù´Â Á¦¿Ü, ÆøÁÖ, ºñ¸·Ãæ Á¦¿Ü)
      //¼ÒÈ¯¸÷ Á¦¿Ü
      if (RaceServer >= RC_ANIMAL) and (RaceServer <> RC_BAMTREE) and (UserName <> __Spider) and (UserName <> __Bee) and (Master = nil) then begin
         new (newpu);
         if Random(100) < 10 then begin
            //±¤¼®1
            if UserEngine.CopyToUserItemFromName('µ¿±¤¼®', newpu^) then begin

               // ¸ó½ºÅÍ µå·Ó ±¤¼® ¼øµµ Á¶Àý.
               newpu.Dura := GetPurity;

               if DropItemDown(newpu^, dropwide, TRUE, itemownership, self,0) then begin
               end;
            end;
         end;

         if Random(100) < 10 then begin
            //±¤¼®2
            if UserEngine.CopyToUserItemFromName('Ã¶±¤¼®', newpu^) then begin

               // ¸ó½ºÅÍ µå·Ó ±¤¼® ¼øµµ Á¶Àý.
               newpu.Dura := GetPurity;

               if DropItemDown(newpu^, dropwide, TRUE, itemownership, self,0) then begin
               end;
            end;
         end;

         if Random(100) < 10 then begin
            //Å©¸®½º¸¶½º ¾ÆÀÌÅÛ1
            if UserEngine.CopyToUserItemFromName('»þÀÌ´×°ñµåº¼', newpu^) then begin
               if DropItemDown(newpu^, dropwide, TRUE, itemownership, self,0) then begin
               end;
            end;
         end;
         if Random(100) < 10 then begin
            //Å©¸®½º¸¶½º ¾ÆÀÌÅÛ2
            if UserEngine.CopyToUserItemFromName('°ñµçº§', newpu^) then begin
               if DropItemDown(newpu^, dropwide, TRUE, itemownership, self,0) then begin
               end;
            end;
         end;
         if Random(100) < 10 then begin
            //Å©¸®½º¸¶½º ¾ÆÀÌÅÛ3
            if UserEngine.CopyToUserItemFromName('¸®º»¸®½º', newpu^) then begin
               if DropItemDown(newpu^, dropwide, TRUE, itemownership, self,0) then begin
               end;
            end;
         end;

         if newpu <> nil then Dispose( newpu );   // Memory Leak sonmg

         if Random(100) < 1 then begin
            //±ÝÀü
            IncGold( 10000 );
            ScatterGolds(itemownership);
         end;
      end;
      //--------------------------------------------------
}

      if dellist <> nil then begin
         SendMsg (self, RM_DELITEMS, 0, integer(dellist), 0, 0, '');
         //dellist´Â rm_delitem¿¡¼­ free ½ÃÄÑ¾ß ÇÑ´Ù.
      end;
   except
      MainOutMessage ('[Exception] TCreature.ScatterBagItems');
   end;
end;

procedure  TCreature.DropEventItems;  //¼´Ê¹»î¶¯µÀ¾ßµôÂä£¬½ÇÉ«ÑÕÉ«Ò²²»»áÔÚÕâÀï¸Ä±ä¡£
var
   i, dropwide: integer;
   pu: PTUserItem;
   pstd: PTStdItem;
   dellist: TStringList;
begin
   dellist := nil;
   dropwide := 3;
   try
      for i:=ItemList.Count-1 downto 0 do begin
         pstd := UserEngine.GetStdItem (PTUserItem(ItemList[i]).Index);
                         //Ì¨Íå,
                         //stdmode=51ºÅÊÇËÀµÄÊ±ºòÒ»¶¨»áµôÏÂÀ´..¡£¶øÇÒ¶ÏÁËÁ¬½ÓµÄÊ±ºòÒ²»áµôÏÂÀ´¡£
         if pstd <> nil then begin
            if (pstd.StdMode = TAIWANEVENTITEM) then begin
               if DropItemDown (PTUserItem(ItemList[i])^, dropwide, TRUE, nil, self,0) then begin
                                            //ÕâÊ±µôÂäµÄÎïÆ·ÊÇÃ»ÓÐÖ÷ÈËµÄÎïÆ·
                  pu := PTUserItem(ItemList[i]);
                  if RaceServer = RC_USERHUMAN then begin
                     if dellist = nil then dellist := TStringList.Create;
                     //½«µôÂäµÄÎïÆ·Í¨Öª¿Í»§¶Ë
                     dellist.AddObject(UserEngine.GetStdItemName (pu.Index), TObject(pu.MakeIndex));
                  end;
                  Dispose(PTUserItem(ItemList[i]));
                  ItemList.Delete (i);
               end;
            end;
         end;
      end;
      if dellist <> nil then begin
         SendMsg (self, RM_DELITEMS, 0, integer(dellist), 0, 0, '');
         //dellist´Â rm_delitem¿¡¼­ free ½ÃÄÑ¾ß ÇÑ´Ù.
      end;
   except
      MainOutMessage ('[Exception] TCreature.DropEventItems');
   end;
end;

procedure TCreature.ScatterGolds (itemownership: TObject);
const
   dropmax = 2000;
var
   i, ngold: integer;
begin
   if DontBagGoldDrop then begin
      DontBagGoldDrop := false;
      Exit;
   end;

   if Gold > 0 then begin
      for i:=0 to 16 do begin
         if Gold > dropmax then begin
            ngold := dropmax;
//            Gold := Gold - dropmax;
            DecGold( dropmax );
         end else begin
            ngold := Gold;
            Gold := 0;
         end;
         if ngold > 0 then begin
            if not DropGoldDown (ngold, TRUE, itemownership, self) then begin
//               Gold := Gold + ngold;
               IncGold( ngold );
               break;
            end;
         end else break;
      end;
      GoldChanged;
   end;
end;

procedure TCreature.DropUseItems (itemownership: TObject; DieFromMob : Boolean);
//ÉúÎïÎïÆ·µôÂä(Ëæ»ú)
//²»ÂÛÊÇÍæ¼Ò»¹ÊÇ¹ÖÎï£¬¶¼ÓÃÕâ¸öº¯ÊýÀ´¼ÆËã
var
   i, ran: integer;
   dellist: TStringList;
   ps: PTStdItem;
   iname: string;
   FameGrade: integer;
begin
   dellist := nil;
   try
      if DontUseItemDrop then begin
         DontUseItemDrop := FALSE;
         exit;
      end;
      if (RaceServer = RC_USERHUMAN) and (not BoOldVersionUser_Italy) then begin
         //------------------------------
         //Òâ´óÀû°æ±¾É¾³ý
         if ENABLE_FAME_SYSTEM then begin
            TUserHuman(self).GetFameName( FameGrade );
           // ×î¸ßµÈ¼¶ 50% Àû¿ë
            if FameGrade >= 20 then begin
               if Random(100) < 50 then begin
                  DontBagItemDrop := TRUE;
                  exit;
               end;
            end else begin
               if Random(100) < ((_MAX(0, FameGrade - 10) div 3) + 1) * 10 then begin
                  DontBagItemDrop := TRUE;
                  exit;
               end;
            end;
         end;
         //------------------------------

        //Òâ´óÀû°æ±¾É¾³ý
         if KOREANVERSION or PHILIPPINEVERSION then begin
            ps := UserEngine.GetStdItem (UseItems[U_CHARM].Index);
            if ps <> nil then begin
               // ¹ß·»Å¸ÀÎ ÀÌº¥Æ®
               if (UseItems[U_CHARM].Index = INDEX_CHOCOLATE) or // ÃÊÄÝ·¿
                  ( (ps.StdMode = 53) and (ps.Shape = SHAPE_OF_LUCKYLADLE) ) or
                  // È­ÀÌÆ®µ¥ÀÌ ÀÌº¥Æ®
                  (UseItems[U_CHARM].Index = INDEX_CANDY) or (UseItems[U_CHARM].Index = INDEX_LOLLIPOP) then // »çÅÁ, ¸·´ë»çÅÁ
               begin
                  // ÃÊÄÝ·¿,»çÅÁ,¸·´ë»çÅÁµµ ¸÷ÇÑÅ× Á×Àº°Ô ¾Æ´Ï¸é ¾È»ç¶óÁü(sonmg 2004/06/24)
                  if DieFromMob then begin
                     if dellist = nil then dellist := TStringList.Create;
                     //¹ö±× ¼öÁ¤(sonmg 2005/03/17)
                     dellist.AddObject(UserEngine.GetStdItemName (UseItems[U_CHARM].Index), TObject(UseItems[U_CHARM].MakeIndex));
                     //·Î±× ³²°Ü¾ß ÇÔ
                     AddUserLog ('16'#9 + //Á×ÆÄ_
                                 MapName + ''#9 +
                                 IntToStr(CX) + ''#9 +
                                 IntToStr(CY) + ''#9 +
                                 UserName + ''#9 +
                                 ps.Name + ''#9 +
                                 IntToStr(UseItems[U_CHARM].MakeIndex) + ''#9 +
                                 IntToStr(BoolToInt(RaceServer = RC_USERHUMAN)) + ''#9 +
                                 '0');

                     UseItems[U_CHARM].Index := 0;
                  end;
                  DontBagItemDrop := true;
                  if dellist <> nil then begin
                     SendMsg (self, RM_DELITEMS, 0, integer(dellist), 0, 0, '');
                     //dellist´Â rm_delitem¿¡¼­ free ½ÃÄÑ¾ß ÇÑ´Ù.
                  end;
                  Exit;
               end;
            end;
         end;

         //ÃÊÈ¥½Ã¸®Áî »ç¶óÁü
         // 2003/03/15 ¾ÆÀÌÅÛ ÀÎº¥Åä¸® È®Àå
         for i:=0 to U_TRANS do begin     // 8->12
            // ¸÷ÇÑÅ× Á×Àº°Ô ¾Æ´Ï¸é ¾È»ç¶óÁø´Ù.
            if (i = U_CHARM) and (not DieFromMob) then continue;

            ps := UserEngine.GetStdItem (UseItems[i].Index);
            if ps <> nil then begin
               if ( ps.ItemDesc and IDC_DIEANDBREAK ) <> 0 then begin
                  // ÃÊÈ¥½Ã¸®Áîµµ ¸÷ÇÑÅ× Á×Àº°Ô ¾Æ´Ï¸é ¾È»ç¶óÁü(sonmg 2004/06/24)
                  if not DieFromMob then continue;

                  if dellist = nil then dellist := TStringList.Create;
                  //¹ö±× ¼öÁ¤(sonmg 2005/03/14)
                  dellist.AddObject(UserEngine.GetStdItemName (UseItems[i].Index), TObject(UseItems[i].MakeIndex));
                  //·Î±× ³²°Ü¾ß ÇÔ
                  AddUserLog ('16'#9 + //Á×ÆÄ_
                              MapName + ''#9 +
                              IntToStr(CX) + ''#9 +
                              IntToStr(CY) + ''#9 +
                              UserName + ''#9 +
                              ps.Name + ''#9 +
                              IntToStr(UseItems[i].MakeIndex) + ''#9 +
                              IntToStr(BoolToInt(RaceServer = RC_USERHUMAN)) + ''#9 +
                              '0');

                  UseItems[i].Index := 0;
               end;
            end;
         end;
      end;
      //µôÂäÎïÆ·£¨µôÂä¶ñÒâºìÉ«µÄ¼¸ÂÊ£©
      if PKLevel >= 3 then ran := (hongmingbaolv)        //ÈËÎïËÀÍöÉíÉÏ×°±¸µôÂäµÄ¼¸ÂÊ ºìÃû
      else ran := (siwangbaolv);                        //ÈËÎïËÀÍöÉíÉÏ×°±¸µôÂäµÄ¼¸ÂÊ °×Ãû
      // 2003/03/15 ¾ÆÀÌÅÛ ÀÎº¥Åä¸® È®Àå
      for i:=0 to U_TRANS do begin     // 8->12
         if Random(ran) = 0 then begin
            // Èç¹û²»ÊÇ¶ñÐÔºìÉ«·Ö×ÓµÄÈËµÄÎäÆ÷£¬µôÂäµÄ¸ÅÂÊ1/2£¨2005/03/09£©
            if (i = U_WEAPON) and (PKLevel < 3) then begin
               if Random(2) = 0 then continue;
            end;
            ps := UserEngine.GetStdItem (UseItems[i].Index);
            if ps <> nil then begin
             if (RaceServer = RC_USERHUMAN) and ((ps.UniqueItem and $32) <> 0) then continue; // UniqueItem 32 ÈËÎïËÀÍö²»»á±¬³öÉíÉÏÅå´÷µÄ×°±¸ jindianadd 20220309
               //¼´Ê¹ËÀÍöÒ²²»»áµôÂäµÄÎïÆ·³ýÍâ(bugÐÞÕý sonmg 2006/01/27)
               if (RaceServer = RC_USERHUMAN) and (ps.ItemDesc and IDC_NEVERLOSE = 0) then begin
                  if DropItemDown (UseItems[i], 2, TRUE, itemownership, self,1) then begin
                     if RaceServer = RC_USERHUMAN then begin
                        if dellist = nil then dellist := TStringList.Create;
                        //Í¨Öª¿Í»§µôÂäµÄÎïÆ·
                        dellist.AddObject(UserEngine.GetStdItemName (UseItems[i].Index), TObject(UseItems[i].MakeIndex));
                     end;
                     UseItems[i].Index := 0;
                  end;
               end;
            end;
         end;
      end;
      if (RaceServer = RC_USERHUMAN) then begin
         for i:=0 to U_TRANS do begin
            if (i = U_WEAPON) or  (i = U_DRESS) then begin
               if UseItems[i].Index = 0 then begin
                  FeatureChanged;
                  Break;
               end;
            end;
         end;
      end;
      if dellist <> nil then begin
         SendMsg (self, RM_DELITEMS, 0, integer(dellist), 0, 0, '');
         //dellist´Â rm_delitem¿¡¼­ free ½ÃÄÑ¾ß ÇÑ´Ù.
      end;
   except
      MainOutMessage ('[Exception] TCreature.DropUseItems');
   end;
end;

procedure TCreature.Die;   //Á×Àº »óÅÂ, »ç¶÷ÀÎ°æ¿ì¸¸ Àç»ýÇÒ ¼ö ÀÖÀ½.
   function BoolToChar (flag: Boolean): Char;
   begin
      if flag then Result := 'T'
      else Result := 'F';
   end;
var
   i, exp: integer;
   guildwarkill, flag: Boolean;
   str: string;
   ehiter, cret: TCreature;
   boBadKill, bogroupcall: Boolean;
   questnpc: TMerchant;
   ps : PTStdItem;
   KingMobLogFlag : Boolean;
   hum : TUserHuman;
   strFZNumber : string;
   svidx: integer;
   lovername, mastername: string;
begin
   //»ç¶÷Àº ¾ÈÀü¿¡¼­ Á×Áö ¾Ê°Ô(»¡°»ÀÌ Á¦¿Ü)(sonmg 2006/03/02)
 {  if (RaceServer = RC_USERHUMAN) and (PkLevel < 2) and InSafeZone then begin
      Abil.HP := 1;
      WAbil.HP := 1;
      exit;
   end; }
   //×é¶ÓËÀÍöÍË³öÐ¡×é
   try
      if GroupOwner <> nil then begin
         GroupOwner.DelGroupMember (self);
      end else begin
         DelGroupMember(self);
      end;
   except
   end;
   if RaceServer = RC_USERHUMAN then begin   //²»ËÀÍö
    if TUserHuman(Self).m_StallMgr.OnSale then begin
      if bosafe°ÚÌ¯ and TUserHuman(Self).InSafeZone then Exit;
    end;
  end;

   if NeverDie then exit;
   Death := TRUE;
   DeathTime := GetTickCount;
   ClearPkHiterList;
   if Master <> nil then begin
      ExpHiter := nil;
      LastHiter := nil;
   end;
   IncSpell := 0;
   IncHealth := 0;
   IncHealing := 0;

   //ËÀÍö¼ÓÔØ¹ÖÎï±¬ÂÊ

  if (RaceServer <> RC_USERHUMAN) and (m_CanDropItemList <> nil) then
  begin
    if (LastHiter <> nil) or g_SuperPoisonMagic then
    begin
      if not IsDie and not m_beidusi or g_SuperPoisonMagic then
      begin
        UserEngine.MonGetRandomItems(Self, m_CanDropItemList);
        IsDie := True;  //½©Ê¬¸´»îºóÔÙËÀÍö²»±¬ÎïÆ·
      end;
    end;
  end;

   try
      //ÉúÈÕµÄÈËËÀÒ²²»»áµôÂä±³°üºÍ×°±¸£¬ÊØ»¤Ê¯Ò²²»»áËé
//      if PremiumBirthDay then begin
//         DontBagItemDrop := TRUE;
//         DontUseItemDrop := TRUE;                      //  LastHiter¾ÍÊÇ¼àÌýÄ¿±ê
//      end;
      //É±ËÀ¶ñÈËµÄÇé¿ö¡£»ñµÃ¾­ÑéÖµ¡££¨¹ÖÎïËÀÍöÊ±
      if (RaceServer <> RC_USERHUMAN) and (LastHiter <> nil) then begin
               //¹ÖÎïËµ»° rainee
         MonsterSayMsg(LastHiter, s_Die);
         //×îºóµÄ´ò»÷Õß±ØÐëÊÇÈËÀà¡£
         if (ExpHiter <> nil) then begin //³Ô¾­ÑéµÄÈË.¡£ÏÈ¶¯ÊÖµÄÈË
            if ExpHiter.RaceServer = RC_USERHUMAN then begin
               //¸ù¾Ý×î´óÌåÁ¦£¬¸ù¾Ý¶ÔÊÖµÈ¼¶»ñµÃ¾­ÑéÖµ¡£
               exp := ExpHiter.CalcGetExp (self.Abil.Level, self.FightExp);//ÕâÀïÊÇ»ñÈ¡Ô­¾­Ñé
               if not BoVentureServer and not m_beidusi or g_SuperPoisonMagic then begin
                  ExpHiter.GainExp (exp);//É±¹Ö»ñÈ¡¾­Ñé£¿
               end else begin
                  //Ã°ÏÕ·þÎñÆ÷ÉÏµÄ·ÖÊý
               end;

                //ÊÇ·ñÓÐµØÍ¼ÈÎÎñ
               if PEnvir.HasMapQuest then begin
                  if ExpHiter.GroupOwner <> nil then begin
                    //×éºÏÊ±Í¬ÑùÊÊÓÃÓÚ×éºÏ³ÉÔ±
                     for i:=0 to ExpHiter.GroupOwner.GroupMembers.Count-1 do begin//ÕâÀïÓ¦¸ÃÊÇ×é¶Ó¾­Ñé·ÖÌ¯
                        cret := TCreature(ExpHiter.GroupOwner.GroupMembers.Objects[i]);
                        if not cret.Death and
                          (ExpHiter.PEnvir = cret.PEnvir) and
                          (abs(ExpHiter.CX-cret.CX) <= 12) and
                          (abs(ExpHiter.CY-cret.CY) <= 12)
                        then begin
                           if cret = ExpHiter then bogroupcall := FALSE
                           else bogroupcall := TRUE;
                           questnpc := TMerchant (PEnvir.GetMapQuest (cret, self.UserName{ËÀÈ¥µÄ¹ÖÎïµÄÃû×Ö}, '', bogroupcall));
                           if questnpc <> nil then
                              questnpc.UserCall (cret);
                        end;
                     end;
                  end else begin
                     //Èç¹ûÄú²»ÔÚÐ¡×éÖÐ£¬ÔòÖ»ÓÐÄú×Ô¼º
                     questnpc := TMerchant (PEnvir.GetMapQuest (ExpHiter, UserName, '', FALSE));
                     if questnpc <> nil then
                        questnpc.UserCall (ExpHiter);
                  end;
               end;

            end else begin
               if ExpHiter.Master <> nil then begin  //±»´òµÄ¼Ò»ïÊÇÕÙ»½ÊÞ
                  //ÏÂÊôÒ²ÓÐ»ñµÃµÄ¾­Ñé
                  ExpHiter.GainSlaveExp (self.Abil.Level);  //¸ù¾Ý¶ÔÊÖµÈ¼¶»ñµÃ¾­Ñé
                   //Ö÷ÈË³Ô¾­Ñé
                  exp := ExpHiter.Master.CalcGetExp (self.Abil.Level, self.FightExp);
                  if not BoVentureServer and not m_beidusi or g_SuperPoisonMagic then begin
                     ExpHiter.Master.GainExp (exp); //ÕÙ»½ÊÞµÄÖ÷ÈË»ñµÃ
                  end else begin
                     //Ã°ÏÕ·þÎñÆ÷ÉÏµÄ·ÖÊý
                  end;

                  //-------¼´Ê¹²¿ÏÂ±»É±£¬Ò²ÒªÖ´ÐÐµØÍ¼ÈÎÎñ--------(sonmg 2005/03/10)
                  //µØÍ¼ÈÎÎñ
                  if PEnvir.HasMapQuest then begin
                     if ExpHiter.Master.GroupOwner <> nil then begin
                        //×éºÏµÄ»°¶Ô×éºÏ³ÉÔ±Í¬ÑùÊÊÓÃ¡£
                        for i:=0 to ExpHiter.Master.GroupOwner.GroupMembers.Count-1 do begin
                           cret := TCreature(ExpHiter.Master.GroupOwner.GroupMembers.Objects[i]);
                           if not cret.Death and
                             (ExpHiter.Master.PEnvir = cret.PEnvir) and
                             (abs(ExpHiter.Master.CX-cret.CX) <= 12) and
                             (abs(ExpHiter.Master.CY-cret.CY) <= 12)
                           then begin
                              if cret = ExpHiter.Master then bogroupcall := FALSE
                              else bogroupcall := TRUE;
                              questnpc := TMerchant (PEnvir.GetMapQuest (cret, self.UserName{ËÀÍö¹ÖÎïÃû×Ö}, '', bogroupcall));
                              if questnpc <> nil then
                                 questnpc.UserCall (cret);
                           end;
                        end;
                     end else begin
                        //±×·ìÀ» ¾ÈÇÏ°í ÀÖÀ¸¸é º»ÀÎ ¸¸
                        questnpc := TMerchant (PEnvir.GetMapQuest (ExpHiter.Master, UserName, '', FALSE));
                        if questnpc <> nil then
                           questnpc.UserCall (ExpHiter.Master);
                     end;
                  end;
                  //----------------------------------

               end;
            end;
         end else
            if LastHiter.RaceServer = RC_USERHUMAN then begin
                //¸ù¾Ý×î´óÌåÁ¦£¬¸ù¾Ý¶ÔÊÖµÈ¼¶»ñµÃ¾­ÑéÖµ¡£
               exp := LastHiter.CalcGetExp (self.Abil.Level, self.FightExp);
               if not BoVentureServer and not m_beidusi or g_SuperPoisonMagic then begin
                  LastHiter.GainExp (exp);
               end else begin
                  //
               end;
            end;
      end;
      //À§¿¡¼­ ¾Æ·§ºÎºÐÀ¸·Î ÀÌµ¿(sonmg 2005/12/22)
//      Master := nil;
   except
      MainOutMessage ('[Exception] TCreature.Die 1');
   end;

      try
      // É±ÈË  ËÀÍö´¥·¢
      if (LastHiter <> nil) and (RaceServer = RC_USERHUMAN) then
        TUserHuman(Self).DeathAndKillsFunc();
   except
      MainOutMessage ('[Exception] TCreature.Die 11 DeathAndKillsFunc');
   end;


   try
      boBadKill := FALSE;
      if (not BoVentureServer) and (not PEnvir.FightZone) and
         (not PEnvir.Fight2Zone) and (not PEnvir.Fight3Zone) and (not PEnvir.Fight4Zone) then begin
        //½ûÖ¹PKÇøÓò£¨ÈËËÀÊ±£©
         if (RaceServer = RC_USERHUMAN) and (LastHiter <> nil) and (PKLevel < 2) then begin
            //ËÀÕßÊÇÈË£¬ÓÐÅ¹´òÕß£¬ËÀÕß²»ÊÇPK
            if LastHiter.RaceServer = RC_USERHUMAN then begin
               boBadKill := TRUE;
               if BoTaiwanEventUser then boBadKill := FALSE;  //´ë¸¸ ÀÌº¥Æ® ÀÎ°æ¿ì Á×¿©µÇ µÊ
            end;
            if LastHiter.Master <> nil then   //¼àÌýÕßµÄÖ÷ÈËÊÇ²»ÊÇµÈÓÚ¿Õ£¨±¦±¦£©
               if LastHiter.Master.RaceServer = RC_USERHUMAN then begin   //¼àÌýÕßµÄÖ÷ÈËÊÇ²»ÊÇÍæ¼Ò
                  LastHiter := LastHiter.Master; //Èç¹ûÊÇ±¦±¦µÄ¼àÌý¶ÔÏóÒ²ÊÇÖ÷ÈËµÄ¼àÌý¶ÔÏó
                  boBadKill := TRUE;
               end;
         end;
      end;

      if boBadKill and (LastHiter <> nil) then begin
         //»ç¶÷ÀÌ Á×Àº °æ¿ì, ¸ðÇè¼­¹ö¿¡¼­´Â ÇØ´ç¾ÈµÊ
         //»ç¶÷ÀÌ ¼±·®ÇÑ »ç¶÷À» Á×ÀÓ.

         //¹®ÆÄÀüÀ¸·Î Á×À½
         guildwarkill := FALSE;
         if (MyGuild <> nil) and (LastHiter.MyGuild <> nil) then begin
            //µÑ´Ù ¹®ÆÄ¿¡ °¡ÀÔµÈ »óÅÂ¿¡¼­
            if GetGuildRelation (self, LastHiter) = 2 then  //¹®Àü(¹®ÆÄÀü)ÁßÀÓ
               guildwarkill := TRUE;  //¹®ÆÄÀüÀ¸·Î Á×À½, »¡°»ÀÌ ¾ÈµÊ
         end;

         //°ø¼ºÀüÀ¸·Î Á×À½
         if UserCastle.BoCastleUnderAttack then
            if (BoInFreePKArea) or (UserCastle.IsCastleWarArea (PEnvir, CX, CY)) then
               guildwarkill := TRUE;

         if not guildwarkill then begin //¹®ÆÄÀüÀ¸·Î Á×À½
            if not LastHiter.IsGoodKilling(self) then begin
               //---------------------------
               if ENABLE_FAME_SYSTEM then begin
                  //¸í¼ºÄ¡ °¨¼Ò(ÀÏ¹Ý Ä³¸¯ÅÍ¿¡°Ô »ìÀÎ´çÇÔ:-·¹º§*5)
                  if LastHiter.PkLevel < 2 then
                     DecFamePoint( Abil.Level * 5 );
                  //¸í¼ºÄ¡ °¨¼Ò(ÀÏ¹Ý Ä³¸¯ÅÍ »ìÀÎ:-100)
                  LastHiter.DecFamePoint( 100 );
               end;
               //---------------------------

               LastHiter.IncPkPoint (100); //

               {$IFDEF KOREA} LastHiter.SysMsg ('Äã·¸ÁËÄ±É±×ï', 0);
               {$ELSE}        LastHiter.SysMsg ('You commit murder.', 0);
               {$ENDIF}
               {$IFDEF KOREA} SysMsg ('Äã±»£º' + LastHiter.UserName + ' É±º¦ÁË£¡', 0);
               {$ELSE}        SysMsg ('You are murdered by ' + LastHiter.UserName + 'die', 0);
               {$ENDIF}

               /////////////////////////////////////////////////////////
               //¿¬ÀÎ¿¡°Ô Åëº¸
               if TUserHuman(self).fLover <> nil then begin
                  lovername := TUserHuman(self).fLover.GetLoverName;
                  if lovername <> '' then begin
                     hum := UserEngine.GetUserHuman(lovername);
                     if hum <> nil then begin
                        {$IFDEF KOREA} hum.SysMsg ('ÄãµÄ°®ÈË±» ' + LastHiter.UserName + ' É±º¦ÁË£¡', 0)
                        {$ELSE}        hum.SysMsg ('[Your lover is murdered by ' + LastHiter.UserName + '.]', 0);
                        {$ENDIF}
                     end else begin
                        if UserEngine.FindOtherServerUser (lovername, svidx) then begin
                           UserEngine.SendInterMsg (ISM_LM_KILLED_MSG, svidx, lovername + '/' + 'ÄãµÄ°®ÈË±» ' + LastHiter.UserName + ' É±º¦ÁË£¡');
                        end;
                     end;
                  end;
               end;
               /////////////////////////////////////////////////////////
//               if (TUserHuman(self).fMaster <> nil) and (TUserHuman(self).fMaster.GetMasterCount <> 0) then begin
//                  mastername := TUserHuman(self).fMaster.GetMasterName;
//                  if mastername <> '' then begin
//                     hum := UserEngine.GetUserHuman(mastername);
//                     if hum <> nil then begin
//                        hum.SysMsg ('ÌáÊ¾£ºÄãµÄÍ½µÜ ['+UserName+'] ±» ['+LastHiter.UserName+'] É±º¦ÁË£¡', 0)
//                     end else begin
//                        if UserEngine.FindOtherServerUser (mastername, svidx) then begin
//                           UserEngine.SendInterMsg (ISM_LM_KILLED_MSG, svidx, mastername + '/' + 'ÌáÊ¾£ºÄãµÄÍ½µÜ ['+UserName+'] ±» ['+LastHiter.UserName+'] É±º¦ÁË£¡');
//                        end;
//                     end;
//                  end;
//               end;

//               if (TUserHuman(self).fMaster <> nil) and (TUserHuman(self).fMaster.GetPupilCount <> 0) then begin
//                  for i := 0 to TUserHuman(self).fMaster.GetPupilCount -1 do begin
//                     mastername := TUserHuman(self).fMaster.GetPupilName(i);
//                     if mastername <> '' then begin
//                        hum := UserEngine.GetUserHuman(mastername);
//                        if hum <> nil then begin
//                           hum.SysMsg ('ÌáÊ¾£ºÄãµÄÊ¦¸µ ['+UserName+'] ±» ['+LastHiter.UserName+'] É±º¦ÁË£¡', 0)
//                        end else begin
//                           if UserEngine.FindOtherServerUser (mastername, svidx) then begin
//                              UserEngine.SendInterMsg (ISM_LM_KILLED_MSG, svidx, mastername + '/' + 'ÌáÊ¾£ºÄãµÄÊ¦¸µ ['+UserName+'] ±» ['+LastHiter.UserName+'] É±º¦ÁË£¡');
//                           end;
//                        end;
//                     end;
//                  end;
//               end;
               //É±ÈËÕßÐÒÔË¼õÉÙ
               LastHiter.AddBodyLuck (-500);
               if PkLevel < 1 then //ËÀÁËµÄÈËÊÇÉÆÁ¼µÄÈË
                  if Random(5) = 0 then begin //É±ÈËÎäÆ÷ÊÜ×çÖä
                     if LastHiter.MakeWeaponUnlock then begin
                        ps := UserEngine.GetStdItem (LastHiter.UseItems[U_WEAPON].Index);  //ÎäÆ÷
                        if ps <> nil then begin
                           //·Î±× ³²±è
                           AddUserLog ('43'#9 + //×çÖä_(É±ÈËµÄ)
                                       LastHiter.MapName + ''#9 +
                                       IntToStr(LastHiter.CX) + ''#9 +
                                       IntToStr(LastHiter.CY) + ''#9 +
                                       LastHiter.UserName + ''#9 +
                                       ps.Name + ''#9 +
                                       IntToStr(LastHiter.UseItems[U_WEAPON].MakeIndex) + ''#9 +
                                       '1'#9 +
                                       '-1');
                        end;
                     end;
                  end;
            end else begin
               {$IFDEF KOREA}
               LastHiter.SysMsg ('[Äã»áÊÜµ½Õýµ±·ÀÎÀµÄ¹æÔò±£»¤]', 1);
               SysMsg ('Äã±»£º' + LastHiter.UserName + ' É±º¦ÁË£¡', 1);
               {$ELSE}
               LastHiter.SysMsg ('[You will be protected by the rule of legal defense]', 1);
               SysMsg ('[You were killed by ' + LastHiter.UserName + ' - legitimate self-defense rule applied.]', 1);
               {$ENDIF}
            end;
         end;
      end else begin
         //ÀÏ¹ÝÀÎÀÌ PK¹üÀ» Á×ÀÎ °æ¿ì
         if PkLevel >= 2 then begin
            //---------------------------
            if ENABLE_FAME_SYSTEM then begin
               //¸í¼ºÄ¡ È¹µæ(PK Ä³¸¯ÅÍ¸¦ »ìÀÎ:+100)
               LastHiter.IncFamePoint( 100 );
               //¸í¼ºÄ¡ °¨¼Ò(PK Ä³¸¯ÅÍ°¡ Á×À½:-(·¹º§*5 + PkPoint))
               DecFamePoint( Abil.Level * 5 + PlayerKillingPoint );
            end;
            //---------------------------
         end;
      end;
   except
      MainOutMessage ('[Exception] TCreature.Die 2');
   end;

   try
      if (not PEnvir.FightZone) and// (not PEnvir.Fight2Zone) and
         (not PEnvir.Fight3Zone) and// (not PEnvir.Fight4Zone) and
         (not BoAnimal) and (not PEnvir.LawFull) then begin //Èç¹ûÊÇ¶¯Îï£¬ÇÐÈâ²ÅÄÜ³öÀ´¡£

         // ±¦Ê¯ËéÆ¬µÄÎÊÌâÐÞ¸Ä(sonmg 2004/06/11)
         // ÈËºÍ¹ÖÎïµÄÇø±ð(2004/06/22)
         if RaceServer <> RC_USERHUMAN then begin
            ehiter := ExpHiter;
            if ExpHiter <> nil then
               if ExpHiter.Master <> nil then
                  ehiter := ExpHiter.Master;
         end else begin
            ehiter := LastHiter;
            if LastHiter <> nil then
               if LastHiter.Master <> nil then
                  ehiter := LastHiter.Master;
         end;

         if (RaceServer <> RC_USERHUMAN) then begin
            //(ËÀÍöµÄÇé¿ö)
            DropUseItems (ehiter, false);
            if (Master = nil) and (not BoNoItem) then
               ScatterBagItems (ehiter);  //ËùÓÐÈ¨±©Ãñ²»»áÒç³öÎïÆ·
            if (RaceServer >= RC_ANIMAL) and (Master = nil) and (not BoNoItem) then
               ScatterGolds (ehiter);  //ÈË²»µôÇ®¡£
         end else begin
            //£¨Èç¹ûÊÇÈË£©
            //¶ÔÕ½¶·µØÍ¼²»µôÂäÎïÆ·µÄµØÍ¼Ò²ÊÇÒ»ÑùµÄ((sonmg 2005/03/14)
            if (not PEnvir.Fight2Zone) and (not PEnvir.NoDropItem) then begin
               if not ((PEnvir.Fight4Zone) and (ehiter <> nil) and (ehiter.RaceServer = RC_USERHUMAN)) then begin
                  //ÈËËÀÁËµÄ»°²»»áµô×°±¸¡£
                  if ehiter <> nil then begin
                     // 2003/06/20 ±»ÊÂ¼þ±©ÃñÉ±ËÀ²»»áµôÂä
                     if (ehiter.RaceServer <> RC_USERHUMAN) and (not ehiter.BoHasMission) then begin
                        //Èç¹û±»±©Í½É±ËÀ
                        DropUseItems (nil, true);

                        //--------------------
                        //ÃûÉùÖµ¼õÉÙ(Ã»ËÀ)
                        if ENABLE_FAME_SYSTEM then begin
                           DecFamePoint( Abil.Level * 10 );
                        end;
                        //--------------------

                     end;
                  end else begin
                     // ÆäËûµÄÇé¿ö
                     DropUseItems (nil, false);
                  end;

                  // ¸æÖª±ä¸ü×´Ì¬(sonmg)
                  FeatureChanged;

                  // 2003/06/20 Èç¹û±»ÊÂ¼þ±©ÃñÉ±ËÀ£¬Ëü²»»áµôÂä¡£
                  if (ehiter <> nil) and (ehiter.BoHasMission) then
                  else
                     ScatterBagItems (nil);
                     DropUseItems (nil, true);
                  //ËÀÍöÊ±ÐÒÔËÖµ¼õÉÙ
                  //2003/02/11 ×î´óÀ´Öµ±ä¸ü
                  AddBodyLuck ( - Abil.Level * 5 );  //50 - (50
               end;
            end;
         end;
      end;

{
      //------------------------------------------------------------
      //´ë·Ã »ç³ÉÅÍ´Â ¸ó½ºÅÍ°¡ ¾ÆÀÌÅÛÀ» ¶³±º´Ù.(sonmg 2004/12/23)
      if (PEnvir.Fight2Zone or PEnvir.Fight4Zone) and (not BoAnimal) then begin
         if (RaceServer <> RC_USERHUMAN) then begin
            ehiter := ExpHiter;
            if ExpHiter <> nil then
               if ExpHiter.Master <> nil then
                  ehiter := ExpHiter.Master;

            //¸÷ÀÌ Á×À» ¶§
            DropUseItems (ehiter, false);
            if (Master = nil) and (not BoNoItem) then
               ScatterBagItems (ehiter);  //ÁÖÀÎÀÖ´Â ¸÷Àº ¹°°ÇÀ» Èê¸®Áö ¾ÊÀ½
            if (RaceServer >= RC_ANIMAL) and (Master = nil) and (not BoNoItem) then
               ScatterGolds (ehiter);  //»ç¶÷Àº µ·À» Èê¸®Áö ¾Ê´Â´Ù.
         end;
      end;
      //------------------------------------------------------------
}

      //¹®ÆÄ ´ëÀü Áß
      if PEnvir.Fight3Zone  then begin
         //3¹ø Á×¾îµµ µÇ´Â ´ë·ÃÀÎ °æ¿ì
         Inc (FightZoneDieCount);
         if MyGuild <> nil then begin
            TGuild(MyGuild).TeamFightWhoDead (UserName);
         end;

         //Á¡¼ö °è»ê
         if (LastHiter <> nil) then begin
            if (LastHiter.MyGuild <> nil) and (MyGuild <> nil) then begin
               TGuild(LastHiter.MyGuild).TeamFightWhoWinPoint (LastHiter.UserName, 100);  //matchpoint Áõ°¡, °³ÀÎ¼ºÀû ±â·Ï
               str := TGuild(LastHiter.MyGuild).GuildName + ':' +
                      IntToStr(TGuild(LastHiter.MyGuild).MatchPoint) + '  ' +
                      TGuild(MyGuild).GuildName + ':' +
                      IntToStr(TGuild(MyGuild).MatchPoint);
               UserEngine.CryCry (RM_CRY, PEnvir, CX, CY, 10000, '- ' + str);  //Çö¸Ê ÀüÃ¼¿¡°Ô ¾Ë¸°´Ù.
            end;
         end;
      end;

      //ºÐ½ÅÀÏ°æ¿ì¿¡´Â »¡¸® ¾ø¿£´ÙÀ½¿¡ ÀÌÆåÆ® ³Ö¾îÁØ´Ù.
      if (RaceServer = RC_CLONE) then begin
//         SendRefMsg (RM_NORMALEFFECT, 0, CX, CY, NE_CLONEHIDE, '');
         SendRefMsg (RM_LOOPNORMALEFFECT, integer(self), 0, 0, NE_CLONEHIDE, '');
      end;


      //·Î±×¸¦ ³²±ä´Ù.(»ç¶÷ÀÌ Á×À» ¶§)
      if RaceServer = RC_USERHUMAN then begin
         if LastHiter <> nil then begin
            if LastHiter.RaceServer = RC_USERHUMAN then str := LastHiter.UserName
            else if LastHiter.BoHasMission then str := '*' + LastHiter.UserName  // ÀÌº¥Æ®¸÷ Ç¥½Ã(sonmg 2005/01/24)
            else begin
               // ¼ÒÈ¯¼öÀÏ ¶§´Â ÁÖÀÎ ÀÌ¸§À» ³²±è(sonmg 2005/03/08)
               if LastHiter.Master <> nil then
                  str := LastHiter.Master.UserName
               else
                  str := '#' + LastHiter.UserName;
            end;
         end else str := '######';
         //-------------------------
         //´ë·ÃÀå Á¾·ù ±¸ºÐ
         strFZNumber := '';
         if PEnvir.FightZone then strFZNumber := '1'
         else if PEnvir.Fight2Zone then strFZNumber := '2'
         else if PEnvir.Fight3Zone then strFZNumber := '3'
         else if PEnvir.Fight4Zone then strFZNumber := '4'
         else strFZNumber := 'F';
         //-------------------------
         //Á¤´ç¹æÀ§ ±¸ºÐ
         if LastHiter <> nil then begin
            if LastHiter.IsGoodKilling(self) then strFZNumber := strFZNumber + '-R'
            else if self.PKLevel >= 2 then strFZNumber := strFZNumber + '-R';
         end;

         AddUserLog ('19'#9 + //Á×À½_ +
                     MapName + ''#9 +
                     IntToStr(CX) + ''#9 +
                     IntToStr(CY) + ''#9 +
                     UserName + ''#9 +
//                     'FZ-' + BoolToChar(PEnvir.FightZone) + '_F3-' + BoolToChar(PEnvir.Fight3Zone) + '_F2-' + BoolToChar(PEnvir.Fight2Zone) + ''#9 +
                     'FZ-' + strFZNumber + ''#9 +
                     '0'#9 +
                     '1'#9 +
                     str);
      end else begin    //(¸ó½ºÅÍ°¡ Á×À» ¶§)
         KingMobLogFlag := FALSE;
         //·¹º§ 60ÀÌ»óÀº ·Î±× ³²±è.
         if (Abil.Level >= 60) then begin
            KingMobLogFlag := TRUE;
         end else if (Abil.Level >= 50) then begin
            //·¹º§ 50ÀÌ»ó 60¹Ì¸¸ ·Î±× ³²±â´Â ¸ó½ºÅÍ ÀÌ¸§ ÇÏµåÄÚµù...
            if (UserName = '±¸¿ï') or (UserName = 'ÁÖ¸¶°Ý·ÚÀå') or (UserName = '¹éµ·') or
                  (UserName = 'ÈæÇ÷»ç') or (UserName = '¼³ÀÎ´ëÃæ') or (UserName = '½Å¼®µ¶¸¶ÁÖ') then begin
               KingMobLogFlag := TRUE;
            end;
         end else if (Abil.Level >= 40) then begin
            //·¹º§ 40ÀÌ»ó 50¹Ì¸¸ ·Î±× ³²±â´Â ¸ó½ºÅÍ ÀÌ¸§ ÇÏµåÄÚµù...
            if (UserName = '»¶Ó­Ò»ºÅ') or (UserName = 'Ñ×¹íÄ§') then begin
               KingMobLogFlag := TRUE;
            end;
         end;

         if KingMobLogFlag then begin
            if LastHiter <> nil then begin
               if LastHiter.RaceServer = RC_USERHUMAN then str := LastHiter.UserName
               else str := '#' + LastHiter.UserName;
            end else str := '######';
            //¸ó½ºÅÍ ¿ÕÁ×À½ ·Î±× ³²±è(sonmg. 2004/05/14)
            AddUserLog ('42'#9 + //¿ÕÁ×À½_ +
                        MapName + ''#9 +
                        IntToStr(CX) + ''#9 +
                        IntToStr(CY) + ''#9 +
                        UserName + ''#9 +
                        'FZ-M' + ''#9 +
                        '0'#9 +
                        '0'#9 +
                        str);
         end;
      end;

      SendRefMsg (RM_DEATH, Dir, CX, CY, 1, '');

      //À§¿¡¼­ ¾Æ·§ºÎºÐÀ¸·Î ÀÌµ¿(sonmg 2005/12/22)
      Master := nil;
   except
      MainOutMessage ('[Exception] TCreature.Die 3');
   end;
end;

procedure TCreature.Alive;
begin
   //Ã¼·ÂÀÌ 0ÀÌ¸é 1 º¸Ãæ
   if Abil.HP = 0 then Abil.HP := 1;

   Death := FALSE;
   if RaceServer = RC_USERHUMAN then
      SendRefMsg (RM_LOOPNORMALEFFECT, integer(self), 0, 0, NE_RELIVE, '');

   SendRefMsg (RM_ALIVE, Dir, CX, CY, 0, '');

   //´É·ÂÄ¡ ÀçÀü¼Û
//   RecalcAbilitys;
   SendRefMsg (RM_CHANGELIGHT, 0, 0, 0, 0, '');
//   SendRefMsg (RM_LOOPNORMALEFFECT, integer(self), 0, 0, NE_RELIVE, '');
//   SendRefMsg (RM_ALIVE, Dir, CX, CY, 0, '');
//   SendRefMsg (RM_CHANGELIGHT, 0, 0, 0, 0, '');
//
//   //´É·ÂÄ¡ ÀçÀü¼Û
////   RecalcAbilitys;
//   SendRefMsg (RM_CHANGELIGHT, 0, 0, 0, 0, '');
end;


procedure TCreature.SetLastHiter (hiter: TCreature);
begin
   LastHiter := hiter;
   // ¸¶Áö¸· ¶§¸°³Ñ Á¾Á· ±â¾ï(2004/07/16)
   if LastHiter <> nil then begin
      if LastHiter.Master <> nil then begin
         //ÁÖÀÎÀÌ ÀÖÀ» °æ¿ì´Â ÁÖÀÎÀÇ Á¾Á·À» ±â¾ïÇÑ´Ù(2004/11/30)
         LastHiterRace := LastHiter.Master.RaceServer;
      end else begin
         LastHiterRace := LastHiter.RaceServer;
      end;
   end;
   LastHitTime := GetTickCount;
   if ExpHiter = nil then begin
      ExpHiter := hiter;
      ExpHitTime := GetTickCount;
   end else
      if ExpHiter = hiter then ExpHitTime := GetTickCount;
end;

//ÀÚ½ÅÀÌ »ç¶÷ÇÑÅ× ¸Â¾ÒÀ» ¶§ È£Ãâ µÊ
procedure  TCreature.AddPkHiter (hiter: TCreature); //»ç¶÷ÀÎÁö ¸ÕÀú È®ÀÎ..
var
   i: integer;
   pk: PTPkHiterInfo;
begin
   if (PkLevel < 2) and (hiter.PkLevel < 2) then begin //¼±·®ÇÑ »ç¶÷µéÇÑÅ×¸¸ Àû¿ë (ÀÚ½ÅÀÌ ¼±·®ÇÑ »ç¶÷)
      if (not PEnvir.FightZone) and (not PEnvir.Fight2Zone) and (not PEnvir.Fight3Zone) and (not PEnvir.Fight4Zone) then begin
         if not BoIllegalAttack then begin  //ÀÚ½ÅÀÌ ¼±Àç°ø°ÝÀ» ÇÏÁö ¾ÊÀº °æ¿ì
            hiter.IllegalAttackTime := GetTickCount;
            if not hiter.BoIllegalAttack then begin
               hiter.BoIllegalAttack := TRUE;
               hiter.ChangeNameColor;
            end;
         end;
      end;
      {end else begin
         for i:=0 to hiter.PKHiterList.Count-1 do begin //»ó´ë¹æÀ» ³»°¡ ¸ÕÀú ¶§·È´ÂÁö °Ë»ç
            if PTPkHiterInfo(hiter.PKHiterList[i]).hiter = self then begin
               exit;  //³»°¡ ¸ÕÀú ¶§¸° °æ¿ì
            end;
         end;
         for i:=0 to PKHiterList.Count-1 do begin
            if PTPkHiterInfo(PKHiterList[i]).hiter = hiter then begin
               PTPkHiterInfo(PKHiterList[i]).hittime := GetTickCount;
               exit;
            end;
         end;
         new (pk);
         pk.hiter := hiter;
         pk.hittime := GetTickCount;
         PKHiterList.Add (pk);
         hiter.ChangeNameColor;  //³ª¿Í Á¤´ç¹æÀ§ÀÎ °æ¿ì »öÀÌ ¹Ù²ñ
      end; }
   end;
end;

procedure  TCreature.CheckTimeOutPkHiterList;
var
   i: integer;
   hum: TUserHuman;
   DuringIllegalTime : longword;
begin
   DuringIllegalTime := 60 * 1000;        //60

   //if BoTestServer then begin
      if BoIllegalAttack then begin
         if GetTickCount - IllegalAttackTime > DuringIllegalTime then begin
            BoIllegalAttack := FALSE;
            ChangeNameColor;
         end;
      end;
   {end else begin
      for i:=0 to PKHiterList.Count-1 do begin
         if GetTickCount - PTPkHiterInfo(PKHiterList[i]).hittime > 60 * 1000 then begin
            hum := TUserHuman (PTPkHiterInfo(PKHiterList[i]).hiter);
            hum.ChangeNameColor;  //Á¤¹æ¹æÀ§ ÇØÁ¦..
            Dispose (PTPkHiterInfo(PKHiterList[i]));
            PKHiterList.Delete (i);
            break;
         end;
      end;
   end;}
end;

procedure  TCreature.ClearPkHiterList;
var
   i: integer;
begin
   for i:=0 to PKHiterList.Count-1 do
      Dispose (PTPkHiterInfo(PKHiterList[i]));
   PKHiterList.Clear;
end;

function  TCreature.IsGoodKilling (target: TCreature): Boolean;
var
   i: integer;
begin
   Result := FALSE;
   //if BoTestServer then begin
      if target.BoIllegalAttack then
         Result := TRUE;
   {end else begin
      for i:=0 to PKHiterList.Count-1 do begin
         if PTPkHiterInfo(PKHiterList[i]).hiter = target then begin
            Result := TRUE;
            break;
         end;
      end;
   end;}
end;

procedure  TCreature.SetAllowLongHit (boallow: Boolean);
begin
   BoAllowLongHit := boallow;
   if BoAllowLongHit then
      {$IFDEF KOREA}
      SysMsg ('¿ªÆô´ÌÉ±½£Êõ', 1)
      {$ELSE}
      SysMsg ('use Thrusting', 1)
      {$ENDIF}
   else
      {$IFDEF KOREA}
      SysMsg ('¹Ø±Õ´ÌÉ±½£Êõ', 1);
      {$ELSE}
      SysMsg ('do not use Thrusting.', 1);
      {$ENDIF}
end;

procedure  TCreature.SetAllowWideHit (boallow: Boolean);
begin
   BoAllowWideHit := boallow;
   if BoAllowWideHit then
      {$IFDEF KOREA}
      SysMsg ('¿ªÆô°ëÔÂ½£·¨', 1)
      {$ELSE}
      SysMsg ('use HalfMoon', 1)
      {$ENDIF}
   else
      {$IFDEF KOREA}
      SysMsg ('¹Ø±Õ°ëÔÂ½£·¨', 1);
      {$ELSE}
      SysMsg ('do not use HalfMoon.', 1);
      {$ENDIF}
end;

procedure  TCreature.SetAllowCrossHit (boallow: Boolean);
begin
   BoAllowCrossHit := boallow;
   if BoAllowCrossHit then
      {$IFDEF KOREA}
      SysMsg ('Ê¹ÓÃ¿ñ·çÕ¶', 1)
      {$ELSE}
      SysMsg ('use CrossHalfMoons.', 1)
      {$ENDIF}
   else
      {$IFDEF KOREA}
      SysMsg ('¹Ø±Õ¿ñ·çÕ¶', 1);
      {$ELSE}
      SysMsg ('Do not use CrossHalfMoons.', 1);
      {$ENDIF}
end;

function  TCreature.SetAllowFireHit: Boolean;   //¿°È­°á
begin
   Result := FALSE;
   if GetTickCount - LatestFireHitTime > 10 * 1000 then begin
      LatestFireHitTime := GetTickCount;
      BoAllowFireHit := TRUE;
      {$IFDEF KOREA}
      SysMsg ('ÄúµÄÎäÆ÷Òò¾«Éñ»ðÇò¶øÖËÈÈ', 1);
      {$ELSE}
      SysMsg ('Your weapon is glowed by spirit of fire.', 1);
      {$ENDIF}
      Result := TRUE;
   end else begin
      {$IFDEF KOREA}
      SysMsg ('Äý¾ÛÄÚÁ¦Ê§°Ü', 0);
      {$ELSE}
      SysMsg ('Gathering spirits failed.', 0);
      {$ENDIF}
   end;
end;

function  TCreature.SetAllowTwinHit: Boolean;   //½Ö·æÂü
begin
   Result := FALSE;
   if GetTickCount - LatestTwinHitTime > 1000 then begin
      LatestTwinHitTime := GetTickCount;
      BoAllowTwinHit := 1;
//    SysMsg ('½Ö·æÂüÀÌ ¹ßµ¿µÇ¾ú½À´Ï´Ù.', 1);
      Result := TRUE;
// end else begin
//    SysMsg ('½Ö·æÂüÀÌ ¹ßµ¿µÇÁö ¾Ê¾Ò½À´Ï´Ù.', 0);
   end;
end;

//(+)¸¸ Çã¿ë
procedure  TCreature.IncHealthSpell (hp, mp: integer);
begin
   if (hp >= 0) and (mp >= 0) then begin
      if WAbil.HP + hp < WAbil.MaxHP then WAbil.HP := WAbil.HP + hp
      else WAbil.HP := WAbil.MaxHP;
      if WAbil.MP + mp < Wabil.MaxMP then WAbil.MP := WAbil.MP + mp
      else WAbil.MP := WAbil.MaxMP;
      HealthSpellChanged;
      //UpdateMsg (self, RM_HEALTHSPELLCHANGED, 0, 0, 0, 0, '');
   end;
end;

procedure TCreature.RandomMove();
var
   xx, yy: integer;
   oldenvir: TEnvirnoment;
   mname, xstr, ystr: string;
begin
   oldenvir := PEnvir;
   if mname = '' then mname := MapName;
   if (xstr <> '') and (ystr <> '') then begin
      xx := Str_ToInt (xstr, 0);
      yy := Str_ToInt (ystr, 0);
      SpaceMove (mname, xx, yy, 0);
   end else
      RandomSpaceMove (mname, 0);
end;


//mapnameÀÇ ¸ÊÀº Ç×»ó 0¹ø¸Ê È¤Àº ¾Æ¸¶³ª °¥ ¼ö ÀÖ´Â ¹ÙÅÁ¸ÊÀÌ´Ù.
procedure TCreature.RandomSpaceMove (mname: string; mtype: integer);
var
   nx, ny, egdey: integer;
   nenvir, oldenvir: TEnvirnoment;
 //  hum: TUserHuman;
begin
  if RaceServer = RC_USERHUMAN then begin
    if TUserHuman(Self).m_StallMgr.OnSale then begin

      Exit;
    end;
  end;
   oldenvir := PEnvir;
   nenvir := GrobalEnvir.GetEnvir (mname);
   if nenvir <> nil then begin
      if (nenvir.TimeMap <> '') and (StrToDateTime(nenvir.TimeMap) > Now) then begin
        TUserHuman(Self).SysMsg('´ËµØÍ¼ÔÝÎ´¿ª·Å,¿ª·ÅÊ±¼ä: '+nenvir.TimeMap, 0);
        exit;
      end;
      if nenvir.MapHeight < 150 then begin
         if nenvir.MapHeight < 30 then egdey := 2
         else egdey := 20;
      end else egdey := 50;
      nx := egdey + Random(nenvir.MapWidth-egdey-1);
      ny := egdey + Random(nenvir.MapHeight-egdey-1);
      SpaceMove (mname, nx, ny, mtype);
       if TUserHuman(Self).iHours <> 0 then
       begin
          FrmIDSoc.SendRechargeInfo (UserName, TUserHuman(Self).UserId, TUserHuman(Self).Certification);
       end;
        if boSecondCardSystem then
        begin
          if (Abil.Level > g_nExpErienceLevel) then
          begin
          if not TUserHuman(self).iDay <= 0 then begin
               exit;
          end;
            if (TUserHuman(self).iDay <= 0) then
            begin
               if (TUserHuman(self).SecondsCard <= 0) and (PEnvir.MapName <> g_sRechargingMap) then begin
                 SysMsg ('[ÕË»§ÐÅÏ¢]µ±Ç°ÕË»§³äÖµÊ±¼äÒÑµ½ÆÚ', 0);
               if RaceServer = RC_USERHUMAN   then begin
                 if GrobalEnvir.GetEnvir (g_sRechargingMap) <> nil then begin
                   SendRefMsg (RM_SPACEMOVE_HIDE, 0, 0, 0, 0, '');
                   RandomSpaceMove (g_sRechargingMap, 0); //¹«ÀÛÀ§ °ø°£ÀÌµ¿
                 end;
               end;
            end;
          end;
        end;
   end;
  end;
end;

//mapnameÀÇ ¸ÊÀº Ç×»ó 0¹ø¸Ê È¤Àº ¾Æ¸¶³ª °¥ ¼ö ÀÖ´Â ¹ÙÅÁ¸ÊÀÌ´Ù.
//ÇöÀç ¸Ê¿¡¼­ ¹Ý°æÀÌ InRangeº¸´Ù Å©°í OutRangeº¸´Ù ÀÛÀº ¹üÀ§·Î ·£´ýÇÏ°Ô ÀÌµ¿.
procedure TCreature.RandomSpaceMoveInRange (mtype, InRange, OutRange: integer);
var
   ran, signX, signY, nx, ny: integer;
   moverange : integer;
begin
  if RaceServer = RC_USERHUMAN then begin
    if TUserHuman(Self).m_StallMgr.OnSale then begin

      Exit;
    end;
  end;
   //ÃÊ±âÈ­.
   signX := 1;
   signY := 1;

   if PEnvir <> nil then begin
      ran := Random(100);
      ran := ran mod 4;

      case ran of
      0:
         begin
            signX := 1;
            signY := 1;
         end;
      1:
         begin
            signX := -1;
            signY := 1;
         end;
      2:
         begin
            signX := -1;
            signY := -1;
         end;
      3:
         begin
            signX := 1;
            signY := -1;
         end;
      end;

      nx := CX + signX * (InRange + Random(OutRange - InRange) + 1);
      // ÁöµµÀÇ »çÀÌÁîº¸´Ù Å¬ °æ¿ì¿¡ ³Ñ¾î°¡Áö ¾Êµµ·Ï ¼öÁ¤...
      // ³Ñ¾î°¡¸é SpaceMove ÇÔ¼ö ¾È¿¡¼­ ·£´ýÇÏ°Ô Æ¨±æ ¼ö ÀÖ´Ù.
      if nx >= PEnvir.MapWidth then begin
         nx := PEnvir.MapWidth -1;
      end else if nx < 0 then begin
         nx := 0;
      end;

      ny := CY + signY * (InRange + Random(OutRange - InRange) + 1);
      // ÁöµµÀÇ »çÀÌÁîº¸´Ù Å¬ °æ¿ì¿¡ ³Ñ¾î°¡Áö ¾Êµµ·Ï ¼öÁ¤...
      // ³Ñ¾î°¡¸é SpaceMove ÇÔ¼ö ¾È¿¡¼­ ·£´ýÇÏ°Ô Æ¨±æ ¼ö ÀÖ´Ù.
      if ny >= PEnvir.MapHeight then begin
         ny := PEnvir.MapHeight -1;
      end else if ny < 0 then begin
         ny := 0;
      end;

      SpaceMove (PEnvir.MapName, nx, ny, mtype);
   end;
end;

function TCreature.MagSpaceMoveInRange(xx, yy, hit: Integer): Boolean;
begin
   Result := False;
   if (PEnvir <> nil) and (PEnvir.CanWalk (xx, yy, TRUE)) and (PEnvir.GetDupCount(xx, yy) = 0) then begin
//      SendRefMsg (RM_SPACEMOVE_HIDE_MAGIC, 0, 0, 0, 0, '');
      if hit = 1 then SpaceMove (PEnvir.MapName, xx, yy, 98)
      else SpaceMove (PEnvir.MapName, xx, yy, 99);
      Result := True;
   end else begin
      if hit = 1 then SendRefMsg (RM_SPACEMOVE_SHOW_MAGIC, Dir, CX, CY, 0, '');
   end;
end;

procedure TCreature.SpaceMove (mname: string; nx, ny, mtype: integer);
   function RandomEnvXY (env: TEnvirnoment; var nnx, nny: integer): Boolean;
   var
      i, step, edge: integer;
   begin
      Result := FALSE;
      if env.MapWidth < 80 then step := 3
      else step := 10;
      if env.MapHeight < 150 then begin
         if env.MapHeight < 50 then edge := 2
         else edge := 15;
      end else edge := 50;
      for i:=0 to 200 do begin
         if env.CanWalk (nnx, nny, TRUE{°âÄ§Çã¿ë}) then begin
            Result := TRUE;
            break;
         end else begin
            if nnx < env.MapWidth-edge-1 then Inc (nnx,step)
            else begin
               nnx := Random(env.MapWidth); //edge;
               if nny < env.MapHeight-edge-1 then Inc (nny,step)
               else nny := Random(env.MapHeight); //edge;
            end;
         end;
      end;
   end;
var
   i, oldx, oldy, step, edge: integer;
   nenvir, oldenvir: TEnvirnoment;
   outofrange: pointer;
   success: Boolean;
   hum: TUserHuman;
begin
  if RaceServer = RC_USERHUMAN then begin
    if TUserHuman(Self).m_StallMgr.OnSale then begin
      SysMsg('[°ÚÌ¯×´Ì¬] ²»ÄÜË²¼äÒÆ¶¯¹¦ÄÜ£¡',1);
      Exit;
    end;
  end;
   nenvir := GrobalEnvir.GetEnvir (mname);
   if nenvir <> nil then begin
      if (nenvir.TimeMap <> '') and (StrToDateTime(nenvir.TimeMap) > Now) then begin
        TUserHuman(Self).SysMsg('´ËµØÍ¼ÔÝÎ´¿ª·Å,¿ª·ÅÊ±¼ä: '+nenvir.TimeMap, 0);
        exit;
      end;
      if ServerIndex = nenvir.Server then begin  //°°Àº ¼­¹ö
         oldenvir := PEnvir;
         oldx := CX;
         oldy := CY;
         success := FALSE;

{
         //½½Â½ »ç¶óÁü.
         if  1 <> PEnvir.DeleteFromMap (CX, CY, OS_MOVINGOBJECT, self) then
         begin
            // »ç¶óÁöÁö ¸øÇßÀ½..
            MainOutMessage('Error DeleteFromMap(1):'+PEnvir.MapName+','+IntToStr(CX)+','+IntToStr(CY));
            // exit;
         end;
}
         Disappear(6);  // (sonmg 2005/02/24)

         MsgTargetList.Clear;
         for i:=0 to VisibleItems.Count-1 do
            Dispose (PTVisibleItemInfo (VisibleItems[i]));
         VisibleItems.Clear;
         // 2003/03/18
         i := 0;
         while TRUE do begin
            if i >= VisibleActors.Count then break;
            {
            if RaceServer = RC_USERHUMAN then begin
            try
               if(PTVisibleActor(VisibleActors[i]).cret <> nil) then
                  TCreature (PTVisibleActor(VisibleActors[i]).cret).DecRefObjCount;
            except
               MainOutMessage ('[Exception] TCreatre.Destroy : Visible Actor Dec RefObjCount');
               end;
            end;
            }
            Dispose (PTVisibleActor(VisibleActors[i]));
            VisibleActors.Delete(i);
          Inc(i);
         end;
         VisibleActors.Clear;

         if VisibleEvents.Count > 0 then VisibleEvents.Clear; //ÒÆ¶¯Ê±Çå³ýÁÐ±í

         //»õ¸Ê¿¡ »Í µîÀå
         PEnvir := nenvir;
         MapName := nenvir.MapName;
         CX := nx; //2 + Random(PEnvir.MapWidth-4);
         CY := ny; //2 + Random(PEnvir.MapHeight-4);
         if RandomEnvXY (PEnvir, CX, CY) then begin
            if ( nil <> PEnvir.AddToMap (CX, CY, OS_MOVINGOBJECT, self)) then
            begin
                if not (mtype in [98,99]) then begin
              SendMsg (self, RM_CLEAROBJECTS, 0, 0, 0, 0, '');
              SendMsg (self, RM_CHANGEMAP, 0, 0, 0, 0, nenvir.GetGuildAgitRealMapName);
              end;
              case mtype of
                 0:    SendRefMsg (RM_SPACEMOVE_SHOW, Dir, CX, CY, 0, '');
                 1:    SendRefMsg (RM_SPACEMOVE_SHOW2, Dir, CX, CY, 0, '');
                 98:   SendRefMsg (RM_SPACEMOVE_SHOW_MAGIC, Dir, CX, CY, 0, '');
                 99:   SendRefMsg (RM_SPACEMOVE_SHOW_MAGIC2, Dir, CX, CY, 0, '');
                 else  SendRefMsg (RM_SPACEMOVE_SHOW_NO, Dir, CX, CY, 0, '');
              end;
              MapMoveTime := GetTickCount;
              SpaceMoved := TRUE; //WalkTo°¡ ½ÇÆÐÇÏÁö ¾Ê°Ô ÇÏ·Á°í..
              success := TRUE;

            end;
         end;

         if not success then begin
            PEnvir := oldenvir;
            CX := oldx;
            CY := oldy;
            if ( nil = PEnvir.AddToMap (CX, CY, OS_MOVINGOBJECT, self) ) then
            begin
               MainOutMessage('Error DeleteFromMap(2):'+PEnvir.MapName+','+IntToStr(CX)+','+IntToStr(CY));
            end;
         end;

      end else begin  //´Ù¸¥ ¼­¹öÀÓ... ¼­¹öÀÌµ¿
         //¼­¹ö ÀÌµ¿
         if RandomEnvXY (nenvir, nx, ny) then begin
            if RaceServer = RC_USERHUMAN then begin
               if Disappear(4) = true then
               begin
                 SpaceMoved := TRUE;
                 hum := TUserHuman (self);
                 hum.ChangeMapName := nenvir.MapName;
                 hum.ChangeCX := nx;
                 hum.ChangeCY := ny;
                 hum.BoChangeServer := TRUE;  //¼­¹öÀÌµ¿
                 hum.ChangeToServerNumber := nenvir.Server;
                 hum.EmergencyClose := TRUE;
                 hum.SoftClosed := TRUE;  //CertifycationÀ» ¸¸·á½ÃÅ°Áö ¾Ê´Â´Ù.
                 hum.FAlreadyDisapper := TRUE;
               end;
               // »ç¶óÁöÁö ¾Ê´Â´Ù¸é ¾î¶»°Ô ÇØ¾ßÇÏ³ª...PDS
            end else begin
               KickException;  //»ç¶óÁø´Ù.
            end;
         end;
      end;
   end;
end;

procedure  TCreature.UserSpaceMove (mname, xstr, ystr: string);
var
   xx, yy: integer;
   oldenvir: TEnvirnoment;
   hum: TUserHuman;
begin
  if RaceServer = RC_USERHUMAN then begin
    if TUserHuman(Self).m_StallMgr.OnSale then begin

      Exit;
    end;
  end;
   oldenvir := PEnvir;
   if mname = '' then mname := MapName;
   if (xstr <> '') and (ystr <> '') then begin
      xx := Str_ToInt (xstr, 0);
      yy := Str_ToInt (ystr, 0);
      SpaceMove (mname, xx, yy, 0);
   end else
      RandomSpaceMove (mname, 0);

   if oldenvir <> PEnvir then begin  //½ÇÁúÀûÀ¸·Î ´Ù¸¥ ¸ÊÀ¸·Î ÀÌµ¿ ÇÏ¿´À½
      if RaceServer = RC_USERHUMAN then begin
         hum := TUserHuman (self);
         hum.BoTimeRecall := FALSE;    //TimeRecall Ãë¼Ò
         hum.BoTimeRecallGroup := FALSE;
      end;
   end;
end;

function  TCreature.UseScroll (Shape: integer): Boolean;
var
   hum : TUserHuman;
   guildagit : TGuildAgit;
   AgitFlag : Boolean;
begin
   Result := FALSE;
   case Shape of
      1: //µØÀÎÌÓÍÑ¾í: 0¹ø ¸ÊÀ¸·Î µ¹¾Æ°£´Ù.
         if not BoTaiwanEventUser then begin
            if not (PEnvir.NoEscapeMove or PEnvir.NoTeleportMove) then begin  //¾Æ°øÀü¼­ »ç¿ëºÒ°¡(sonmg)
               SendRefMsg (RM_SPACEMOVE_HIDE, 0, 0, 0, 0, '');
               UserSpaceMove (HomeMap, '', ''); //¹«ÀÛÀ§ °ø°£ÀÌµ¿  //'0'
               Result := TRUE;
            end;
         end else
            {$IFDEF KOREA}
            SysMsg ('ÎÞ·¨Ê¹ÓÃ.', 0);
            {$ELSE}
            SysMsg ('Don''t use.', 0);
            {$ENDIF}
{      2: //ÇöÀç ¸Ê¿¡¼­ ¹«ÀÛÀ§·Î Á¡ÇÁ
         if not BoTaiwanEventUser then begin
            if not PEnvir.NoRandomMove then begin
               SendRefMsg (RM_SPACEMOVE_HIDE, 0, 0, 0, 0, '');
               UserSpaceMove (MapName, '', ''); //¹«ÀÛÀ§ °ø°£ÀÌµ¿
               Result := TRUE;
            end;
         end else
            SysMsg ('»ç¿ëÇÒ ¼ö ¾ø½À´Ï´Ù.', 0);
}
      2: //Ëæ»ú´«ËÍ¾í
         if not BoTaiwanEventUser then begin
            if not (PEnvir.NoRandomMove or PEnvir.NoTeleportMove) then begin  //¾Æ°øµµ¾à¼­ »ç¿ëºÒ°¡(sonmg)
               //°ø¼ºÀü ÁßÀÎ ³»¼ºÀÇ °æ¿ì
               if (UserCastle.BoCastleUnderAttack) and (PEnvir = UserCastle.CorePEnvir) then begin
                  if GetTickCount - LatestSpaceScrollTime > 10 * 1000 then begin
                     LatestSpaceScrollTime := GetTickCount;

                     SendRefMsg (RM_SPACEMOVE_HIDE, 0, 0, 0, 0, '');
                     UserSpaceMove (MapName, '', ''); //¹«ÀÛÀ§ °ø°£ÀÌµ¿
                     Result := TRUE;
                  end else begin
                     {$IFDEF KOREA}
                     SysMsg (IntToStr(10 - (GetTickCount - LatestSpaceScrollTime) div 1000) + 'Ãëºó¿ÉÒÔÊ¹ÓÃ', 0);
                     {$ELSE}
                     SysMsg ('You can use it ' + IntToStr(10 - (GetTickCount - LatestSpaceScrollTime) div 1000) + ' seconds later.', 0);
                     {$ENDIF}
                     Result := FALSE;
                  end;

               end else begin
                  SendRefMsg (RM_SPACEMOVE_HIDE, 0, 0, 0, 0, '');
                  UserSpaceMove (MapName, '', ''); //¹«ÀÛÀ§ °ø°£ÀÌµ¿
                  Result := TRUE;
               end;
            end;
         end else
            {$IFDEF KOREA}
            SysMsg ('ÎÞ·¨Ê¹ÓÃ.', 0);
            {$ELSE}
            SysMsg ('Don''t use.', 0);
            {$ENDIF}


      3: //»Ø³Ç¾í
         if not BoTaiwanEventUser then begin
            if not PEnvir.NoEscsafeMove  then begin
            SendRefMsg (RM_SPACEMOVE_HIDE, 0, 0, 0, 0, '');
            if PKLevel < 2 then begin
               UserSpaceMove (HomeMap, IntToStr(HomeX), IntToStr(HomeY));
            end else begin
               UserSpaceMove (BADMANHOMEMAP, IntToStr(BADMANSTARTX), IntToStr(BADMANSTARTY));
            end;
            Result := TRUE;
            end;
         end else
            {$IFDEF KOREA}
            SysMsg ('ÎÞ·¨Ê¹ÓÃ.', 0);
            {$ELSE}
            SysMsg ('You cannot use it.', 0);
            {$ENDIF}

      4: //Ãàº¹ÀÇ±â¸§...  ¹«±â¿¡ Çà¿îÀ» ÁØ´Ù.
         begin
            if MakeWeaponGoodLock then begin
               Result := TRUE;
            end;
         end;
      5: //»çºÏ±ÍÈ¯ÁÖ¹®¼­,±Í¼ºÀü¼­
         if not BoTaiwanEventUser then begin
            if MyGuild <> nil then begin
               if not BoInFreePKArea then begin //not UserCastle.BoCastleUnderAttack then begin
                  if UserCastle.IsOurCastle(TGuild(MyGuild)) then begin //¿ì¸®¹®ÆÄ°¡ »çºÏ¼ºÀ» Á¡·É
                     UserSpaceMove (UserCastle.CastleMap,
                                    IntToStr(UserCastle.GetCastleStartX),
                                    IntToStr(UserCastle.GetCastleStartY));
                  end else
                     {$IFDEF KOREA}
                     SysMsg ('Ã»ÓÐÈÎºÎÐ§¹û', 0);
                     {$ELSE}
                     SysMsg ('It has no effect.', 0);
                     {$ENDIF}
                  Result := TRUE;
               end else
                  {$IFDEF KOREA}
                  SysMsg ('ÔÚÕâÀïÄãÎÞ·¨Ê¹ÓÃ', 0);
                  {$ELSE}
                  SysMsg ('You cannot use it here.', 0);
                  {$ENDIF}
            end;
         end else
            {$IFDEF KOREA}
            SysMsg ('ÎÞ·¨Ê¹ÓÃ', 0);
            {$ELSE}
            SysMsg ('You cannot use it.', 0);
            {$ENDIF}
      6: //±ÍÈ¯Àü¼­(Àå¿øÀ¸·Î ±ÍÈ¯) -> ÇØ´ç Àå¿øÀÌ ¾øÀ¸¸é ÃÊ°øÀü¼­¿Í µ¿ÀÏÇÑ ±â´É.
         //Àå¿øÀ¸·Î ±ÍÈ¯
      begin
         AgitFlag := FALSE;
         if not BoTaiwanEventUser then begin
            if RaceServer = RC_USERHUMAN then begin
               hum := TUserHuman(self);
               if hum.MyGuild <> nil then begin
                  // ¹®ÆÄÀÇ Àå¿ø ¹øÈ£¿Í ÇöÀç ÀÖ´Â ¸ÊÀÇ Àå¿ø¹øÈ£°¡ ÀÏÄ¡ÇÏ¸é Àå¿øÀ¸·Î ÀÌµ¿.
                  guildagit := GuildAgitMan.GetGuildAgit( TGuild(hum.MyGuild).GuildName );
                  if guildagit <> nil then begin
                     if guildagit.GuildAgitNumber > -1 then begin
                        hum.CmdGuildAgitFreeMove( guildagit.GuildAgitNumber );
                        AgitFlag := TRUE;
                        Result := TRUE;
                     end;
                  end;
               end;

               if AgitFlag = FALSE then begin
                  //¾Æ´Ï¸é... ÃÊ°øÀü¼­¿Í °°Àº ±â´É
                  SendRefMsg (RM_SPACEMOVE_HIDE, 0, 0, 0, 0, '');
                  if PKLevel < 2 then begin
                     UserSpaceMove (HomeMap, IntToStr(HomeX), IntToStr(HomeY));
                  end else begin
                     UserSpaceMove (BADMANHOMEMAP, IntToStr(BADMANSTARTX), IntToStr(BADMANSTARTY));
                  end;
                  Result := TRUE;
               end;
            end;
         end else
            {$IFDEF KOREA}
            SysMsg ('ÎÞ·¨Ê¹ÓÃ', 0);
            {$ELSE}
            SysMsg ('You cannot use it.', 0);
            {$ENDIF}
      end;
      9: //¼ö¸®±â¸§... ÇöÀç ¹«±âÀÇ ³»±¸·ÂÈ¸º¹ (ÀÏ¹Ý¼ö¸®)
         begin
            if RepaireWeaponNormaly then begin
               Result := TRUE;
            end;
         end;
      10: //¹«½ÅÀÇ±â¸§... ÇöÀç ¹«±âÀÇ ³»±¸·ÂÈ¸º¹ (Æ¯¼ö¼ö¸®)
         begin
            if RepaireWeaponPerfect then begin
               Result := TRUE;
            end;
         end;

      11: //º¹±Ç
         begin
            if UseLotto then begin
               Result := TRUE;
            end;
         end;
      14: //ÕÙ»½Ç¿»¯¾í
         begin
            if CallMobeItem() then begin
               Result := TRUE;
            end;
         end;
         15: //³¬¼¶×£¸£ÓÍ
         begin
            if CallluckItem() then begin
               Result := TRUE;
            end;
         end;
   end;
end;

function   TCreature.MakeWeaponGoodLock: Boolean;
var
   difficulty: integer;
   flag: Boolean;
   pstd: PTStdItem;
   // 2003/06/13 ·Î±× Ãß°¡
   Delta, Old : integer;
   hum: TUserHuman;
begin
   // 2003/06/13 ·Î±× Ãß°¡
   Delta := 0;
   if UseItems[U_WEAPON].Desc[4] > 0 then Old   := - UseItems[U_WEAPON].Desc[4]  //ÀúÁÖ´Â À½¼ö
   else                                   Old   := UseItems[U_WEAPON].Desc[3];

   Result := FALSE;
   if UseItems[U_WEAPON].Index <> 0 then begin
      difficulty := 0;
      pstd := UserEngine.GetStdItem (UseItems[U_WEAPON].Index);
      if pstd <> nil then begin  //·£´ýÄ¡°¡ Å¬¼ö·Ï Çà¿îÀÌ ºÙ±â Èûµé´Ù.
         difficulty := abs(Hibyte(pstd.DC) - Lobyte(pstd.DC)) div 5;
      // 2003/06/13 ·Î±× Ãß°¡
      end else exit;

      if Random ((zhufuzuzhou)) = 1 then begin
         if MakeWeaponUnlock then begin  //ÀúÁÖ¿¡ °É¸²...
            Delta := -1;
         end;
      end else begin
         flag := FALSE;
         if UseItems[U_WEAPON].Desc[4] > 0 then begin
            UseItems[U_WEAPON].Desc[4] := UseItems[U_WEAPON].Desc[4] - 1; //ºÒ¿î(ÀúÁÖ) °¨¼Ò
            {$IFDEF KOREA}
            SysMsg ('ÄúµÄÎäÆ÷µÃµ½ÁË×£¸£', 1);
            {$ELSE}
            SysMsg ('Luck dwelled in your weapon', 1);
            {$ENDIF}
            Delta := 1;
            flag := TRUE;
         end else begin
            if (UseItems[U_WEAPON].Desc[3] < 1) then begin
               UseItems[U_WEAPON].Desc[3] := UseItems[U_WEAPON].Desc[3] + 1; //Çà¿î
               {$IFDEF KOREA}
               SysMsg ('ÄúµÄÎäÆ÷µÃµ½ÁË×£¸£', 1);
               {$ELSE}
               SysMsg ('Luck dwelled in your weapon', 1);
               {$ENDIF}
               Delta := 1;
               flag := TRUE;
            end else begin
               if (UseItems[U_WEAPON].Desc[3] < (erjidianshu)) and (Random((erjizhufu) + difficulty) = 1) then begin
                  UseItems[U_WEAPON].Desc[3] := UseItems[U_WEAPON].Desc[3] + 1; //Çà¿î
                  {$IFDEF KOREA}
                  SysMsg ('ÄúµÄÎäÆ÷µÃµ½ÁË×£¸£', 1);
                  {$ELSE}
                  SysMsg ('Luck dwelled in your weapon', 1);
                  {$ENDIF}
                  Delta := 1;
                  flag := TRUE;
               end else begin
                  if (UseItems[U_WEAPON].Desc[3] < (sanjidianshu)) and (Random((sanjizhufu) + difficulty * 5) = 1) then begin
                     UseItems[U_WEAPON].Desc[3] := UseItems[U_WEAPON].Desc[3] + 1; //Çà¿î
                     {$IFDEF KOREA}
                     SysMsg ('ÄúµÄÎäÆ÷µÃµ½ÁË×£¸£', 1);
                     {$ELSE}
                     SysMsg ('Luck dwelled in your weapon', 1);
                     {$ENDIF}
                     Delta := 1;
                     flag := TRUE;
                  end;
               end;
            end;
         end;
         if RaceServer = RC_USERHUMAN then begin
            RecalcAbilitys;
            hum := TUserHuman(self);   //added by sonmg(2003/11/07)
            hum.SendUpdateItem (UseItems[U_WEAPON]);   //added by sonmg(2003/11/07)
            SendMsg (self, RM_ABILITY, 0, 0, 0, 0, '');
            SendMsg (self, RM_SUBABILITY, 0, 0, 0, 0, '');
         end;
         if not flag then
            {$IFDEF KOREA}
            SysMsg ('ÎÞÐ§', 1);
            {$ELSE}
            SysMsg ('It has no effect.', 1);
            {$ENDIF}
      end;
      // 2003/06/13 ·Î±× Ãß°¡
//      if Delta <> 0 then begin    //ºÒº¯ ·Î±×µµ ³²±âµµ·Ï(sonmg 2005/04/13)
         //·Î±× ³²°Ü¾ß ÇÔ
         AddUserLog ('29'#9 + //Ãà±â_(»ç¿ë)
                     MapName + ''#9 +
                     IntToStr(CX) + ''#9 +
                     IntToStr(CY) + ''#9 +
                     UserName + ''#9 +
                     pstd.Name + ''#9 +
                     IntToStr(UseItems[U_WEAPON].MakeIndex) + ''#9 +
                     '0' +''#9 +
                     IntToStr(Delta) + '(' + IntToStr(Old) + '->' + IntToStr(Old+Delta) + ')'
                     );
//      end;
      Result := TRUE;
   end;
end;

function   TCreature.RepaireWeaponNormaly: Boolean;
var
   repair: integer;
   ps: PTStdItem;
   WeaponName: string;
   Repair_type: integer;
begin
   Result := FALSE;
   Repair_type := 0;
   if UseItems[U_WEAPON].Index > 0 then begin
      ps := UserEngine.GetStdItem (UseItems[U_WEAPON].Index);
      if ps <> nil then begin
         // À¯´ÏÅ©¾ÆÀÌÅÛ ÇÊµå°¡ 3ÀÌ¸é ¼ö¸®ºÒ°¡.
         // => UNIQUEITEM ÇÊµå°¡ 00000010(2Áø¼ö)¸¦ Æ÷ÇÔÇÏ¸é ¼ö¸®ºÒ°¡ ¾ÆÀÌÅÛ(sonmg 2005/12/09)
         if {ps.UniqueItem = 3} (ps.UniqueItem and $02) <> 0 then begin
            {$IFDEF KOREA}
            SysMsg ('Õâ¸öÎäÆ÷ÎÞ·¨ÐÞ¸´', 0);
            {$ELSE}
            SysMsg ('This weapon cannot be repaired.', 0);
            {$ENDIF}
            Result := FALSE;
            exit;
         end;
         WeaponName := ps.Name;
      end;

      repair := _MIN(5000, _MAX(0, UseItems[U_WEAPON].DuraMax - UseItems[U_WEAPON].Dura));   //DURAMAX¼öÁ¤
      if repair > 0 then begin
         UseItems[U_WEAPON].DuraMax := _MAX(0, UseItems[U_WEAPON].DuraMax - (repair div 30));   //DURAMAX¼öÁ¤
         UseItems[U_WEAPON].Dura := _MIN(UseItems[U_WEAPON].Dura + repair, UseItems[U_WEAPON].DuraMax);
         SendMsg (self, RM_DURACHANGE, U_WEAPON, UseItems[U_WEAPON].Dura, UseItems[U_WEAPON].DuraMax, 0, '');
         RecalcAbilitys;//sonmg Ãß°¡
         SendMsg (self, RM_ABILITY, 0, 0, 0, 0, '');   //added by sonmg(2004/04/02)
         SendMsg (self, RM_SUBABILITY, 0, 0, 0, 0, '');   //added by sonmg(2004/04/02)
//         SysMsg ('¹«±â°¡ ÀÏºÎ ¼ö¸®µÇ¾ú½À´Ï´Ù.', 1);
         {$IFDEF KOREA}
         SysMsg ('''' + WeaponName + '''' + ' ²¿·ÖÐÞ¸´', 1);
         {$ELSE}
         SysMsg ('''' + WeaponName + '''' + ' is partially repaired.', 1);
         {$ENDIF}
         Result := TRUE;

         //¼ö¸® ·Î±× ³²±è
         Repair_type := 3;
         AddUserLog ('36'#9 + //¼ö¸®_ +
                 MapName + ''#9 +
                 '0' + ''#9 +
                 IntToStr(Gold) + ''#9 +
                 UserName + ''#9 +
                 intToStr(UseItems[U_WEAPON].DuraMax) + ''#9 +
                 IntToStr(UseItems[U_WEAPON].MakeIndex) + ''#9 +
                 intToStr(Repair_type)+#9 +
                 '0');
      end else begin
         {$IFDEF KOREA}
         SysMsg ('Äã²»ÐèÒªÐÞÀíÕâ¸öÎïÆ·', 0);
         {$ELSE}
         SysMsg ('You need not repair this item.', 0);
         {$ENDIF}
      end;
   end;
end;

function   TCreature.RepaireWeaponPerfect: Boolean;
var
   ps: PTStdItem;
   Repair_type: integer;
begin
   Result := FALSE;
   Repair_type := 0;
   if UseItems[U_WEAPON].Index > 0 then begin
      ps := UserEngine.GetStdItem (UseItems[U_WEAPON].Index);
      if ps <> nil then begin
         // À¯´ÏÅ©¾ÆÀÌÅÛ ÇÊµå°¡ 3ÀÌ¸é ¼ö¸®ºÒ°¡.
         // => UNIQUEITEM ÇÊµå°¡ 00000010(2Áø¼ö)¸¦ Æ÷ÇÔÇÏ¸é ¼ö¸®ºÒ°¡ ¾ÆÀÌÅÛ(sonmg 2005/12/09)
         if {ps.UniqueItem = 3} (ps.UniqueItem and $02) <> 0 then begin
            {$IFDEF KOREA}
            SysMsg ('Õâ°ÑÎäÆ÷ÎÞ·¨ÐÞ¸´', 0);
            {$ELSE}
            SysMsg ('This weapon cannot be repaired.', 0);
            {$ENDIF}
            Result := FALSE;
            exit;
         end;
      end;

      UseItems[U_WEAPON].Dura := UseItems[U_WEAPON].DuraMax;
      SendMsg (self, RM_DURACHANGE, U_WEAPON, UseItems[U_WEAPON].Dura, UseItems[U_WEAPON].DuraMax, 0, '');
      RecalcAbilitys;//sonmg Ãß°¡
      SendMsg (self, RM_ABILITY, 0, 0, 0, 0, '');   //added by sonmg(2004/04/02)
      SendMsg (self, RM_SUBABILITY, 0, 0, 0, 0, '');   //added by sonmg(2004/04/02)
      {$IFDEF KOREA}
      SysMsg ('ÎäÆ÷ÍêÈ«ÐÞ¸´', 1);
      {$ELSE}
      SysMsg ('ÎäÆ÷ÍêÈ«ÐÞ¸´', 1);
      {$ENDIF}
      Result := TRUE;

      //¼ö¸® ·Î±× ³²±è
      Repair_type := 4;
      AddUserLog ('36'#9 + //¼ö¸®_ +
              MapName + ''#9 +
              '0' + ''#9 +
              IntToStr(Gold) + ''#9 +
              UserName + ''#9 +
              intToStr(UseItems[U_WEAPON].DuraMax) + ''#9 +
              IntToStr(UseItems[U_WEAPON].MakeIndex) + ''#9 +
              intToStr(Repair_type)+#9 +
              '0');
   end;
end;


//È«²¿ÐÞ¸´,ÐèÒªµÄ³Ö¾ÃÖµ 20080325
Function TCreature.RepairAllItemDura:Integer;
var
  nWhere: Integer;
//  sCheckItemName: string;
  StdItem: pTStdItem;
begin
  Result:= 0;
  for nWhere := Low(UseItems) to High(UseItems) do begin
    if UseItems[nWhere].Index > 0 then begin
      StdItem := UserEngine.GetStdItem(UseItems[nWhere].Index);
      if StdItem <> nil then begin
        if ((UseItems[nWhere].DuraMax div 1000) > (UseItems[nWhere].Dura div 1000)) and  (StdItem.StdMode<>7) and (StdItem.StdMode<>25) and (StdItem.StdMode<>43) and (StdItem.AniCount<>21) then begin
          Inc(Result,(UseItems[nWhere].DuraMax - UseItems[nWhere].Dura));
        end;
      end;
    end;
  end;
end;

//È«²¿ÐÞ¸´
procedure TCreature.RepairAllItem(DureCount: Integer; boDec: Boolean);
var
  nWhere,RepCount: Integer;
  StdItem: pTStdItem;
begin
  for nWhere := Low(UseItems) to High(UseItems) do begin
    if UseItems[nWhere].Index > 0 then begin
      StdItem := UserEngine.GetStdItem(UseItems[nWhere].Index);
      if StdItem <> nil then begin
        if ((UseItems[nWhere].DuraMax div 1000) > (UseItems[nWhere].Dura div 1000)) and (StdItem.StdMode<>7) and (StdItem.StdMode<>25) and (StdItem.StdMode<>43) and (StdItem.AniCount<>21) then begin
          if not boDec then begin//ÐÞ¸´µã¹»,ÔòÖ±½ÓÐÞ¸´²»¼ÆËã
              if (UseItems[nWhere].DuraMax div 1000) - (UseItems[nWhere].Dura div 1000) > 0 then
                 SysMsg(StdItem.Name+'ÐÞ²¹³É¹¦¡£', 1);
              UseItems[nWhere].Dura := UseItems[nWhere].DuraMax;
              SendMsg(Self, RM_DURACHANGE, nWhere, UseItems[nWhere].Dura, UseItems[nWhere].DuraMax, 0, '');
          end else begin
            RepCount:= (UseItems[nWhere].DuraMax div 1000) - (UseItems[nWhere].Dura div 1000);
            if DureCount >= RepCount then begin
              Dec(DureCount,RepCount);
              if (UseItems[nWhere].DuraMax div 1000) - (UseItems[nWhere].Dura div 1000) > 0 then
                 SysMsg(StdItem.Name+'ÐÞ²¹³É¹¦¡£', 1); //20071229
              UseItems[nWhere].Dura := UseItems[nWhere].DuraMax;
              SendMsg(Self, RM_DURACHANGE, nWhere, UseItems[nWhere].Dura, UseItems[nWhere].DuraMax, 0, '');
            end else
            if DureCount > 0 then begin
               DureCount:= 0;
               UseItems[nWhere].Dura :=UseItems[nWhere].Dura + DureCount * 1000;
               SendMsg(Self, RM_DURACHANGE, nWhere, UseItems[nWhere].Dura, UseItems[nWhere].DuraMax, 0, '');
               Break;
            end;
          end;
        end;
      end;
    end;
  end;
end;

function TCreature.CallMobeItem(): Boolean;     //±¦±¦Ç¿»¯¾í jigndian add
var
  I: Integer;
  Slave: TUserHuman;
begin
  Result := False;
  if SlaveList.Count = 0 then begin
    SysMsg('ÌáÊ¾£ºÄúÃ»ÓÐÕÙ»½±¦±¦,²»ÄÜÊ¹ÓÃ´ËÎïÆ·!', 0);
    Exit;
  end;
  if SlaveList.Count > 0 then begin
    for I := 0 to SlaveList.Count - 1 do begin
      Slave := TUserHuman(SlaveList.Items[I]);
      if Slave.RaceServer = RC_CLONE then Continue;
      if Slave.SlaveExpLevel < 7 then begin
        Slave.SlaveExpLevel := 7;
        Slave.RecalcAbilitys;
        Slave.ChangeNameColor;
        Result := True;
        SysMsg('ÌáÊ¾£ºÔÚÉñÃØµÄÁ¦Á¿Ó°ÏìÏÂ£¬ÄúµÄ³èÎï:' + Slave.userName + ' ³É³¤Îª7¼¶', 1);
        Break;
      end;
    end;
  end;
end;

function TCreature.CallluckItem(): Boolean;     //³¬¼¶×£¸£ÓÍ jigndian add
var
  difficulty: integer;
  flag: Boolean;
  pstd: PTStdItem;
  // 2003/06/13 ·Î±× Ãß°¡
  Delta, Old: integer;
  hum: TUserHuman;
begin
  // 2003/06/13 ·Î±× Ãß°¡
  Delta := 0;
  if UseItems[U_WEAPON].Desc[4] > 0 then
    Old := -UseItems[U_WEAPON].Desc[4] // ÀúÁÖ´Â À½¼ö
  else
    Old := UseItems[U_WEAPON].Desc[3];

  result := FALSE;
  if UseItems[U_WEAPON].index <> 0 then
  begin
    difficulty := 0;
    pstd := UserEngine.GetStdItem(UseItems[U_WEAPON].index);
    if pstd <> nil then
    begin // ·£´ýÄ¡°¡ Å¬¼ö·Ï Çà¿îÀÌ ºÙ±â Èûµé´Ù.
      difficulty := abs(Hibyte(pstd.dc) - Lobyte(pstd.dc)) div 5;
      // 2003/06/13 ·Î±× Ãß°¡
    end
    else
      exit;

//    if Random(20) = 1 then
//    begin
//      if MakeWeaponUnlock then
//      begin // ÀúÁÖ¿¡ °É¸²...
//        Delta := -1;
//      end;
   if  (UseItems[U_WEAPON].Desc[3]  > 6) then begin
    SysMsg('ÌáÊ¾£ºÄúµÄÎäÆ÷ÒÑ¾­³¬¹ý7µãÐÒÔËÁË,²»ÄÜÊ¹ÓÃ´ËÎïÆ·!', 0);
    Exit;
    end
    else
    begin
      flag := FALSE;
      if UseItems[U_WEAPON].Desc[4] > 0 then
      begin
        UseItems[U_WEAPON].Desc[4] := UseItems[U_WEAPON].Desc[4] - 1;
        // ºÒ¿î(ÀúÁÖ) °¨¼Ò
        SysMsg('ÄãµÄÎäÆ÷µÃµ½ÁË×£¸£¡£', 1);
        Delta := 1;
        flag := TRUE;
      end
      else
      begin
        if (UseItems[U_WEAPON].Desc[3] < 1) then
        begin
          UseItems[U_WEAPON].Desc[3] := UseItems[U_WEAPON].Desc[3] + 1; // Çà¿î
          SysMsg('ÄãµÄÎäÆ÷µÃµ½ÁË×£¸£¡£', 1);
          Delta := 1;
          flag := TRUE;
        end
        else
        begin
          if (UseItems[U_WEAPON].Desc[3] < (g_Powerfulblessingoil)) and (Random((g_PPowerfulblessingoil) + difficulty) = 1)
          then
          begin
            UseItems[U_WEAPON].Desc[3] := UseItems[U_WEAPON].Desc[3] + 1; // Çà¿î
            SysMsg('ÄãµÄÎäÆ÷µÃµ½ÁË×£¸£¡£', 1);
            Delta := 1;
            flag := TRUE;
          end
          else
          begin
            if (UseItems[U_WEAPON].Desc[3] < (g_WPowerfulblessingoil)) and
              (Random((g_EPowerfulblessingoil) + difficulty * 5) = 1) then
            begin
              UseItems[U_WEAPON].Desc[3] := UseItems[U_WEAPON].Desc[3] + 1;
              // Çà¿î
              SysMsg('ÄãµÄÎäÆ÷µÃµ½ÁË×£¸£¡£', 1);
              Delta := 1;
              flag := TRUE;
            end;
          end;
        end;
      end;
      if RaceServer = RC_USERHUMAN then
      begin
        RecalcAbilitys;
        hum := TUserHuman(self); // added by sonmg(2003/11/07)
        hum.SendUpdateItem(UseItems[U_WEAPON]); // added by sonmg(2003/11/07)
        SendMsg(self, RM_ABILITY, 0, 0, 0, 0, '');
        SendMsg(self, RM_SUBABILITY, 0, 0, 0, 0, '');
      end;
      if not flag then
        SysMsg('ÎÞÐ§', 1);
    end;
    // 2003/06/13 ·Î±× Ãß°¡
    // if Delta <> 0 then begin    //ºÒº¯ ·Î±×µµ ³²±âµµ·Ï(sonmg 2005/04/13)
    // ·Î±× ³²°Ü¾ß ÇÔ
    AddUserLog('29'#9 + // Ãà±â_(»ç¿ë)
      MapName + ''#9 + intTostr(CX) + ''#9 + intTostr(CY) + ''#9 + UserName +
      ''#9 + pstd.Name + ''#9 + intTostr(UseItems[U_WEAPON].MakeIndex) + ''#9 +
      '0' + ''#9 + intTostr(Delta) + '(' + intTostr(Old) + '->' +
      intTostr(Old + Delta) + ')');
    // end;
    result := TRUE;
  end;
end;

// ÀÏ¹Ý ¾ÆÀÌÅÛ ¼ö¸®(2004/03/17).
function   TCreature.RepairItemNormaly( psSeed: PTStdItem; puSeed: PTUserItem ): Boolean;
var
   repair: integer;
   hum: TUserHuman;
begin
   Result := FALSE;

   if psSeed <> nil then begin
      // À¯´ÏÅ©¾ÆÀÌÅÛ ÇÊµå°¡ 3ÀÌ¸é ¼ö¸®ºÒ°¡.
      // => UNIQUEITEM ÇÊµå°¡ 00000010(2Áø¼ö)¸¦ Æ÷ÇÔÇÏ¸é ¼ö¸®ºÒ°¡ ¾ÆÀÌÅÛ(sonmg 2005/12/09)
      if {psSeed.UniqueItem = 3} (psSeed.UniqueItem and $02) <> 0 then begin
         {$IFDEF KOREA}
         SysMsg ('Õâ°ÑÎäÆ÷ÎÞ·¨ÐÞ¸´', 0);
         {$ELSE}
         SysMsg ('This weapon cannot be repaired.', 0);
         {$ENDIF}
         Result := FALSE;
         exit;
      end;

      repair := _MIN(5000, _MAX(0, puSeed.DuraMax - puSeed.Dura));   //DURAMAX¼öÁ¤
      if repair > 0 then begin
         puSeed.DuraMax := _MAX(0, puSeed.DuraMax - (repair div 30));   //DURAMAX¼öÁ¤
         puSeed.Dura := _MIN(puSeed.Dura + repair, puSeed.DuraMax);
         if RaceServer = RC_USERHUMAN then begin
            hum := TUserHuman(self);
            hum.SendUpdateItem (puSeed^);
         end;
         {$IFDEF KOREA}
         SysMsg ('''' + psSeed.Name + '''' + ' ²¿·ÖÐÞ¸´', 1);
         {$ELSE}
         SysMsg ('''' + psSeed.Name + '''' + ' is partially repaired.', 1);
         {$ENDIF}
         Result := TRUE;
      end else begin
         {$IFDEF KOREA}
         SysMsg ('Äã²»ÐèÒªÐÞÀíÕâ¸öÎïÆ·', 0);
         {$ELSE}
         SysMsg ('You need not repair this item.', 0);
         {$ENDIF}
      end;
   end;
end;

//º¹±ÇÀ» ±Ü´Â´Ù.
function   TCreature.UseLotto: Boolean;
var
   ngold, grade: integer;
begin
   ngold := 0;
   grade := 0;
   case Random(30000) of  //500*25000 = 12,500,000 (11,500,000)
      0..4999: //500 * 5000 = 2,500,000
         if LottoSuccess < LottoFail then begin
            ngold := 500;
            grade := 6;
            Inc (Lotto6);
         end;
      14000..15999:  //1000 * 2000 = 2,000,000
         if LottoSuccess < LottoFail then begin
            ngold := 1000;
            grade := 5;
            Inc (Lotto5);
         end;
      16000..16149:  //10000 * 200 = 2,000,000
         if LottoSuccess < LottoFail then begin
            ngold := 10000;
            grade := 4;
            Inc (Lotto4);
         end;
      16150..16169:  //100000 * 20 = 2,000,000
         if LottoSuccess < LottoFail then begin
            ngold := 100000;
            grade := 3;
            Inc (Lotto3);
         end;
      16170..16179: //200000 * 10 = 2,000,000
         if LottoSuccess < LottoFail then begin
            ngold := 200000;
            grade := 2;
            Inc (Lotto2);
         end;
      18000:    //1000000 (1µî)
         if LottoSuccess < LottoFail then begin
            ngold := 1000000;
            grade := 1;
            Inc (Lotto1);
         end;

   end;
   if ngold > 0 then begin
      LottoSuccess := LottoSuccess + ngold;
      case grade of
         1: begin
               {$IFDEF KOREA}
               SysMsg ('¹§Ï²ÄúÖÐÁËÍ·µÈ½±', 1);
               {$ELSE}
               SysMsg ('Congratulations. You won 1st prize.', 1);
               {$ENDIF}
            end;
         2: begin
               {$IFDEF KOREA}
               SysMsg ('¹§Ï²ÄúÖÐÁË¶þµÈ½±', 1);
               {$ELSE}
               SysMsg ('Congratulations. You won 2nd prize.', 1);
               {$ENDIF}
            end;
         3: begin
               {$IFDEF KOREA}
               SysMsg ('¹§Ï²ÄúÖÐÁËÈýµÈ½±', 1);
               {$ELSE}
               SysMsg ('Congratulations. You won 3rd prize.', 1);
               {$ENDIF}
            end;
         4: begin
               {$IFDEF KOREA}
               SysMsg ('¹§Ï²ÄúÖÐÁËËÄµÈ½±', 1);
               {$ELSE}
               SysMsg ('Congratulations. You won 4th prize.', 1);
               {$ENDIF}
            end;
         5: begin
               {$IFDEF KOREA}
               SysMsg ('¹§Ï²ÄúÖÐÁËÎåµÈ½±', 1);
               {$ELSE}
               SysMsg ('Congratulations. You won 5th prize.', 1);
               {$ENDIF}
            end;
         6: begin
               {$IFDEF KOREA}
               SysMsg ('¹§Ï²ÄúÖÐÁËÁùµÈ½±', 1);
               {$ELSE}
               SysMsg ('Congratulations. You won 6th prize.', 1);
               {$ENDIF}
            end;
         7: begin
               {$IFDEF KOREA}
               SysMsg ('¹§Ï²ÄúÖÐÁËÆßµÈ½±', 1);
               {$ELSE}
               SysMsg ('Congratulations. You won 7th prize.', 1);
               {$ENDIF}
            end;
         8: begin
               {$IFDEF KOREA}
               SysMsg ('¹§Ï²ÄúÖÐÁË°ËµÈ½±', 1);
               {$ELSE}
               SysMsg ('Congratulations. You won 8th prize.', 1);
               {$ENDIF}
            end;
      end;
      if IncGold (ngold) then begin
         GoldChanged;
      end else begin
         DropGoldDown (ngold, TRUE, nil, nil);
      end;
   end else begin
      LottoFail := LottoFail + 500;
      {$IFDEF KOREA}
      SysMsg ('µÈÏÂ´Î»ú»á°É', 0);
      {$ELSE}
      SysMsg ('Nothing..', 0);
      {$ENDIF}
   end;
   Result := TRUE;
end;


procedure  TCreature.MakeHolySeize (htime: integer);
begin
   BoHolySeize := TRUE;
   HolySeizeStart := GetTickCount;
   HolySeizeTime := htime;
   ChangeNameColor;
end;

procedure  TCreature.BreakHolySeize;
begin
   BoHolySeize := FALSE;
   ChangeNameColor;
end;

procedure  TCreature.MakeCrazyMode (csec: integer);
begin
   BoCrazyMode := TRUE;
   CrazyModeStart := GetTickCount;
   CrazyModeTime := csec * 1000;
   ChangeNameColor;
end;

procedure  TCreature.MakeGoodCrazyMode (csec: integer);
begin
   BoGoodCrazyMode := TRUE;
   CrazyModeStart := GetTickCount;
   CrazyModeTime := csec * 1000;
   ChangeNameColor;
end;

procedure  TCreature.BreakCrazyMode;
begin
   if BoCrazyMode or BoGoodCrazyMode then begin
      BoCrazyMode := FALSE;
      BoGoodCrazyMode := FALSE;
      ChangeNameColor;
   end;
end;

procedure  TCreature.MakeOpenHealth;
begin
   BoOpenHealth := TRUE;
   CharStatusEx := CharStatusEx or STATE_OPENHEATH;
   CharStatus := GetCharStatus;
   SendRefMsg (RM_OPENHEALTH, 0, WAbil.HP{lparam1}, WAbil.MaxHP{lparam2}, 0, '');
end;

procedure  TCreature.BreakOpenHealth;
begin
   if BoOpenHealth then begin
      BoOpenHealth := FALSE;
      CharStatusEx := CharStatusEx xor STATE_OPENHEATH;
      CharStatus := GetCharStatus;
      SendRefMsg (RM_CLOSEHEALTH, 0, 0, 0, 0, '');
   end;
end;

//hiter´Â nilÀÏ ¼ö ÀÖÀ½
function   TCreature.GetHitStruckDamage (hiter: TCreature; damage: integer): integer;  //³» ¹æ¾î·ÂÀ» °¨¾ÈÇÏ¿© µ¥¹ÌÁö °è»ê
var
   armor: integer;
begin
//   armor := Lobyte(WAbil.AC) + Random(ShortInt(Hibyte(WAbil.AC)-Lobyte(WAbil.AC)) + 1);
   armor := Lobyte(WAbil.AC) + Random(Integer(Hibyte(WAbil.AC)-Lobyte(WAbil.AC)) + 1);
   damage := _MAX(0, damage - armor);
   if (LifeAttrib = LA_UNDEAD) and (hiter <> nil) then begin
      damage := damage + hiter.AddAbil.UndeadPower;
   end;
   if damage > 0 then begin
      if BoAbilMagBubbleDefence then begin
         damage := Round (damage / 100 * (MagBubbleDefenceLevel + 2) * 8);
         DamageBubbleDefence;
      end;
            if BoAbilCelestial then begin
         damage := Round (damage / g_YinYangDharmaring2 * (CelestialLevel + 2) * 8);
         DamageCelestial;
      end;
   end;
   Result := damage;
end;

//hiter´Â nilÀÏ ¼ö ÀÖÀ½
function   TCreature.GetMagStruckDamage (hiter: TCreature; damage: integer): integer;  //³» ¸¶Ç×·ÂÀ» °¨¾ÈÇÏ¿© µ¥¹ÌÁö °è»ê
var
   armor: integer;
begin
//   armor := Lobyte(WAbil.MAC) + Random(ShortInt(Hibyte(WAbil.MAC)-Lobyte(WAbil.MAC)) + 1);
   armor := Lobyte(WAbil.MAC) + Random(Integer(Hibyte(WAbil.MAC)-Lobyte(WAbil.MAC)) + 1);
   damage := _MAX(0, damage - armor);
   if (LifeAttrib = LA_UNDEAD) and (hiter <> nil) then begin
      damage := damage + hiter.AddAbil.UndeadPower;
   end;
   if damage > 0 then begin
      if BoAbilMagBubbleDefence then begin
         damage := Round (damage / 100 * (MagBubbleDefenceLevel + 2) * 8);
         DamageBubbleDefence;
      end;
            if BoAbilCelestial then begin
         damage := Round (damage / g_YinYangDharmaring2 * (CelestialLevel + 2) * 8);
         DamageCelestial;
      end;
   end;
   Result := damage;
end;

procedure  TCreature.StruckDamage (damage: integer; hiter : TCreature );

   function DirectAttack2 (target: TCreature; damage: integer): Boolean;
   begin
      Result := FALSE;
      if (RaceServer = RC_USERHUMAN) and (target.RaceServer = RC_USERHUMAN) and ((target.InSafeZone) or (InSafeZone)) then
         exit;  //¾ÈÀüÁö´ë
      if IsProperTarget (target) then begin
         if Random(target.SpeedPoint) < AccuracyPoint then begin
            if TUserHuman(target).m_StallMgr.OnSale and bosafe°ÚÌ¯ and TUserHuman(target).InSafeZone then begin
              Result := TRUE;
              Exit;
            end;
            target.StruckDamage (damage, self);
            target.SendDelayMsg (TCreature(RM_STRUCK), RM_REFMESSAGE, damage{wparam},
                     target.WAbil.HP{lparam1}, target.WAbil.MaxHP{lparam2}, Longint(self){hiter}, '', 500);
            //¸ó½ºÅÍÇÑÅ×´Â Á÷Á¢Àü´ÞÇØ¾ß ÇÔ..
            if target.RaceServer <> RC_USERHUMAN then
               target.SendMsg (target, RM_STRUCK, damage, target.WAbil.HP, target.WAbil.MaxHP, Longint(self), '');
            Result := TRUE;
         end;
      end;
   end;

   function AroundAttack (damage: integer): TCreature;
   var
      i, j, dir, xx, yy: integer;
      target: TCreature;
   begin
      Result := nil;
      for i := -1 to 1 do begin
         for j := -1 to 1 do begin
            xx := CX + i;
            yy := CY + j;
            target := TCreature (PEnvir.GetCreature (xx, yy, TRUE));

            if (damage > 0) and (target <> nil) then begin
               if target.RaceServer <> RC_USERHUMAN then begin
                  if ( DirectAttack2 (target, damage) ) then begin
                     Result := Target;
                  end;
               end;
            end;

         end; // for j
      end; // for i
   end;

var
   i, wdam, adura, old: integer;
   bocalc: Boolean;
   hum: TUserHuman;
   ps: PTStdItem;
   realdam: integer;
   hitername: string;
begin
   if damage > 0 then begin
      //È¸ÇÇ È®·ü
      if MissProbability > Random(100) then begin
        {$IFDEF DEBUG}
        UserEngine.CryCry (RM_CRY, PEnvir, CX, CY, 10000, UserName + ' Miss!!! ');
        {$ENDIF}
         exit;
      end;

      // 2003/03/04 ¸¶Áö¸· È÷ÅÍ ¼öÁ¤
      if(hiter <> nil) then SetLastHiter(hiter);

      //ÇÇÇØ¸¦ ÀÔÀ½.
      //Àåºñ¿¡ ÇÇÇØ¸¦ ÀÔ´Â´Ù.
      wdam := Random (10) + 5;

      if StatusArr[POISON_DAMAGEARMOR] > 0 then begin
         //¹æ¾î·ÂÀÌ ¶³¾îÁö´Â µ¶, Àåºñ°¡ »¡¸® ±úÁø´Ù.
         //damage´Â 20% ´Ã¾î³­´Ù.
//         wdam := Round(wdam * 1.2);
//         damage := Round(damage * 1.2);
         //level¿¡ µû¶ó ´Ù¸£°Ô Àû¿ë
         wdam := Round(wdam * ((10 + RedPoisonLevel) / 10));
         damage := Round(damage * ((10 + RedPoisonLevel) / 10));
      end;
      // ½ºÅÏÁßÀÏ °æ¿ì µ¥¹ÌÁö´Â 1.2¹è »ó½Â
      if StatusArr[POISON_STUN] > 0 then begin
//       MainOutMessage ('[»óÅÂÀÌ»ó] ½ºÅÏ½Ã µ¥¹ÌÁö 1.2¹è');
         damage := Round(damage * 1.2);
      end;


      if RaceServer = RC_USERHUMAN then begin
        hum := TUserHuman(self);
        if hum.m_StallMgr.OnSale then begin
          if bosafe°ÚÌ¯ and hum.InSafeZone then Exit;
        end;
      end;

      bocalc := FALSE;
      if (UseItems[U_DRESS].Index > 0) and (UseItems[U_DRESS].Dura > 0) then begin //¿ÊÀº ??º»À¸·Î ?´Â´Ù.
         adura := UseItems[U_DRESS].Dura;
         old := Round (adura / 1000);
         adura := adura - (wdam * (zbchijiu) div 100);              // Èç¹ûÒªÒÂ·þ³Ö¾ÃÂýÒ»°ë£¬¾ÍÊÇÕâ¸ö  (wdam / 2);
         if adura <= 0 then begin
            if RaceServer = RC_USERHUMAN then begin
               hum := TUserHuman(self);
               hum.SendDelItem (UseItems[U_DRESS]); //Å¬¶óÀÌ¾ðÆ®¿¡ ¾ø¾îÁø°Å º¸³¿
               //´â¾Æ ¾ø¾îÁø°Å ·Î±× ³²±è
               AddUserLog ('3'#9 +  //´âÀ½_ +
                           MapName + ''#9 +
                           IntToStr(CX) + ''#9 +
                           IntToStr(CY) + ''#9 +
                           UserName + ''#9 +
                           UserEngine.GetStdItemName (UseItems[U_DRESS].Index) + ''#9 +
                           IntToStr(UseItems[U_DRESS].MakeIndex) + ''#9 +
                           IntToStr(BoolToInt(RaceServer = RC_USERHUMAN)) + ''#9 +
                           '0');
               SysMsg (UserEngine.GetStdItemName (UseItems[U_DRESS].Index) + 'Òò³Ö¾ÃÖµºÄ¾¡¶øÏûÊ§', 0);
               UseItems[U_DRESS].Index := 0;
               hum.FeatureChanged;
            end;
            UseItems[U_DRESS].Dura := 0;
            UseItems[U_DRESS].Index := 0;


            UseItems[U_DRESS].Dura := 0;
            bocalc := TRUE;
         end else
            UseItems[U_DRESS].Dura := adura;

         if old <> Round (adura / 1000) then begin
            //ÄÍ¾ÃÐÔ±ä»¯
            SendMsg (self, RM_DURACHANGE, U_DRESS, adura, UseItems[U_DRESS].DuraMax, 0, '');
         end;
      end;
      // 2003/03/15 ¾ÆÀÌÅÛ ÀÎº¥Åä¸® È®Àå
      // 2003/04/01 ¾ÆÀÌÅÛ ³»±¸ Á¶Á¤
      for i:=1 to 11 do begin  // ±¦Ê¯ÎÞÄÍ¾Ã£¬»¤·ûÎÞÄÍ¾ÃÄ¥Ëð
         if (RaceServer = RC_USERHUMAN) and (bosafe°ÚÌ¯ and InSafezone) and TUserHuman(Self).m_StallMgr.OnSale then begin
            Break;
         end;
         if (UseItems[i].Index > 0) and (UseItems[i].Dura > 0) and (Random(8) = 0) and (i<>U_BUJUK) then begin
            //Èç¹ûËüÊÇÅå´÷ÔÚ×ó±ÛÉÏµÄ»¤Éí·û»ò¶¾·Û£¬ÔòÄÍÓÃÐÔ²»»áÄ¥Ëð(sonmg 2004/06/30)
            if i = U_ARMRINGL then begin
               ps := UserEngine.GetStdItem (UseItems[i].Index);
               if ps <> nil then begin
                  //»¤Éí·û£¬¶¾·Û
                  if ps.StdMode = 25 then continue;
               end;
            end;
            adura := UseItems[i].Dura;
            old := Round (adura / 1000);
            adura := adura - (wdam * (zbchijiu) div 100);
            if adura <= 0 then begin
               if RaceServer = RC_USERHUMAN then begin
                  hum := TUserHuman(self);
                  hum.SendDelItem (UseItems[i]); //Å¬¶óÀÌ¾ðÆ®¿¡ ¾ø¾îÁø°Å º¸³¿
                  //´â¾Æ ¾ø¾îÁø°Å ·Î±× ³²±è
                  AddUserLog ('3'#9 +  //´âÀ½_ +
                           MapName + ''#9 +
                           IntToStr(CX) + ''#9 +
                           IntToStr(CY) + ''#9 +
                           UserName + ''#9 +
                           UserEngine.GetStdItemName (UseItems[i].Index) + ''#9 +
                           IntToStr(UseItems[i].MakeIndex) + ''#9 +
                           IntToStr(BoolToInt(RaceServer = RC_USERHUMAN)) + ''#9 +
                           '0');
                  SysMsg (UserEngine.GetStdItemName (UseItems[i].Index) + 'Òò³Ö¾ÃÖµºÄ¾¡¶øÏûÊ§', 0);
                  UseItems[i].Index := 0;
                  hum.FeatureChanged;
               end;
               UseItems[i].Dura := 0;
               UseItems[i].Index := 0;
               UseItems[i].Dura := 0;
               bocalc := TRUE;
            end else
               UseItems[i].Dura := adura;

            if old <> Round (adura / 1000) then begin
               //ÄÍ¾ÃÐÔ±ä»¯
               SendMsg (self, RM_DURACHANGE, i, adura, UseItems[i].DuraMax, 0, '');
            end;
         end;
      end;
      if bocalc then begin
         RecalcAbilitys; //¹«±â°¡ ´Ù ´â¾ÒÀ¸¸é ´É·ÂÄ¡ ´Ù½Ã °è»ê
         SendMsg (self, RM_ABILITY, 0, 0, 0, 0, '');
         SendMsg (self, RM_SUBABILITY, 0, 0, 0, 0, '');
      end;
      //Ã¼·ÂÀÌ ´â´Â´Ù.

      try

         if RaceServer = RC_CLONE then begin
            if ( not Death     ) and
               ( not BoGhost   ) and
               ( Master <> nil ) and
               ( Master.RaceServer = RC_USERHUMAN ) and
               ( not Master.BoGhost  ) and
               ( not Master.Death    ) and
               ( Master.WAbil.MP > 0 ) then
            begin
               if ( Master.WAbil.MP >= (damage div 5) ) then begin
                  Master.WAbil.MP := Master.Wabil.MP - (damage div 5);
               end else begin
                  Master.WAbil.MP := 0;
               end;

               Master.healthspellchanged;

            end;
         end;

         // ²»ÊÇÈËµÄÊ±ºò±ä³ÉÊ¯Í·±»´ò¾Í»á½â¿ª¡£
         if ( RaceServer <> RC_USERHUMAN ) and ( StatusArr[POISON_DONTMOVE] > 1) then StatusArr[POISON_DONTMOVE] := 1;

         realdam := DamageHealth (damage, 0);
//         if  WAbil.HP = 0 then
//           m_beidusi := False;
         // ÇÇµå¹é È®·ü
         if FeedbackProbability > Random(100) then begin
            AroundAttack(realdam * FeedbackRatio div 100);
         end;

        {$IFDEF DEBUG}
        if hiter <> nil then hitername := hiter.UserName
        else hitername := '?';
        if realdam > 0 then
        UserEngine.CryCry (RM_CRY, PEnvir, CX, CY, 10000, UserName + ' ¹¥»÷ÉËº¦ ' + hitername + ' : ' + IntToStr(realdam));
        {$ENDIF}

      except
         MainOutMessage('EXCEPTION CLON HP CACULATE');
      end;

   end;
      UseBlizzard := False;

end;

//damage : if (+) damage health
//         if (-) healing health
function TCreature.DamageHealth (damage, minimum: integer): integer;
var
   spdam: integer;
begin
   Result := 0;
   if BoMagicShield and (damage > 0) and (WAbil.MP > 0) then begin
      spdam := Round (damage * 1.5);
      if integer(WAbil.MP) >= spdam then begin
         WAbil.MP := WAbil.MP - spdam;
         spdam := 0;
      end else begin
         spdam := spdam - WAbil.MP;
         WAbil.MP := 0;
      end;
      damage := Round (spdam / 1.5);
      HealthSpellChanged;
   end;
   if damage > 0 then begin
      if integer(WAbil.HP) - damage > 0 then begin
         Result := damage;
         WAbil.HP := WAbil.HP - damage;
      end else begin
         Result := WAbil.HP - minimum;
         WAbil.HP := _MAX(minimum, 0);  // 2004/07/14 sonmg
      end;

       if BoAbilCelestial then begin
//        if CelestialOdds >= (Random(g_YinYangDharmaring - (CelestialLevel div 10))) then begin
           if CelestialOdds >= (Random(g_YinYangDharmaring - (CelestialLevel ))) then begin
          //  WAbil.HP:=WAbil.HP + (damage + ((CelestialLevel div 10) * CelestialDamage));
             WAbil.HP:=WAbil.HP + (damage  div g_YinYangDharmaring1) + 4 * CelestialLevel;
         // WAbil.HP:=WAbil.HP + 150;
         end;
      end;

   end else begin
      if integer(WAbil.HP) - damage < WAbil.MaxHP then begin
         Result := damage;
         WAbil.HP := WAbil.HP - damage;
      end else begin
         Result := WAbil.HP - WAbil.MaxHP;
         WAbil.HP := WAbil.MaxHP;
      end;
   end;
end;

//val : (+) dec spell
//      (-) inc spell
procedure TCreature.DamageSpell (val: integer);
begin
   if val > 0 then begin
      if WAbil.MP - val > 0 then WAbil.MP := WAbil.MP - val
      else WAbil.MP := 0;
   end else begin
      if WAbil.MP - val < WAbil.MaxMP then WAbil.MP := WAbil.MP - val
      else WAbil.MP := WAbil.MaxMP;
   end;
end;

//³» ±âÁØÀ¸·Î ÀâÀº ¸÷ÀÇ °æÇèÄ¡¸¦ °è»ê
function  TCreature.CalcGetExp (targlevel, targhp: integer): integer;
//begin //¹Ö»ñÈ¡×ÔÉí¾­Ñé£¿
//   if Abil.Level < (targlevel+10) then Result := targhp
//   else Result := targhp - Round ((targhp / 15) * (Abil.Level - (targlevel+10)));
//
//
//   if Result <= 0 then Result := 1;
//end;

begin //¹Ö»ñÈ¡×ÔÉí¾­Ñé£¿
   if g_boHighLevelKillMonFixExp or (Abil.Level < (targlevel+10)) then
   begin
    Result := targhp
  end else
  begin
  Result := targhp - Round ((targhp / 15) * (Abil.Level - (targlevel+10)));
   end;

   if Result <= 0 then Result := 1;
   //2022/10/6  ¼ÓÈë»ñµÃ¾­Ñé´¥·¢
         if QFunctionNpc <> nil then
         QFunctionNpc.NpcSayTitle(TUserHuman(Self), '@KillMon');

end;
{
<±×·ì¿ø ¼ö¿¡ µû¸¥ °æÇèÄ¡ Áõ°¡Ä¡>
¸í¼ö   : 2    3    4    5    6    7    8    9  10   11
Áõ°¡Ä¡ : 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2, 2.1, 2.2

<¼ö½Ä>
°æÇèÄ¡ X ±×·ì¿ø¼ö¿¡µû¸¥ °æÇèÄ¡Áõ°¡ºÐ X ÀÚ½ÅÀÇ ·¹º§ / ±×·ì¿ø ÀüÃ¼·¹º§ÀÇ ÇÕ

<¼³¸í>
±×·ì¿ø ÀüÃ¼ÀÇ ·¹º§ÀÇ ÇÕ Áß ÀÚ½ÅÀÌ Â÷ÁöÇÏ´Â ·¹º§¸¸Å­ Áõ°¡µÈ °æÇèÄ¡¸¦ ³ª´²°¡Áü
}
procedure TCreature.GainExp (exp: longword);
var
   i, n, sumlv: integer;
   dexp, iexp: longword;
   cret: TCreature;
const
   bonus: array[0..GROUPMAX] of Real = (1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2, 2.1, 2.2);
begin
   try
      if GroupOwner <> nil then begin
         //ÆÄÆ¼ÀåÀÌ »ýÀÏÀÎ °æ¿ì 10% °æÇèÄ¡ Áõ°¡
         if GroupOwner.PremiumBirthDay then begin
            exp := exp + (exp div 10);
         end;
         sumlv := 0;
         n := 0;
         for i:=0 to GroupOwner.GroupMembers.Count-1 do begin
            cret := TCreature(GroupOwner.GroupMembers.Objects[i]);
            if not cret.Death and (PEnvir = cret.PEnvir) and (abs(CX-cret.CX) <= 12) and (abs(CY-cret.CY) <= 12) then begin
               sumlv := sumlv + cret.Abil.Level;//¼ÆËã³ö×é¶ÓÈËÊý×ÜµÈ¼¶
               Inc (n);//±¶Êý
            end;
         end;
         if (sumlv > 0) and (n > 1) then begin
            dexp := 0;
            if n in [0..GROUPMAX] then
               dexp := Round (exp * bonus[n]);//È¡³ö¾­Ñé*±¶Êý
            for i:=0 to GroupOwner.GroupMembers.Count-1 do begin
               cret := TCreature(GroupOwner.GroupMembers.Objects[i]);
               if not cret.Death and (PEnvir = cret.PEnvir) and (abs(CX-cret.CX) <= 12) and (abs(CY-cret.CY) <= 12) then begin
                  iexp := Round (dexp / sumlv * cret.Abil.Level);//±¶Êý¾­Ñé/×ÜµÈ¼¶*µ±Ç°ÈËÎïµÈ¼¶
                  if iexp > exp then iexp := exp;
                  if boExpDouble then
                    cret.WinExp (iexp * g_nExpDouble)
                    else cret.WinExp (iexp);
               end;
            end;
         end else
            if boExpDouble then
            WinExp (exp * g_nExpDouble)
            else WinExp (exp);
      end else
         if boExpDouble then
         WinExp (exp * g_nExpDouble)
         else WinExp (exp);
   except
      MainOutMessage ('[Exception] TCreature.GainExp');
   end;
end;

//¸ó½ºÅÍµµ ºÎÇÏÀÎ °æ¿ì °æÇèÄ¡¸¦ ¸ÔÀ½
procedure  TCreature.GainSlaveExp (exp: integer);
   function NextExp: integer;
   const
      slaveupexp: array[0..6] of integer = (0, 0, 50, 100, 200, 300, 600);
   var
      more: integer;
   begin
      if SlaveExpLevel in [0..6] then more := slaveupexp[SlaveExpLevel]
      else more := 0;
      Result := 100 + (Abil.Level * 15) + more;
                 //+ more
                 //+ (Abil.MaxHP div 100) * 30;  //Ã¼·Â¿¡ µû¶ó
   end;
begin

   // ¿ù·É ¶Ç´Â ºÐ½ÅÀÏ °æ¿ì¿¡´Â °æÇèÄ¡¸¦ ¸ÔÁö ¾Ê´Â´Ù.
   if ( RaceServer = RC_CLONE) or
      ( RaceServer = RC_ANGEL) then Exit;

   SlaveExp := SlaveExp + exp;
   if SlaveExp > NextExp then begin
      SlaveExp := SlaveExp - NextExp;
      if SlaveExpLevel < (SlaveMakeLevel * 2 + 1) then begin
         Inc (SlaveExpLevel);
         RecalcAbilitys; //ApplySlaveLevelAbilitys;
         ChangeNameColor;
      end;
   end;
end;

//[ÁÖÀÇ] ¸®¼Â »óÅÂ¿¡¼­ Æ÷ÀÎÆ®¸¦ ¿Ã¸°´Ù.
procedure  TCreature.ApplySlaveLevelAbilitys;
var
   i, chp: integer;
//begin
//
//   if (RaceServer = RC_ANGEL) or (RaceServer = RC_CLONE) then Exit;
//
//   chp := 0;
//   if (RaceServer = RC_WHITESKELETON) or //¹é°ñ
//      (RaceServer = RC_ELFMON) or
//      (RaceServer = RC_ELFWARRIORMON)
//   then begin
//
//      WAbil.DC := MakeWord(Lobyte(WAbil.DC), Hibyte(Abil.DC));
//
//      WAbil.DC := MakeWord(Lobyte(WAbil.DC), Round(Hibyte(WAbil.DC) + (3 * (0.3 + SlaveExpLevel * 0.1) * SlaveExpLevel)));
//      chp := chp + Round(Abil.MaxHP * (0.3 + SlaveExpLevel * 0.1)) * SlaveExpLevel;
//
//      chp := Abil.MaxHP + chp;
//      if SlaveExpLevel > 0 then begin
//         WAbil.MaxHP := chp; //_MIN(Round(Abil.MaxHP + 60 * SlaveExpLevel), chp);
//                              //Round(Abil.MaxHP * SlaveExpLevel * 1.2))
//      end else
//         WAbil.MaxHP := Abil.MaxHP;
//      //2003/03/15 ½Å±Ô¹«°ø Ãß°¡
//      WAbil.DC := MakeWord(
//                     Lobyte(WAbil.DC),
//                     _MIN( 255, Hibyte(WAbil.DC) + ExtraAbil[EABIL_DCUP] )
//                  );
//
//   end else if UserName = '»¢ÎÀ' then begin           //Éý¼¶ÓÐ¹Ø
//      if Master <> nil then begin// ¼ú»ç°¡ ²¿½Å°Å´Â Master °¡ nil ÀÌ ¾Æ´Ô
//
//         chp := Abil.MaxHP;
//
//         WAbil.DC := MakeWord(Lobyte(WAbil.DC), Hibyte(Abil.DC));
//
//         WAbil.DC := MakeWord(Lobyte(WAbil.DC), Round(Hibyte(WAbil.DC) + (2 * SlaveExpLevel)));
//         chp := chp + Round(Abil.MaxHP * 0.15) * SlaveExpLevel;
//
//         WAbil.MaxHP := _MIN(Round(Abil.MaxHP + 240 * SlaveExpLevel), 3000);
//         WAbil.MAC := 0;  //Å×ÀÌ¹Ö¸÷Àº ¸¶¹ý¿¡ ¾àÇÔ
//      end;
//   end else if UserName = 'Ó¥ÎÀ' then begin
//      if Master <> nil then begin// ¼ú»ç°¡ ²¿½Å°Å´Â Master °¡ nil ÀÌ ¾Æ´Ô
//
//         chp := Abil.MaxHP;
//
//         WAbil.DC := MakeWord(Lobyte(WAbil.DC), Hibyte(Abil.DC));
//
//         WAbil.DC := MakeWord(Lobyte(WAbil.DC), Round(Hibyte(WAbil.DC) + (8 * SlaveExpLevel)));
//         chp := chp + Round(Abil.MaxHP * 0.15) * SlaveExpLevel;
//
//         WAbil.MaxHP := _MIN(Round(Abil.MaxHP + 60 * SlaveExpLevel), chp);
//         WAbil.MAC := 0;  //Å×ÀÌ¹Ö¸÷Àº ¸¶¹ý¿¡ ¾àÇÔ
//      end;
//   end else begin   //¼ú»ç°¡ ²¿½Å¸÷
//      if Master <> nil then begin// ¼ú»ç°¡ ²¿½Å°Å´Â Master °¡ nil ÀÌ ¾Æ´Ô
//
//         chp := Abil.MaxHP;
//
//         WAbil.DC := MakeWord(Lobyte(WAbil.DC), Hibyte(Abil.DC));
//
//         WAbil.DC := MakeWord(Lobyte(WAbil.DC), Round(Hibyte(WAbil.DC) + (2 * SlaveExpLevel)));
//         chp := chp + Round(Abil.MaxHP * 0.15) * SlaveExpLevel;
//
//         WAbil.MaxHP := _MIN(Round(Abil.MaxHP + 60 * SlaveExpLevel), chp);
//         WAbil.MAC := 0;  //Å×ÀÌ¹Ö¸÷Àº ¸¶¹ý¿¡ ¾àÇÔ
//                                //Round(Abil.MaxHP * SlaveExpLevel * 1.2))
//      end;
//
//   end;
//
//   AccuracyPoint := 15; //Á¤È®µµ,.. (Å×ÀÌ¹Ö¸÷,¼ÒÈ¯¸÷Àº Á¤È®ÀÌ 15·Î °íÁ¤)
begin

   if (RaceServer = RC_ANGEL) or (RaceServer = RC_CLONE) then Exit;

   chp := 0;
   if (RaceServer = RC_WHITESKELETON) or //°×¹Ç
      (RaceServer = RC_ELFMON) or
      (RaceServer = RC_ELFWARRIORMON)
   then begin
      if (g_Taoistbabycontrol)and (Master <> nil) then begin
         WAbil.DC := MakeWord(Lobyte(WAbil.DC), Hibyte(Abil.DC));
          WAbil.DC := MakeWord(Lobyte(WAbil.DC), Round(Hibyte(WAbil.DC) + (3 * (0.3 + SlaveExpLevel * 0.1) * SlaveExpLevel) + (Hibyte(Master.WAbil.SC) div g_Taoistbabyattackpower)));
          chp := chp + Round(Abil.MaxHP * (0.3 + SlaveExpLevel * 0.1)) * SlaveExpLevel;

      chp := Abil.MaxHP + chp;
      end else
      if not g_Taoistbabycontrol and (Master <> nil) then begin
      WAbil.DC := MakeWord(Lobyte(WAbil.DC), Hibyte(Abil.DC));

      WAbil.DC := MakeWord(Lobyte(WAbil.DC), Round(Hibyte(WAbil.DC) + (3 * (0.3 + SlaveExpLevel * 0.1) * SlaveExpLevel)));
      chp := chp + Round(Abil.MaxHP * (0.3 + SlaveExpLevel * 0.1)) * SlaveExpLevel;

      chp := Abil.MaxHP + chp;
      end;
      if SlaveExpLevel > 0 then begin
         WAbil.MaxHP := chp; //_MIN(Round(Abil.MaxHP + 60 * SlaveExpLevel), chp);
                              //Round(Abil.MaxHP * SlaveExpLevel * 1.2))
      end else
         WAbil.MaxHP := Abil.MaxHP;
      //2003/03/15 ÐÂÔöÎä¹¦
      WAbil.DC := MakeWord(
                     Lobyte(WAbil.DC),
                     _MIN( 255, Hibyte(WAbil.DC) + ExtraAbil[EABIL_DCUP] )
                  );

   end else if UserName = '»¢ÎÀ' then begin           //Éý¼¶ÓÐ¹Ø
      if Master <> nil then begin// ·¨Ê¦ÓÕ»óµÄ¡£ Master ¼ÓÉÏ nil ²»ÊÇ

         chp := Abil.MaxHP;

         WAbil.DC := MakeWord(Lobyte(WAbil.DC), Hibyte(Abil.DC));

         WAbil.DC := MakeWord(Lobyte(WAbil.DC), Round(Hibyte(WAbil.DC) + (2 * SlaveExpLevel)));
         chp := chp + Round(Abil.MaxHP * 0.15) * SlaveExpLevel;

         WAbil.MaxHP := _MIN(Round(Abil.MaxHP + 240 * SlaveExpLevel), 3000);
         WAbil.MAC := 0;  //Ñ±·þ¹ÖÎï¶ÔÄ§·¨ºÜÈõ¡£
      end;
   end else if UserName = 'Ó¥ÎÀ' then begin
      if Master <> nil then begin// ·¨Ê¦ÓÕ»óµÄ¡£ Master ¼ÓÉÏ nil ²»ÊÇ

         chp := Abil.MaxHP;

         WAbil.DC := MakeWord(Lobyte(WAbil.DC), Hibyte(Abil.DC));

         WAbil.DC := MakeWord(Lobyte(WAbil.DC), Round(Hibyte(WAbil.DC) + (8 * SlaveExpLevel)));
         chp := chp + Round(Abil.MaxHP * 0.15) * SlaveExpLevel;

         WAbil.MaxHP := _MIN(Round(Abil.MaxHP + 60 * SlaveExpLevel), chp);
         WAbil.MAC := 0;  //Ñ±·þ¹ÖÎï¶ÔÄ§·¨ºÜÈõ
      end;
   end else if (g_Magebabycontrol)and (Master <> nil) then begin
      if Master <> nil then begin// ·¨Ê¦ÓÕ»óµÄ¡£ Master ¼ÓÉÏ nil ²»ÊÇ

         chp := Abil.MaxHP;

         WAbil.DC := MakeWord(Lobyte(WAbil.DC), Hibyte(Abil.DC));

         WAbil.DC := MakeWord(Lobyte(WAbil.DC), Round(Hibyte(WAbil.DC) + (g_MagebabyFoundation * SlaveExpLevel) + (Hibyte(Master.WAbil.MC) div g_Magebabyattack)));
         chp := chp + Round(Abil.MaxHP * 0.15) * SlaveExpLevel;

         WAbil.MaxHP := _MIN(Round(Abil.MaxHP + 60 * SlaveExpLevel), chp);
         WAbil.MAC := 0;  //Ñ±·þ¹ÖÎï¶ÔÄ§·¨ºÜÈõ
                                //Round(Abil.MaxHP * SlaveExpLevel * 1.2))
      end;
   end else begin   //¼ú»ç°¡ ²¿½Å¸÷
      if (Master <> nil) and not g_Magebabycontrol then begin// ·¨Ê¦ÓÕ»óµÄ¡£ Master ¼ÓÉÏ nil ²»ÊÇ

         chp := Abil.MaxHP;

         WAbil.DC := MakeWord(Lobyte(WAbil.DC), Hibyte(Abil.DC));

         WAbil.DC := MakeWord(Lobyte(WAbil.DC), Round(Hibyte(WAbil.DC) + (g_MagebabyFoundation * SlaveExpLevel)));
         chp := chp + Round(Abil.MaxHP * 0.15) * SlaveExpLevel;

         WAbil.MaxHP := _MIN(Round(Abil.MaxHP + 60 * SlaveExpLevel), chp);
         WAbil.MAC := 0;  //Ñ±·þ¹ÖÎï¶ÔÄ§·¨ºÜÈõ
                                //Round(Abil.MaxHP * SlaveExpLevel * 1.2))
      end;



   end;

   AccuracyPoint := 15; //×¼È·¶È£¬..£¨Ñ±·þÐ¡¹ÖºÍÕÙ»½Ð¡¹ÖµÄ×¼È·¶ÈÎª 15£©

end;

//°æÇèÄ¡¸¦ ¾òÀ½, ·¹º§¾÷ Ã¼Å©
procedure TCreature.WinExp (exp: longword);
const
   MAXITEMEXPPOINT = 200000;
var
   ExpRate : Single;
   exptotal, addeditemexp : longword;
   FameGrade: integer;
   i: integer;
   pstd: PTStdItem;
   eventdate: TDateTime;
   ayear, amon, aday: Word;
begin
   addeditemexp := 0;

   // °æÇèÄ¡ ¿À·ù ¹®Á¦
   if exp >= High(LongWord) then exp := High(LongWord);//Õâ¾äÓ¦¸Ã¶àÓà
   exptotal := exp;

   // °æÇèÄ¡ Àû¿ë(Å×¼·Àº °æÇèÄ¡ 3¹è)
   {if boTestServer then ExpRate := 300
   else }ExpRate := 100;

   // ¼ø°£ °æÇèÄ¡ µÎ ¹è Àû¿ë(2005/12/14)
   if InstantExpDoubleTime > 1 then
   begin
     if (nInstantExpDouble > 100) and (InstantExpDoubleTime > GetTickCount) then begin
        ExpRate := nInstantExpDouble / 100;
     end
     else
      ExpRate := 100 / 100;
   end else
   begin
      if (nInstantExpDouble > 100) then
        ExpRate := nInstantExpDouble / 100
        else ExpRate := 100 / 100;
   end;

      if ( MyGuild <> nil ) and (g_NoviceguildEXP) then begin
     if CompareText (TGuild(MyGuild).GuildName, 'ÐÂÊÖÐÐ»á') = 0 then ExpRate := ExpRate + (g_NoviceguildEXPSZ / 100 - 1);
   end;

   //ÈËÎï×·¸Ï¾­Ñé¾ùºâ·­±¶
   if g_Allowablelevel then   begin

    if Abil.Level >= g_ExtraLowLevel1 then begin ExpRate :=  ExpRate;
    end
     else
     ExpRate :=  ExpRate + (((g_ExtraLowLevel1 + g_ExtraHighquantity - Abil.Level )div 3) / 10);
    end;

   exptotal := Round(exp * ExpRate);
   Abil.Exp := Abil.Exp + exptotal;
{
   // ÀÌº¥Æ® 2006³â 2¿ù ÇÑ ´Þ µ¿¾È¸¸ Àû¿ë
   // Åä¿äÀÏÀº °æÇèÄ¡ 1.3¹è º»¼·¸¸ (sonmg 2006/01/24)
   eventdate := Date;
   DecodeDate (eventdate, ayear, amon, aday);
//   SysMsg('¿À´Ã : ' + IntToStr(ayear) + '³â ' + IntToStr(amon) + '¿ù', 0);
   if (ayear = 2006) and (amon = 2) then begin
      if DayOfWeek(eventdate) = 7(*SAT*) then begin
//         SysMsg('¿À´ÃÀº Åä¿äÀÏÀÔ´Ï´Ù.', 0);
         if not BoTestServer then begin
            ExpRate := 130;
//            SysMsg('º»¼·! °æÇèÄ¡ 1.3¹è Àû¿ë!!!', 0);
         end;
      end;
   end;
}

//   case ExpRate of //ExpRate   Ó¦¸ÃÊÇ±¶Êý±êÊ¶
//   100 : begin
//           Abil.Exp := Abil.Exp + exp;
//           exptotal := exp;
//         end;
//   120 : begin
//           Abil.Exp := Abil.Exp + exp + (exp div 5);
//           exptotal := exp + (exp div 5);
//         end;
//   130 : begin
//           Abil.Exp := Abil.Exp + exp + (exp div 3);
//           exptotal := exp + (exp div 3);
//         end;
//   150 : begin
//           Abil.Exp := Abil.Exp + exp + (exp div 2);
//           exptotal := exp + (exp div 2);
//         end;
//   200 : begin
//           Abil.Exp := Abil.Exp + exp + exp;
//           exptotal := exp + exp;
//         end;
//   else
//      begin
//         Abil.Exp := Abil.Exp + exp * LongWord(ExpRate div 100);
//         exptotal := exp * LongWord(ExpRate div 100);
//      end;
//   end;

   //°æÇèÄ¡ ÇÑ°è(65000) sonmg 2005/12/09
   exptotal := _MIN(High(integer), exptotal);//Òç³ö´¦Àí

//{
   //----------------------------------------------
   // ¾ÆÀÌÅÛ °æÇèÄ¡ Àû¿ë ==> ÀÚ½ÅÀÌ ¸Ô´Â °æÇèÄ¡ ¾ÆÀÌÅÛ ÀÖÀ» ¶§¸¸ ±ðÀÌµµ·Ï ¼öÁ¤¿ä¸Á
   addeditemexp := exptotal - (exptotal div 2); //¾ÆÀÌÅÛ¿¡ ´©ÀûµÉ °æÇèÄ¡
   pstd := nil;
   for i:=0 to U_TRANS do begin    // 8->12
      if UseItems[i].Index > 0 then begin
         pstd := UserEngine.GetStdItem (UseItems[i].Index);
         if pstd <> nil then begin
            if (i = U_NECKLACE) then begin
               if pstd.Shape = PAIN_SERIES_SHAPE then begin
                  ItemExpPoint := ItemExpPoint + LongInt(addeditemexp);
SysMsg(pstd.Name + ' ÏîÄ¿¾­ÑéÖµÔö¼Ó : ' + IntToStr(addeditemexp) + ', ÀÛ»ý : ' + IntToStr(ItemExpPoint), 0);
                  exptotal := exptotal div 2;   //ÀÚ½ÅÀÌ ¸Ô´Â °æÇèÄ¡´Â ¹ÝÀ¸·Î ±ðÀÓ
                  if ItemExpPoint >= MAXITEMEXPPOINT then begin
                     UseItems[i].Desc[10] := _MIN(250, UseItems[i].Desc[10] + 1);
                     ItemExpPoint := _MAX(0, ItemExpPoint - MAXITEMEXPPOINT);
                     if RaceServer = RC_USERHUMAN then begin
                        TUserHuman(self).SendUpdateItem (UseItems[i]);
                     end;
                  end;
                  break;   //ÇÏ³ªÀÇ ¾ÆÀÌÅÛ¿¡¸¸ Àû¿ë
               end;
            end;
            if (i = U_ARMRINGL) or (i = U_ARMRINGR) then begin
               if pstd.Shape = PAIN_SERIES_SHAPE then begin
                  ItemExpPoint := ItemExpPoint + LongInt(addeditemexp);
SysMsg(pstd.Name + ' ÏîÄ¿¾­ÑéÖµÔö¼Ó: ' + IntToStr(addeditemexp) + ', ÀÛ»ý : ' + IntToStr(ItemExpPoint), 0);
                  exptotal := exptotal div 2;   //ÀÚ½ÅÀÌ ¸Ô´Â °æÇèÄ¡´Â ¹ÝÀ¸·Î ±ðÀÓ
                  if ItemExpPoint >= MAXITEMEXPPOINT then begin
                     UseItems[i].Desc[10] := _MIN(250, UseItems[i].Desc[10] + 1);
                     ItemExpPoint := _MAX(0, ItemExpPoint - MAXITEMEXPPOINT);
                     if RaceServer = RC_USERHUMAN then begin
                        TUserHuman(self).SendUpdateItem (UseItems[i]);
                     end;
                  end;
                  break;   //ÇÏ³ªÀÇ ¾ÆÀÌÅÛ¿¡¸¸ Àû¿ë
               end;
            end;
            if (i = U_RINGL) or (i = U_RINGR) then begin
               if pstd.Shape = PAIN_SERIES_SHAPE then begin
                  ItemExpPoint := ItemExpPoint + LongInt(addeditemexp);
SysMsg(pstd.Name + ' ÏîÄ¿¾­ÑéÖµÔö¼Ó : ' + IntToStr(addeditemexp) + ', ÀÛ»ý : ' + IntToStr(ItemExpPoint), 0);
                  exptotal := exptotal div 2;   //ÀÚ½ÅÀÌ ¸Ô´Â °æÇèÄ¡´Â ¹ÝÀ¸·Î ±ðÀÓ
                  if ItemExpPoint >= MAXITEMEXPPOINT then begin
                     UseItems[i].Desc[10] := _MIN(250, UseItems[i].Desc[10] + 1);
                     ItemExpPoint := _MAX(0, ItemExpPoint - MAXITEMEXPPOINT);
                     if RaceServer = RC_USERHUMAN then begin
                        TUserHuman(self).SendUpdateItem (UseItems[i]);
                     end;
                  end;
                  break;   //ÇÏ³ªÀÇ ¾ÆÀÌÅÛ¿¡¸¸ Àû¿ë
               end;
            end;
            if (i = U_CHARM) then begin
               if pstd.Shape = PAIN_SERIES_SHAPE then begin
                  ItemExpPoint := ItemExpPoint + LongInt(addeditemexp);
SysMsg(pstd.Name + ' ÏîÄ¿¾­ÑéÖµÔö¼Ó : ' + IntToStr(addeditemexp) + ', ÀÛ»ý : ' + IntToStr(ItemExpPoint), 0);
                  exptotal := exptotal div 2;   //ÀÚ½ÅÀÌ ¸Ô´Â °æÇèÄ¡´Â ¹ÝÀ¸·Î ±ðÀÓ
                  if ItemExpPoint >= MAXITEMEXPPOINT then begin
                     UseItems[i].Desc[10] := _MIN(250, UseItems[i].Desc[10] + 1);
                     ItemExpPoint := _MAX(0, ItemExpPoint - MAXITEMEXPPOINT);
                     if RaceServer = RC_USERHUMAN then begin
                        TUserHuman(self).SendUpdateItem (UseItems[i]);
                     end;
                  end;
                  break;   //ÇÏ³ªÀÇ ¾ÆÀÌÅÛ¿¡¸¸ Àû¿ë
               end;
            end;
         end;
      end;
   end;
   //----------------------------------------------
//}

   //Å¬¶óÀÌ¾ðÆ®¿¡ È¹µæÇÑ °æÇèÄ¡ Àü¼Û
   SendMsg (self, RM_WINEXP, 0, exptotal , 0, 0, '');//·¢ËÍ»ñÈ¡¾­ÑéÏûÏ¢

   //----------------------------------------
   //¸í¼ºÄ¡ È¹µæ(°æÇèÄ¡ÀÇ 1%) : °æÇèÄ¡ÀÇ °æ¿ì 18µî±ÞÀ¸·Î Á¦ÇÑ
   if ENABLE_FAME_SYSTEM then begin
      if RaceServer = RC_USERHUMAN then begin
         TUserHuman(self).GetFameName(FameGrade);
         if FameGrade < 18 then
            IncFamePoint( Trunc(exptotal * 0.01) )
         else
            IncFamePoint( Trunc(exptotal * 0.01), TRUE );
      end;
   end;
   //----------------------------------------

   //°æÇèÄ¡ ¸ÔÀ» ¶§¸¶´Ù Çà¿îÄ¡ ¿À¸§
   AddBodyLuck (exp * 0.002);

   if Abil.Exp >= Abil.MaxExp then begin//¾­ÑéÂúÉý¼¶´¦Àí
      Abil.Exp := Abil.Exp - Abil.MaxExp;
      Inc (Abil.Level);
      HasLevelUp (Abil.Level-1);
      AddBodyLuck (100);  //·¾¾÷¶§¸¶´Ù Çà¿î °ªÀÌ ¿À¸¥´Ù.
      AddUserLog ('12'#9 + //·¾¾÷_ +
                  MapName + ''#9 +
                  IntToStr(Abil.Level) + ''#9 +
                  IntToStr(Abil.Exp) + ''#9 +
                  UserName + ''#9 +
                  '0'#9 +
                  '0'#9 +
                  '1'#9 +
                  '0');
      //·¾¾÷ÇÏ¸é Ã¼·ÂÀÌ ¸¸¶¥Âü,  9/25ÀÏºÎÅÍ Àû¿ë
      IncHealthSpell (2000, 2000);
   end;
end;

procedure TCreature.AddCreditPoint();
Const
  //mCt : array[0..3] of Integer = (1, 2,3, 4);
  //sCt : array[0..3] of Integer = (1, 1, 1, 2);
  mCt : array[0..9] of Integer = (1, 1, 1, 2, 2, 2, 3, 3, 3, 4);
  sCt : array[0..9] of Integer = (0, 0, 0, 1, 1, 1, 1, 2, 2, 2);
var
  hum, hum2, hum3: TUserHuman;
  Info: TRelationShipInfo;
  i: Integer;
  nno : Integer;
begin
  hum := TUserHuman(Self);
  if hum = nil then exit;
  if hum.Abil.Level < (shitucanshu) then exit;  //19 ÕâÀï²»ÄÜµÍÓÚ°ÝÊ¦µÈ¼¶£¬Èç¹û°ÝÊ¦18¼¶ÒÔÏÂÄÇÃ´£¬ÕâÀï±ØÐë´óÓÚ18 £¬·ñÔòÍ½µÜÉý¼¶18¼¶Ê¦¸µÉùÍû¾Í´í¡£
  if hum.fMaster.MasterName = '' then exit;
  g_DBSQL.AddCreditPoint(hum.fMaster.MasterName,mCt[hum.Abil.Level - (shitucanshu)]); //19
  g_DBSQL.AddCreditPoint(UserName,sCt[hum.Abil.Level - (shitucanshu)]);  //19

  if hum.Abil.Level in [(chushi1)..(chushi2)] then begin   //Í½µÜÉý¼¶½±Àø  19 - 27
    hum.SysMsg(Format('¹§Ï²£ºÄãÉýµ½%d¼¶£¡½±ÀøÉùÍû£º%dµã£¡', [hum.Abil.Level,sCt[hum.Abil.Level - (shitucanshu)]]), 2);   //19
    Inc(hum.m_btCreditPoint, sCt[hum.Abil.Level - (shitucanshu)]); //19
    hum2 := UserEngine.GetUserHuman(hum.fMaster.MasterName);
    hum.SendCreditPoint;
    if hum2 <> nil then begin
      hum2.SysMsg(Format('¹§Ï²£ºÄãµÄÍ½µÜ %s Éýµ½%d¼¶£¡½±ÀøÉùÍû£º%dµã£¡', [ UserName, hum.Abil.Level, mCt[hum.Abil.Level - (shitucanshu)]]), 2); //19
      Inc(hum2.m_btCreditPoint, mCt[hum.Abil.Level - (shitucanshu)]);  //
      hum2.SendCreditPoint;
    end;
  end;
  nno := hum.fMaster.SonNumber;
  if hum.Abil.Level = (chushidengji) then begin    //Í½µÜ³öÊ¦   28

    hum.SysMsg(Format('¹§Ï²£ºÄã³É¹¦³öÊ¦£¡½±ÀøÉùÍû£º%dµã£¡', [sCt[hum.Abil.Level - (shitucanshu)]]), 2);   //19
    UserEngine.SysMsgAll('¹§Ï²£º'+ UserName +' ³É¹¦³öÊ¦£¬ËûÊÇ·ñÄÜÇà³öÓÚÀ¶¶øÊ¤ÓÚÀ¶£¿ ');
    Inc(hum.m_btCreditPoint, sCt[hum.Abil.Level - (shitucanshu)]);   //19
    hum2 := UserEngine.GetUserHuman(hum.fMaster.MasterName);
    hum.SendCreditPoint;
    if hum2 <> nil then begin
      hum2.fMaster.DelChild(UserName, nno);
      hum2.SysMsg(Format('¹§Ï²£ºÄãµÄÍ½µÜ %s ³É¹¦³öÊ¦£¡½±ÀøÉùÍû£º%dµã£¡', [ UserName, mCt[hum.Abil.Level - (shitucanshu)]]), 2);   //19
      Inc(hum2.m_btCreditPoint, mCt[hum.Abil.Level - (shitucanshu)]);  //19
      g_DBSQL.ObMaster(hum.fMaster.MasterName,UserName,'30');
      g_DBSQL.LoadMaaListEx2(hum.fMaster.MasterName,UserName);
      hum2.SendCreditPoint;
      if hum2.fmaster.Items.Count > 0 then
      begin
        for i := nno - 1 to hum2.fmaster.Items.Count - 1 do
        begin
          Info := hum2.fmaster.Items.Items[i];
          if Info <> nil then
          begin
            hum3 := UserEngine.GetUserHuman(Info.Name);
            if hum3 <> nil then
            begin
              hum3.fMaster.SonNumber := hum3.fMaster.SonNumber - 1;
              g_DBSQL.ObMaster2(hum2.UserName,hum3.UserName,IntToStr(hum3.fMaster.SonNumber));
              hum3.UserNameChanged;
            end
            else
            begin
              g_DBSQL.ObMaster2(hum2.UserName,Info.Name,IntToStr(Info.SonNumber));
            end;
          end;
        end;
      end;
    end else begin
      g_DBSQL.ObMaster(hum.fMaster.MasterName,UserName,'20');
      if hum.fmaster.Items.Count > 0 then
      begin
        for i := 0 to hum.fmaster.Items.Count - 1 do
        begin
          Info := hum.fmaster.Items.Items[i];
          if Info <> nil then
          begin
            hum3 := UserEngine.GetUserHuman(Info.Name);
            if hum3 <> nil then
            begin
              if nno < hum3.fMaster.SonNumber then
              begin
                hum3.fMaster.SonNumber := hum3.fMaster.SonNumber - 1;
                g_DBSQL.ObMaster2(hum.fMaster.MasterName,hum3.UserName,IntToStr(hum3.fMaster.SonNumber));
                hum3.UserNameChanged;
              end;
            end
            else
            begin
              if nno < Info.SonNumber then
                g_DBSQL.ObMaster2(hum.fMaster.MasterName,Info.Name,IntToStr(Info.SonNumber - 1));
            end;
          end;
        end;
      end;
    end;
    hum.fMaster.MasterName := '';
    hum.UserNameChanged;
  end;
end;

procedure TCreature.HasLevelUp (prevlevel: integer);
var
  i, svidx, nMcp: Integer;
  MasterName: string;
  hum: TUserHuman;
  flag: Boolean;
begin
   nMcp := 0;    //³õÊ¼»¯Ê¦¸µ»ñÈ¡ÃûÍûµã
   flag := False;

   Abil.MaxExp := GetNextLevelExp (Abil.Level);  //´ÙÀ½ ·¹º§À» ¿Ã¸®´Âµ¥ ÇÊ¿äÇÑ °æÇèÄ¡
   //if prevlevel <> 0 then begin
   RecalcLevelAbilitys;  //·¹º§¿¡ µû¸¥ ´É·ÂÄ¡¸¦ °è»êÇÑ´Ù.
   //end else
      //RecalcLevelAbilitys_old;

{$IFDEF FOR_ABIL_POINT}
//4/16ÀÏ ºÎÅÍ Àû¿ë
   if prevlevel + 1 = Abil.Level then begin
      BonusPoint := BonusPoint + GetBonusPoint (Job, Abil.Level);  //·¾¾÷¿¡ µû¸¥ º¸³Ê½º
      SendMsg (self, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
   end else begin
      if prevlevel <> Abil.Level then begin
         //º¸³Ê½º Æ÷ÀÎÆ®¸¦ Ã³À½ºÎÅÍ ´Ù½Ã °è»êÇÑ´Ù.
         BonusPoint := GetLevelBonusSum (Job, Abil.Level);
         FillChar (BonusAbil, sizeof(TNakedAbility), #0);
         FillChar (CurBonusAbil, sizeof(TNakedAbility), #0);
         //if prevlevel <> 0 then begin
         RecalcLevelAbilitys;  //·¹º§¿¡ µû¸¥ ´É·ÂÄ¡¸¦ °è»êÇÑ´Ù.
         //end else begin
         //   RecalcLevelAbilitys_old;
         //   BonusPoint := 0;
         //end;
         SendMsg (self, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
      end;
   end;
{$ENDIF}

   RecalcAbilitys;
   SendRefMsg (RM_LOOPNORMALEFFECT, integer(self), 0, 0, NE_LEVELUP, '');
   SendMsg (self, RM_LEVELUP, 0, Abil.Exp, 0, 0, '');

   //Ã¼ÇèÆÇ »ç¿ëÀÚ´Â Ã¼ÇèÆÇ ·¹º§ÀÌ»ó ¿Ã¸± ¼ö ¾ø´Ù.(sonmg 2005/03/17)
   if RaceServer = RC_USERHUMAN then begin
      if boSecondCardSystem then
      begin
        if (Abil.Level > g_nExpErienceLevel) then begin
          if TUserHuman(self).iDay <= 0 then
          begin
           if (TUserHuman(self).SecondsCard <= 0) and (PEnvir.MapName <> g_sRechargingMap) then begin
             TUserHuman(self).SecondsCard := 0;
             SysMsg ('[ÕË»§ÐÅÏ¢]µ±Ç°ÕË»§³äÖµÊ±¼äÒÑµ½ÆÚ', 0);
             if RaceServer = RC_USERHUMAN   then begin
             if GrobalEnvir.GetEnvir (g_sRechargingMap) <> nil then begin
                SendRefMsg (RM_SPACEMOVE_HIDE, 0, 0, 0, 0, '');
                RandomSpaceMove (g_sRechargingMap, 0); //¹«ÀÛÀ§ °ø°£ÀÌµ¿
             end;
            end;
            end;
          end;
          end;
        end;
      end;
      AddCreditPoint();
      if QFunctionNpc <> nil then
         QFunctionNpc.NpcSayTitle(TUserHuman(Self), '@LevelUp');
   end;

function TCreature.GetNextLevelExp (lv: integer): longword;  //»ó¼ö·Î Á¤ÇÏ±â·Î ÇÔ
var
  i : integer;
begin
//   if lv in [1..MAXLEVEL] then Result := NEEDEXPS[lv]
//   else Result := $7FFFFFFF;  // ¼öÁ¤ (sonmg 2005/05/13)
  if lv in [1..MAXLEVEL] then begin
    for i:=0 to UserEngine.CharExpList.Count-1 do begin
      if PTCharExpInfo(UserEngine.CharExpList[i]).Level = lv then begin
        Result := PTCharExpInfo(UserEngine.CharExpList[i]).Exp;
        break;
      end;
    end;
  end else Result := $FFFFFFFF;
end;

procedure  TCreature.ChangeLevel (level: integer);
begin
   if level in [1..255] then //GMÃüÁîµ÷ÕûËûÈËµÈ¼¶ÏÞÖÆ
      Abil.Level := level;
end;

//²»ÄÜÕ½¶·µÄ°²È«µØ´ø
function  TCreature.InSafeZone: Boolean;
var
   map, scopestr: string;
   i, sx, sy, scope: integer;
begin
   Result := PEnvir.Lawfull;
   if not Result then begin
      Result := (PEnvir.MapName = BADMANHOMEMAP) and
                  ((abs(CX-BADMANSTARTX) <= 10) and (abs(CY-BADMANSTARTY) <= 10));   //°²È«Çø·¶Î§ÊýÖµ ÓÐ3¸öµØ·½²ÎÊýÍ¬²½µ÷Õû£¬Ä¬ÈÏ10
      if not Result then begin
         // ÆðµãÊÇ°²È«Çø
         for i:=0 to StartPoints.Count-1 do begin
            map := GetStartPointMapName(i);//StartPoints[i];
            //·¶Î§ÌáÈ¡
            scopestr := GetValidStr3(map, map, ['/']);
            scope := Str_ToInt(scopestr, 10); //Ä¬ÈÏ10
            sx := Loword(integer(StartPoints.Objects[i]));
            sy := Hiword(integer(StartPoints.Objects[i]));
            if (map = PEnvir.MapName) and ((abs(CX-sx) <= scope) and (abs(CY-sy) <= scope)) then begin
               Result := TRUE;
               break;
            end;
         end;

         // È«µãÒ²ÊÇ°²È«Çø
         if not Result then
         for i:=0 to SafePoints.Count-1 do begin
            map := SafePoints[i];
            //·¶Î§ÌáÈ¡
            scopestr := GetValidStr3(map, map, ['/']);
            scope := Str_ToInt(scopestr, 10);  //Ä¬ÈÏ10
            sx := Loword(integer(SafePoints.Objects[i]));
            sy := Hiword(integer(SafePoints.Objects[i]));
            if (map = PEnvir.MapName) and ((abs(CX-sx) <= scope) and (abs(CY-sy) <= scope)) then begin
               Result := TRUE;
               break;
            end;
         end;

      end;
   end;
end;
//ÃÅ½ûµØ´ø
function   TCreature.InGuildWarSafeZone: Boolean;
var
   map: string;
   i, sx, sy: integer;
begin
   Result := PEnvir.Lawfull;
   if not Result then begin
      if not Result then begin
         for i:=0 to StartPoints.Count-1 do begin
            map := GetStartPointMapName(i);//StartPoints[i];
            sx := Loword(integer(StartPoints.Objects[i]));
            sy := Hiword(integer(StartPoints.Objects[i]));
            if (map = PEnvir.MapName) and ((abs(CX-sx) <= 60) and (abs(CY-sy) <= 60)) then begin  //Àë¿ª°²È«Çø¾ÍÊÇÐÐ»áÕ½·¶Î§ Ä¬ÈÏ60
               Result := TRUE;
               break;
            end;
         end;
      end;
   end;
end;

function  TCreature.PKLevel: integer;       //PK ·¹º§ 1ÀÌ»óÀ¸¸é PK¹ü ÀÌ´Ù.
begin
   Result := PlayerKillingPoint div 100;
end;

procedure  TCreature.UserNameChanged;
var
   FameGrade: integer;
begin
   //¸í¼º È£Äª
   SendRefMsg (RM_USERNAME, 0, 0, 0, 0, GetUserName + '/' + TUserHuman(self).GetFameName(FameGrade));
end;

procedure TCreature.ChangeNameColor;
begin
   SendRefMsg (RM_CHANGENAMECOLOR, 0, 0, 0, 0, '');
end;

function  TCreature.MyColor: byte;
begin
   Result := DefNameColor;
   if PKLevel = 1 then Result := 251; //yellow
   if PKLevel >= 2 then Result := 249;  //red
end;

//self°¡ cretÀ» ºÃÀ»¶§ cretÀÇ »öÀ» ¸®ÅÏÇÑ´Ù(sonmg 2005/11/29)
function  TCreature.GetThisCharColor (cret: TCreature): byte;
const
   SlaveColors : array[0..7] of byte = (255, 254, 147, 154, 229, 168, 180, 252);
var
   relat          : integer;
   pkarea         : Boolean;
   CheckAllyGuild : Boolean;
begin
   Result := cret.MyColor;
   if cret.RaceServer = RC_USERHUMAN then begin //»ç¶÷
      if PKLevel < 2 then begin  //ÈòµÕÀÌ=0(¶Ç´Â ³ë·©ÀÌ=1) ÀÎ °æ¿ì

         if cret.BoIllegalAttack then
            Result := 47; //»ÒÉ«

         relat := GetGuildRelation (self, cret);
         case relat of
            1, 3: Result := 180; //À¶É«(ÎÒ·½)
            2: Result := 69;  //³ÈÉ«
         end;

         if cret.PEnvir.Fight3Zone then begin  //ÃÅÅÉÕ½ÕùµØÍ¼
            if MyGuild = cret.MyGuild then  //ÎÒ·½
               Result := 180 //À¶É«
            else  //´Ù¸¥ Æí
               Result := 69;  //³ÈÉ«
         end;
      end;

      //°ø¼ºÀü °ü·Ã »ö
      if UserCastle.BoCastleUnderAttack then begin  //°ø¼ºÀü ÁßÀÎ °æ¿ì
         if BoInFreePKArea and cret.BoInFreePKArea then begin  //ÇÁ¸®ÇÇÄÉÀÌÁ¸(ÀüÀïÅÍ)¿¡ ÀÖÀ½, °ø¼º Áö¿ª¿¡ ÀÖÀ½
            Result := 221;  //Àûµµ¾Æ´Ï°í ¿ì¸®Æíµµ ¾Æ´Ï¸é ³ì»öÀ¸·Î º¸ÀÎ´Ù.
            BoGuildWarArea := TRUE; //°ø¼ºÀü Áö¿ª

            CheckAllyGuild := false;
            if ( UserCastle.OwnerGuild <> nil ) and ( MyGuild <> nil ) then
               CheckAllyGuild := TGuild(UserCastle.OwnerGuild).IsAllyGuild(TGuild(MyGuild))
            else
               CheckAllyGuild := false;

            // 2003/06/12 ¼ö¼º ¹®ÆÄ »Ó¸¸ ¾Æ´Ï¶ó ¼ö¼º¹®ÆÄ ¿¬ÇÕ ¹®ÆÄÀÎ°æ¿ìµµ ÇØ´çµÇµµ·Ï ¼öÁ¤
//          if UserCastle.IsOurCastle (TGuild(MyGuild)) then begin
            if UserCastle.IsOurCastle (TGuild(MyGuild)) or CheckAllyGuild then begin
               //¼ºÀ» ÁöÅ°´Â ÀÔÀå
               if (MyGuild = cret.MyGuild) or TGuild(MyGuild).IsAllyGuild(TGuild(cret.MyGuild)) then  //¿ì¸®¹®ÆÄ,µ¿¸Í¹®ÆÄ
                  Result := 180 //Çª¸¥°è¿­ (¿ì¸®Æí)
               else if UserCastle.IsRushAllyCastleGuild (TGuild(cret.MyGuild)) then
                  Result := 69;   //°ø°ÝÇÏ°í ÀÖ´Â ¹®ÆÄ, Àû
            end else begin
               //¼ºÀ» °ø°ÝÇÏ´Â ÀÔÀå(°ø¼º ¶Ç´Â °ø¼ºµ¿¸Í)
               if UserCastle.IsRushAllyCastleGuild (TGuild(MyGuild)) then begin
                  //¿ì¸® ¹®ÆÄ°¡ °ø°ÝÇÏ°í ÀÖÀ½
                  if (MyGuild = cret.MyGuild) or TGuild(MyGuild).IsAllyGuild(TGuild(cret.MyGuild)) then begin
                     //¿ì¸® ¹®ÆÄ¿ø ÀÓ, µ¿¸Í ¹®ÆÄ¿ø
                     Result := 180 //Çª¸¥°è¿­ (¿ì¸®Æí)
                  end else begin
                     if UserCastle.IsCastleAllyMember(TUserHuman(cret)) then
                        Result := 69; //¼ºÀ» Â÷ÁöÇÑ ¹®ÆÄ´Â ÀûÀ¸·Î º¸ÀÎ´Ù.
                  end;
               end;
            end;
         end;
      end;

   end else begin  //¸ó½ºÅÍ

      try
         if ( cret.RaceServer = RC_CLONE ) then begin
            if (cret.Master <> nil ) and (cret.Master.RaceServer = RC_USERHUMAN ) then begin
               Result := cret.Master.MyColor;
            end;
         end else begin
            if cret.SlaveExpLevel in [0..7] then
               Result := SlaveColors[cret.SlaveExpLevel];
            if cret.BoCrazyMode then Result := 249;  //red ÆøÁÖ»óÅÂ
            if cret.BoGoodCrazyMode then Result := 253;  //violet °ö°Ô¹ÌÄ£»óÅÂ (»ö±òÁ¶Á¤)
            if cret.BoHolySeize then Result := 125;  //
         end;
      except
         MainOutMessage('EXCEPT CHARCOLOR');
      end;

   end;
end;

// 0: »ó°ü°ü°è¾øÀ½
// 1: ¿ì¸® ¹®ÆÄ
// 2: Àû´ë °ü°è
// 3: µ¿¸Í°ü°è
function  TCreature.GetGuildRelation (onecret, twocret: TCreature): integer;
begin
   Result := 0;
   BoGuildWarArea := FALSE;
   if (onecret.MyGuild <> nil) and (twocret.MyGuild <> nil) then begin
      if onecret.InGuildWarSafeZone or twocret.InGuildWarSafeZone then begin
         Result := 0;  //¹®ÆÄÀü ±ÝÁö ±¸¿ª
      end else begin
         if TGuild(onecret.MyGuild).KillGuilds.Count > 0 then begin
            BoGuildWarArea := TRUE;
            if TGuild(onecret.MyGuild).IsHostileGuild (TGuild(twocret.MyGuild)) and
               TGuild(twocret.MyGuild).IsHostileGuild (TGuild(onecret.MyGuild))
            then begin
               Result := 2; //69;  //µÐ¶ÔµÄ
            end;
            if TGuild(onecret.MyGuild) = TGuild(twocret.MyGuild) then begin
               Result := 1; //180; //ºÍÎÒÍ¬¸öÃÅÅÉ
            end;
            if (TGuild(onecret.MyGuild).IsAllyGuild(TGuild(twocret.MyGuild))) and
               (TGuild(twocret.MyGuild).IsAllyGuild(TGuild(onecret.MyGuild))) then
               Result := 3;  //ÁªÃË
         end;
      end;
   end;
end;

function  TCreature.IsGuildMaster: Boolean;
begin
   if (MyGuild <> nil) and (GuildRank = 1) then
      Result := TRUE
   else
      Result := FALSE;
end;

function  TCreature.IsMyGuildMaster: Boolean;
var
   guildagit : TGuildAgit;
begin
   Result := FALSE;

   if (MyGuild <> nil) and (GuildRank = 1) then begin
      //´Ù¸¥ ¹®ÁÖÀÌ¸é FALSE.
      // ¹®ÁÖÀÇ Àå¿ø ¹øÈ£¿Í ÇöÀç ÀÖ´Â ¸ÊÀÇ Àå¿ø¹øÈ£°¡ ÀÏÄ¡ ÇØ¾ßÇÔ.
      guildagit := GuildAgitMan.GetGuildAgit( TGuild(MyGuild).GuildName );
      if guildagit <> nil then begin
         if (guildagit.GuildAgitNumber > -1 ) and (guildagit.GuildAgitNumber = PEnvir.GuildAgit) then begin
            Result := TRUE;
         end;
      end;
   end;
end;

function  TCreature.GetGuildNameHereAgit: string;
var
   guildagit : TGuildAgit;
begin
   Result := '';

   // ÇöÀç ÀÖ´Â ¸ÊÀÇ Àå¿ø ¹®ÆÄ¸¦ ¾ò´Â´Ù.
   if PEnvir.GuildAgit > -1 then begin
      Result := GuildAgitMan.GetGuildNameFromAgitNum(PEnvir.GuildAgit);
   end;

{
   if MyGuild <> nil then begin
      // °¡ÀÔµÈ ¹®ÆÄ¿Í ÇöÀç ÀÖ´Â ¸ÊÀÇ Àå¿øÀÇ ¹®ÆÄ°¡ ÀÏÄ¡ ÇØ¾ßÇÔ.
      guildagit := GuildAgitMan.GetGuildAgit( TGuild(MyGuild).GuildName );
      if guildagit <> nil then begin
         if (guildagit.GuildAgitNumber > -1 ) and (guildagit.GuildAgitNumber = PEnvir.GuildAgit) then begin
            Result := TRUE;
         end;
      end;
   end;
}
end;

function  TCreature.GetGuildMasterNameHereAgit: string;
var
   guildagit : TGuildAgit;
begin
   Result := '';

   // ÇöÀç ÀÖ´Â ¸ÊÀÇ Àå¿ø ¹®ÆÄ¸¦ ¾ò´Â´Ù.
   if PEnvir.GuildAgit > -1 then begin
      Result := GuildAgitMan.GetGuildMasterNameFromAgitNum(PEnvir.GuildAgit);
   end;
end;

procedure TCreature.IncPKPoint (point: integer);
var
   old: integer;
begin
   old := PKLevel;
   //if old >= 2 then point := point * 2; //°¡ÁßÃ³¹ú
   //PkPoint 100¸¸À¸·Î Á¦ÇÑ(sonmg 2005/04/14)
   PlayerKillingPoint := _MIN(1000000, PlayerKillingPoint + point);
   if (old <> PKLevel) and (PKLevel <= 2) then begin
      ChangeNameColor;
   end;
end;

procedure TCreature.DecPKPoint (point: integer);
var
   old: integer;
begin
   old := PKLevel;
   PlayerKillingPoint := PlayerKillingPoint - point;
   if PlayerKillingPoint < 0 then PlayerKillingPoint := 0;
   if (old <> PKLevel) and (old > 0) and (old <= 2) then begin
      ChangeNameColor;
   end;
end;

function TCreature.GetPKTimeMin : string;
var
   hourstr: string;
begin
{
   //Æ²¸° ÄÚµå... 2¸¦ °öÇØ¾ß ÇÔ.
   if PlayerKillingPoint  < (60 * 24) then
      result := '24½Ã°£ÀÌ³»'
   else if PlayerKillingPoint  < ( 60 * 24  * 7 )then
      result := '1~7 ÀÏÀÌ³»'
   else if PlayerKillingPoint  < ( 60 * 24  * 14) then
      result := '8~14 ÀÏÀÌ³»'
   else if PlayerKillingPoint  < ( 60 * 24  * 30) then
      result := '15~30 ÀÏÀÌ³»'
   else result := 'ÇÑ´ÞÀÌ»ó'
}
   {$IFDEF KOREA} hourstr := '½Ã°£';
   {$ELSE}        hourstr := ' Hours';
   {$ENDIF}
   //PkPoint 1Á¡ °¨¼ÒµÇ´Âµ¥ 2ºÐ ¼Ò¿ä.
   Result := IntToStr( Round( (PlayerKillingPoint * 2) / 60) ) + hourstr;
end;

procedure  TCreature.AddBodyLuck (r: Real);
var
   n: integer;
begin
   if (r > 0) and (BodyLuck < 5 * BODYLUCKUNIT) then
      BodyLuck := BodyLuck + r;
   if (r < 0) and (BodyLuck > -(5 * BODYLUCKUNIT)) then
      BodyLuck := BodyLuck + r;

   n := Trunc (BodyLuck / BODYLUCKUNIT);
   if n > 5 then n := 5;
   if n < -10 then n := -10;
   BodyLuckLevel := n;
end;

function  TCreature.IncGold (igold: integer): Boolean;
var
   strlevel: string;
begin
   Result := FALSE;
   if igold < 0 then exit; // (sonmg 2005/06/22)

   if Int64(Gold) + igold <= AvailableGold then begin
      Gold := Gold + igold;
      Result := TRUE;
      //±ÝÀüº¯µ¿
      if igold >= EXORBITANT_GOLD then begin
//         MainOutMessage('***±ÝÀüº¯µ¿: +' + GetGoldStr(igold) + ' ' + UserName + ' (Lv:' + IntToStr(Abil.Level) + ') => ' + GetGoldStr(Gold));

         //·¹º§ÀÇ 10ÀÇ ÀÚ¸®¼ö
         strlevel := IntToStr( _MIN(9, Abil.Level div 10) );
         //·Î±× ³²°Ü¾ß ÇÔ
         AddUserLog ('45'#9 + //±ÝÀü_
                     MapName + ''#9 +
                     IntToStr(CX) + ''#9 +
                     IntToStr(CY) + ''#9 +
                     UserName + ''#9 +
                     NAME_OF_GOLD{'½ð±Ò'} + ''#9 +
                     IntToStr(igold) + ''#9 +
                     strlevel + ''#9 +
                     IntToStr(Gold));
      end;
   end;
end;

function  TCreature.DecGold (igold: integer): Boolean;
var
   strlevel: string;
begin
   Result := FALSE;
   if igold < 0 then Exit;

   if Int64(Gold) - igold >= 0 then begin
      Gold := Gold - igold;
      Result := TRUE;
      //±ÝÀüº¯µ¿
      if igold >= EXORBITANT_GOLD then begin
//         MainOutMessage('***±ÝÀüº¯µ¿: -' + GetGoldStr(igold) + ' ' + UserName + ' (Lv:' + IntToStr(Abil.Level) + ') => ' + GetGoldStr(Gold));

         //·¹º§ÀÇ 10ÀÇ ÀÚ¸®¼ö
         strlevel := IntToStr( _MIN(9, Abil.Level div 10) );
         //·Î±× ³²°Ü¾ß ÇÔ
         AddUserLog ('45'#9 + //±ÝÀü_
                     MapName + ''#9 +
                     IntToStr(CX) + ''#9 +
                     IntToStr(CY) + ''#9 +
                     UserName + ''#9 +
                     NAME_OF_GOLD{'±ÝÀü'} + ''#9 +
                     IntToStr(-igold) + ''#9 +
                     strlevel + ''#9 +
                     IntToStr(Gold));
      end;
   end;
end;

function  TCreature.CalcBagWeight: integer;
var
   i, w, temp: integer;
   ps: PTStdItem;
begin
   w := 0;
   for i:=0 to ItemList.Count-1 do begin
      ps := UserEngine.GetStdItem (PTUserItem(Itemlist[i]).Index);
      if ps <> nil then begin
         if ps.OverlapItem = 1 then begin
             temp := PTUserItem(Itemlist[i]).Dura;
             w := w + (temp div 10);   // Ä«¿îÆ® ¾ÆÀÌÅÛ(1)Àº 10°³´ç ¹«°Ô 1
         end else if ps.OverlapItem >= 2 then begin
             temp := PTUserItem(Itemlist[i]).Dura; // Ä«¿îÆ® ¾ÆÀÌÅÛ(2ÀÌ»ó)Àº 1°³´ç ¹«°Ô 1
             w := w + temp * ps.Weight;
         end else begin
             w := w + ps.Weight;
         end;
      end;
   end;
   Result := w;
end;

function  TCreature.CalcWearWeightEx (windex: integer): integer;
var
   i, w: integer;
   ps: PTStdItem;
begin
   w := 0;
   // 2003/03/15 ¾ÆÀÌÅÛ ÀÎº¥Åä¸® È®Àå
   for i:=0 to U_TRANS do begin  //8->12
      if (windex = -1) or (i <> windex) and (i <> U_WEAPON) and (i <> U_RIGHTHAND) then begin
         ps := UserEngine.GetStdItem (UseItems[i].Index);
         if ps <> nil then
            w := w + ps.Weight;
      end;
   end;
   Result := w;
end;

{$IFDEF FOR_ABIL_POINT}
//4/16ÀÏºÎÅÍ Àû¿ë

//ÀÚ½ÅÀÇ ·¹º§¿¡ ¸Â´Â ´É·ÂÄ¡
//»ç¿ë¾ÈÇÔ.
procedure TCreature.RecalcLevelAbilitys;  //º¸³Ê½º Æ÷ÀÎÆ® Àû¿ë½Ã
var
   n, mlevel: integer;
begin
{  º¸³Ê½º Æ÷ÀÎÆ®¿¡ ´ëÇÑ ´É·ÂÄ¡ Á¶Á¤
   ÇöÀç, »ç¿ëÇÏÁö ¾ÊÀ½  }
   if Abil.Level > ADJ_LEVEL then mlevel := ADJ_LEVEL
   else mlevel := Abil.Level;
   case Job of
      0: //Àü»ç
         begin
            Abil.MaxWeight := 50 + Round((Abil.Level / 3) * Abil.Level);
            Abil.MaxWearWeight := _MIN(255, 15 + Round((Abil.Level / 20) * Abil.Level));
            // 2003/02/11 ÃÖ´ë¹«°Ô 255·Î Á¦ÇÑ
            if( (12 + Round((Abil.Level / 13) * Abil.Level)) > 255 ) then Abil.MaxHandWeight := 255
            else
               Abil.MaxHandWeight := 12 + Round((Abil.Level / 13) * Abil.Level);
            Abil.MaxHP := DEFHP + Round((mlevel / 4 + 4) * mlevel);
            Abil.MaxMP := DEFMP + mlevel * 2;
            Abil.DC := MakeWord(_MAX(mlevel div 7 - 1, 1), _MAX(1, mlevel div 5));
            Abil.SC := 0;
            Abil.MC := 0;
            Abil.AC := MakeWord(0, mlevel div 7);
            Abil.MAC := 0;
         end;
      1: //¼ú»çÀÎ°æ¿ì
         begin
            Abil.MaxWeight := 50 + Round((Abil.Level / 5{4.2}) * Abil.Level);
            Abil.MaxWearWeight := 15 + Round((Abil.Level / 100) * Abil.Level);
            Abil.MaxHandWeight := 12 + Round((Abil.Level / 90) * Abil.Level);
            Abil.MaxHP := DEFHP + Round((mlevel / 15{18/30} + 1.8) * mlevel);
            Abil.MaxMP := DEFMP + Round((mlevel / 5 + 2)*2.2 * mlevel);
            n := mlevel div 7;
            Abil.DC := MakeWord(_MAX(n-1, 0), _MAX(1, n));
            Abil.MC := MakeWord(_MAX(n-1, 0), _MAX(1, n));
            Abil.SC := 0;
            Abil.AC := 0;
            Abil.MAC := 0;
         end;
      2: //µµ»çÀÎ °æ¿ì
         begin
            Abil.MaxWeight := 50 + Round((Abil.Level / 4{3.5}) * Abil.Level);
            Abil.MaxWearWeight := 15 + Round((Abil.Level / 50) * Abil.Level);
            Abil.MaxHandWeight := 12 + Round((Abil.Level / 42) * Abil.Level);
            Abil.MaxHP := DEFHP + Round((mlevel / 6{13} + 2.5) * mlevel);
            Abil.MaxMP := DEFMP + Round((mlevel / 8)*2.2 * mlevel);
            n := mlevel div 7;
            Abil.DC := MakeWord(_MAX(n-1, 0), _MAX(1, n));
            Abil.MC := 0;
            Abil.SC := MakeWord(_MAX(n-1, 0), _MAX(1, n));
            Abil.AC := 0;
            n := Round(mlevel / 6);
            Abil.MAC := MakeWord(n div 2, n+1);
         end;
   end;
   Abil.MaxHP := Abil.MaxHP + BonusAbil.HP;
   Abil.MaxMP := Abil.MaxMP + BonusAbil.MP;
   Abil.DC := MakeWord(Lobyte(Abil.DC) + Lobyte(BonusAbil.DC), Hibyte(Abil.DC) + Hibyte(BonusAbil.DC));
   Abil.SC := MakeWord(Lobyte(Abil.SC) + Lobyte(BonusAbil.SC), Hibyte(Abil.SC) + Hibyte(BonusAbil.SC));
   Abil.MC := MakeWord(Lobyte(Abil.MC) + Lobyte(BonusAbil.MC), Hibyte(Abil.MC) + Hibyte(BonusAbil.MC));
   Abil.AC  := MakeWord(Lobyte(Abil.AC) + Lobyte(BonusAbil.AC), Hibyte(Abil.AC) + Hibyte(BonusAbil.AC));
   Abil.MAC := MakeWord(Lobyte(Abil.MAC) + Lobyte(BonusAbil.MAC), Hibyte(Abil.MAC) + Hibyte(BonusAbil.MAC));

   if Abil.HP > Abil.MaxHP then Abil.HP := Abil.MaxHP;
   if Abil.MP > Abil.MaxMP then Abil.MP := Abil.MaxMP;

end;

{$ELSE}

procedure TCreature.RecalcLevelAbilitys;
//procedure TCreature.RecalcLevelAbilitys_old;
var
   n: integer;
begin
   //Abil °è»ê
   //Àü»çÀÎ °æ¿ì
   case Job of
      0: //Àü»ç
         begin
            Abil.MaxHP := 14 + Round((Abil.Level / 4 + 4.5 + (Abil.Level / 20)) * Abil.Level);
            Abil.MaxMP := 11 + Round(Abil.Level * 3.5);
               //Abil.MaxHP := 14 + Round((Abil.Level / 4 + 4) * Abil.Level);
               //Abil.MaxMP := 11 + Abil.Level * 2;
            Abil.MaxWeight := 50 + Round((Abil.Level / 3) * Abil.Level);
            Abil.MaxWearWeight := _MIN(255, 15 + Round((Abil.Level / 20) * Abil.Level));
            // 2003/02/11 ÃÖ´ë¹«°Ô 255·Î Á¦ÇÑ
            if( (12 + Round((Abil.Level / 13) * Abil.Level)) > 255 ) then Abil.MaxHandWeight := 255
            else
               Abil.MaxHandWeight := 12 + Round((Abil.Level / 13) * Abil.Level);
            Abil.DC := MakeWord(_MAX(Abil.Level div 5 - 1, 1), _MAX(1, Abil.Level div 5));
               //Abil.DC := MakeWord(_MAX(Abil.Level div 7 - 1, 1), _MAX(1, Abil.Level div 5));
            Abil.SC := 0;
            Abil.MC := 0;
            Abil.AC := MakeWord(0, Abil.Level div 7);
            Abil.MAC := 0;
         end;
      1: //¼ú»çÀÎ°æ¿ì
         begin
            Abil.MaxHP := 14 + Round((Abil.Level / 15{18/30} + 1.8) * Abil.Level);
            //Abil.MaxHP := 14 + Round((Abil.Level / 18 + 1.5) * Abil.Level);
            Abil.MaxMP := 13 + Round((Abil.Level / 5 + 2)*2.2 * Abil.Level);
            Abil.MaxWeight := 50 + Round((Abil.Level / 5{4.2}) * Abil.Level);
            Abil.MaxWearWeight := 15 + Round((Abil.Level / 100) * Abil.Level);
            Abil.MaxHandWeight := 12 + Round((Abil.Level / 90) * Abil.Level);
            n := Abil.Level div 7;
            Abil.DC := MakeWord(_MAX(n-1, 0), _MAX(1, n));
            Abil.MC := MakeWord(_MAX(n-1, 0), _MAX(1, n));
            Abil.SC := 0;
            Abil.AC := 0;
            Abil.MAC := 0; //MakeWord(_MAX(n-1, 0), n);
         end;
      2: //µµ»çÀÎ °æ¿ì
         begin
            Abil.MaxHP := 14 + Round((Abil.Level / 6{13} + 2.5) * Abil.Level);
            //Abil.MaxHP := 14 + Round((Abil.Level / 13 + 2.5) * Abil.Level);
            Abil.MaxMP := 13 + Round((Abil.Level / 8)*2.2 * Abil.Level);
            Abil.MaxWeight := 50 + Round((Abil.Level / 4{3.5}) * Abil.Level);
            Abil.MaxWearWeight := _MIN(255, 15 + Round((Abil.Level / 50) * Abil.Level));
            Abil.MaxHandWeight := _MIN(255, 12 + Round((Abil.Level / 42) * Abil.Level));
            n := Abil.Level div 7;
            Abil.DC := MakeWord(_MAX(n-1, 0), _MAX(1, n));
            Abil.MC := 0;
            Abil.SC := MakeWord(_MAX(n-1, 0), _MAX(1, n));
            Abil.AC := 0; //MakeWord(_MAX(n-1, 0), n);
            n := Round(Abil.Level / 6);
            Abil.MAC := MakeWord(n div 2, n+1);
         end;
   end;

   if Abil.HP > Abil.MaxHP then Abil.HP := Abil.MaxHP;
   if Abil.MP > Abil.MaxMP then Abil.MP := Abil.MaxMP;

end;

{$ENDIF}

//Á¤È®µµ, È¸ÇÇ·Â Àç¼³Á¤..
//MagicList ¿¡¼­ ±âº»°Ë¼úÀ» Ã£¾Æ¼­ Àç¼³Á¤ÇÔ..
//±âº»°Ë¼úÀº ¾÷±×·¹ÀÌµåµÇ¸é ÇÏ³ªÀÌ´Ù.
procedure TCreature.RecalcHitSpeed;
var
   i: integer;
   pum: PTUserMagic;
   fin: Boolean;
begin
   fin := FALSE;
   AccuracyPoint := DEFHIT + BonusAbil.Hit;
   HitPowerPlus := 0;
   HitDouble := 0;
   case Job of
      2: SpeedPoint := DEFSPEED + BonusAbil.Speed + 3;  //µµ»ç´Â ±âº» ¹ÎÃ¸ÀÌ ³ô´Ù.
      else SpeedPoint := DEFSPEED + BonusAbil.Speed;
   end;
   PSwordSkill := nil;
   PPowerHitSkill := nil;
   PLongHitSkill := nil;
   PWideHitSkill := nil;
   PFireHitSkill := nil;
   // 2003/03/15 ½Å±Ô¹«°ø
   PCrossHitSkill := nil;
   PTwinHitSkill  := nil;
   PStoneHitSkill := nil;
   for i:=0 to MagicList.Count-1 do begin
      pum := PTUserMagic (MagicList[i]);
      case pum.MagicId of
         3: //¿Ü¼ö°Ë¹ý (Àü»ç ±âÃÊ °Ë¹ý)
         begin
            PSwordSkill := pum;  //¹«°ø »èÁ¦½Ã ÁÖÀÇÇØ¾ß ÇÑ´Ù.
            if pum.Level > 0 then
               AccuracyPoint := AccuracyPoint + Round(9 / 3 * pum.Level);
         end;

         7: //¿¹µµ°Ë¹ý (Àü»çÀÇ °ø°Ý °Ë¹ý)
         begin
            PPowerHitSkill := pum;
            if pum.Level > 0 then
               AccuracyPoint := AccuracyPoint + Round(3 / 3 * pum.Level);
            HitPowerPlus := 5 + pum.Level;  //ÆÄ¿ö 5, 6, 7, 8
            AttackSkillCount := 7 - PPowerHitSkill.Level;
            AttackSkillPointCount := Random(AttackSkillCount);
         end;

         12: //¾î°Ë¼ú
         begin
            PLongHitSkill := pum;
         end;

         25: //¹Ý¿ù°Ë¹ý
         begin
            PWideHitSkill := pum;
         end;

         26: //¿°È­°á
         begin
            PFireHitSkill := pum;
            HitDouble := 4 + pum.Level * 4;  //+40% ~ +160%
         end;

         // 2003/03/15 ½Å±Ô¹«°ø
         34: //±¤Ç³Âü
         begin
            HitPowerPlus := 5 + pum.Level;  //ÆÄ¿ö 5, 6, 7, 8
            PCrossHitSkill := pum;
         end;

         38: //½Ö·æÂü
         begin
            HitPowerPlus  := pum.Level;  //ÆÄ¿ö 0, 1, 2, 3
            PTwinHitSkill := pum;
         end;

         43: //»çÀÚÈÄ
         begin
            HitPowerPlus  := pum.Level;  //ÆÄ¿ö 0, 1, 2, 3
            PStoneHitSkill := pum;
         end;

         4: //ÀÏ±¤°Ë¹ý (µµ»ç ±âÃÊ°Ë¹ý)
         begin
            PSwordSkill := pum;  //¹«°ø »èÁ¦½Ã ÁÖÀÇÇØ¾ß ÇÑ´Ù.
            if pum.Level > 0 then
               AccuracyPoint := AccuracyPoint + Round(8 / 3 * pum.Level);
         end;
      end;
   end;
end;

procedure TCreature.AddMagicWithItem (magic: integer);  //¾ÆÀÌÅÛÀ» Âø¿ëÇØ¼­ ¾ò´Â ¸¶¹ý
var
   pdm: PTDefMagic;
   pum: PTUserMagic;
   hum: TUserHuman;
begin
   pdm := nil;
   if magic = AM_FIREBALL then begin  //È­¿°Àå
      {$IFDEF KOREA} pdm := UserEngine.GetDefMagic ('»ðÇòÊõ');
      {$ELSE}        pdm := UserEngine.GetDefMagic ('Fireball');
      {$ENDIF}
   end;
   if magic = AM_HEALING then begin
      {$IFDEF KOREA} pdm := UserEngine.GetDefMagic ('ÖÎÓúÊõ');
      {$ELSE}	      pdm := UserEngine.GetDefMagic ('Healing');
      {$ENDIF}
   end;
   if pdm <> nil then begin
      if not IsMyMagic (pdm.MagicId) then begin
         new (pum);
         pum.pDef := pdm;
         pum.MagicId := pdm.MagicId;
         pum.Key := #0;
         pum.Level := 1;
         pum.CurTrain := 0;
         MagicList.Add (pum);   //¸¶¹ýÀ» »õ·Î ¹è¿ò..
         if RaceServer = RC_USERHUMAN then begin
            hum := TUserHuman (self);
            hum.SendAddMagic (pum);    //¸¶¹ý Ãß°¡¸¦ Å¬¶óÀÌ¾ðÆ®¿¡ ¾Ë¸²
         end;
      end;
   end;
end;

procedure TCreature.DelMagicWithItem (magic: integer);
   procedure DelMagicByName (mname: string);
   var
      i: integer;
      hum: TUserHuman;
   begin
      if self.RaceServer = RC_USERHUMAN then   //PDS
      begin
        for i:=MagicList.Count-1 downto 0 do begin
           if PTUserMagic(MagicList[i]).pDef.MagicName = mname then begin
              hum := TUserHuman (self);
              hum.SendDelMagic (PTUserMagic(MagicList[i]));
              Dispose (PTUserMagic(MagicList[i]));
              MagicList.Delete (i);
              break;
           end;
        end;
      end;
   end;
begin
   if RaceServer <> RC_USERHUMAN then exit;
   if magic = AM_FIREBALL then begin
      if (Job <> 1) then begin  //¼ú»ç°¡ ¾Æ´Ï¸é
         {$IFDEF KOREA} DelMagicByName ('»ðÇòÊõ');
         {$ELSE}	      DelMagicByName ('Fireball');
         {$ENDIF}
      end;
   end;
   if magic = AM_HEALING then begin
      if (Job <> 2) then begin  //µµ»ç°¡ ¾Æ´Ï¸é
         {$IFDEF KOREA} DelMagicByName ('ÖÎÓúÊõ');
         {$ELSE}	      DelMagicByName ('Healing');
         {$ENDIF}
      end;
   end;
end;

//Àç»ýÀÇ¹ÝÁöÀÇ ³»±¸·ÂÀÌ ´â´Â´Ù.
procedure TCreature.ItemDamageRevivalRing;
var
   i, idura, olddura: integer;
   pstd: PTStdItem;
   hum: TUserHuman;
begin
   // 2003/03/15 ¾ÆÀÌÅÛ ÀÎº¥Åä¸® È®Àå
   for i:=0 to U_TRANS do begin    // 8->12
      if UseItems[i].Index > 0 then begin
         pstd := UserEngine.GetStdItem (UseItems[i].Index);
         if pstd <> nil then begin
            if (i = U_RINGR) or (i = U_RINGL) then begin
               if pstd.Shape = RING_REVIVAL_ITEM then begin
                  idura := UseItems[i].Dura;  //Dura´Â word°ªÀÌ±â ¶§¹®¿¡... idura(integer)·Î °è»êÇßÀ½
                  olddura := Round (idura / 1000);
                  idura := idura - 1000; //ÇÑ¹ø »ç¿ëÇÒ¶§ 1000¾¿ ´â´Â´Ù.
                  if idura <= 0 then begin
                     idura := 0;
                     UseItems[i].Dura := idura;
                     //´Ù ´à¸é ¾ø¾îÁø´Ù.
                     if RaceServer = RC_USERHUMAN then begin
                        hum := TUserHuman(self);
                        hum.SendDelItem (UseItems[i]); //Å¬¶óÀÌ¾ðÆ®¿¡ ¾ø¾îÁø°Å º¸³¿
                        hum.SysMsg(pstd.Name + 'ÆÆ»µÁË', 0); //Àç»ýÀÇ¹ÝÁö ÆÄ±« ¸Þ½ÃÁö(2004/11/18)
                     end;

                     //·Î±× ³²°Ü¾ß ÇÔ(Àç»ýÀÇ¹ÝÁö)
                     AddUserLog ('16'#9 + //Á×ÆÄ_
                                 MapName + ''#9 +
                                 IntToStr(CX) + ''#9 +
                                 IntToStr(CY) + ''#9 +
                                 UserName + ''#9 +
                                 pstd.Name + ''#9 +
                                 IntToStr(UseItems[i].MakeIndex) + ''#9 +
                                 IntToStr(BoolToInt(RaceServer = RC_USERHUMAN)) + ''#9 +
                                 '0');

                     UseItems[i].Index := 0;
                     RecalcAbilitys;
                  end else begin
                     UseItems[i].Dura := idura;

                     //·Î±× ³²±è(Àç»ýÀÇ¹ÝÁö)(sonmg 2005/10/10)
                     AddUserLog ('11'#9 + //»ç¿ë_ +
                                 MapName + ''#9 +
                                 IntToStr(CX) + ''#9 +
                                 IntToStr(CY) + ''#9 +
                                 UserName + ''#9 +
                                 pstd.Name + ''#9 +
                                 IntToStr(UseItems[i].MakeIndex) + ''#9 +
                                 IntToStr(BoolToInt(RaceServer = RC_USERHUMAN)) + ''#9 +
                                 '1');
                  end;
                  if olddura <> Round(idura / 1000) then
                     SendMsg (self, RM_DURACHANGE, i, idura, UseItems[i].DuraMax, 0, '');
                  break;
               end;
            end;
         end;
      end;
   end;
end;

//Âø¿ë ´É·ÂÄ¡·Î °è»ê
procedure TCreature.RecalcAbilitys;
var
   i, oldlight, n, m: integer;
   cghi: array[0..3] of Boolean;
   pstd: PTStdItem;
   temp: TAbility;
   fastmoveflag : Boolean;
   oldhmode: Boolean;
   mh_ring, mh_bracelet, mh_necklace: Boolean;
   sh_ring, sh_bracelet, sh_necklace: Boolean;
   // 2003/01/15 ¼¼Æ® ¾ÆÀÌÅÛ Ãß°¡...¼¼·û¼Â, ³ìÃë¼Â, µµºÎ¼Â
   hp_ring, hp_bracelet : Boolean;
   mp_ring, mp_bracelet : Boolean;
   hpmp_ring, hpmp_bracelet : Boolean;
   // 2003/02/11 ¼¼Æ® ¾ÆÀÌÅÛ Ãß°¡...¿ÀÇö¼Â, ÃÊÈ¥¼Â
   hpp_necklace, hpp_bracelet, hpp_ring : Boolean;
   cho_weapon, cho_necklace, cho_ring, cho_helmet, cho_bracelet : Boolean;
   // 2003/03/04 ¼¼Æ® ¾ÆÀÌÅÛ Ãß°¡...ÆÄ¼â¼Â, È¯¸¶¼®¼Â, ¿µ·É¿Á¼Â
   pset_necklace, pset_bracelet, pset_ring : Boolean;
   hset_necklace, hset_bracelet, hset_ring : Boolean;
   yset_necklace, yset_bracelet, yset_ring : Boolean;
   dset_wingdress :Boolean;
   // 2003/11/17 Á¦Á¶ Àü¿ë ¼¼Æ® ¾ÆÀÌÅÛ Ãß°¡
   // »À´Ù±Í¼Â,¹ú·¹¼Â,¹é±Ý¼Â,¿¬¿Á¼Â,È«¿Á¼Â,°­È­¹é±Ý¼Â,°­È­¿¬¿Á¼Â,°­È­È«¿Á¼Â.
   boneset_weapon, boneset_helmet, boneset_dress: Boolean;
   bugset_necklace, bugset_ring, bugset_bracelet: Boolean;
   ptset_belt, ptset_boots, ptset_necklace, ptset_bracelet, ptset_ring: Boolean;
   ksset_belt, ksset_boots, ksset_necklace, ksset_bracelet, ksset_ring: Boolean;
   rubyset_belt, rubyset_boots, rubyset_necklace, rubyset_bracelet, rubyset_ring: Boolean;
   strong_ptset_belt, strong_ptset_boots, strong_ptset_necklace, strong_ptset_bracelet, strong_ptset_ring: Boolean;
   strong_ksset_belt, strong_ksset_boots, strong_ksset_necklace, strong_ksset_bracelet, strong_ksset_ring: Boolean;
   strong_rubyset_belt, strong_rubyset_boots, strong_rubyset_necklace, strong_rubyset_bracelet, strong_rubyset_ring: Boolean;

   // 2004/01/09 ¿ë ¼¼Æ® ¾ÆÀÌÅÛ Ãß°¡(sonmg)
   dragonset_ring_left, dragonset_ring_right, dragonset_bracelet_left, dragonset_bracelet_right, dragonset_necklace, dragonset_dress,
      dragonset_helmet, dragonset_weapon, dragonset_boots, dragonset_belt: Boolean;
   // ¹ÝÂ¦ÀÌº¥Æ® 2004/08/09
   banjjak_weapon38, banjjak_weapon39, banjjak_weapon40 : Boolean;
   // ¹ÝÂ¦ÀÌº¥Æ®2Â÷ 2004/08/13
   banjjak2_weapon0, banjjak2_weapon1, banjjak2_weapon2 : Boolean;
   banjjak2_dress : Boolean;
   // ¼öÁ¤°©¿Ê Ãß°¡´É·Â
   crystal_dress : Boolean;

   // ÀÌº¥Æ® 2004-02-06
   hum1, hum2 : TUserHuman;
   cret : TCreature;
   tempvalue, tempcount : integer;
begin
   FillChar (AddAbil, sizeof(TAddAbility), 0);
   temp := WAbil;
   WAbil := Abil;
   WAbil.HP := temp.HP;
   WAbil.MP := temp.MP;
   WAbil.Weight := 0;
   WAbil.WearWeight := 0;
   WAbil.HandWeight := 0;
   AntiPoison := 0; //±âº» 2%(sonmg)
   PoisonRecover := 0;
   HealthRecover := 0;
   SpellRecover := 0;
   AntiMagic := 1;   //±âº» 10% => 2%
   Luck := 0;
   HitSpeed := 0;
   oldhmode := BoHumHideMode;
   BoHumHideMode := FALSE;

   //Æ¯¼öÇÑ ´É·Â
   BoAbilSpaceMove := FALSE;
   BoAbilMakeStone := FALSE;
   BoAbilRevival := FALSE;
   BoAddMagicFireball := FALSE;
   BoAddMagicHealing := FALSE;
   BoAbilAngerEnergy := FALSE;
   BoMagicShield := FALSE;   //»¤Éí
   BoAbilSuperStrength := FALSE;
   BoFastTraining := FALSE;
   BoAbilSearch := FALSE;

   ManaToHealthPoint := 0; //¸¶·Â -> Ã¼·Â
   mh_ring := FALSE;
   mh_bracelet := FALSE;
   mh_necklace := FALSE;

   SuckupEnemyHealthRate := 0; //Ã¼·Â Èí¼ö
   SuckupEnemyHealth := 0;
   sh_ring := FALSE;
   sh_bracelet := FALSE;
   sh_necklace := FALSE;
   // 2003/01/15 ¼¼Æ® ¾ÆÀÌÅÛ Ãß°¡...¼¼·û¼Â, ³ìÃë¼Â, µµºÎ¼Â
   hp_ring        := FALSE;
   hp_bracelet    := FALSE;
   mp_ring        := FALSE;
   mp_bracelet    := FALSE;
   hpmp_ring      := FALSE;
   hpmp_bracelet  := FALSE;
   // 2003/02/11 ¼¼Æ® ¾ÆÀÌÅÛ Ãß°¡...¿ÀÇö¼Â, ÃÊÈ¥¼Â
   hpp_necklace   := FALSE;
   hpp_bracelet   := FALSE;
   hpp_ring       := FALSE;
   cho_weapon     := FALSE;
   cho_necklace   := FALSE;
   cho_ring       := FALSE;
   cho_helmet     := FALSE;
   cho_bracelet   := FALSE;
   // 2003/02/11 ÃÊÈ¥ Ç®¼¼Æ® Âø¿ë¿©ºÎ ÇÃ·¹±×·Î ¿ëµµ º¯°æÇÏ¿© »ç¿ë
   BoOldVersionUser_Italy := FALSE;
   // 2003/03/04 ¼¼Æ® ¾ÆÀÌÅÛ Ãß°¡...ÆÄ¼â¼Â, È¯¸¶¼®¼Â, ¿µ·É¿Á¼Â
   pset_necklace  := FALSE;
   pset_bracelet  := FALSE;
   pset_ring      := FALSE;
   hset_necklace  := FALSE;
   hset_bracelet  := FALSE;
   hset_ring      := FALSE;
   yset_necklace  := FALSE;
   yset_bracelet  := FALSE;
   yset_ring      := FALSE;

   // 2003/11/17 Á¦Á¶ Àü¿ë ¼¼Æ® ¾ÆÀÌÅÛ Ãß°¡(sonmg)
   // »À´Ù±Í¼Â,¹ú·¹¼Â,¹é±Ý¼Â,¿¬¿Á¼Â,È«¿Á¼Â,°­È­¹é±Ý¼Â,°­È­¿¬¿Á¼Â,°­È­È«¿Á¼Â.
   boneset_weapon := FALSE;
   boneset_helmet := FALSE;
   boneset_dress := FALSE;
   bugset_necklace := FALSE;
   bugset_ring := FALSE;
   bugset_bracelet := FALSE;
   ptset_belt := FALSE;
   ptset_boots := FALSE;
   ptset_necklace := FALSE;
   ptset_bracelet := FALSE;
   ptset_ring := FALSE;
   ksset_belt := FALSE;
   ksset_boots := FALSE;
   ksset_necklace := FALSE;
   ksset_bracelet := FALSE;
   ksset_ring := FALSE;
   rubyset_belt := FALSE;
   rubyset_boots := FALSE;
   rubyset_necklace := FALSE;
   rubyset_bracelet := FALSE;
   rubyset_ring := FALSE;
   strong_ptset_belt := FALSE;
   strong_ptset_boots := FALSE;
   strong_ptset_necklace := FALSE;
   strong_ptset_bracelet := FALSE;
   strong_ptset_ring := FALSE;
   strong_ksset_belt := FALSE;
   strong_ksset_boots := FALSE;
   strong_ksset_necklace := FALSE;
   strong_ksset_bracelet := FALSE;
   strong_ksset_ring := FALSE;
   strong_rubyset_belt := FALSE;
   strong_rubyset_boots := FALSE;
   strong_rubyset_necklace := FALSE;
   strong_rubyset_bracelet := FALSE;
   strong_rubyset_ring := FALSE;

   // 2004/01/09 ¿ë ¼¼Æ® ¾ÆÀÌÅÛ Ãß°¡(sonmg)
   dragonset_ring_left := FALSE;
   dragonset_ring_right := FALSE;
   dragonset_bracelet_left := FALSE;
   dragonset_bracelet_right := FALSE;
   dragonset_necklace := FALSE;
   dragonset_dress := FALSE;
   dragonset_helmet := FALSE;
   dragonset_weapon := FALSE;
   dragonset_boots := FALSE;
   dragonset_belt := FALSE;

   // ¹ÝÂ¦ÀÌº¥Æ® 2004/08/09
   banjjak_weapon38 := FALSE;
   banjjak_weapon39 := FALSE;
   banjjak_weapon40 := FALSE;
   // ¹ÝÂ¦ÀÌº¥Æ®2Â÷ 2004/08/13
   banjjak2_weapon0 := FALSE;
   banjjak2_weapon1 := FALSE;
   banjjak2_weapon2 := FALSE;
   banjjak2_dress := FALSE;
   // ¼öÁ¤°©¿Ê Ãß°¡´É·Â
   crystal_dress := FALSE;

   BoCGHIEnable := FALSE;  //ÃµÁöÇÕÀÏ
   cghi[0] := FALSE;
   cghi[1] := FALSE;
   cghi[2] := FALSE;
   cghi[3] := FALSE;

   //changeHumAbilityÊôÐÔ¼Óµã
   if RaceServer = RC_USERHUMAN then begin //Ö»ÓÐÈËÎï²Å´¦Àí¸½¼ÓÊôÐÔ
       AddAbil.AC :=  MakeWord(_MIN(255, Lobyte(m_TempAbil[0].nAddWord)), _MIN(255, Lobyte(m_TempAbil[1].nAddWord)));
       AddAbil.MAC := MakeWord(_MIN(255, Lobyte(m_TempAbil[2].nAddWord)), _MIN(255, Lobyte(m_TempAbil[3].nAddWord)));
       AddAbil.DC :=  MakeWord(_MIN(255, Lobyte(m_TempAbil[4].nAddWord)), _MIN(255, Lobyte(m_TempAbil[5].nAddWord)));
       AddAbil.MC :=  MakeWord(_MIN(255, Lobyte(m_TempAbil[6].nAddWord)), _MIN(255, Lobyte(m_TempAbil[7].nAddWord)));
       AddAbil.SC :=  MakeWord(_MIN(255, Lobyte(m_TempAbil[8].nAddWord)), _MIN(255, Lobyte(m_TempAbil[9].nAddWord)));
       AddAbil.HP :=  AddAbil.HP + m_TempAbil[10].nAddWord;
       AddAbil.MP :=  AddAbil.MP + m_TempAbil[11].nAddWord;
       AddAbil.Luck := AddAbil.Luck + m_TempAbil[12].nAddWord;      //ÐÒÔË
       AddAbil.HitSpeed := AddAbil.HitSpeed + m_TempAbil[13].nAddWord;  //¹¥»÷ËÙ¶È
       AddAbil.AntiMagic := AddAbil.AntiMagic + m_TempAbil[14].nAddWord;      //Ä§·¨¶ã±Ü
       AddAbil.AntiPoison := AddAbil.AntiPoison + m_TempAbil[15].nAddWord;    //¶¾Îï¶ã±Ü
       AddAbil.Speed := AddAbil.Speed + m_TempAbil[16].nAddWord;       //Ãô½Ý
       AddAbil.HIT := AddAbil.HIT + m_TempAbil[17].nAddWord;     //×¼È·
       AddAbil.HealthRecover := AddAbil.HealthRecover + m_TempAbil[18].nAddWord;     //ÌåÁ¦»Ö¸´
       AddAbil.SpellRecover := AddAbil.SpellRecover + m_TempAbil[19].nAddWord;      //Ä§·¨»Ö¸´
       AddAbil.PoisonRecover := AddAbil.PoisonRecover + m_TempAbil[20].nAddWord;      //¶¾Îï»Ö¸´
   end;

   dset_wingdress := FALSE; // ÃµÀÇ¹«ºÀ
   PlusFinalDamage := 0;   // ÃÖÁ¾ µ¥¹ÌÁö
   LoverPlusAbility := FALSE;   // ¿¬ÀÎ ±×·ì ´É·ÂÄ¡ Àû¿ë ¿©ºÎ(2005 »©»©·Î ÀÌº¥Æ®)

   // 2003/03/04 »ç¶÷ÀÇ °æ¿ì¸¸ ¾ÆÀÌÅÛ Âø¿ë¿©ºÎ °Ë»çÅä·Ï º¯°æ
   if (RaceServer = RC_USERHUMAN) {or (Master <> nil)} then begin
      // 2003/03/15 ¾ÆÀÌÅÛ ÀÎº¥Åä¸® È®Àå
      for i:=0 to U_TRANS do begin // 8 -> 12
{
         //2005 »©»©·Î ÀÌº¥Æ®
         if (i = U_RIGHTHAND) then begin
            StatusArr[STATE_TEMPORARY1] := 0;
            StatusArr[STATE_TEMPORARY2] := 0;
            StatusArr[STATE_TEMPORARY3] := 0;
         end;
}

         if (UseItems[i].Index > 0) {and (UseItems[i].Dura > 0)} then begin
            //----------------------------------------------------------
            // ¾ÆÀÌÅÛ ³»±¸°¡ 0ÀÌ¸é ´É·ÂÄ¡ °è»ê ¾ÈÇÏ°í ¹«°Ô¸¸ °è»êÇÔ.(sonmg 2005/03/31)
            if UseItems[i].Dura = 0 then begin
               pstd := UserEngine.GetStdItem (UseItems[i].Index);
               if pstd <> nil then begin
                  if (i = U_WEAPON) or (i = U_RIGHTHAND) then begin
                     WAbil.HandWeight := WAbil.HandWeight + pstd.Weight;  //¼Õ¿¡ µé°í ÀÖ´Â ¹«°Ô
                  end else begin
                     WAbil.WearWeight := WAbil.WearWeight + pstd.Weight;  //ÀÔ°í ÀÖ°Å³ª Âø¿ëÇÑ ¹«°Ô.
                  end;
               end;
               continue;
            end;
            //----------------------------------------------------------

            ApplyItemParameters (UseItems[i], AddAbil);
            // 2003/03/15 ¾ÆÀÌÅÛ ÀÎº¥Åä¸® È®Àå
            ApplyItemParametersEx (UseItems[i], WAbil);

            pstd := UserEngine.GetStdItem (UseItems[i].Index);
            if pstd <> nil then begin
{
               //2005 »©»©·Î ÀÌº¥Æ® (2005/11/8~11/21)
               if (i = U_RIGHTHAND) and (pstd.StdMode = 30) and (pstd.Shape = SHAPE_OF_PUMPKINHEAD) then begin
                  PlusFinalDamage := 10;
                  StatusArr[STATE_TEMPORARY2] := 60000;
               end else if (i = U_RIGHTHAND) and (pstd.StdMode = 30) and (pstd.Shape = SHAPE_OF_LOVEPEPERO) then begin
                  LoverPlusAbility := TRUE;
                  StatusArr[STATE_TEMPORARY1] := 60000;

                  //¿¬ÀÎÀÌ Á¢¼ÓÇØ ÀÖÀ¸¸é ÇÏÆ®»©»©·Î
                  if RaceServer = RC_USERHUMAN then begin
                     if TUserHuman(self).fLover <> nil then begin
                        hum2 := UserEngine.GetUserHuman(TUserHuman(self).fLover.GetLoverName);
                        if hum2 <> nil then begin
                           if hum2.fLover.GetLoverName <> '' then begin
                              StatusArr[STATE_TEMPORARY1] := 0;
                              StatusArr[STATE_TEMPORARY3] := 60000;
                           end;
                        end;
                     end;
                  end;
               end;
               CharStatus := GetCharStatus;
               CharStatusChanged;
}

               if (i = U_WEAPON) or (i = U_RIGHTHAND) then begin
                  WAbil.HandWeight := WAbil.HandWeight + pstd.Weight;  //¼Õ¿¡ µé°í ÀÖ´Â ¹«°Ô
               end else begin
                  WAbil.WearWeight := WAbil.WearWeight + pstd.Weight;  //ÀÔ°í ÀÖ°Å³ª Âø¿ëÇÑ ¹«°Ô.
               end;
//               WAbil.Weight := WAbil.Weight + pstd.Weight; //ÀüÃ¼ÀÇ ¹«°Ô
               //¹«±âÀÎ °æ¿ì °­µµ
               if (i = U_WEAPON) or (i = U_ARMRINGL) or (i = U_ARMRINGR) then begin
{//ApplyParameters·Î ¿Å±è(sonmg).
                  if pstd.SpecialPwr in [1..10] then
                     AddAbil.WeaponStrong := pstd.SpecialPwr;  //¹«±âÀÇ °­µµ, °­µµ°¡ ³ôÀ¸¸é Àß ¾È»Ç°³Áü
}
                  if (pstd.SpecialPwr <= -1) and (pstd.SpecialPwr >= -50) then
                     AddAbil.UndeadPower := AddAbil.UndeadPower + (-pstd.SpecialPwr);  //¾ðµ¥µå °ø°Ý È¿°ú »ó½Â
                  if (pstd.SpecialPwr <= -51) and (pstd.SpecialPwr >= -100) then
                     AddAbil.UndeadPower := AddAbil.UndeadPower + (pstd.SpecialPwr + 50);  //¾ðµ¥µå °ø°Ý È¿°ú °¨¼Ò

                  if pstd.Shape = CCHO_WEAPON then
                     cho_weapon     := TRUE;
                  // 2003/11/19 ¼¼Æ® ¾ÆÀÌÅÛ Ãß°¡(sonmg)
                  // º°µµ ±¸ºÐ ÇÊ¿ä
                  if (pstd.Shape = BONESET_WEAPON_SHAPE) and (pstd.StdMode = 6) then boneset_weapon := TRUE;
                  // 2004/01/09 ¿ë ¼¼Æ® ¾ÆÀÌÅÛ Ãß°¡(sonmg)
                  if pstd.Shape = DRAGON_WEAPON_SHAPE then dragonset_weapon := TRUE;
                  // 2004/08/09 ¹ÝÂ¦ÀÌº¥Æ®
                  if UseItems[i].Index = 692 then banjjak_weapon38 := TRUE;
                  if UseItems[i].Index = 693 then banjjak_weapon39 := TRUE;
                  if UseItems[i].Index = 694 then banjjak_weapon40 := TRUE;
                  // 2004/08/13 ¹ÝÂ¦ÀÌº¥Æ®2Â÷
                  if UseItems[i].Index = 697 then banjjak2_weapon0 := TRUE;
                  if UseItems[i].Index = 698 then banjjak2_weapon1 := TRUE;
                  if UseItems[i].Index = 699 then banjjak2_weapon2 := TRUE;
               end;
               //³á°òÔö¼Ó¿ªÊ¼
               if (i = U_WEAPON) then
               begin
                  if pstd.AniCount > 0 then
                     WeaponEffType := pstd.AniCount;
               end;
               if (i = U_RIGHTHAND) then
               begin
                  if pstd.Shape > 0 then
                     DressEffType := pstd.Shape;
               end;
               if (i = U_DRESS) then
               begin
                  if UseItems[i].Desc[5] > 0 then
                    DressEffType := UseItems[i].Desc[5];
                if pstd.AniCount > 0 then
                DressEffType := pstd.AniCount;
               end;
               //³á°òÔö¼Ó½áÊø
               //¸ñ°ÉÀÌ
               if i = U_NECKLACE then begin
                  if pstd.Shape = NECTLACE_FASTTRAINING_ITEM then begin  //¼ö·ÃÀÇ¸ñ°ÉÀÌ
                     BoFastTraining := TRUE;
                  end;
                  if pstd.Shape = NECTLACE_SEARCH_ITEM then begin
                     BoAbilSearch := TRUE;
                  end;
                  if pstd.Shape = NECKLACE_GI_ITEM then begin  //ÃµÁöÇÕÀÏ (Áö)
                     cghi[1] := TRUE;
                  end;
                  if pstd.Shape = NECKLACE_OF_MANATOHEALTH then begin //¸¶·Â -> Ã¼·Â
                     mh_necklace := TRUE;
                     ManaToHealthPoint := ManaToHealthPoint + pstd.AniCount;
                  end;
                  if pstd.Shape = NECKLACE_OF_SUCKHEALTH then begin  //»ó´ë Ã¼·Â Èí¼ö
                     sh_necklace := TRUE;
                     SuckupEnemyHealthRate := SuckupEnemyHealthRate + pstd.AniCount;
                  end;
                  if pstd.Shape = NECKLACE_OF_HPPUP then begin  //HP PERCENT UP
                     hpp_necklace   := TRUE;
                  end;
                  if pstd.Shape = CCHO_NECKLACE then cho_necklace   := TRUE;
                  // 2003/03/04 ¼¼Æ® ¾ÆÀÌÅÛ Ãß°¡...ÆÄ¼â¼Â, È¯¸¶¼®¼Â, ¿µ·É¿Á¼Â
                  if pstd.Shape = PSET_NECKLACE_SHAPE then pset_necklace := TRUE;
                  if pstd.Shape = HSET_NECKLACE_SHAPE then hset_necklace := TRUE;
                  if pstd.Shape = YSET_NECKLACE_SHAPE then yset_necklace := TRUE;
                  // 2003/11/19 ¼¼Æ® ¾ÆÀÌÅÛ Ãß°¡(sonmg)
                  if pstd.Shape = BUGSET_NECKLACE_SHAPE then bugset_necklace := TRUE;
                  if pstd.Shape = PTSET_NECKLACE_SHAPE then ptset_necklace := TRUE;
                  if pstd.Shape = KSSET_NECKLACE_SHAPE then ksset_necklace := TRUE;
                  if pstd.Shape = RUBYSET_NECKLACE_SHAPE then rubyset_necklace := TRUE;
                  if pstd.Shape = STRONG_PTSET_NECKLACE_SHAPE then strong_ptset_necklace := TRUE;
                  if pstd.Shape = STRONG_KSSET_NECKLACE_SHAPE then strong_ksset_necklace := TRUE;
                  if pstd.Shape = STRONG_RUBYSET_NECKLACE_SHAPE then strong_rubyset_necklace := TRUE;
                  // 2004/01/09 ¿ë ¼¼Æ® ¾ÆÀÌÅÛ Ãß°¡(sonmg)
                  if pstd.Shape = DRAGON_NECKLACE_SHAPE then dragonset_necklace := TRUE;
               end;
               //¹ÝÁö
               if (i = U_RINGR) or (i = U_RINGL) then begin
                  if pstd.Shape = RING_TRANSPARENT_ITEM then begin
                     StatusArr[STATE_TRANSPARENT] := 60000;  //Å¸ÀÓ¾Æ¿ô ¾øÀ½..
                     BoHumHideMode := TRUE;   //Åõ¸í¸ðµå
                     BoFixedHideMode := False;    // 20220726 ÐÞÕý£¬ÏÈÄ§·¨ÒþÉíºó£¬ÔÙ´øÒþÉí×°±¸£¬ÅÜ¶¯ÒþÉíÏûÊ§BUG
                  end;
                  if pstd.Shape = RING_SPACEMOVE_ITEM then begin
                     BoAbilSpaceMove := TRUE;
                  end;
                  if pstd.Shape = RING_MAKESTONE_ITEM then begin
                     BoAbilMakeStone := TRUE;
                  end;
                  if pstd.Shape = RING_REVIVAL_ITEM then begin
                     BoAbilRevival := TRUE;
                  end;
                  if pstd.Shape = RING_FIREBALL_ITEM then begin
                     BoAddMagicFireBall := TRUE;
                  end;
                  if pstd.Shape = RING_HEALING_ITEM then begin
                     BoAddMagicHealing := TRUE;
                  end;
                  if pstd.Shape = RING_ANGERENERGY_ITEM then begin
                     BoAbilAngerEnergy := TRUE;
                  end;
                  if pstd.Shape = RING_MAGICSHIELD_ITEM then begin         //»¤Éí118
                     BoMagicShield := TRUE;
                  end;
                  if pstd.Shape = RING_SUPERSTRENGTH_ITEM then begin
                     BoAbilSuperStrength := TRUE;
                  end;
                  if pstd.Shape = RING_CHUN_ITEM then begin  //ÃµÁöÇÕÀÏ (Ãµ)
                     cghi[0] := TRUE;
                  end;
                  if pstd.Shape = RING_OF_MANATOHEALTH then begin  //¸¶·Â -> Ã¼·Â
                     mh_ring := TRUE;
                     ManaToHealthPoint := ManaToHealthPoint + pstd.AniCount;
                  end;
                  if pstd.Shape = RING_OF_SUCKHEALTH then begin  //»ó´ë Ã¼·Â Èí¼ö
                     sh_ring := TRUE;
                     SuckupEnemyHealthRate := SuckupEnemyHealthRate + pstd.AniCount;
                  end;
                  // 2003/01/15 ¼¼Æ® ¾ÆÀÌÅÛ Ãß°¡...¼¼·û¼Â, ³ìÃë¼Â, µµºÎ¼Â
                  if pstd.Shape = RING_OF_HPUP then begin  //HPÁõ°¡
                     hp_ring := TRUE;
                  end;
                  if pstd.Shape = RING_OF_MPUP then begin  //MPÁõ°¡
                     mp_ring := TRUE;
                  end;
                  if pstd.Shape = RING_OF_HPMPUP then begin  //HP/MP Áõ°¡
                     hpmp_ring := TRUE;
                  end;
                  if pstd.Shape = RING_OH_HPPUP then begin  //HP PERCENT Áõ°¡
                     hpp_ring := TRUE;
                  end;
                  if pstd.Shape = CCHO_RING then cho_ring   := TRUE;
                  // 2003/03/04 ¼¼Æ® ¾ÆÀÌÅÛ Ãß°¡...ÆÄ¼â¼Â, È¯¸¶¼®¼Â, ¿µ·É¿Á¼Â
                  if pstd.Shape = PSET_RING_SHAPE then pset_ring := TRUE;
                  if pstd.Shape = HSET_RING_SHAPE then hset_ring := TRUE;
                  if pstd.Shape = YSET_RING_SHAPE then yset_ring := TRUE;
                  // 2003/11/19 ¼¼Æ® ¾ÆÀÌÅÛ Ãß°¡(sonmg)
                  if pstd.Shape = BUGSET_RING_SHAPE then bugset_ring := TRUE;
                  if pstd.Shape = PTSET_RING_SHAPE then ptset_ring := TRUE;
                  if pstd.Shape = KSSET_RING_SHAPE then ksset_ring := TRUE;
                  if pstd.Shape = RUBYSET_RING_SHAPE then rubyset_ring := TRUE;
                  if pstd.Shape = STRONG_PTSET_RING_SHAPE then strong_ptset_ring := TRUE;
                  if pstd.Shape = STRONG_KSSET_RING_SHAPE then strong_ksset_ring := TRUE;
                  if pstd.Shape = STRONG_RUBYSET_RING_SHAPE then strong_rubyset_ring := TRUE;
                  // 2004/01/09 ¿ë ¼¼Æ® ¾ÆÀÌÅÛ Ãß°¡(sonmg)
                  if pstd.Shape = DRAGON_RING_SHAPE then begin
                     if (i = U_RINGL) then dragonset_ring_left := TRUE;
                     if (i = U_RINGR) then dragonset_ring_right := TRUE;
                  end;
               end;
               //ÆÈÂî
               if (i = U_ARMRINGL) or (i = U_ARMRINGR) then begin
                  if pstd.Shape = ARMRING_HAP_ITEM then begin  //ÃµÁöÇÕÀÏ (ÇÕ)
                     cghi[2] := TRUE;
                  end;
                  if pstd.Shape = BRACELET_OF_MANATOHEALTH then begin  //¸¶·Â -> Ã¼·Â
                     mh_bracelet := TRUE;
                     ManaToHealthPoint := ManaToHealthPoint + pstd.AniCount;
                  end;
                  if pstd.Shape = BRACELET_OF_SUCKHEALTH then begin  //»ó´ë Ã¼·Â Èí¼ö
                     sh_bracelet := TRUE;
                     SuckupEnemyHealthRate := SuckupEnemyHealthRate + pstd.AniCount;
                  end;
                  // 2003/01/15 ¼¼Æ® ¾ÆÀÌÅÛ Ãß°¡...¼¼·û¼Â, ³ìÃë¼Â, µµºÎ¼Â
                  if pstd.Shape = BRACELET_OF_HPUP then begin  //HPÁõ°¡
                     hp_bracelet := TRUE;
                  end;
                  if pstd.Shape = BRACELET_OF_MPUP then begin  //MPÁõ°¡
                     mp_bracelet := TRUE;
                  end;
                  if pstd.Shape = BRACELET_OF_HPMPUP then begin  //HP/MPÁõ°¡
                     hpmp_bracelet := TRUE;
                  end;
                  if pstd.Shape = BRACELET_OF_HPPUP then begin  //HP PERCENT Áõ°¡
                     hpp_bracelet := TRUE;
                  end;
                  if pstd.Shape = CCHO_BRACELET then cho_bracelet   := TRUE;
                  // 2003/03/04 ¼¼Æ® ¾ÆÀÌÅÛ Ãß°¡...ÆÄ¼â¼Â, È¯¸¶¼®¼Â, ¿µ·É¿Á¼Â
                  if pstd.Shape = PSET_BRACELET_SHAPE then pset_bracelet := TRUE;
                  if pstd.Shape = HSET_BRACELET_SHAPE then hset_bracelet := TRUE;
                  if pstd.Shape = YSET_BRACELET_SHAPE then yset_bracelet := TRUE;
                  // 2003/11/19 ¼¼Æ® ¾ÆÀÌÅÛ Ãß°¡(sonmg)
                  if pstd.Shape = BUGSET_BRACELET_SHAPE then bugset_bracelet := TRUE;
                  if pstd.Shape = PTSET_BRACELET_SHAPE then ptset_bracelet := TRUE;
                  if pstd.Shape = KSSET_BRACELET_SHAPE then ksset_bracelet := TRUE;
                  if pstd.Shape = RUBYSET_BRACELET_SHAPE then rubyset_bracelet := TRUE;
                  if pstd.Shape = STRONG_PTSET_BRACELET_SHAPE then strong_ptset_bracelet := TRUE;
                  if pstd.Shape = STRONG_KSSET_BRACELET_SHAPE then strong_ksset_bracelet := TRUE;
                  if pstd.Shape = STRONG_RUBYSET_BRACELET_SHAPE then strong_rubyset_bracelet := TRUE;
                  // 2004/01/09 ¿ë ¼¼Æ® ¾ÆÀÌÅÛ Ãß°¡(sonmg)
                  if pstd.Shape = DRAGON_BRACELET_SHAPE then begin
                     if (i = U_ARMRINGL) then dragonset_bracelet_left := TRUE;
                     if (i = U_ARMRINGR) then dragonset_bracelet_right := TRUE;
                  end;
               end;
               //Åõ±¸
               if (i = U_HELMET) then begin
                  if pstd.Shape = HELMET_IL_ITEM then begin
                     cghi[3] := TRUE;
                  end;
                  if pstd.Shape = CCHO_HELMET then cho_helmet   := TRUE;
                  // 2003/11/19 ¼¼Æ® ¾ÆÀÌÅÛ Ãß°¡(sonmg)
                  if pstd.Shape = BONESET_HELMET_SHAPE then boneset_helmet := TRUE;
                  // 2004/01/09 ¿ë ¼¼Æ® ¾ÆÀÌÅÛ Ãß°¡(sonmg)
                  if pstd.Shape = DRAGON_HELMET_SHAPE then dragonset_helmet := TRUE;
               end;
               // ¿Ê
               if ( i = U_DRESS ) then begin
                  if pstd.Shape = DRESS_SHAPE_WING then begin
                     // ¹ÝÂ¦ÀÌº¥Æ®2Â÷ 2004/08/13
                     if (UseItems[i].Index = 700) or (UseItems[i].Index = 701) then
                        banjjak2_dress := TRUE
                     else
                        dset_wingdress := TRUE;
                  end;
                  // 2003/11/19 ¼¼Æ® ¾ÆÀÌÅÛ Ãß°¡(sonmg)
                  // º°µµ ±¸ºÐ ÇÊ¿ä
                  if (pstd.Shape = BONESET_DRESS_SHAPE)
                     and ( (pstd.Name = '°×¹ÇµÄÈË')
                     or (pstd.Name = '°×¹ÇµÄÅ®') ) then boneset_dress := TRUE;

                  // 2004/01/09 ¿ë ¼¼Æ® ¾ÆÀÌÅÛ Ãß°¡(sonmg)
                  if pstd.Shape = DRAGON_DRESS_SHAPE then dragonset_dress := TRUE;
                  // ¼öÁ¤°©¿Ê Ãß°¡´É·Â(2005/11/11)
                  if pstd.Shape = DRESS_SHAPE_CRYSTAL then crystal_dress := TRUE;
               end;
               // º§Æ®(sonmg)
               if ( i = U_BELT ) then begin
                  // 2003/11/19 ¼¼Æ® ¾ÆÀÌÅÛ Ãß°¡(sonmg)
                  if pstd.Shape = PTSET_BELT_SHAPE then ptset_belt := TRUE;
                  if pstd.Shape = KSSET_BELT_SHAPE then ksset_belt := TRUE;
                  if pstd.Shape = RUBYSET_BELT_SHAPE then rubyset_belt := TRUE;
                  if pstd.Shape = STRONG_PTSET_BELT_SHAPE then strong_ptset_belt := TRUE;
                  if pstd.Shape = STRONG_KSSET_BELT_SHAPE then strong_ksset_belt := TRUE;
                  if pstd.Shape = STRONG_RUBYSET_BELT_SHAPE then strong_rubyset_belt := TRUE;
                  // 2004/01/09 ¿ë ¼¼Æ® ¾ÆÀÌÅÛ Ãß°¡(sonmg)
                  if pstd.Shape = DRAGON_BELT_SHAPE then dragonset_belt := TRUE;
               end;
               // ½Å¹ß(sonmg)
               if ( i = U_BOOTS ) then begin
                  // 2003/11/19 ¼¼Æ® ¾ÆÀÌÅÛ Ãß°¡(sonmg)
                  if pstd.Shape = PTSET_BOOTS_SHAPE then ptset_boots := TRUE;
                  if pstd.Shape = KSSET_BOOTS_SHAPE then ksset_boots := TRUE;
                  if pstd.Shape = RUBYSET_BOOTS_SHAPE then rubyset_boots := TRUE;
                  if pstd.Shape = STRONG_PTSET_BOOTS_SHAPE then strong_ptset_boots := TRUE;
                  if pstd.Shape = STRONG_KSSET_BOOTS_SHAPE then strong_ksset_boots := TRUE;
                  if pstd.Shape = STRONG_RUBYSET_BOOTS_SHAPE then strong_rubyset_boots := TRUE;
                  // 2004/01/09 ¿ë ¼¼Æ® ¾ÆÀÌÅÛ Ãß°¡(sonmg)
                  if pstd.Shape = DRAGON_BOOTS_SHAPE then dragonset_boots := TRUE;
               end;
               // ¼öÈ£¼®(sonmg)
               if ( i = U_CHARM ) then begin
                  if (pstd.StdMode = 53) and (pstd.Shape = SHAPE_OF_LUCKYLADLE) then begin
                     // º¹Á¶¸®ÀÌ¸é Çà¿î +1 ½ÃÅ²´Ù.
                     AddAbil.Luck := _MIN(255, AddAbil.Luck + 1);
                  end;
               end;
            end;
         end;
      end;

      //-----¼¼Æ® ¾ÆÀÌÅÛ
      //ÃµÁöÇÕÀÏ °Ë»ç
      if cghi[0] and cghi[1] and cghi[2] and cghi[3] then begin  //ÃµÁöÇÕÀÏÀ» ´Ù Ã¡À½
         BoCGHIEnable := TRUE;
      end;

      //¸¶·Â -> Ã¼·ÂÀ¸·Î ¼¼Æ® (Àû³­ ¼¼Æ®)
      if mh_necklace and mh_bracelet and mh_ring then begin
         ManaToHealthPoint := ManaToHealthPoint + 50;   //º¸³Ê½º 50
      end;

      //»ó´ë Ã¼·ÂÈí¼ö ¼¼Æ® (¹ÐÈ­ ¼¼Æ®)
      if sh_necklace and sh_bracelet and sh_ring then begin
         AddAbil.HIT := AddAbil.HIT + 2;  //º¸³Ê½º·Î Á¤È®ÀÌ 2 Áõ°¡
      end;

      // 2003/01/15 ¼¼Æ® ¾ÆÀÌÅÛ Ãß°¡...¼¼·û¼Â, ³ìÃë¼Â, µµºÎ¼Â
      if hp_bracelet and hp_ring then begin
         AddAbil.HP := AddAbil.HP + 50;  //º¸³Ê½º·Î HP 50 Áõ°¡
      end;
      if mp_bracelet and mp_ring then begin
         AddAbil.MP := AddAbil.MP + 50;  //º¸³Ê½º·Î MP 50 Áõ°¡
      end;
      if hpmp_bracelet and hpmp_ring then begin
         AddAbil.HP := AddAbil.HP + 30;  //º¸³Ê½º·Î HP 30 Áõ°¡
         AddAbil.MP := AddAbil.MP + 30;  //º¸³Ê½º·Î MP 30 Áõ°¡
      end;

      // 2003/02/11 ¼¼Æ® ¾ÆÀÌÅÛ Ãß°¡...¿ÀÇö¼Â, ÃÊÈ¥¼Â
      if hpp_necklace and hpp_bracelet and hpp_ring then begin
         AddAbil.HP := AddAbil.HP + ((WAbil.MaxHP * 30) div 100);  // º¸³Ê½º·Î HPÀÇ 30% Áõ°¡
         AddAbil.AC := AddAbil.AC + MAKEWORD(2,2);
      end;

      if cho_weapon and cho_necklace and cho_ring and cho_helmet and cho_bracelet then begin
         {//<ÃÊÈ¥¼¼Æ®È¿°ú : +4 (½ÇÁ¦°ø¼Ó +2)>
         //*ÃÊÈ¥µµ(°ø¼Ó-1) + 4 = +3 (½ÇÁ¦°ø¼Ó:1)
         //*ÃÊÈ¥µµ(°ø¼Ó 0) + 4 = +4 (½ÇÁ¦°ø¼Ó:2)
         //*ÃÊÈ¥µµ(°ø¼Ó+1) + 4 = +5 (½ÇÁ¦°ø¼Ó:2)
         //*ÃÊÈ¥µµ(°ø¼Ó+2) + 4 = +6 (½ÇÁ¦°ø¼Ó:3)}
         AddAbil.HitSpeed := AddAbil.HitSpeed + 4; //¼ÂÆ® °ø¼Ó ¼öÁ¤(sonmg 2004/12/30)
         AddAbil.DC := AddAbil.DC + MakeWord(2,5); // º¸³Ê½º·Î ÃÖ¼ÒÆÄ±« +2, ÃÖ´ëÆÄ±« +5
         BoOldVersionUser_Italy := TRUE;           // Ç®¼Â Âø¿ë ¼¼Æ®
      end;
      // 2003/03/04 ¼¼Æ® ¾ÆÀÌÅÛ Ãß°¡...ÆÄ¼â¼Â, È¯¸¶¼®¼Â, ¿µ·É¿Á¼Â
      if pset_bracelet and pset_ring then begin          // º¸³Ê½º·Î °ø¼Ó +1
         AddAbil.HitSpeed := AddAbil.HitSpeed + 2; //sonmg(2004/02/02)
         if pset_necklace then begin                     // º¸³Ê½º·Î ÆÄ±«1-3
            AddAbil.DC := AddAbil.DC + MakeWord(1,3);
         end;
      end;
      {
      // ¹«°Ô ÃÊ±âÈ­
      case Job of
         0: //Àü»ç
            begin
               Abil.MaxWeight := 50 + Round((Abil.Level / 3) * Abil.Level);
               Abil.MaxWearWeight := 15 + Round((Abil.Level / 20) * Abil.Level);
            end;
         1: //¼ú»çÀÎ°æ¿ì
            begin
               Abil.MaxWeight := 50 + Round((Abil.Level / 5{) * Abil.Level);
               Abil.MaxWearWeight := 15 + Round((Abil.Level / 100) * Abil.Level);
            end;
         2: //µµ»çÀÎ °æ¿ì
            begin
               Abil.MaxWeight := 50 + Round((Abil.Level / 4) * Abil.Level);
               Abil.MaxWearWeight := 15 + Round((Abil.Level / 50) * Abil.Level);
            end;
      end;
      }
      if hset_bracelet and hset_ring then begin          // º¸³Ê½º·Î Âø¿ë+5, °¡¹æ+20
         WAbil.MaxWeight     := WAbil.MaxWeight     + 20;
         WAbil.MaxWearWeight := _MIN(255, WAbil.MaxWearWeight + 5);
         if hset_necklace then begin                     // º¸³Ê½º·Î ¸¶¹ý1-2
            AddAbil.MC := AddAbil.MC + MakeWord(1,2);
         end;
      end;
      if yset_bracelet and yset_ring then begin          // º¸³Ê½º·Î ½Å¼º+3
         AddAbil.UndeadPower := AddAbil.UndeadPower + 3;
         if yset_necklace then begin                     // º¸³Ê½º·Î µµ·Â1-2
            AddAbil.SC := AddAbil.SC + MakeWord(1,2);
         end;
      end;

      // 2003/11/19 ¼¼Æ® ¾ÆÀÌÅÛ Ãß°¡(sonmg)
      // »À´Ù±Í ¼¼Æ®
      if boneset_weapon and boneset_helmet and boneset_dress then begin
      // º¸³Ê½º·Î ¹æ¾î+2, ¸¶·Â+1, µµ·Â+1
         AddAbil.AC := AddAbil.AC + MakeWord(0,2);
         AddAbil.MC := AddAbil.MC + MakeWord(0,1);
         AddAbil.SC := AddAbil.SC + MakeWord(0,1);
      end;
      // ¹ú·¹ ¼¼Æ®
      if bugset_necklace and bugset_ring and bugset_bracelet then begin
      // º¸³Ê½º·Î ÆÄ±«+1, ¸¶·Â+1, µµ·Â+1, ¸¶¹ýÀúÇ×+1, Áßµ¶ÀúÇ×+1
         AddAbil.DC := AddAbil.DC + MakeWord(0,1);
         AddAbil.MC := AddAbil.MC + MakeWord(0,1);
         AddAbil.SC := AddAbil.SC + MakeWord(0,1);
         AddAbil.AntiMagic := AddAbil.AntiMagic + 1;
         AddAbil.AntiPoison := AddAbil.AntiPoison + 1;
      end;
      // ¹é±Ý ¼¼Æ®
      if ptset_belt and ptset_boots and ptset_necklace
         and ptset_bracelet and ptset_ring then begin
         // º¸³Ê½º·Î ÆÄ±«+2, ¹æ¾î+2, ¾ç¼Õ+1, Âø¿ë+2
         AddAbil.DC := AddAbil.DC + MakeWord(0,2);
         AddAbil.AC := AddAbil.AC + MakeWord(0,2);
         WAbil.MaxHandWeight := _MIN(255, WAbil.MaxHandWeight + 1);
         WAbil.MaxWearWeight := _MIN(255, WAbil.MaxWearWeight + 2);
      end;
      // ¿¬¿Á ¼¼Æ®
      if ksset_belt and ksset_boots and ksset_necklace
         and ksset_bracelet and ksset_ring then begin
         // º¸³Ê½º·Î µµ·Â+2, ¹æ¾î+1, ¸¶Ç×+1, ¹ÎÃ¸+1, ¾ç¼Õ+1, Âø¿ë+2
         AddAbil.SC := AddAbil.SC + MakeWord(0,2);
         AddAbil.AC := AddAbil.AC + MakeWord(0,1);
         AddAbil.MAC := AddAbil.MAC + MakeWord(0,1);
         AddAbil.SPEED := AddAbil.SPEED + 1;
         WAbil.MaxHandWeight := _MIN(255, WAbil.MaxHandWeight + 1);
         WAbil.MaxWearWeight := _MIN(255, WAbil.MaxWearWeight + 2);
      end;
      // È«¿Á ¼¼Æ®
      if rubyset_belt and rubyset_boots and rubyset_necklace
         and rubyset_bracelet and rubyset_ring then begin
         // º¸³Ê½º·Î ¸¶·Â+2, ¸¶Ç×+2, ¾ç¼Õ+1, Âø¿ë+2
         AddAbil.MC := AddAbil.MC + MakeWord(0,2);
         AddAbil.MAC := AddAbil.MAC + MakeWord(0,2);
         WAbil.MaxHandWeight := _MIN(255, WAbil.MaxHandWeight + 1);
         WAbil.MaxWearWeight := _MIN(255, WAbil.MaxWearWeight + 2);
      end;
      // °­È­¹é±Ý ¼¼Æ®
      if strong_ptset_belt and strong_ptset_boots and strong_ptset_necklace
         and strong_ptset_bracelet and strong_ptset_ring then begin
         // º¸³Ê½º·Î ÆÄ±«+3, HP +30, °ø¼Ó+1, Âø¿ë+2
         AddAbil.DC := AddAbil.DC + MakeWord(0,3);
         AddAbil.HP := AddAbil.HP + 30;
         AddAbil.HitSpeed := AddAbil.HitSpeed + 2;
         WAbil.MaxWearWeight := _MIN(255, WAbil.MaxWearWeight + 2);
      end;
      // °­È­¿¬¿Á ¼¼Æ®
      if strong_ksset_belt and strong_ksset_boots and strong_ksset_necklace
         and strong_ksset_bracelet and strong_ksset_ring then begin
         // º¸³Ê½º·Î µµ·Â+2, HP +15, MP +20, ½Å¼º+1, Á¤È®+1, ¹ÎÃ¸+1, Âø¿ë+2
         AddAbil.SC := AddAbil.SC + MakeWord(0,2);
         AddAbil.HP := AddAbil.HP + 15;
         AddAbil.MP := AddAbil.MP + 20;
         AddAbil.UndeadPower := AddAbil.UndeadPower + 1;
         AddAbil.HIT := AddAbil.HIT + 1;
         AddAbil.SPEED := AddAbil.SPEED + 1;
         WAbil.MaxWearWeight := _MIN(255, WAbil.MaxWearWeight + 2);
      end;
      // °­È­È«¿Á ¼¼Æ®
      if strong_rubyset_belt and strong_rubyset_boots and strong_rubyset_necklace
         and strong_rubyset_bracelet and strong_rubyset_ring then begin
         // º¸³Ê½º·Î ¸¶·Â+2, MP +40, ¹ÎÃ¸+2, Âø¿ë+2
         AddAbil.MC := AddAbil.MC + MakeWord(0,2);
         AddAbil.MP := AddAbil.MP + 40;
         AddAbil.SPEED := AddAbil.SPEED + 2;
         WAbil.MaxWearWeight := _MIN(255, WAbil.MaxWearWeight + 2);
      end;

      //--------------------------------
      // 2004/01/09 ¿ë ¼¼Æ® °Ë»ç(sonmg)
      //--------------------------------
      //¿ë ¼¼Æ® (ÀüºÎ)
      if dragonset_ring_left and dragonset_ring_right and dragonset_bracelet_left and dragonset_bracelet_right
         and dragonset_necklace and dragonset_dress
         and dragonset_helmet and dragonset_weapon and dragonset_boots and dragonset_belt then begin
         //¹æ¾î+(1-4) / ¸¶¹æ+(1-4) / Çà¿î+2 / °ø¼Ó+2 / ¸¶¹ýÈ¸ÇÇ +6% / Áßµ¶È¸ÇÇ +6%
         //¾ç¼Õ¹«°Ô+34 / Âø¿ë¹«°Ô+27 / °¡¹æ¹«°Ô+120 / +HP+70 / +MP+80 / Æ¯¼ö¹«°ø(?)
         //¹ÎÃ¸+1 / °ø°Ý(1-4) / ¸¶¹ý(1-3) / µµ·Â(1-3)
         AddAbil.AC := MakeWord( LoByte(AddAbil.AC) + 1, _MIN(255, HiByte(AddAbil.AC) + 4) );
         AddAbil.MAC := MakeWord( LoByte(AddAbil.MAC) + 1, _MIN(255, HiByte(AddAbil.MAC) + 4) );
         AddAbil.Luck := _MIN(255, AddAbil.Luck + 2);
         AddAbil.HitSpeed := AddAbil.HitSpeed + 2; //°ø¼Ó+2
         AddAbil.AntiMagic := AddAbil.AntiMagic + 6;
         AddAbil.AntiPoison := AddAbil.AntiPoison + 6;
         WAbil.MaxHandWeight := _MIN(255, WAbil.MaxHandWeight + 34);
         WAbil.MaxWearWeight := _MIN(255, WAbil.MaxWearWeight + 27);
         WAbil.MaxWeight := WAbil.MaxWeight + 120;
         WAbil.MaxHP := WAbil.MaxHP + 70;
         WAbil.MaxMP := WAbil.MaxMP + 80;
         AddAbil.SPEED := AddAbil.SPEED + 1;
         AddAbil.DC := MakeWord( LoByte(AddAbil.DC) + 1, _MIN(255, HiByte(AddAbil.DC) + 4) );
         AddAbil.MC := MakeWord( LoByte(AddAbil.MC) + 1, _MIN(255, HiByte(AddAbil.MC) + 3) );
         AddAbil.SC := MakeWord( LoByte(AddAbil.SC) + 1, _MIN(255, HiByte(AddAbil.SC) + 3) );
      end else begin
         //-----------------
         //¿ë ¼¼Æ® (Type B)
         //-----------------
         //¿ë ¼¼Æ®(B-3)
         if dragonset_dress
            and dragonset_helmet and dragonset_weapon and dragonset_boots and dragonset_belt then begin
            //¾ç¼Õ¹«°Ô+34 / °¡¹æ¹«°Ô+50 / ¹ÎÃ¸+1 / °ø°Ý(1-4) / ¸¶¹ý(1-3) / µµ·Â(1-3)
            WAbil.MaxHandWeight := _MIN(255, WAbil.MaxHandWeight + 34);
            WAbil.MaxWeight := WAbil.MaxWeight + 50;
            AddAbil.SPEED := AddAbil.SPEED + 1;
            AddAbil.DC := MakeWord( LoByte(AddAbil.DC) + 1, _MIN(255, HiByte(AddAbil.DC) + 4) );
            AddAbil.MC := MakeWord( LoByte(AddAbil.MC) + 1, _MIN(255, HiByte(AddAbil.MC) + 3) );
            AddAbil.SC := MakeWord( LoByte(AddAbil.SC) + 1, _MIN(255, HiByte(AddAbil.SC) + 3) );
         //¿ë ¼¼Æ®(B-2)
         end
         else if dragonset_dress
            and dragonset_boots and dragonset_belt then begin
            //¾ç¼Õ¹«°Ô+17 / °¡¹æ¹«°Ô+30 / °ø°Ý(0-1) / ¸¶¹ý(0-1) / µµ·Â(0-1)
            WAbil.MaxHandWeight := _MIN(255, WAbil.MaxHandWeight + 17);
            WAbil.MaxWeight := WAbil.MaxWeight + 30;
            AddAbil.DC := MakeWord( LoByte(AddAbil.DC), _MIN(255, HiByte(AddAbil.DC) + 1) );
            AddAbil.MC := MakeWord( LoByte(AddAbil.MC), _MIN(255, HiByte(AddAbil.MC) + 1) );
            AddAbil.SC := MakeWord( LoByte(AddAbil.SC), _MIN(255, HiByte(AddAbil.SC) + 1) );
         //¿ë ¼¼Æ®(B-1)
         end
         else if dragonset_dress
            and dragonset_helmet and dragonset_weapon then begin
            //°ø°Ý(0-2) / ¸¶¹ý(0-1) / µµ·Â(0-1) / ¹ÎÃ¸ +1
            AddAbil.DC := MakeWord( LoByte(AddAbil.DC), _MIN(255, HiByte(AddAbil.DC) + 2) );
            AddAbil.MC := MakeWord( LoByte(AddAbil.MC), _MIN(255, HiByte(AddAbil.MC) + 1) );
            AddAbil.SC := MakeWord( LoByte(AddAbil.SC), _MIN(255, HiByte(AddAbil.SC) + 1) );
            AddAbil.SPEED := AddAbil.SPEED + 1;
         end;

         //-----------------
         //¿ë ¼¼Æ® (Type A)
         //-----------------
         //¿ë ¼¼Æ®(A-6)
         if dragonset_ring_left and dragonset_ring_right and dragonset_bracelet_left and dragonset_bracelet_right
            and dragonset_necklace then begin
            //Âø¿ë¹«°Ô+27 / °¡¹æ¹«°Ô+50 / ¹æ¾î(1-3) / ¸¶¹æ(1-3)
            WAbil.MaxWearWeight := _MIN(255, WAbil.MaxWearWeight + 27);
            WAbil.MaxWeight := WAbil.MaxWeight + 50;
            AddAbil.AC := MakeWord( LoByte(AddAbil.AC) + 1, _MIN(255, HiByte(AddAbil.AC) + 3) );
            AddAbil.MAC := MakeWord( LoByte(AddAbil.MAC) + 1, _MIN(255, HiByte(AddAbil.MAC) + 3) );
         //¿ë ¼¼Æ®(A-5)
         end
         else if (dragonset_ring_left or dragonset_ring_right) and dragonset_bracelet_left and dragonset_bracelet_right
            and dragonset_necklace then begin
            //A-3 + [A-2]
            //Âø¿ë¹«°Ô+17 / °¡¹æ¹«°Ô+30 / ¹æ¾î(0-1) / ¸¶¹æ(0-1) + [¹æ¾î(1-0) / ¸¶¹æ(1-0)]
            WAbil.MaxWearWeight := _MIN(255, WAbil.MaxWearWeight + 17);
            WAbil.MaxWeight := WAbil.MaxWeight + 30;
            AddAbil.AC := MakeWord( LoByte(AddAbil.AC) + 1, _MIN(255, HiByte(AddAbil.AC) + 1) );
            AddAbil.MAC := MakeWord( LoByte(AddAbil.MAC) + 1, _MIN(255, HiByte(AddAbil.MAC) + 1) );
         //¿ë ¼¼Æ®(A-4)
         end
         else if dragonset_ring_left and dragonset_ring_right and (dragonset_bracelet_left or dragonset_bracelet_right)
            and dragonset_necklace then begin
            //A-3 + [A-1]
            //Âø¿ë¹«°Ô+17 / °¡¹æ¹«°Ô+30 / ¹æ¾î(0-1) / ¸¶¹æ(0-1) + [¹æ¾î(0-1) / ¸¶¹æ(0-1)]
            WAbil.MaxWearWeight := _MIN(255, WAbil.MaxWearWeight + 17);
            WAbil.MaxWeight := WAbil.MaxWeight + 30;
            AddAbil.AC := MakeWord( LoByte(AddAbil.AC), _MIN(255, HiByte(AddAbil.AC) + 2) );
            AddAbil.MAC := MakeWord( LoByte(AddAbil.MAC), _MIN(255, HiByte(AddAbil.MAC) + 2) );
         //¿ë ¼¼Æ®(A-3)
         end
         else if (dragonset_ring_left or dragonset_ring_right) and (dragonset_bracelet_left or dragonset_bracelet_right)
            and dragonset_necklace then begin
            //Âø¿ë¹«°Ô+17 / °¡¹æ¹«°Ô+30 / ¹æ¾î(0-1) / ¸¶¹æ(0-1)
            WAbil.MaxWearWeight := _MIN(255, WAbil.MaxWearWeight + 17);
            WAbil.MaxWeight := WAbil.MaxWeight + 30;
            AddAbil.AC := MakeWord( LoByte(AddAbil.AC), _MIN(255, HiByte(AddAbil.AC) + 1) );
            AddAbil.MAC := MakeWord( LoByte(AddAbil.MAC), _MIN(255, HiByte(AddAbil.MAC) + 1) );
         end else begin
            //¿ë ¼¼Æ®(A-2)
            if dragonset_bracelet_left and dragonset_bracelet_right then begin
               //¹æ¾î(1-0) / ¸¶¹æ(1-0)
               AddAbil.AC := MakeWord( LoByte(AddAbil.AC) + 1, _MIN(255, HiByte(AddAbil.AC)) );
               AddAbil.MAC := MakeWord( LoByte(AddAbil.MAC) + 1, _MIN(255, HiByte(AddAbil.MAC)) );
            end;
            //¿ë ¼¼Æ®(A-1)
            if dragonset_ring_left and dragonset_ring_right then begin
               //¹æ¾î(0-1) / ¸¶¹æ(0-1)
               AddAbil.AC := MakeWord( LoByte(AddAbil.AC), _MIN(255, HiByte(AddAbil.AC) + 1) );
               AddAbil.MAC := MakeWord( LoByte(AddAbil.MAC), _MIN(255, HiByte(AddAbil.MAC) + 1) );
            end;
         end;
      end;
      // ¿ë ¼¼Æ® °Ë»ç ³¡.
      //--------------------------------

      //-----¼¼Æ® ¾ÆÀÌÅÛ ³¡

     //---------------------------------
     // 2004/08/13 ¹ÝÂ¦ÀÌº¥Æ®2Â÷
     if banjjak2_dress and ( Abil.Level >= 20 ) then begin
        //¹ÝÂ¦ÃµÀÇ
        if ( Abil.Level < 30 ) then
        begin
            // ±âº»°ªÀ¸·Î ¼³Á¤
        end
        else if ( Abil.Level < 40 ) then
        begin
          AddAbil.DC  := AddAbil.DC  + MakeWord(0,1); // °ø°Ý
          AddAbil.MC  := AddAbil.MC  + MakeWord(0,2); // ¸¶·Â
          AddAbil.SC  := AddAbil.SC  + MakeWord(0,2); // µµ·Â
          AddAbil.AC  := AddAbil.AC  + MakeWord(2,4); // ¹æ¾î
          AddAbil.MAC := AddAbil.MAC + MakeWord(1,3); // ¸¶¹æ
        end
        else// 40~
        begin
          AddAbil.DC  := AddAbil.DC  + MakeWord(0,2); // °ø°Ý
          AddAbil.MC  := AddAbil.MC  + MakeWord(0,4); // ¸¶·Â
          AddAbil.SC  := AddAbil.SC  + MakeWord(0,4); // µµ·Â
          AddAbil.AC  := AddAbil.AC  + MakeWord(5,7); // ¹æ¾î
          AddAbil.MAC := AddAbil.MAC + MakeWord(2,4); // ¸¶¹æ
        end;
     end else

      // ÃµÀÇ¹«ºÀ --------------------------------------------------------------
      if dset_wingdress and ( Abil.Level >= 20 ) then
      begin
        // ±âº»ÀûÀ¸·Î Çà¿î+1
//        AddAbil.Luck:= AddAbil.Luck + 1;   //--->ApplyItemParameters ¿¡¼­ Ã³¸®...

        if ( Abil.Level < 30 ) then
        begin
            // ±âº»°ªÀ¸·Î ¼³Á¤
        end
        else if ( Abil.Level < 40 ) then
        begin
          AddAbil.DC  := AddAbil.DC  + MakeWord(0,1); // °ø°Ý
          AddAbil.MC  := AddAbil.MC  + MakeWord(0,2); // ¸¶·Â
          AddAbil.SC  := AddAbil.SC  + MakeWord(0,2); // µµ·Â
          AddAbil.AC  := AddAbil.AC  + MakeWord(2,3); // ¹æ¾î
          AddAbil.MAC := AddAbil.MAC + MakeWord(0,2); // ¸¶¹æ
        end
        else if ( Abil.Level < 50 ) then
        begin
          AddAbil.DC  := AddAbil.DC  + MakeWord(0,3); // °ø°Ý
          AddAbil.MC  := AddAbil.MC  + MakeWord(0,4); // ¸¶·Â
          AddAbil.SC  := AddAbil.SC  + MakeWord(0,4); // µµ·Â
          AddAbil.AC  := AddAbil.AC  + MakeWord(5,5); // ¹æ¾î
          AddAbil.MAC := AddAbil.MAC + MakeWord(1,2); // ¸¶¹æ
        end
        else// 50
        begin
          AddAbil.DC  := AddAbil.DC  + MakeWord(0,5); // °ø°Ý
          AddAbil.MC  := AddAbil.MC  + MakeWord(0,6); // ¸¶·Â
          AddAbil.SC  := AddAbil.SC  + MakeWord(0,6); // µµ·Â
          AddAbil.AC  := AddAbil.AC  + MakeWord(9,7); // ¹æ¾î
          AddAbil.MAC := AddAbil.MAC + MakeWord(2,4); // ¸¶¹æ
        end;
      end;

      //-----------------------------
      //¹ÝÂ¦ÀÌº¥Æ® 2004/08/09
      if banjjak_weapon38 and ( Abil.Level > 20 ) then begin
         //»¡°»ÀÌ´Â ÀúÁÖ ºÙÀ½.
         if PKLevel >= 2 then begin
            AddAbil.UnLuck := AddAbil.UnLuck + 10;  //ÀúÁÖ
         end;
         //¹ÝÂ¦¹¬Ã»
         if ( Abil.Level < 30 ) then // 20 ~ 29
         begin
         // ±âº»°ªÀ¸·Î ¼³Á¤
         end
         else if ( Abil.Level < 40 ) then // 30 ~ 39
         begin
            WAbil.HandWeight := WAbil.HandWeight + 25;
            AddAbil.DC  := AddAbil.DC  + MakeWord(1,4); // °ø°Ý
         end
         else// 40~
         begin
            WAbil.HandWeight := WAbil.HandWeight + 50;
            AddAbil.DC  := AddAbil.DC  + MakeWord(2,7); // °ø°Ý
         end;
      end else if banjjak_weapon39 and ( Abil.Level > 20 ) then begin
         //»¡°»ÀÌ´Â ÀúÁÖ ºÙÀ½.
         if PKLevel >= 2 then begin
            AddAbil.UnLuck := AddAbil.UnLuck + 10;  //ÀúÁÖ
         end;
         //¹ÝÂ¦»ç°¢µµ
         if ( Abil.Level < 30 ) then // 20 ~ 29
         begin
         // ±âº»°ªÀ¸·Î ¼³Á¤
            //½Å¼º ¾ø¾Ú
            AddAbil.UndeadPower := AddAbil.UndeadPower - 1;
         end
         else if ( Abil.Level < 40 ) then // 30 ~ 39
         begin
            WAbil.HandWeight := WAbil.HandWeight + 8;
            AddAbil.DC  := AddAbil.DC  + MakeWord(1,2); // °ø°Ý
            AddAbil.SC  := AddAbil.SC  + MakeWord(1,1); // µµ·Â
         end
         else// 40~
         begin
            WAbil.HandWeight := WAbil.HandWeight + 16;
            AddAbil.DC  := AddAbil.DC  + MakeWord(2,5); // °ø°Ý
            AddAbil.SC  := AddAbil.SC  + MakeWord(2,1); // µµ·Â
         end;
      end else if banjjak_weapon40 and ( Abil.Level > 20 ) then begin
         //»¡°»ÀÌ´Â ÀúÁÖ ºÙÀ½.
         if PKLevel >= 2 then begin
            AddAbil.UnLuck := AddAbil.UnLuck + 10;  //ÀúÁÖ
         end;
         //¹ÝÂ¦ÃµÇü¸ñ
         if ( Abil.Level < 30 ) then // 20 ~ 29
         begin
         // ±âº»°ªÀ¸·Î ¼³Á¤
         end
         else if ( Abil.Level < 40 ) then // 30 ~ 39
         begin
            WAbil.HandWeight := WAbil.HandWeight + 6;
            AddAbil.DC  := AddAbil.DC  + MakeWord(1,1); // °ø°Ý
            AddAbil.MC  := AddAbil.MC  + MakeWord(0,2); // ¸¶·Â
         end
         else// 40~
         begin
            WAbil.HandWeight := WAbil.HandWeight + 10;
            AddAbil.DC  := AddAbil.DC  + MakeWord(2,2); // °ø°Ý
            AddAbil.MC  := AddAbil.MC  + MakeWord(0,3); // ¸¶·Â
         end;
      end;

      //-----------------------------
      //¹ÝÂ¦ÀÌº¥Æ®2Â÷ 2004/08/13
      if banjjak2_weapon0 and ( Abil.Level > 20 ) then begin
         //»¡°»ÀÌ´Â ÀúÁÖ ºÙÀ½.
         if PKLevel >= 2 then begin
            AddAbil.UnLuck := AddAbil.UnLuck + 10;  //ÀúÁÖ
         end;
         //¹ÝÂ¦µ¶°í
         if ( Abil.Level < 30 ) then // 20 ~ 29
         begin
         // ±âº»°ªÀ¸·Î ¼³Á¤
         end
         else if ( Abil.Level < 40 ) then // 30 ~ 39
         begin
            WAbil.HandWeight := WAbil.HandWeight + 36;
            AddAbil.DC  := AddAbil.DC  + MakeWord(1,4); // °ø°Ý
         end
         else// 40~
         begin
            WAbil.HandWeight := WAbil.HandWeight + 57;
            AddAbil.DC  := AddAbil.DC  + MakeWord(2,10); // °ø°Ý
         end;
      end else if banjjak2_weapon1 and ( Abil.Level > 20 ) then begin
         //»¡°»ÀÌ´Â ÀúÁÖ ºÙÀ½.
         if PKLevel >= 2 then begin
            AddAbil.UnLuck := AddAbil.UnLuck + 10;  //ÀúÁÖ
         end;
         //¹ÝÂ¦ÅÂ±Ø
         if ( Abil.Level < 30 ) then // 20 ~ 29
         begin
         // ±âº»°ªÀ¸·Î ¼³Á¤
            //½Å¼º 2 ÁÙÀÓ
            AddAbil.UndeadPower := AddAbil.UndeadPower - 2;
         end
         else if ( Abil.Level < 40 ) then // 30 ~ 39
         begin
            WAbil.HandWeight := WAbil.HandWeight + 9;
            AddAbil.DC  := AddAbil.DC  + MakeWord(1,4); // °ø°Ý
            AddAbil.SC  := AddAbil.SC  + MakeWord(1,2); // µµ·Â
         end
         else// 40~
         begin
            WAbil.HandWeight := WAbil.HandWeight + 24;
            AddAbil.DC  := AddAbil.DC  + MakeWord(2,8); // °ø°Ý
            AddAbil.SC  := AddAbil.SC  + MakeWord(2,3); // µµ·Â
         end;
      end else if banjjak2_weapon2 and ( Abil.Level > 20 ) then begin
         //»¡°»ÀÌ´Â ÀúÁÖ ºÙÀ½.
         if PKLevel >= 2 then begin
            AddAbil.UnLuck := AddAbil.UnLuck + 10;  //ÀúÁÖ
         end;
         //¹ÝÂ¦¿µ»ç
         if ( Abil.Level < 30 ) then // 20 ~ 29
         begin
         // ±âº»°ªÀ¸·Î ¼³Á¤
         end
         else if ( Abil.Level < 40 ) then // 30 ~ 39
         begin
            WAbil.HandWeight := WAbil.HandWeight + 5;
            AddAbil.DC  := AddAbil.DC  + MakeWord(1,1); // °ø°Ý
            AddAbil.MC  := AddAbil.MC  + MakeWord(0,2); // ¸¶·Â
         end
         else// 40~
         begin
            WAbil.HandWeight := WAbil.HandWeight + 9;
            AddAbil.DC  := AddAbil.DC  + MakeWord(2,2); // °ø°Ý
            AddAbil.MC  := AddAbil.MC  + MakeWord(0,4); // ¸¶·Â
         end;
      end;

      //Ë®¾§¿ø¼××·¼ÓÄÜÁ¦
//      if crystal_dress then begin
//         MissProbability := 2;
//         FeedbackProbability := 30; //µÇµ¹·Á ÁÙ È®·ü (30%)
//         FeedbackRatio := 50;       //µ¥¹ÌÁöÀÇ 50%¸¦ µÇµ¹·Á ÁÜ.
//      end;

      //----------------------------------------------------------//

      WAbil.Weight := {WAbil.Weight +} CalcBagWeight;
   end;  // 2003/03/04 »ç¶÷ÀÇ °æ¿ì¸¸ ¾ÆÀÌÅÛ Âø¿ë¿©ºÎ °Ë»çÅä·Ï º¯°æ

   if (BoFixedHideMode) and (StatusArr[STATE_TRANSPARENT] > 0) then  //Àº½Å¼ú
      BoHumHideMode := TRUE;

   if BoHumHideMode then begin
      if not oldhmode then begin
         CharStatus := GetCharStatus;
         CharStatusChanged;
      end;
   end else begin
      if oldhmode then begin
         StatusArr[STATE_TRANSPARENT] := 0;
         CharStatus := GetCharStatus;
         CharStatusChanged;
      end;
   end;

   //ÇÁ¸®¹Ì¾ö ÀÌº¥Æ®(sonmg 2005/07/29)
{
   if PremiumGrade = 1 then begin
      case Job of
      0:
         begin
            AddAbil.DC := AddAbil.DC + MakeWord(0, 7);
         end;
      1:
         begin
            AddAbil.MC := AddAbil.MC + MakeWord(0, 5);
         end;
      2:
         begin
            AddAbil.DC := AddAbil.DC + MakeWord(0, 3);
            AddAbil.SC := AddAbil.SC + MakeWord(0, 3);
         end;
      end;
      PlusFinalDamage := 3;
   end else if PremiumGrade = 2 then begin
      case Job of
      0:
         begin
            AddAbil.DC := AddAbil.DC + MakeWord(0, 11);
         end;
      1:
         begin
            AddAbil.MC := AddAbil.MC + MakeWord(0, 8);
         end;
      2:
         begin
            AddAbil.DC := AddAbil.DC + MakeWord(0, 5);
            AddAbil.SC := AddAbil.SC + MakeWord(0, 5);
         end;
      end;
      PlusFinalDamage := 5;
   end;
}

   //AccuracyPoint, SpeedPoint Àú¼³Á¤, ¹«¼ú·Î ¿Ã¶ó°£´Ù.
   RecalcHitSpeed;
   SendRefMsg(RM_SHOWBLUEHEALTH, Byte(BoMagicShield), 0, 0, 0, '');   //»¤ÉíÏûÏ¢
   // ¿©±â¿¡ Ãß°¡(À§Ä¡ Áß¿ä)
   //°ø°Ý¼Óµµ °ª 1/2·Î Àû¿ë(sonmg 2003/12/22->¼öÁ¤)
   if AddAbil.HitSpeed >= 0 then
      AddAbil.HitSpeed := ShortInt( Integer(AddAbil.HitSpeed) div 2 )
   else  //À½¼öÀÏ¶§ 1¾¿ »©¼­ Ã³¸®(sonmg 2004/01/13->¼öÁ¤)
      AddAbil.HitSpeed := ShortInt( Integer(AddAbil.HitSpeed - 1) div 2 );
   //°ø°Ý¼Óµµ ÇÕ°è Á¦ÇÑ(added by sonmg)
   AddAbil.HitSpeed := _MIN(15, AddAbil.HitSpeed);

   //ÃÊ,È¶ºÒ
   oldlight := Light;
   Light := GetMyLight;
   if oldlight <> light then
      SendRefMsg (RM_CHANGELIGHT, 0, 0, 0, 0, '');

   //AddAbil°ú 2ÁßÀ¸·Î µÇ¾î ÀÖÀ½(sonmg)
   SpeedPoint := SpeedPoint + AddAbil.SPEED;
   AccuracyPoint := AccuracyPoint + AddAbil.HIT;
   AntiPoison := AntiPoison + AddAbil.AntiPoison;
   PoisonRecover := PoisonRecover + AddAbil.PoisonRecover;
   HealthRecover := HealthRecover + AddAbil.HealthRecover;
   SpellRecover := SpellRecover + AddAbil.SpellRecover;
   AntiMagic := AntiMagic + AddAbil.AntiMagic;
   Luck := Luck + AddAbil.Luck;
   Luck := Luck - AddAbil.UnLuck;
   HitSpeed := AddAbil.HitSpeed;

   WAbil.MaxHP := Abil.MaxHP + AddAbil.HP;
   WAbil.MaxMP := Abil.MaxMP + AddAbil.MP;

   WAbil.AC := MakeWord ( _MIN(255, Lobyte(AddAbil.AC) + Lobyte(Abil.AC)), _MIN(255, Hibyte(AddAbil.AC) + Hibyte(Abil.AC)) );
   WAbil.MAC := MakeWord ( _MIN(255, Lobyte(AddAbil.MAC) + Lobyte(Abil.MAC)), _MIN(255, Hibyte(AddAbil.MAC) + Hibyte(Abil.MAC)) );
   WAbil.DC := MakeWord ( _MIN(255, Lobyte(AddAbil.DC) + Lobyte(Abil.DC)), _MIN(255, Hibyte(AddAbil.DC) + Hibyte(Abil.DC)) );
   WAbil.MC := MakeWord ( _MIN(255, Lobyte(AddAbil.MC) + Lobyte(Abil.MC)), _MIN(255, Hibyte(AddAbil.MC) + Hibyte(Abil.MC)) );
   WAbil.SC := MakeWord ( _MIN(255, Lobyte(AddAbil.SC) + Lobyte(Abil.SC)), _MIN(255, Hibyte(AddAbil.SC) + Hibyte(Abil.SC)) );

   //¸¶¹ýÀ¸·Î °É¸° ¼³Á¤
   if StatusArr[STATE_DEFENCEUP] > 0 then begin //¹æ¾î·Â »ó½Â
{
      WAbil.AC := MakeWord ( Lobyte(WAbil.AC), // + 2 + (Abil.Level div 8),
                             Hibyte(WAbil.AC) + 2 + (Abil.Level div 7) );
}
      //»õ °ø½Ä(sonmg 2005/06/03)
      WAbil.AC := MakeWord ( Lobyte(WAbil.AC),
                             _MIN( 255, Hibyte(WAbil.AC) + (Abil.Level div 7) + StatusValue[STATE_DEFENCEUP] ) );
   end;
   if StatusArr[STATE_MAGDEFENCEUP] > 0 then begin //¸¶Ç×·Â »ó½Â
{
      WAbil.MAC := MakeWord ( Lobyte(WAbil.MAC), // + 2 + (Abil.Level div 8),
                              Hibyte(WAbil.MAC) + 2 + (Abil.Level div 7) );
}
      //»õ °ø½Ä(sonmg 2005/06/03)
      WAbil.MAC := MakeWord ( Lobyte(WAbil.MAC),
                              _MIN( 255, Hibyte(WAbil.MAC) + (Abil.Level div 7) + StatusValue[STATE_MAGDEFENCEUP] ) );
   end;

   //¹°¾àÀ¸·Î Áõ»çÇÑ ´É·Â ¼³Á¤
   if ExtraAbil[EABIL_DCUP] > 0 then begin
      WAbil.DC := MakeWord(
                     Lobyte(WAbil.DC),
                     _MIN( 255, Hibyte(WAbil.DC) + ExtraAbil[EABIL_DCUP] )
                  );
   end;
   if ExtraAbil[EABIL_MCUP] > 0 then begin
      WAbil.MC := MakeWord(
                     Lobyte(WAbil.MC),
                     _MIN( 255, Hibyte(WAbil.MC) + ExtraAbil[EABIL_MCUP] )
                  );
   end;
   if ExtraAbil[EABIL_SCUP] > 0 then begin
      WAbil.SC := MakeWord(
                     Lobyte(WAbil.SC),
                     _MIN( 255, Hibyte(WAbil.SC) + ExtraAbil[EABIL_SCUP] )
                  );
   end;
   if ExtraAbil[EABIL_HITSPEEDUP] > 0 then begin
      HitSpeed := HitSpeed + ExtraAbil[EABIL_HITSPEEDUP];
   end;
   if ExtraAbil[EABIL_HPUP] > 0 then begin
      WAbil.MaxHP := WAbil.MaxHP + ExtraAbil[EABIL_HPUP];
   end;
   if ExtraAbil[EABIL_MPUP] > 0 then begin
      WAbil.MaxMP := WAbil.MaxMP + ExtraAbil[EABIL_MPUP];
   end;

   if ExtraAbil[EABIL_PWRRATE] > 0 then begin
      WAbil.DC := MakeWord(
                     ( Lobyte(WAbil.DC) * ExtraAbil[EABIL_PWRRATE] ) div 100,
                     ( Hibyte(WAbil.DC) * ExtraAbil[EABIL_PWRRATE] ) div 100
                  );
      WAbil.MC := MakeWord(
                     ( Lobyte(WAbil.MC) * ExtraAbil[EABIL_PWRRATE] ) div 100,
                     ( Hibyte(WAbil.MC) * ExtraAbil[EABIL_PWRRATE] ) div 100
                  );
      WAbil.SC := MakeWord(
                     ( Lobyte(WAbil.SC) * ExtraAbil[EABIL_PWRRATE] ) div 100,
                     ( Hibyte(WAbil.SC) * ExtraAbil[EABIL_PWRRATE] ) div 100
                  );
   end;
      if ExtraAbil[EABIL_MAGICDCUP] > 0 then begin
      WAbil.DC := MakeWord(
                     _MIN( 255, Lobyte(WAbil.DC) + ExtraAbil[EABIL_MAGICDCUP] ),
                     _MIN( 255, Hibyte(WAbil.DC) + ExtraAbil[EABIL_MAGICDCUP] )
                     );
   end;

     if ExtraAbil[EABIL_MAGICACUP] > 0 then begin
      WAbil.AC := MakeWord(
                     _MIN( 255, Lobyte(WAbil.AC) + ExtraAbil[EABIL_MAGICACUP] ),
                     _MIN( 255, Hibyte(WAbil.AC) + ExtraAbil[EABIL_MAGICACUP] )
                  );
   end;

   //¹ÝÁöÀÇ Æ¯¼öÇÑ ´É·Â,... È­¿°ÀÇ¹ÝÁö(È­¿°Àå), È¸º¹ÀÇ¹ÝÁö(È¸º¹¼ú)
   if BoAddMagicFireBall then begin
      AddMagicWithItem (AM_FIREBALL);
   end else begin
      DelMagicWithItem (AM_FIREBALL);
   end;

   if BoAddMagicHealing then begin
      AddMagicWithItem (AM_HEALING);
   end else begin
      DelMagicWithItem (AM_HEALING);
   end;

   if BoAbilSuperStrength then begin
      WAbil.MaxWeight := WAbil.MaxWeight * 2;
      WAbil.MaxWearWeight := _MIN(255, WAbil.MaxWearWeight * 2);
      if(WAbil.MaxHandWeight * 2 > 255) then WAbil.MaxHandWeight := 255
      else                                   WAbil.MaxHandWeight := WAbil.MaxHandWeight * 2;
   end;

   //Àû³­ ¼¼Æ® ¸¶·Â->Ã¼·Â
   if ManaToHealthPoint > 0 then begin
      if ManaToHealthPoint >= WAbil.MaxMp then ManaToHealthPoint := WAbil.MaxMp-1; //MaxMP´Â 0ÀÌ ¾Æ´Ô
      WAbil.MaxMP := WAbil.MaxMP - ManaToHealthPoint;
      WAbil.MaxHP := WAbil.MaxHP + ManaToHealthPoint;
      if(RaceServer = RC_USERHUMAN) and (WAbil.HP > WAbil.MaxHP) then WAbil.HP := WAbil.MaxHP;
   end;

// ¹ß·»Å¸ÀÎ ÀÌº¥Æ® ±×·ì¿øÀÌ 2¸íÀÌ°í ¼ºº°ÀÌ ´Ù¸£¸é ÇÇHP , MP 30% Áõ°¡
//  if IsGroupGenderDiffernt( self ) or IsGroupGenderDiffernt( GroupOwner ) then
//  begin
//      TempValue   := ( WAbil.MaxHP * 30 ) div 100;
//      WAbil.MaxHP := WAbil.MaxHP +( TempValue );
//      TempValue   := ( WAbil.MaxMP * 30 ) div 100;
//      WAbil.MaxMP := WAbil.MaxMP +( TempValue );
//   end;

{
   //¿¬ÀÎ ±×·ì ÀÌº¥Æ®
   if RaceServer = RC_USERHUMAN then begin
      //¿¬ÀÎ³¢¸® ±×·ìÀÌ¸é ¹æ¾î, ¸¶Ç× Áõ°¡(¿¬ÀÎ 100ÀÏ º¸»ó ÀÌº¥Æ®)
      //³ª ÀÚ½Å
      hum1 := TUserHuman(self);
      if hum1 <> nil then begin
         if hum1.fLover <> nil then begin
            tempcount := 0;
            if (GroupOwner <> nil) and (GroupOwner.GroupMembers <> nil) then begin
               if GroupOwner.GroupMembers.Count = 2 then begin
                  for i:=0 to GroupOwner.GroupMembers.Count-1 do begin
                     cret := TCreature(GroupOwner.GroupMembers.Objects[i]);
                     if cret.UserName = hum1.fLover.GetLoverName then begin
                        Inc(tempcount);
                     end else if cret.UserName = self.UserName then begin
                        Inc(tempcount);
                     end;
                  end;
                  //¿¬ÀÎ°ú ³ª¸¸ ±×·ìÀÌ¸é...
                  if tempcount = 2 then begin
                     WAbil.AC := MakeWord ( Lobyte(WAbil.AC), _MIN(255, Hibyte(WAbil.AC) + 10) );
                     WAbil.MAC := MakeWord ( Lobyte(WAbil.MAC), _MIN(255, Hibyte(WAbil.MAC) + 10) );
                  end;
               end;
            end;
         end;
      end;
   end;
}

{
   //2005 »©»©·Î ÀÌº¥Æ® (´É·ÂÄ¡ Àû¿ë)
   if LoverPlusAbility then begin
      if RaceServer = RC_USERHUMAN then begin
         //¿¬ÀÎÀÌ ÇÑ ±×·ìÀÇ ±×·ì¿øÀÌ°í µÑ ¸ðµÎ »©»©·Î¸¦ ÀåÂøÇÏ°í ÀÖÀ¸¸é ´É·ÂÄ¡ Áõ°¡
         //³ª ÀÚ½Å
         hum1 := TUserHuman(self);
         if hum1 <> nil then begin
            if hum1.fLover <> nil then begin
               tempcount := 0;
               if (GroupOwner <> nil) and (GroupOwner.GroupMembers <> nil) then begin
                  for i:=0 to GroupOwner.GroupMembers.Count-1 do begin
                     cret := TCreature(GroupOwner.GroupMembers.Objects[i]);
                     if (cret.UserName = hum1.fLover.GetLoverName) and (cret.LoverPlusAbility) then begin
                        Inc(tempcount);
                     end;
                  end;
                  //´É·ÂÄ¡ Àû¿ë...
                  if tempcount = 1 then begin
                     WAbil.DC := MakeWord ( Lobyte(WAbil.DC), _MIN(255, Hibyte(WAbil.DC) + 7) );
                     WAbil.MC := MakeWord ( Lobyte(WAbil.MC), _MIN(255, Hibyte(WAbil.MC) + 5) );
                     WAbil.SC := MakeWord ( Lobyte(WAbil.SC), _MIN(255, Hibyte(WAbil.SC) + 5) );
                  end;
               end;
            end;
         end;
      end;
   end;
}

   if(RaceServer = RC_USERHUMAN) and (WAbil.HP > WAbil.MaxHP) and ((not mh_necklace) and (not mh_bracelet) and (not mh_ring)) then
      WAbil.HP := WAbil.MaxHP;
   if(RaceServer = RC_USERHUMAN) and (WAbil.MP > WAbil.MaxMP) then WAbil.MP := WAbil.MaxMP;

   // 2003/07/03 ÀÌº¥Æ®¿ë ÄÚµå ¼ö¿µº¹µé...
   if RaceServer = RC_USERHUMAN then
   begin
      fastmoveflag := false;
      //ÌØ¶¨µÀ¾ßÊÇÃâÖúÅÜµÄ.
      if  (UseItems[U_DRESS].Dura > 0) and
          ( (UseItems[U_DRESS].Index = 466) or
            (UseItems[U_DRESS].Index = 467) or
            (UseItems[U_DRESS].Index = 470) or
            (UseItems[U_DRESS].Index = 471) or
            (UseItems[U_DRESS].Index = 695) or
            (UseItems[U_DRESS].Index = 696) )
      then fastmoveflag := true;

      // ÀÌº¥Æ® ½Å¹ß Â¤½Å ÁúÁÖ±â´ÉÃß°¡ ³ªÁß¿¡ ¾ø¿¡ÀÚ
      //if  (UseItems[U_BOOTS].Dura > 0) and (UseItems[U_BOOTS].Index = 665)
      //then fastmoveflag := true;

      // Âù·æ½ÅÇàº¸ ÁúÁÖ±â´É Ãß°¡
      if  (UseItems[U_BOOTS].Dura > 0) and (UseItems[U_BOOTS].Index = INDEX_MIRBOOTS)
      then fastmoveflag := true;


      if fastmoveflag then
         StatusArr[STATE_FASTMOVE] := 60000
      else
         StatusArr[STATE_FASTMOVE] := 0;

      // 50·¹º§ Áö¿ø - (sonmg 2004/03/22)
      if (Abil.Level >= EFFECTIVE_HIGHLEVEL) then begin
         if BoHighLevelEffect then begin
            StatusArr[STATE_50LEVELEFFECT] := 60000;
         end else begin
            StatusArr[STATE_50LEVELEFFECT] := 0;
         end;
      end else begin
         StatusArr[STATE_50LEVELEFFECT] := 0;
      end;

      CharStatus := GetCharStatus;
      CharStatusChanged;
   end;

   if RaceServer = RC_USERHUMAN then begin
      UpdateMsg (self, RM_CHARSTATUSCHANGED, HitSpeed{wparam}, CharStatus, 0, 0, '');
   end;

   if RaceServer >= RC_ANIMAL then begin
      //if Master <> nil then
      ApplySlaveLevelAbilitys;
   end;
end;

function TCreature.IsGroupGenderDiffernt( cret : TCreature ):Boolean;
var
   hum1 , hum2 : TCreature;
begin
   Result := false;
   if( Cret <> nil )and (Cret.GroupMembers.Count = 2 )then begin
      hum1 := TCreature (Cret.GroupMembers.Objects[0]);
      hum2 := TCreature (Cret.GroupMembers.Objects[1]);

      if ( hum1  <> nil ) and
            ( hum2 <> nil ) and
            ( hum1.RaceServer = RC_USERHUMAN ) and
            ( hum2.RaceServer = RC_USERHUMAN) then begin
         if ( hum1.sex <> hum2.sex ) then begin
            Result := true;
         end;
      end;
   end;

end;

//¾ÆÀÌÅÛÀÇ ´É·ÂÄ¡¸¦ ÇÕ
procedure TCreature.ApplyItemParameters (uitem: TUserItem; var aabil: TAddAbility);
var
   ps: PTStdItem;
   std: TStdItem;
begin
   ps := UserEngine.GetStdItem (uitem.Index);
   if ps <> nil then begin
      std := ps^;
      ItemMan.GetUpgradeStdItem (uitem, std); //»ñµÃÎäÆ÷Éý¼¶ÄÜÁ¦Öµ.

      if (uitem.Index = 706) or (uitem.Index = 707) or (uitem.Index = 708) then
         //¹ÝÂ¦¾ÆÀÌÅÛ 3Â÷
         BanjjakApplyItemParametersByJob (uitem, std, Abil.Level)
      else
      // Á÷¾÷¿¡ µû¸¥ ¿ë ¾ÆÀÌÅÛ ´É·ÂÄ¡ Â÷µî Àû¿ë(2004/01/08 sonmg)
      ApplyItemParametersByJob (uitem, std);

      case ps.StdMode of
         5,6: //¹«±â·ù AC:Á¤È®  MAC:¹ÎÃ¸
         begin
            aabil.HIT := aabil.HIT + Hibyte(std.AC);

            //°ø°Ý¼Óµµ Àû¿ë
            aabil.HitSpeed := aabil.HitSpeed + ItemMan.RealAttackSpeed( HIBYTE(std.MAC) );

{
            if Hibyte(std.MAC) > 10 then
               aabil.HitSpeed := aabil.HitSpeed + (Hibyte(std.MAC) - 10) //°ø°Ý¼Óµµ (+)
            else
               aabil.HitSpeed := aabil.HitSpeed - Hibyte(std.MAC); //°ø°Ý¼Óµµ (-)
}
            aabil.Luck := aabil.Luck + Lobyte(std.AC);   //°ÔÀÓ»óÀÇ ÀÌº¥Æ®¸¦ ÅëÇØ ºÙÀ½
            aabil.UnLuck := aabil.UnLuck + Lobyte(std.MAC);  //°ÔÀÓ»óÀÇ ÀÌº¥Æ®¸¦ ÅëÇØ ºÙÀ½(ÇÇÄÉÀÌ)
            aabil.Slowdown := aabil.Slowdown + std.Slowdown;
            aabil.Poison := aabil.Poison + std.Tox;

            // °­µµ(¹«±â, ÆÈÂî¿¡ Àû¿ë)
            if std.SpecialPwr in [1..10] then
               aabil.WeaponStrong := std.SpecialPwr;  //¹«±âÀÇ °­µµ, °­µµ°¡ ³ôÀ¸¸é Àß ¾È»Ç°³Áü
         end;
         10,11: //¿Ê(added by sonmg)
         begin
            aabil.AC := MakeWord (Lobyte(aabil.AC) + Lobyte(std.AC), Hibyte(aabil.AC) + Hibyte(std.AC));
            aabil.MAC := MakeWord (Lobyte(aabil.MAC) + Lobyte(std.MAC), Hibyte(aabil.MAC) + Hibyte(std.MAC));

            aabil.SPEED := aabil.SPEED + std.Agility;
            aabil.AntiMagic := aabil.AntiMagic + std.MgAvoid;
            aabil.AntiPoison := aabil.AntiPoison + std.ToxAvoid;

            // 2004/07/06(sonmg)
            aabil.HP := aabil.HP + std.HpAdd;
            aabil.MP := aabil.MP + std.MpAdd;

            // ¿ë¾ÆÀÌÅÛ È¿°ú »õ·ÎÃß°¡(sonmg)
            if std.EffType1 > 0 then begin
               case std.EffType1 of
                  EFFTYPE_HP_MP_ADD: //HP È¹º¹·®, MP È¸º¹·®
                  begin
                     //HP È¹º¹·®
                     if(aabil.HealthRecover + std.EffRate1 > 65000) then
                        aabil.HealthRecover := 65000
                     else
                        aabil.HealthRecover := aabil.HealthRecover + std.EffRate1;

                     //MP È¹º¹·®
                     if(aabil.SpellRecover + std.EffValue1 > 65000) then
                        aabil.SpellRecover := 65000
                     else
                        aabil.SpellRecover := aabil.SpellRecover + std.EffValue1;
                  end;
               end;
            end;
            if std.EffType2 > 0 then begin
               case std.EffType2 of
                  EFFTYPE_HP_MP_ADD: //HP È¹º¹·®, MP È¸º¹·®
                  begin
                     //HP È¹º¹·®
                     if(aabil.HealthRecover + std.EffRate2 > 65000) then
                        aabil.HealthRecover := 65000
                     else
                        aabil.HealthRecover := aabil.HealthRecover + std.EffRate2;

                     //MP È¹º¹·®
                     if(aabil.SpellRecover + std.EffValue2 > 65000) then
                        aabil.SpellRecover := 65000
                     else
                        aabil.SpellRecover := aabil.SpellRecover + std.EffValue2;
                  end;
               end;
            end;

            // ¿Ê Çà¿îÄ¡ Àû¿ë
            if std.EffType1 = EFFTYPE_LUCK_ADD then begin
               if aabil.Luck + std.EffValue1 > 255 then aabil.Luck := 255
               else aabil.Luck := aabil.Luck + std.EffValue1;   //¿Ê¿¡ ºÙÀº Çà¿î
            end else if std.EffType2 = EFFTYPE_LUCK_ADD then begin
               if aabil.Luck + std.EffValue2 > 255 then aabil.Luck := 255
               else aabil.Luck := aabil.Luck + std.EffValue2;   //¿Ê¿¡ ºÙÀº Çà¿î
            end;

         end;
         15: //Åõ±¸(added by sonmg)
         begin
            aabil.AC := MakeWord (Lobyte(aabil.AC) + Lobyte(std.AC), Hibyte(aabil.AC) + Hibyte(std.AC));
            aabil.MAC := MakeWord (Lobyte(aabil.MAC) + Lobyte(std.MAC), Hibyte(aabil.MAC) + Hibyte(std.MAC));

            aabil.HIT := aabil.HIT + std.Accurate;
            aabil.AntiMagic := aabil.AntiMagic + std.MgAvoid;
            aabil.AntiPoison := aabil.AntiPoison + std.ToxAvoid;
         end;
         19: //¸ñ°ÉÀÌ
         begin
            aabil.AntiMagic := aabil.AntiMagic + Hibyte(std.AC);
            aabil.UnLuck := aabil.UnLuck + Lobyte(std.MAC);
            aabil.Luck := aabil.Luck + Hibyte(std.MAC);

            aabil.HitSpeed := aabil.HitSpeed + std.AtkSpd;
            aabil.HIT := aabil.HIT + std.Accurate;
            aabil.Slowdown := aabil.Slowdown + std.Slowdown;
            aabil.Poison := aabil.Poison + std.Tox;
         end;
         20: //¸ñ°ÉÀÌ
         begin
            aabil.HIT := aabil.HIT + Hibyte(std.AC);
            aabil.SPEED := aabil.SPEED + Hibyte(std.MAC);

            aabil.HitSpeed := aabil.HitSpeed + std.AtkSpd;
            aabil.AntiMagic := aabil.AntiMagic + std.MgAvoid;
            aabil.Slowdown := aabil.Slowdown + std.Slowdown;
            aabil.Poison := aabil.Poison + std.Tox;
         end;
         21: //¸ñ°ÉÀÌ
         begin
            aabil.HealthRecover := aabil.HealthRecover + Hibyte(std.AC);
            aabil.SpellRecover := aabil.SpellRecover + Hibyte(std.MAC);
            aabil.HitSpeed := aabil.HitSpeed + Lobyte(std.AC);
            aabil.HitSpeed := aabil.HitSpeed - Lobyte(std.MAC);

            aabil.HitSpeed := aabil.HitSpeed + std.AtkSpd;
            aabil.HIT := aabil.HIT + std.Accurate;
            aabil.AntiMagic := aabil.AntiMagic + std.MgAvoid;
            aabil.Slowdown := aabil.Slowdown + std.Slowdown;
            aabil.Poison := aabil.Poison + std.Tox;
         end;
         22: //¹ÝÁö
         begin
            aabil.AC := MakeWord (Lobyte(aabil.AC) + Lobyte(std.AC), Hibyte(aabil.AC) + Hibyte(std.AC));
            aabil.MAC := MakeWord (Lobyte(aabil.MAC) + Lobyte(std.MAC), Hibyte(aabil.MAC) + Hibyte(std.MAC));

            aabil.HitSpeed := aabil.HitSpeed + std.AtkSpd;
            aabil.Slowdown := aabil.Slowdown + std.Slowdown;
            aabil.Poison := aabil.Poison + std.Tox;

            //¿ë¾ÆÀÌÅÛ È¿°ú Ãß°¡(sonmg)
            aabil.HIT := aabil.HIT + std.Accurate; //Á¤È®
            aabil.HP := aabil.HP + std.HpAdd;   //HP
         end;
         23: //¹ÝÁö23
         begin
            aabil.AntiPoison := aabil.AntiPoison + Hibyte(std.AC);
            aabil.PoisonRecover := aabil.PoisonRecover + Hibyte(std.MAC);
            aabil.HitSpeed := aabil.HitSpeed + Lobyte(std.AC);
            aabil.HitSpeed := aabil.HitSpeed - Lobyte(std.MAC);

            aabil.HitSpeed := aabil.HitSpeed + std.AtkSpd;
            aabil.Slowdown := aabil.Slowdown + std.Slowdown;
            aabil.Poison := aabil.Poison + std.Tox;
         end;
         24, 26://ÆÈÂî
         begin
            // °­µµ(¹«±â, ÆÈÂî¿¡ Àû¿ë)
            if std.SpecialPwr in [1..10] then
               aabil.WeaponStrong := std.SpecialPwr;  //¹«±âÀÇ °­µµ, °­µµ°¡ ³ôÀ¸¸é Àß ¾È»Ç°³Áü

            case ps.StdMode of
               24: //ÆÈÂî24
               begin
                  aabil.HIT := aabil.HIT + Hibyte(std.AC);
                  aabil.SPEED := aabil.SPEED + Hibyte(std.MAC);
               end;
               26: //ÆÈÂî26(added by sonmg)
               begin
                  aabil.AC := MakeWord (Lobyte(aabil.AC) + Lobyte(std.AC), Hibyte(aabil.AC) + Hibyte(std.AC));
                  aabil.MAC := MakeWord (Lobyte(aabil.MAC) + Lobyte(std.MAC), Hibyte(aabil.MAC) + Hibyte(std.MAC));

                  aabil.HIT := aabil.HIT + std.Accurate;
                  aabil.SPEED := aabil.SPEED + std.Agility;

                  //¿ë¾ÆÀÌÅÛ È¿°ú Ãß°¡(sonmg)
                  aabil.MP := aabil.MP + std.MpAdd;   //MP
               end;
            end;
         end;
         52: //½Å¹ß(sonmg)
         begin
            aabil.AC := MakeWord (Lobyte(aabil.AC) + Lobyte(std.AC), Hibyte(aabil.AC) + Hibyte(std.AC));
            aabil.MAC := MakeWord (Lobyte(aabil.MAC) + Lobyte(std.MAC), Hibyte(aabil.MAC) + Hibyte(std.MAC));

            aabil.SPEED := aabil.SPEED + std.Agility;
         end;
         54: //º§Æ®(sonmg)
         begin
            aabil.AC := MakeWord (Lobyte(aabil.AC) + Lobyte(std.AC), Hibyte(aabil.AC) + Hibyte(std.AC));
            aabil.MAC := MakeWord (Lobyte(aabil.MAC) + Lobyte(std.MAC), Hibyte(aabil.MAC) + Hibyte(std.MAC));

            aabil.HIT := aabil.HIT + std.Accurate;
            aabil.SPEED := aabil.SPEED + std.Agility;
            aabil.AntiPoison := aabil.AntiPoison + std.ToxAvoid;
         end;
         // 2003/03/15 ¾ÆÀÌÅÛ ÀÎº¥Åä¸® È®Àå
         53: //ÊØ»¤Ê¯£¬±¦Ê¯
         begin
            aabil.HP := aabil.HP + std.HpAdd;
            aabil.MP := aabil.MP + std.MpAdd;
         end;
         else begin
            aabil.AC := MakeWord (Lobyte(aabil.AC) + Lobyte(std.AC), Hibyte(aabil.AC) + Hibyte(std.AC));
            aabil.MAC := MakeWord (Lobyte(aabil.MAC) + Lobyte(std.MAC), Hibyte(aabil.MAC) + Hibyte(std.MAC));
         end;
      end;
      aabil.DC := MakeWord (Lobyte(aabil.DC) + Lobyte(std.DC), _MIN(255, Hibyte(aabil.DC) + Hibyte(std.DC)));
      aabil.MC := MakeWord (Lobyte(aabil.MC) + Lobyte(std.MC), _MIN(255, Hibyte(aabil.MC) + Hibyte(std.MC)));
      aabil.SC := MakeWord (Lobyte(aabil.SC) + Lobyte(std.SC), _MIN(255, Hibyte(aabil.SC) + Hibyte(std.SC)));
   end;
end;

////////////////////////////////////////////////////////////////////////////
// Á÷¾÷¿¡ µû¸¥ ¿ë ¾ÆÀÌÅÛ ´É·ÂÄ¡ Â÷º° Àû¿ë
procedure TCreature.ApplyItemParametersByJob (uitem: TUserItem; var std: TStdItem);
var
   ps: PTStdItem;
begin
   ps := UserEngine.GetStdItem (uitem.Index);
   if ps <> nil then begin

   // ÁÖÀÇ : ChangeItemByJob °ú µ¿ÀÏÇÑ °ªÀ» °¡Á®¾ß ÇÔ(sonmg)

      //////////////////////////////////////
      //--------------
      //¹ÝÁö
      if (ps.StdMode = 22) and (ps.Shape = DRAGON_RING_SHAPE) then begin
         case Job of
         0: //Àü»ç
            begin
               std.DC := MakeWord (Lobyte(std.DC), _MIN(255, Hibyte(std.DC) + 4));   //ÇÏµåÄÚµù
               std.MC := 0;
               std.SC := 0;
            end;
         1: //¼ú»ç
            begin
               std.DC := 0;
//±×´ë·Î               std.MC := 0;
               std.SC := 0;
            end;
         2: //µµ»ç
            begin
//               std.DC := 0;
               std.MC := 0;
//               std.SC := 0;
            end;
         end;//case
      //--------------
      //ÆÈÂî26
      end else if (ps.StdMode = 26) and (ps.Shape = DRAGON_BRACELET_SHAPE) then begin
         case Job of
         0: //Àü»ç
            begin
               std.DC := MakeWord (Lobyte(std.DC) + 1, _MIN(255, Hibyte(std.DC) + 2));   //ÇÏµåÄÚµù
               std.MC := 0;
               std.SC := 0;
               std.AC := MakeWord (Lobyte(std.AC), _MIN(255, Hibyte(std.AC) + 1));   //ÇÏµåÄÚµù
            end;
         1: //¼ú»ç
            begin
               std.DC := 0;
//               std.MC := 0;
               std.SC := 0;
               std.AC := MakeWord (Lobyte(std.AC), _MIN(255, Hibyte(std.AC) + 1));   //ÇÏµåÄÚµù
            end;
         2: //µµ»ç
            begin
//               std.DC := 0;
               std.MC := 0;
//               std.SC := 0;
//               std.AC := 0;
            end;
         end;//case
      //--------------
      //¸ñ°ÉÀÌ
      end else if (ps.StdMode = 19) and (ps.Shape = DRAGON_NECKLACE_SHAPE) then begin
         case Job of
         0: //Àü»ç
            begin
//               std.DC := 0;
               std.MC := 0;
               std.SC := 0;
            end;
         1: //¼ú»ç
            begin
               std.DC := 0;
//               std.MC := 0;
               std.SC := 0;
            end;
         2: //µµ»ç
            begin
               std.DC := 0;
               std.MC := 0;
//               std.SC := 0;
            end;
         end;//case
      //--------------
      //¿Ê
      end else if ((ps.StdMode = 10) or (ps.StdMode = 11)) and (ps.Shape = DRAGON_DRESS_SHAPE) then begin
         case Job of
         0: //Àü»ç
            begin
//               std.DC := 0;
               std.MC := 0;
               std.SC := 0;
            end;
         1: //¼ú»ç
            begin
               std.DC := 0;
//               std.MC := 0;
               std.SC := 0;
            end;
         2: //µµ»ç
            begin
               std.DC := 0;
               std.MC := 0;
//               std.SC := 0;
            end;
         end;//case
      //--------------
      //Åõ±¸
      end else if (ps.StdMode = 15) and (ps.Shape = DRAGON_HELMET_SHAPE) then begin
         case Job of
         0: //Àü»ç
            begin
//               std.DC := 0;
               std.MC := 0;
               std.SC := 0;
            end;
         1: //¼ú»ç
            begin
               std.DC := 0;
//               std.MC := 0;
               std.SC := 0;
            end;
         2: //µµ»ç
            begin
               std.DC := 0;
               std.MC := 0;
//               std.SC := 0;
            end;
         end;//case
      //--------------
      //¹«±â
      end else if ((ps.StdMode = 5) or (ps.StdMode = 6)) and (ps.Shape = DRAGON_WEAPON_SHAPE) then begin
         case Job of
         0: //Àü»ç
            begin
               std.DC := MakeWord (Lobyte(std.DC) + 1, _MIN(255, Hibyte(std.DC) + 28));   //ÇÏµåÄÚµù
               std.MC := 0;
               std.SC := 0;
               // Çà¿î¿¡¼­ 2¸¦ »«´Ù. Áï, Lo(AC)¿¡¼­ 2¸¦ »«´Ù.
               std.AC := MakeWord(LOBYTE(std.AC) -2, HIBYTE(std.AC));

               // Çà¿îÀ» °ø¼ÓÀ¸·Î ¹Ù²Ù°í Çà¿îÀ» ¾ø¾Ø´Ù.
               // Lo(AC)¸¦ Hi(MAC)¿¡ Áý¾î ³Ö´Â´Ù.
//               std.MAC := MakeWord(LOBYTE(std.MAC), LOBYTE(std.AC) + 10);
//               std.AC := MakeWord(0, HIBYTE(std.AC));
            end;
         1: //¼ú»ç
            begin
//               std.DC := 0;
//               std.MC := 0;
               std.SC := 0;
               // °ø¼Ó¿¡¼­ 12¸¦ »©°í Çà¿î°ªÀº ¹Ý¿µÇÑ´Ù.
               if HIBYTE(std.MAC) > 12 then
                  std.MAC := MakeWord(LOBYTE(std.MAC), HIBYTE(std.MAC) - 12)
               else
                  std.MAC := MakeWord(LOBYTE(std.MAC), 0);

            end;
         2: //µµ»ç
            begin
               std.DC := MakeWord (Lobyte(std.DC) + 2, _MIN(255, Hibyte(std.DC) + 10));   //ÇÏµåÄÚµù
               std.MC := 0;
//               std.SC := 0;
               // Çà¿î¿¡¼­ 2¸¦ »«´Ù. Áï, Lo(AC)¿¡¼­ 2¸¦ »«´Ù.
               std.AC := MakeWord(LOBYTE(std.AC) -2, HIBYTE(std.AC));

               // Çà¿îÀ» °ø¼ÓÀ¸·Î ¹Ù²Ù°í Çà¿îÀ» ¾ø¾Ø´Ù.
               // Lo(AC)¸¦ Hi(MAC)¿¡ Áý¾î ³Ö´Â´Ù.
//               std.MAC := MakeWord(LOBYTE(std.MAC), LOBYTE(std.AC) + 10);
//               std.AC := MakeWord(0, HIBYTE(std.AC));
            end;
         end;//case
      //--------------
      //¼öÈ£¼®(¸·´ë»çÅÁ)
      end else if (ps.StdMode = 53) then begin
         if (ps.Shape = LOLLIPOP_SHAPE) then begin
            case Job of
            0: //Àü»ç
               begin
                  std.DC := MakeWord (Lobyte(std.DC), _MIN(255, Hibyte(std.DC) + 2));  //ÇÏµåÄÚµù
                  std.MC := 0;
                  std.SC := 0;
               end;
            1: //¼ú»ç
               begin
                  std.DC := 0;
                  std.MC := MakeWord (Lobyte(std.MC), _MIN(255, Hibyte(std.MC) + 2));  //ÇÏµåÄÚµù
                  std.SC := 0;
               end;
            2: //µµ»ç
               begin
                  std.DC := 0;
                  std.MC := 0;
                  std.SC := MakeWord (Lobyte(std.SC), _MIN(255, Hibyte(std.SC) + 2));  //ÇÏµåÄÚµù
               end;
            end;//case
         end else if (std.Shape = GOLDMEDAL_SHAPE) or (std.Shape = SILVERMEDAL_SHAPE) or (std.Shape = BRONZEMEDAL_SHAPE) then begin
            case Job of
            0: //Àü»ç
               begin
                  std.DC := MakeWord (Lobyte(std.DC), _MIN(255, Hibyte(std.DC)));
                  std.MC := 0;
                  std.SC := 0;
               end;
            1: //¼ú»ç
               begin
                  std.DC := 0;
                  std.MC := MakeWord (Lobyte(std.MC), _MIN(255, Hibyte(std.MC)));
                  std.SC := 0;
               end;
            2: //µµ»ç
               begin
                  std.DC := 0;
                  std.MC := 0;
                  std.SC := MakeWord (Lobyte(std.SC), _MIN(255, Hibyte(std.SC)));
               end;
            end;//case
         end;
      end;//if series
      //////////////////////////////////////
      // 2004-06-29 ½Å±Ô°©¿Ê(ÆÄÈ²Ãµ¸¶ÀÇ) Á÷¾÷º° ´É·ÂÄ¡
      if ((ps.StdMode = 10) or (ps.StdMode = 11)) and (ps.Shape = DRESS_SHAPE_PBKING) then begin
         case Job of
         0: //Àü»ç
            begin
               std.DC := MakeWord (Lobyte(std.DC), _MIN(255, Hibyte(std.DC) + 2));   //ÇÏµåÄÚµù
               std.MC := 0;
               std.SC := 0;
               std.AC := MakeWord (Lobyte(std.AC) + 2, _MIN(255, Hibyte(std.AC) + 4));   //ÇÏµåÄÚµù
//               std.MAC := 0;
               std.MpAdd := std.MpAdd + 30;   //ÇÏµåÄÚµù
            end;
         1: //¼ú»ç
            begin
               std.DC := 0;
//               std.MC := 0;
               std.SC := 0;
//               std.AC := 0;
               std.MAC := MakeWord (Lobyte(std.MAC) + 1, _MIN(255, Hibyte(std.MAC) + 2));   //ÇÏµåÄÚµù
               std.HpAdd := std.HpAdd + 30;   //ÇÏµåÄÚµù
            end;
         2: //µµ»ç
            begin
               std.DC := MakeWord (Lobyte(std.DC) + 1, _MIN(255, Hibyte(std.DC)));   //ÇÏµåÄÚµù
               std.MC := 0;
//               std.SC := 0;
               std.AC := MakeWord (Lobyte(std.AC) + 1, _MIN(255, Hibyte(std.AC)));   //ÇÏµåÄÚµù
               std.MAC := MakeWord (Lobyte(std.MAC) + 1, _MIN(255, Hibyte(std.MAC)));   //ÇÏµåÄÚµù
               std.HpAdd := std.HpAdd + 20;   //ÇÏµåÄÚµù
               std.MpAdd := std.MpAdd + 10;   //ÇÏµåÄÚµù
            end;
         end;//case
      end;

   end;//if
end;

procedure TCreature.BanjjakApplyItemParametersByJob (uitem: TUserItem; var std: TStdItem; lv: integer);
var
   ps: PTStdItem;
begin
   ps := UserEngine.GetStdItem (uitem.Index);
   if ps <> nil then begin

   // ÁÖÀÇ : BanjjakChangeItemByJob °ú µ¿ÀÏÇÑ °ªÀ» °¡Á®¾ß ÇÔ(sonmg)

{
      //////////////////////////////////////
      //--------------
      //¹ÝÁö
      if (ps.StdMode = 22) and (ps.Shape = DRAGON_RING_SHAPE) then begin
         case Job of
         0: //Àü»ç
            begin
               std.DC := MakeWord (Lobyte(std.DC), _MIN(255, Hibyte(std.DC) + 4));   //ÇÏµåÄÚµù
               std.MC := 0;
               std.SC := 0;
            end;
         1: //¼ú»ç
            begin
               std.DC := 0;
//±×´ë·Î               std.MC := 0;
               std.SC := 0;
            end;
         2: //µµ»ç
            begin
//               std.DC := 0;
               std.MC := 0;
//               std.SC := 0;
            end;
         end;//case
      //--------------
      //ÆÈÂî26
      end else if (ps.StdMode = 26) and (ps.Shape = DRAGON_BRACELET_SHAPE) then begin
         case Job of
         0: //Àü»ç
            begin
               std.DC := MakeWord (Lobyte(std.DC) + 1, _MIN(255, Hibyte(std.DC) + 2));   //ÇÏµåÄÚµù
               std.MC := 0;
               std.SC := 0;
               std.AC := MakeWord (Lobyte(std.AC), _MIN(255, Hibyte(std.AC) + 1));   //ÇÏµåÄÚµù
            end;
         1: //¼ú»ç
            begin
               std.DC := 0;
//               std.MC := 0;
               std.SC := 0;
               std.AC := MakeWord (Lobyte(std.AC), _MIN(255, Hibyte(std.AC) + 1));   //ÇÏµåÄÚµù
            end;
         2: //µµ»ç
            begin
//               std.DC := 0;
               std.MC := 0;
//               std.SC := 0;
//               std.AC := 0;
            end;
         end;//case
      //--------------
      //¸ñ°ÉÀÌ
      end else if (ps.StdMode = 19) and (ps.Shape = DRAGON_NECKLACE_SHAPE) then begin
         case Job of
         0: //Àü»ç
            begin
//               std.DC := 0;
               std.MC := 0;
               std.SC := 0;
            end;
         1: //¼ú»ç
            begin
               std.DC := 0;
//               std.MC := 0;
               std.SC := 0;
            end;
         2: //µµ»ç
            begin
               std.DC := 0;
               std.MC := 0;
//               std.SC := 0;
            end;
         end;//case
      //--------------
      //Åõ±¸
      end else if (ps.StdMode = 15) and (ps.Shape = DRAGON_HELMET_SHAPE) then begin
         case Job of
         0: //Àü»ç
            begin
//               std.DC := 0;
               std.MC := 0;
               std.SC := 0;
            end;
         1: //¼ú»ç
            begin
               std.DC := 0;
//               std.MC := 0;
               std.SC := 0;
            end;
         2: //µµ»ç
            begin
               std.DC := 0;
               std.MC := 0;
//               std.SC := 0;
            end;
         end;//case
      //--------------
      //¿Ê
      end else } if ((ps.StdMode = 10) or (ps.StdMode = 11)) and (ps.Shape = DRAGON_DRESS_SHAPE) then begin
         //¹ÝÂ¦ÀÌº¥Æ® 3Â÷
         case Job of
         0: //Àü»ç
            begin
               //°øÅëÀû¿ë
               std.MC := 0;
               std.SC := 0;

               //50ÀÌÇÏ °øÅë Àû¿ë
               if lv < 50 then begin
                  // HPÈ¸º¹·®, MPÈ¸º¹·® ±â´É »èÁ¦
                  if std.EffType1 > 0 then begin
                     case std.EffType1 of
                        EFFTYPE_HP_MP_ADD: //HP È¹º¹·®, MP È¸º¹·®
                        begin
                           //±â´É ÀÚÃ¼¸¦ ¾ø¾Ú
                           std.EffType1 := 0;
                           //HP È¹º¹·®
                           std.EffRate1 := 0;
                           //MP È¹º¹·®
                           std.EffValue1 := 0;
                        end;
                     end;
                  end;
                  if std.EffType2 > 0 then begin
                     case std.EffType2 of
                        EFFTYPE_HP_MP_ADD: //HP È¹º¹·®, MP È¸º¹·®
                        begin
                           //±â´É ÀÚÃ¼¸¦ ¾ø¾Ú
                           std.EffType2 := 0;
                           //HP È¹º¹·®
                           std.EffRate2 := 0;
                           //MP È¹º¹·®
                           std.EffValue2 := 0;
                        end;
                     end;
                  end;
               end;

               //·¹º§º° Àû¿ë
               if lv < 30 then begin
                  //±âº»°ª
               end else if lv < 40 then begin
                  std.DC := MakeWord (Lobyte(std.DC), _MIN(255, Hibyte(std.DC) + 1));   //ÇÏµåÄÚµù
                  std.AC := MakeWord (Lobyte(std.AC) + 2, _MIN(255, Hibyte(std.AC) + 3));   //ÇÏµåÄÚµù
                  std.MAC := MakeWord (Lobyte(std.MAC) + 1, _MIN(255, Hibyte(std.MAC) + 3));   //ÇÏµåÄÚµù
               end else if lv < 50 then begin
                  std.DC := MakeWord (Lobyte(std.DC) + 1, _MIN(255, Hibyte(std.DC) + 2));   //ÇÏµåÄÚµù
                  std.AC := MakeWord (Lobyte(std.AC) + 5, _MIN(255, Hibyte(std.AC) + 6));   //ÇÏµåÄÚµù
                  std.MAC := MakeWord (Lobyte(std.MAC) + 2, _MIN(255, Hibyte(std.MAC) + 4));   //ÇÏµåÄÚµù
               end else begin
                  std.DC := MakeWord (Lobyte(std.DC) + 1, _MIN(255, Hibyte(std.DC) + 3));   //ÇÏµåÄÚµù
                  std.AC := MakeWord (Lobyte(std.AC) + 8, _MIN(255, Hibyte(std.AC) + 9));   //ÇÏµåÄÚµù
                  std.MAC := MakeWord (Lobyte(std.MAC) + 2, _MIN(255, Hibyte(std.MAC) + 7));   //ÇÏµåÄÚµù
               end;
            end;
         1: //¼ú»ç
            begin
               //°øÅëÀû¿ë
               std.DC := 0;
               std.SC := 0;

               //50ÀÌÇÏ °øÅë Àû¿ë
               if lv < 50 then begin
                  // HPÈ¸º¹·®, MPÈ¸º¹·® ±â´É »èÁ¦
                  if std.EffType1 > 0 then begin
                     case std.EffType1 of
                        EFFTYPE_HP_MP_ADD: //HP È¹º¹·®, MP È¸º¹·®
                        begin
                           //±â´É ÀÚÃ¼¸¦ ¾ø¾Ú
                           std.EffType1 := 0;
                           //HP È¹º¹·®
                           std.EffRate1 := 0;
                           //MP È¹º¹·®
                           std.EffValue1 := 0;
                        end;
                     end;
                  end;
                  if std.EffType2 > 0 then begin
                     case std.EffType2 of
                        EFFTYPE_HP_MP_ADD: //HP È¹º¹·®, MP È¸º¹·®
                        begin
                           //±â´É ÀÚÃ¼¸¦ ¾ø¾Ú
                           std.EffType2 := 0;
                           //HP È¹º¹·®
                           std.EffRate2 := 0;
                           //MP È¹º¹·®
                           std.EffValue2 := 0;
                        end;
                     end;
                  end;
               end;

               //·¹º§º° Àû¿ë
               if lv < 30 then begin
                  //±âº»°ª
               end else if lv < 40 then begin
                  std.MC := MakeWord (Lobyte(std.MC), _MIN(255, Hibyte(std.MC) + 2));   //ÇÏµåÄÚµù
                  std.AC := MakeWord (Lobyte(std.AC) + 2, _MIN(255, Hibyte(std.AC) + 3));   //ÇÏµåÄÚµù
                  std.MAC := MakeWord (Lobyte(std.MAC) + 1, _MIN(255, Hibyte(std.MAC) + 3));   //ÇÏµåÄÚµù
               end else if lv < 50 then begin
                  std.MC := MakeWord (Lobyte(std.MC) + 1, _MIN(255, Hibyte(std.MC) + 4));   //ÇÏµåÄÚµù
                  std.AC := MakeWord (Lobyte(std.AC) + 5, _MIN(255, Hibyte(std.AC) + 6));   //ÇÏµåÄÚµù
                  std.MAC := MakeWord (Lobyte(std.MAC) + 2, _MIN(255, Hibyte(std.MAC) + 4));   //ÇÏµåÄÚµù
               end else begin
                  std.MC := MakeWord (Lobyte(std.MC) + 1, _MIN(255, Hibyte(std.MC) + 6));   //ÇÏµåÄÚµù
                  std.AC := MakeWord (Lobyte(std.AC) + 8, _MIN(255, Hibyte(std.AC) + 9));   //ÇÏµåÄÚµù
                  std.MAC := MakeWord (Lobyte(std.MAC) + 2, _MIN(255, Hibyte(std.MAC) + 7));   //ÇÏµåÄÚµù
               end;
            end;
         2: //µµ»ç
            begin
               //°øÅëÀû¿ë
               std.DC := 0;
               std.MC := 0;

               //50ÀÌÇÏ °øÅë Àû¿ë
               if lv < 50 then begin
                  // HPÈ¸º¹·®, MPÈ¸º¹·® ±â´É »èÁ¦
                  if std.EffType1 > 0 then begin
                     case std.EffType1 of
                        EFFTYPE_HP_MP_ADD: //HP È¹º¹·®, MP È¸º¹·®
                        begin
                           //±â´É ÀÚÃ¼¸¦ ¾ø¾Ú
                           std.EffType1 := 0;
                           //HP È¹º¹·®
                           std.EffRate1 := 0;
                           //MP È¹º¹·®
                           std.EffValue1 := 0;
                        end;
                     end;
                  end;
                  if std.EffType2 > 0 then begin
                     case std.EffType2 of
                        EFFTYPE_HP_MP_ADD: //HP È¹º¹·®, MP È¸º¹·®
                        begin
                           //±â´É ÀÚÃ¼¸¦ ¾ø¾Ú
                           std.EffType2 := 0;
                           //HP È¹º¹·®
                           std.EffRate2 := 0;
                           //MP È¹º¹·®
                           std.EffValue2 := 0;
                        end;
                     end;
                  end;
               end;

               //·¹º§º° Àû¿ë
               if lv < 30 then begin
                  //±âº»°ª
               end else if lv < 40 then begin
                  std.SC := MakeWord (Lobyte(std.SC), _MIN(255, Hibyte(std.SC) + 2));   //ÇÏµåÄÚµù
                  std.AC := MakeWord (Lobyte(std.AC) + 2, _MIN(255, Hibyte(std.AC) + 3));   //ÇÏµåÄÚµù
                  std.MAC := MakeWord (Lobyte(std.MAC) + 1, _MIN(255, Hibyte(std.MAC) + 3));   //ÇÏµåÄÚµù
               end else if lv < 50 then begin
                  std.SC := MakeWord (Lobyte(std.SC) + 1, _MIN(255, Hibyte(std.SC) + 4));   //ÇÏµåÄÚµù
                  std.AC := MakeWord (Lobyte(std.AC) + 5, _MIN(255, Hibyte(std.AC) + 6));   //ÇÏµåÄÚµù
                  std.MAC := MakeWord (Lobyte(std.MAC) + 2, _MIN(255, Hibyte(std.MAC) + 4));   //ÇÏµåÄÚµù
               end else begin
                  std.SC := MakeWord (Lobyte(std.SC) + 1, _MIN(255, Hibyte(std.SC) + 6));   //ÇÏµåÄÚµù
                  std.AC := MakeWord (Lobyte(std.AC) + 8, _MIN(255, Hibyte(std.AC) + 9));   //ÇÏµåÄÚµù
                  std.MAC := MakeWord (Lobyte(std.MAC) + 2, _MIN(255, Hibyte(std.MAC) + 7));   //ÇÏµåÄÚµù
               end;
            end;
         end;//case
      //--------------
      //¹«±â
      end else if ((ps.StdMode = 5) or (ps.StdMode = 6)) and (ps.Shape = DRAGON_WEAPON_SHAPE) then begin
         //»¡°»ÀÌ´Â ÀúÁÖ ºÙÀ½.
         if PKLevel >= 2 then begin
            std.MAC := std.MAC + MakeWord(10,0);  //ÀúÁÖ
         end;
         //¹ÝÂ¦ÀÌº¥Æ® 3Â÷
         case Job of
         0: //Àü»ç
            begin
               //°øÅëÀû¿ë
               std.MC := 0;
               std.SC := 0;
               // Çà¿î¿¡¼­ 2¸¦ »«´Ù. Áï, Lo(AC)¿¡¼­ 2¸¦ »«´Ù.
               std.AC := MakeWord(LOBYTE(std.AC) -2, HIBYTE(std.AC));

               //50ÀÌÇÏ °øÅë Àû¿ë
               if lv < 50 then begin
                  // °ø¼Ó¿¡¼­ 12¸¦ »«´Ù.
                  if HIBYTE(std.MAC) > 12 then
                     std.MAC := MakeWord(LOBYTE(std.MAC), HIBYTE(std.MAC) - 12)
                  else
                     std.MAC := MakeWord(LOBYTE(std.MAC), 0);
               end;

               //·¹º§º° Àû¿ë
               if lv < 30 then begin
                  std.DC := MakeWord (Lobyte(std.DC) - 1, _MIN(255, Hibyte(std.DC) + 11));   //ÇÏµåÄÚµù
               end else if lv < 40 then begin
                  std.DC := MakeWord (Lobyte(std.DC), _MIN(255, Hibyte(std.DC) + 17));   //ÇÏµåÄÚµù
               end else if lv < 50 then begin
                  std.DC := MakeWord (Lobyte(std.DC) + 1, _MIN(255, Hibyte(std.DC) + 24));   //ÇÏµåÄÚµù
               end else begin
                  std.DC := MakeWord (Lobyte(std.DC) + 2, _MIN(255, Hibyte(std.DC) + 32));   //ÇÏµåÄÚµù
               end;
            end;
         1: //¼ú»ç
            begin
               //°øÅëÀû¿ë
               std.SC := 0;
               // °ø¼Ó¿¡¼­ 12¸¦ »«´Ù.
               if HIBYTE(std.MAC) > 12 then
                  std.MAC := MakeWord(LOBYTE(std.MAC), HIBYTE(std.MAC) - 12)
               else
                  std.MAC := MakeWord(LOBYTE(std.MAC), 0);

               //50ÀÌÇÏ °øÅë Àû¿ë
               if lv < 50 then begin
                  // Çà¿î¿¡¼­ 2¸¦ »«´Ù. Áï, Lo(AC)¿¡¼­ 2¸¦ »«´Ù.
                  std.AC := MakeWord(LOBYTE(std.AC) -2, HIBYTE(std.AC));
               end;

               //·¹º§º° Àû¿ë
               if lv < 30 then begin
                  //±âº»°ª
               end else if lv < 40 then begin
                  std.DC := MakeWord (Lobyte(std.DC) + 1, _MIN(255, Hibyte(std.DC) + 1));   //ÇÏµåÄÚµù
                  std.MC := MakeWord (Lobyte(std.MC) + 1, _MIN(255, Hibyte(std.MC) + 2));  //ÇÏµåÄÚµù
               end else if lv < 50 then begin
                  std.DC := MakeWord (Lobyte(std.DC) + 2, _MIN(255, Hibyte(std.DC) + 2));   //ÇÏµåÄÚµù
                  std.MC := MakeWord (Lobyte(std.MC) + 1, _MIN(255, Hibyte(std.MC) + 4));  //ÇÏµåÄÚµù
               end else begin
                  std.DC := MakeWord (Lobyte(std.DC) + 3, _MIN(255, Hibyte(std.DC) + 4));   //ÇÏµåÄÚµù
                  std.MC := MakeWord (Lobyte(std.MC) + 2, _MIN(255, Hibyte(std.MC) + 7));  //ÇÏµåÄÚµù
               end;
            end;
         2: //µµ»ç
            begin
               //°øÅëÀû¿ë
               std.MC := 0;
               // Çà¿î¿¡¼­ 2¸¦ »«´Ù. Áï, Lo(AC)¿¡¼­ 2¸¦ »«´Ù.
               std.AC := MakeWord(LOBYTE(std.AC) -2, HIBYTE(std.AC));

               //50ÀÌÇÏ °øÅë Àû¿ë
               if lv < 50 then begin
                  // °ø¼Ó¿¡¼­ 12¸¦ »«´Ù.
                  if HIBYTE(std.MAC) > 12 then
                     std.MAC := MakeWord(LOBYTE(std.MAC), HIBYTE(std.MAC) - 12)
                  else
                     std.MAC := MakeWord(LOBYTE(std.MAC), 0);
               end;

               //·¹º§º° Àû¿ë
               if lv < 30 then begin
                  std.DC := MakeWord (Lobyte(std.DC) + 1, _MIN(255, Hibyte(std.DC) - 2));   //ÇÏµåÄÚµù
               end else if lv < 40 then begin
                  std.DC := MakeWord (Lobyte(std.DC) + 2, _MIN(255, Hibyte(std.DC) + 2));   //ÇÏµåÄÚµù
                  std.SC := MakeWord (Lobyte(std.SC), _MIN(255, Hibyte(std.SC) + 2));  //ÇÏµåÄÚµù
               end else if lv < 50 then begin
                  std.DC := MakeWord (Lobyte(std.DC) + 3, _MIN(255, Hibyte(std.DC) + 6));   //ÇÏµåÄÚµù
                  std.SC := MakeWord (Lobyte(std.SC) + 1, _MIN(255, Hibyte(std.SC) + 3));  //ÇÏµåÄÚµù
               end else begin
                  std.DC := MakeWord (Lobyte(std.DC) + 4, _MIN(255, Hibyte(std.DC) + 12));   //ÇÏµåÄÚµù
                  std.SC := MakeWord (Lobyte(std.SC) + 2, _MIN(255, Hibyte(std.SC) + 6));  //ÇÏµåÄÚµù
               end;
            end;
         end;//case
{
      //--------------
      //¼öÈ£¼®(¸·´ë»çÅÁ)
      end else if (ps.stdMode = 53) then begin
         if (ps.Shape = LOLLIPOP_SHAPE) then begin
            case Job of
            0: //Àü»ç
               begin
                  std.DC := MakeWord (Lobyte(std.DC), _MIN(255, Hibyte(std.DC) + 2));  //ÇÏµåÄÚµù
                  std.MC := 0;
                  std.SC := 0;
               end;
            1: //¼ú»ç
               begin
                  std.DC := 0;
                  std.MC := MakeWord (Lobyte(std.MC), _MIN(255, Hibyte(std.MC) + 2));  //ÇÏµåÄÚµù
                  std.SC := 0;
               end;
            2: //µµ»ç
               begin
                  std.DC := 0;
                  std.MC := 0;
                  std.SC := MakeWord (Lobyte(std.SC), _MIN(255, Hibyte(std.SC) + 2));  //ÇÏµåÄÚµù
               end;
            end;//case
         end else if (std.Shape = GOLDMEDAL_SHAPE) or (std.Shape = SILVERMEDAL_SHAPE) or (std.Shape = BRONZEMEDAL_SHAPE) then begin
            case Job of
            0: //Àü»ç
               begin
                  std.DC := MakeWord (Lobyte(std.DC), _MIN(255, Hibyte(std.DC)));
                  std.MC := 0;
                  std.SC := 0;
               end;
            1: //¼ú»ç
               begin
                  std.DC := 0;
                  std.MC := MakeWord (Lobyte(std.MC), _MIN(255, Hibyte(std.MC)));
                  std.SC := 0;
               end;
            2: //µµ»ç
               begin
                  std.DC := 0;
                  std.MC := 0;
                  std.SC := MakeWord (Lobyte(std.SC), _MIN(255, Hibyte(std.SC)));
               end;
            end;//case
         end;
      end;//if series
      //////////////////////////////////////
      // 2004-06-29 ½Å±Ô°©¿Ê(ÆÄÈ²Ãµ¸¶ÀÇ) Á÷¾÷º° ´É·ÂÄ¡
      if ((ps.StdMode = 10) or (ps.StdMode = 11)) and (ps.Shape = DRESS_SHAPE_PBKING) then begin
         case Job of
         0: //Àü»ç
            begin
               std.DC := MakeWord (Lobyte(std.DC), _MIN(255, Hibyte(std.DC) + 2));   //ÇÏµåÄÚµù
               std.MC := 0;
               std.SC := 0;
               std.AC := MakeWord (Lobyte(std.AC) + 2, _MIN(255, Hibyte(std.AC) + 4));   //ÇÏµåÄÚµù
//               std.MAC := 0;
               std.MpAdd := std.MpAdd + 30;   //ÇÏµåÄÚµù
            end;
         1: //¼ú»ç
            begin
               std.DC := 0;
//               std.MC := 0;
               std.SC := 0;
//               std.AC := 0;
               std.MAC := MakeWord (Lobyte(std.MAC) + 1, _MIN(255, Hibyte(std.MAC) + 2));   //ÇÏµåÄÚµù
               std.HpAdd := std.HpAdd + 30;   //ÇÏµåÄÚµù
            end;
         2: //µµ»ç
            begin
               std.DC := MakeWord (Lobyte(std.DC) + 1, _MIN(255, Hibyte(std.DC)));   //ÇÏµåÄÚµù
               std.MC := 0;
//               std.SC := 0;
               std.AC := MakeWord (Lobyte(std.AC) + 1, _MIN(255, Hibyte(std.AC)));   //ÇÏµåÄÚµù
               std.MAC := MakeWord (Lobyte(std.MAC) + 1, _MIN(255, Hibyte(std.MAC)));   //ÇÏµåÄÚµù
               std.HpAdd := std.HpAdd + 20;   //ÇÏµåÄÚµù
               std.MpAdd := std.MpAdd + 10;   //ÇÏµåÄÚµù
            end;
         end;//case
}
      end;

   end;//if
end;

// 2003/03/15 ¾ÆÀÌÅÛ ÀÎº¥Åä¸® È®Àå
procedure  TCreature.ApplyItemParametersEx (uitem: TUserItem; var AWabil: TAbility);
var
   ps: PTStdItem;
   std: TStdItem;
begin
   ps := UserEngine.GetStdItem (uitem.Index);
   if ps <> nil then begin
      std := ps^;
      ItemMan.GetUpgradeStdItem (uitem, std); //¹«±âÀÇ ¾÷±×·¹ÀÌµåµÈ ´É·ÂÄ¡¸¦ ¾ò¾î¿Â´Ù.
      case ps.StdMode of
         52: //½Å¹ß·ù
         begin
            if std.EffType1 > 0 then begin
               case std.EffType1 of
                  EFFTYPE_TWOHAND_WEHIGHT_ADD:
                    if(AWabil.MaxHandWeight + std.EffValue1 > 255) then AWabil.MaxHandWeight := 255
                     else AWabil.MaxHandWeight := AWabil.MaxHandWeight + std.EffValue1;
                  // Overflow ¹æÁö¸¦ À§ÇØ ¼öÁ¤(sonmg)
                  EFFTYPE_EQUIP_WHEIGHT_ADD:
                    if(AWabil.MaxWearWeight + std.EffValue1 > 255) then AWabil.MaxWearWeight := 255
                     else AWabil.MaxWearWeight := AWabil.MaxWearWeight + std.EffValue1;
               end;
            end;
            if std.EffType2 > 0 then begin
               case std.EffType2 of
                  EFFTYPE_TWOHAND_WEHIGHT_ADD:
                    if(AWabil.MaxHandWeight + std.EffValue2 > 255) then AWabil.MaxHandWeight := 255
                     else AWabil.MaxHandWeight := AWabil.MaxHandWeight + std.EffValue2;
                  // Overflow ¹æÁö¸¦ À§ÇØ ¼öÁ¤(sonmg)
                  EFFTYPE_EQUIP_WHEIGHT_ADD:
                    if(AWabil.MaxWearWeight + std.EffValue2 > 255) then AWabil.MaxWearWeight := 255
                     else AWabil.MaxWearWeight := AWabil.MaxWearWeight + std.EffValue2;
               end;
            end;
         end;
         54: //º§Æ®         2022/12/24ÐÞ¸Ä
         begin
            if std.EffType1 > 0 then begin
               case std.EffType1 of
                  EFFTYPE_BAG_WHIGHT_ADD:
                    if(AWabil.MaxWeight + std.EffValue1 > 65000) then AWabil.MaxWeight := 65000
                     else AWabil.MaxWeight := AWabil.MaxWeight + std.EffValue1;
               end;
            end;
            if std.EffType2 > 0 then begin
               case std.EffType2 of
                  EFFTYPE_BAG_WHIGHT_ADD:
                    if(AWabil.MaxWeight + std.EffValue2 > 65000) then AWabil.MaxWeight := 65000
                     else AWabil.MaxWeight := AWabil.MaxWeight + std.EffValue2;
               end;
            end;
        // end;
        // begin
            if std.EffType1 > 0 then begin
               case std.EffType1 of
                  EFFTYPE_TWOHAND_WEHIGHT_ADD:
                    if(AWabil.MaxHandWeight + std.EffValue1 > 255) then AWabil.MaxHandWeight := 255
                     else AWabil.MaxHandWeight := AWabil.MaxHandWeight + std.EffValue1;
                  // Overflow ¹æÁö¸¦ À§ÇØ ¼öÁ¤(sonmg)
                  EFFTYPE_EQUIP_WHEIGHT_ADD:
                    if(AWabil.MaxWearWeight + std.EffValue1 > 255) then AWabil.MaxWearWeight := 255
                     else AWabil.MaxWearWeight := AWabil.MaxWearWeight + std.EffValue1;
               end;
            end;
            if std.EffType2 > 0 then begin
               case std.EffType2 of
                  EFFTYPE_TWOHAND_WEHIGHT_ADD:
                    if(AWabil.MaxHandWeight + std.EffValue2 > 255) then AWabil.MaxHandWeight := 255
                     else AWabil.MaxHandWeight := AWabil.MaxHandWeight + std.EffValue2;
                  // Overflow ¹æÁö¸¦ À§ÇØ ¼öÁ¤(sonmg)
                  EFFTYPE_EQUIP_WHEIGHT_ADD:
                    if(AWabil.MaxWearWeight + std.EffValue2 > 255) then AWabil.MaxWearWeight := 255
                     else AWabil.MaxWearWeight := AWabil.MaxWearWeight + std.EffValue2;
               end;
            end;
         end;
      end; //case
   end;
end;

function  TCreature.MakeWeaponUnlock : Boolean;
var
   hum: TUserHuman;
begin
   Result := FALSE;

   if UseItems[U_WEAPON].Index <> 0 then begin
      if UseItems[U_WEAPON].Desc[3] > 0 then begin
         UseItems[U_WEAPON].Desc[3] := UseItems[U_WEAPON].Desc[3] - 1; //Çà¿î °¨¼Ò
         {$IFDEF KOREA} SysMsg ('ÄúµÄÎäÆ÷±»×çÖäÁË£¡', 0);
         {$ELSE}        SysMsg ('A curse dwells in your weapon.', 0);
         {$ENDIF}
         Result := TRUE;
      end else begin
         if UseItems[U_WEAPON].Desc[4] < 10 then begin
            UseItems[U_WEAPON].Desc[4] := UseItems[U_WEAPON].Desc[4] + 1; //ºÒ¿î
            {$IFDEF KOREA} SysMsg ('ÄúµÄÎäÆ÷±»×çÖäÁË£¡', 0);
            {$ELSE}        SysMsg ('A curse dwells in your weapon.', 0);
            {$ENDIF}
            Result := TRUE;
         end;
      end;
      if RaceServer = RC_USERHUMAN then begin
         RecalcAbilitys;
         hum := TUserHuman(self);   //added by sonmg(2003/11/07)
         hum.SendUpdateItem (UseItems[U_WEAPON]);   //added by sonmg(2003/11/07)
         SendMsg (self, RM_ABILITY, 0, 0, 0, 0, '');
         SendMsg (self, RM_SUBABILITY, 0, 0, 0, 0, '');
//         Result := TRUE;
      end;
   end;
end;

procedure  TCreature.TrainSkill (pum: PTUserMagic; train: integer);
begin
   //-----------------------------------------
   //ComeBack2005 ¹«°ø ¼ö·ÃÄ¡ 2¹è Áõ°¡
   if EventCheckFlag then train := train * 2;
   //-----------------------------------------
   if BoFastTraining then train := train * 3;
   pum.CurTrain := pum.CurTrain + train;
end;

//´É·ÂÄ¡ÀÇ ÇÕÀ» º¸³½´Ù.
function  TCreature.GetMyAbility: TAbility;
begin
   Result := Abil;
   Result.HP := AddAbil.HP + Abil.HP;
   Result.MP := AddAbil.MP + Abil.MP;
   Result.AC := MakeWord ( _MIN(255, Lobyte(AddAbil.AC) + Lobyte(Abil.AC)), _MIN(255, Hibyte(AddAbil.AC) + Hibyte(Abil.AC)) );
   Result.MAC := MakeWord ( _MIN(255, Lobyte(AddAbil.MAC) + Lobyte(Abil.MAC)), _MIN(255, Hibyte(AddAbil.MAC) + Hibyte(Abil.MAC)) );
   Result.DC := MakeWord ( _MIN(255, Lobyte(AddAbil.DC) + Lobyte(Abil.DC)), _MIN(255, Hibyte(AddAbil.DC) + Hibyte(Abil.DC)) );
   Result.MC := MakeWord ( _MIN(255, Lobyte(AddAbil.MC) + Lobyte(Abil.MC)), _MIN(255, Hibyte(AddAbil.MC) + Hibyte(Abil.MC)) );
   Result.SC := MakeWord ( _MIN(255, Lobyte(AddAbil.SC) + Lobyte(Abil.SC)), _MIN(255, Hibyte(AddAbil.SC) + Hibyte(Abil.SC)) );
end;


function  TCreature.GetMyLight: integer;

   function CheckLightValue : integer;
   var
      i : integer;
      ps: PTStdItem;
      CurrentLight : integer;
      hum : TUserHuman;
   begin
      CurrentLight := 0;

      if RaceServer = RC_USERHUMAN then begin
         hum := TUserHuman(self);
         if hum <> nil then begin
            // 50·¹º§ ÀÌÆåÆ® ¹ßÇö½Ã 1ÁÖÀÚ(±âº» ¹à±â ¹ö±× ¼öÁ¤ sonmg)
            if BoHighLevelEffect then begin
               if Abil.Level >= EFFECTIVE_HIGHLEVEL then begin
                  CurrentLight := 1;
               end;
            end;
         end;
      end;

      // ¸ðµçÂø¿ë¾ÆÀÌÅÛ¿¡ ´ëÇÏ¿© °Ë»çÇÑ´Ù.
      for i := U_DRESS to U_TRANS do
      begin
         if (UseItems[i].Index > 0) and (UseItems[i].Dura > 0) then
         begin
            ps := UserEngine.GetStdItem( UseItems[i].Index );
            if ps <> nil then
            begin
               if CurrentLight < ps.light then
               begin
                  CurrentLight := ps.Light ;
               end;
            end;
         end;
      end;
      Result := CurrentLight;
   end;
{
    function checkLightIndex( index_ :integer ) :Boolean;
    begin
        case index_ of
        464, //Çü±¤¼ö¿µº¹(³²)
        465, //Çü±¤¼ö¿µº¹(¿©)
        470, //¿©¸§ÀÇ Àü¼³
        471, //ÆÄµµÀÇ Àü¼³
        529, //ÃµÀÇ¹«ºÀ(³²)
        530, //ÃµÀÇ¹«ºÀ(¿©)
        531, //¹«È²¼ºÀÇ(³²)
        532, //¹«È²¼ºÀÇ(¿©)
        635, //Ãµ·æÈ¥¼¼È¯
        636, //Ãµ·æ±¤¸¶·û
        637, //Ãµ·æ¿¬¿ù½Å
        638, //Ãµ·æºÒ»çÀÇ (³²)
        639, //Ãµ·æºÒ»çÀÇ (¿©)
        640, //Ãµ·æÃßÈ¥¸ð
        641, //Ãµ·æ½ÅÇüÅ»¸í°Ë
        642, //Ãµ·æ½ÅÇàº¸
        643  //Ãµ·æ¹ÝÇâ´ë
        : result := true
        else
          result := false;
        end;
    end;
}
var
    DressIndex : integer;
begin
   if BoTaiwanEventUser then
   begin
      Result := 4;
   end
   else
   begin
      Result := CheckLightValue;
   end;

end;


function  TCreature.GetUserName: string;
var
  ShowName: string;
begin
   if RaceServer <> RC_USERHUMAN then begin
      GetValidStrNoVal (UserName, Result);   //¼ýÀÚ ÀÌ¸§Àº ¾È³ª¿À°Ô ÇÑ´Ù.

      if Master <> nil then begin  //ÁÖÀÎÀÌ ÀÖÀ¸¸é..
         if not Master.BoSuperviserMode then begin
            //ºÐ½Å
            if RaceServer = RC_CLONE then begin
               if Master.RaceServer = RC_USERHUMAN then
                  Result := Master.UserName;
            end else begin
               //°¨½ÃÀÚ°¡ ¾Æ´Ï¸é
               Result := Result + '(' + Master.UserName + ')';
            end;
         end;
      end;

   end else begin
      ShowName := Format(RankLevelName, [UserName]); //NPCÉÏ»ñÈ¡³ÆºÅ
      if RankLevelName <> '' then
        Result := ShowName
      else
        Result := UserName;



      if BoTaiwanEventUser then  //´ë¸¸ ¾ÆÀÌÅÛ ÀÌº¥Æ®
         Result := Result + '(' + TaiwanEventItemName + ')';

      if MyGuild <> nil then begin
         if UserCastle.IsOurCastle(TGuild(MyGuild)) then begin //¿ì¸®¹®ÆÄ°¡ »çºÏ¼ºÀ» Á¡·É
            Result := Result + '\' +  //Å¬¶óÀÌ¾ðÆ®¿¡¼­´Â ¹Ý´ë·Î ÀÌ¸§ÀÌ ¸Ç ³ªÁß¿¡ ½áÁø´Ù.
                      TGuild(MyGuild).GuildName + '(' + UserCastle.CastleName + ')';
         end else begin
           // if UserCastle.BoCastleUnderAttack then      //¼ì²âÉ³°Í¿Ë¹¥³ÇÏÔÊ¾Ãû³Æ
             //  if (BoInFreePKArea) or (UserCastle.IsCastleWarArea (PEnvir, CX, CY)) then    /¼ì²âÉ³°Í¿Ë¹¥³ÇÏÔÊ¾Ãû³Æ
                  Result := Result + '\' +
                            TGuild(MyGuild).GuildName;
         end;
      end;

      if TUserHuman(Self).fLover.GetLoverName <> '' then
        if TUserHuman(Self).Sex = 1 then
          Result := Result + '\[' +TUserHuman(Self).fLover.GetLoverName+' µÄÆÞ×Ó]'
        else
          Result := Result + '\[' +TUserHuman(Self).fLover.GetLoverName+' µÄÕÉ·ò]';

      if TUserHuman(Self).fMaster.MasterName <> '' then begin
         Result := Result + '\' + TUserHuman(Self).fMaster.GetTitle;
      end;

   end;
end;

function  TCreature.GetHungryState: integer;
begin
   Result := HungryState div 1000;
   if Result > 4 then Result := 4; //0, 1, 2, 3, 4
end;

function   TCreature.GetQuestMark (idx: integer): integer;
var
   dcount, mcount: integer;
begin
   Result := 0;
   idx := idx - 1;
   if idx >= 0 then begin
      dcount := idx div 8;
      mcount := idx mod 8;
      if dcount in [0..MAXQUESTBYTE-1] then begin
         if QuestStates[dcount] and ($80 shr mcount) <> 0 then
            Result := 1
         else Result := 0;
      end;
   end;
end;

procedure  TCreature.SetQuestMark (idx, value: integer); // value: 0 or 1
var
   dcount, mcount: integer;
   val: byte;
begin
   idx := idx - 1;
   if idx >= 0 then begin
      dcount := idx div 8;
      mcount := idx mod 8;
      if dcount in [0..MAXQUESTBYTE-1] then begin
         val := QuestStates[dcount];
         if value = 0 then
            QuestStates[dcount] := val and (not ($80 shr mcount))
         else
            QuestStates[dcount] := val or ($80 shr mcount);
      end;
   end;
end;

function   TCreature.GetQuestOpenIndexMark (idx: integer): integer;
var
   dcount, mcount: integer;
begin
   Result := 0;
   idx := idx - 1;
   if idx >= 0 then begin
      dcount := idx div 8;
      mcount := idx mod 8;
      if dcount in [0..MAXQUESTINDEXBYTE-1] then begin
         if QuestIndexOpenStates[dcount] and ($80 shr mcount) <> 0 then
            Result := 1
         else Result := 0;
      end;
   end;
end;

procedure  TCreature.SetQuestOpenIndexMark (idx, value: integer);
var
   dcount, mcount: integer;
   val: byte;
begin
   idx := idx - 1;
   if idx >= 0 then begin
      dcount := idx div 8;
      mcount := idx mod 8;
      if dcount in [0..MAXQUESTINDEXBYTE-1] then begin
         val := QuestIndexOpenStates[dcount];
         if value = 0 then
            QuestIndexOpenStates[dcount] := val and (not ($80 shr mcount))
         else
            QuestIndexOpenStates[dcount] := val or ($80 shr mcount);
      end;
   end;
end;

function   TCreature.GetQuestFinIndexMark (idx: integer): integer;
var
   dcount, mcount: integer;
begin
   Result := 0;
   idx := idx - 1;
   if idx >= 0 then begin
      dcount := idx div 8;
      mcount := idx mod 8;
      if dcount in [0..MAXQUESTINDEXBYTE-1] then begin
         if QuestIndexFinStates[dcount] and ($80 shr mcount) <> 0 then
            Result := 1
         else Result := 0;
      end;
   end;
end;

procedure  TCreature.SetQuestFinIndexMark (idx, value: integer);
var
   dcount, mcount: integer;
   val: byte;
begin
   idx := idx - 1;
   if idx >= 0 then begin
      dcount := idx div 8;
      mcount := idx mod 8;
      if dcount in [0..MAXQUESTINDEXBYTE-1] then begin
         val := QuestIndexFinStates[dcount];
         if value = 0 then
            QuestIndexFinStates[dcount] := val and (not ($80 shr mcount))
         else
            QuestIndexFinStates[dcount] := val or ($80 shr mcount);
      end;
   end;
end;


procedure TCreature.CmdMonClear(smap: string);
var
   list : TList;
   k : integer;
begin
   list := TList.Create;
   UserEngine.GetMapMons (GrobalEnvir.GetEnvir(smap), list);
   for k:=0 to list.Count-1 do begin
      TCreature(list[k]).BoNoItem := TRUE;
      TCreature(list[k]).WAbil.HP := 0;  //¸ðµÎ Á×ÀÎ´Ù.
   end;
   list.Free;
end;

procedure TCreature.DoDamageWeapon (wdam: integer);
var
   olddura, idura: integer;
   hum: TUserHuman;
begin
   if (UseItems[U_WEAPON].Index > 0) and (UseItems[U_WEAPON].Dura > 0) then begin
      idura := UseItems[U_WEAPON].Dura;  //Dura´Â word°ªÀÌ±â ¶§¹®¿¡... idura(integer)·Î °è»êÇßÀ½
      olddura := Round (idura / 1000);
      idura := idura - wdam;
      if idura <= 0 then begin
         idura := 0;
         UseItems[U_WEAPON].Dura := 0;
         //´Ù ´à¸é ¾ø¾îÁø´Ù.
         if RaceServer = RC_USERHUMAN then begin
            hum := TUserHuman(self);
            hum.SendDelItem (UseItems[U_WEAPON]); //Å¬¶óÀÌ¾ðÆ®¿¡ ¾ø¾îÁø°Å º¸³¿
            //´â¾Æ ¾ø¾îÁø°Å ·Î±× ³²±è
            AddUserLog ('3'#9 +  //´âÀ½_ +
                        MapName + ''#9 +
                        IntToStr(CX) + ''#9 +
                        IntToStr(CY) + ''#9 +
                        UserName + ''#9 +
                        UserEngine.GetStdItemName (UseItems[U_WEAPON].Index) + ''#9 +
                        IntToStr(UseItems[U_WEAPON].MakeIndex) + ''#9 +
                        IntToStr(BoolToInt(RaceServer = RC_USERHUMAN)) + ''#9 +
                        '0');
         end;
         SysMsg (UserEngine.GetStdItemName (UseItems[U_WEAPON].Index) + 'Òò³Ö¾ÃÖµºÄ¾¡¶øÏûÊ§', 0);
         UseItems[U_WEAPON].Index := 0;
         UseItems[U_WEAPON].Dura := 0;
         RecalcAbilitys;
         SendMsg (self, RM_DURACHANGE, U_WEAPON, UseItems[U_WEAPON].Dura, UseItems[U_WEAPON].DuraMax, 0, '');
         SendMsg (self, RM_ABILITY, 0, 0, 0, 0, '');
         SendMsg (self, RM_SUBABILITY, 0, 0, 0, 0, '');
         FeatureChanged;
      end else
         UseItems[U_WEAPON].Dura := idura;

      if olddura <> Round(idura / 1000) then begin //³»±¸¼º ¼öÄ¡ º¯°æ
         SendMsg (self, RM_DURACHANGE, U_WEAPON, UseItems[U_WEAPON].Dura, UseItems[U_WEAPON].DuraMax, 0, '');
      end;
   end;
end;

function TCreature.GetAttackPower (damage, ranval: integer): integer;
var
   v1, v2: integer;
begin
   if ranval < 0 then ranval := 0;
   if Luck > 0 then begin
      if Random(10 - _MIN(9,Luck)) = 0 then Result := damage + ranval //Çà¿îÀÎ°æ¿ì
      else Result := damage + Random(ranval + 1);
   end else begin
      Result := damage + Random(ranval + 1);
      if Luck < 0 then begin
         //10º¸´Ù Å« ºÒ¿îÀÎ°æ¿ì 100% ÃÖ¼Òµ¥¹ÌÁö Àû¿ë(sonmg 2004/08/16)
         if Random(_MAX(0, 10 - _MAX(0,-Luck))) = 0 then
            Result := damage;  //ºÒ¿îÀÎ°æ¿ì
      end;
   end;
end;

   // 2003/03/15 ½Å±Ô¹«°ø Ãß°¡·Î ·çÆ¾ º¯°æ

function  TCreature._Attack (hitmode: word; targ: TCreature): Boolean;


   function DirectAttack (target: TCreature; damage: integer): Boolean;
   begin
      Result := FALSE;
      if (RaceServer = RC_USERHUMAN) and (target.RaceServer = RC_USERHUMAN) and ((target.InSafeZone) or (InSafeZone)) then
         exit;  //¾ÈÀüÁö´ë

      if (target.RaceServer = RC_USERHUMAN) and  TUserHuman(target).m_StallMgr.OnSale and bosafe°ÚÌ¯ and TUserHuman(target).InSafeZone then begin
        Exit;
      end;
      if IsProperTarget (target) then begin
         if Random(target.SpeedPoint) < AccuracyPoint then begin
            target.StruckDamage (damage, self);
            target.SendDelayMsg (TCreature(RM_STRUCK), RM_REFMESSAGE, damage{wparam},
                     target.WAbil.HP{lparam1}, target.WAbil.MaxHP{lparam2}, Longint(self){hiter}, '', 500);
            //¸ó½ºÅÍÇÑÅ×´Â Á÷Á¢Àü´ÞÇØ¾ß ÇÔ..
            if target.RaceServer <> RC_USERHUMAN then
               target.SendMsg (target, RM_STRUCK, damage, target.WAbil.HP, target.WAbil.MaxHP, Longint(self), '');
            Result := TRUE;
         end;
      end;
   end;


   //»çÀÚÈÄÀÇ °³º°°ø°Ý
   function DirectStoneAttack ( target: TCreature ; damage: integer ) :Boolean;
   begin
      Result := FALSE;

      if IsProperTarget (target) then begin
         //¸Â´ÂÁö °áÁ¤
         if ( damage > 0) and  // µ¥¹ÌÁö°¡ ÀÖ¾î ¾ß µÇ°í
            ( target.Abil.Level < Self.Abil.Level + 4) and //ÀÚ½ÅÀÇ ·¹º§º¸´Ù 4´Ü°è ¹Ì¸¸¸¸ µÇ°í
            ( target.Abil.Level < 60) // ¿Õ±Þ¸ó½ºÅÍ¿¡°Ô´Â ÅëÇÏÁö ¾ÊÀ½
         then begin
            target.MakePoison (POISON_DONTMOVE, damage, 0);   //¸¶ºñ
            Result := TRUE;
         end;
      end;
   end;

   // µ¹ °ø°Ý
   function StoneAttack (damage: integer): TCreature;
   var
      i, j, dir, xx, yy: integer;
      target: TCreature;
   begin
      Result := nil;
      for i := -2 to 2 do begin
         for j := -2 to 2 do begin
            xx := CX + i;
            yy := CY + j;
            target := TCreature (PEnvir.GetCreature (xx, yy, TRUE));

            if (damage > 0) and (target <> nil) then begin
               if target.RaceServer <> RC_USERHUMAN then begin
                  if ( DirectStoneAttack (target, damage) ) then begin
                     Result := Target;
                  end;
               end;
            end;

         end; // for j
      end; // for i
   end;


   function SwordLongAttack (damage: integer): Boolean;
   var
      xx, yy: integer;
      target: TCreature;
   begin
      Result := FALSE;
      damage := Round(damage * (cishaweili) / 100);    //´ÌÉ±
      if GetNextPosition (PEnvir, CX, CY, Dir, 2, xx, yy) then begin
         target := TCreature (PEnvir.GetCreature (xx, yy, TRUE));
         if (damage > 0) and (target <> nil) then begin
            if IsProperTarget (target) then begin
               Result := DirectAttack (target, damage);
               SelectTarget (target);
            end;
         end;
      end;
   end;

   function SwordWideAttack (damage: integer): Boolean;
   const
      valarr: array[0..2] of integer = (7, 1, 2);
   var
      i, ndir, xx, yy: integer;
      target: TCreature;
   begin
      Result := FALSE;
      for i:=0 to 2 do begin
         ndir := (Dir + valarr[i]) mod 8;
         if GetNextPosition (PEnvir, CX, CY, ndir, 1, xx, yy) then begin
            target := TCreature (PEnvir.GetCreature (xx, yy, TRUE));
            if (damage > 0) and (target <> nil) then begin
               if IsProperTarget (target) then begin
                  Result := DirectAttack (target, damage);
                  SelectTarget (target);
               end;
            end;
         end;
      end;
   end;
   // 2003/03/15 ½Å±Ô¹«°ø Ãß°¡·Î ·çÆ¾ º¯°æ
   function SwordCrossAttack (damage: integer): Boolean;
   const
      valarr: array[0..6] of integer = (7, 1, 2, 3, 4, 5, 6);
   var
      i, ndir, xx, yy: integer;
      target: TCreature;
   begin
      Result := FALSE;
      for i:=0 to 6 do begin
         ndir := (Dir + valarr[i]) mod 8;
         if GetNextPosition (PEnvir, CX, CY, ndir, 1, xx, yy) then begin
            target := TCreature (PEnvir.GetCreature (xx, yy, TRUE));
            if (damage > 0) and (target <> nil) then begin
               if IsProperTarget (target) then begin
                  if target.RaceServer <> RC_USERHUMAN then
                     Result := DirectAttack (target, damage)
                  else
                     Result := DirectAttack (target, Round(damage * 0.8) );
                  SelectTarget (target);
               end;
            end;
         end;
      end;
   end;
{
   var
      ndir: byte;
      rx, ry, xx, yy: integer;
      target: TCreature;
      procedure __DAttack;
      begin
         if GetNextPosition (PEnvir, rx, ry, ndir, 1, xx, yy) then begin
            target := TCreature (PEnvir.GetCreature (xx, yy, TRUE));
            if (damage > 0) and (target <> nil) then
               Result := DirectAttack (target, damage);
         end;
      end;
   begin
      Result := FALSE;
      ndir := Dir; GetNextPosition (PEnvir, CX, CY, ndir, 1, rx, ry);
      //Á¤¸é ¾Õ
      __DAttack;
      //¿À¸¥ÂÊ
      ndir := GetTurnDir (Dir, 2);
      __DAttack;
      //¿ÞÂÊ
      ndir := GetTurnDir (Dir, 6);
      __DAttack;
   end;
}
var
   dam, seconddam, armor, olddura, idura, weapondamage, n: integer;
   hum: TUserHuman;
   addplus: Boolean;
   Gap, MoC, Dur : integer;
   test : integer;it:Boolean;
   AllowPk:Boolean;
begin
   Result := FALSE;
   test := 0;
   try
      addplus := FALSE;  //Ç®·¯½º ÆÄ¿ö°¡ ¸ÔÇû´ÀÁö ¿©ºÎ
      weapondamage := 0;
      dam := 0;
      seconddam := 0;
      if targ <> nil then begin
         //Å¸°Ù ·¹º§¿¡ µû¸¥ µ¥¹ÌÁö Á¶Á¤
         if (MultiplyTargetLevelMin > 0) and (MultiplyTargetLevelMax > 0) then begin
            with WAbil do
               dam := GetAttackPower (Trunc(targ.Abil.Level * MultiplyTargetLevelMin div 100) + Lobyte(DC), (Trunc(targ.Abil.Level * MultiplyTargetLevelMax div 100) + Hibyte(DC)-Lobyte(DC))); //
         end else begin
            with WAbil do
               dam := GetAttackPower (Lobyte(DC), Integer(Hibyte(DC)-Lobyte(DC))); //sonmg ¼öÁ¤(2006/02/14)
         end;
         //°Ë¹ýÀ¸·Î Çâ»óµÈ ÆÄ¿ö
         if (hitmode = HM_POWERHIT) and (BoAllowPowerHit) then begin
            BoAllowPowerHit := FALSE;
            dam := dam + HitPowerPlus;
            addplus := TRUE;
         end;
         if (hitmode = HM_FIREHIT) and (BoAllowFireHit) then begin
            BoAllowFireHit := FALSE;
            with WAbil do
               dam := dam + Round(dam / 100 * (HitDouble * 10));
               dam := Round(dam * (huoweili) / 100);   //ÍþÁ¦±¶Êý 20% Ôö¼ÓÁÒ»ðÍþÁ¦
                  //GetAttackPower (Lobyte(DC), ShortInt(Hibyte(DC)-Lobyte(DC)));
            addplus := TRUE;
         end;
         // 2003/03/15 ±¤Ç³Âü...Àç°ËÅä
{
         if (hitmode = HM_CROSSHIT) then begin
            BoAllowPowerHit := FALSE;
            dam := dam + HitPowerPlus;
            addplus := TRUE;
         end;
}
         // ¿©±â´Ù ³Ö¾îº¼±î? µÐÈ­ / Áßµ¶ sonmg(2003/11/07)
         // ...µÐÈ­ÆÇÁ¤...
         //ÆòÈ­°ø°Ý½Ã µÐÈ­/Áßµ¶ °É¸®´Â ¹ö±× ¼öÁ¤(sonmg 2004/01/13)
         if IsProperTarget (targ) then begin
            if (targ.Abil.Level < 60) and
                  (targ.StatusArr[POISON_SLOW] = 0) and
                  (AddAbil.Slowdown > 0) and (Random(20) <= AddAbil.Slowdown) and
                  (Random(50) > targ.AntiMagic) then begin // 100->50
               MoC := 1;
               Gap := targ.Abil.Level - Abil.Level;
               if Gap > 10 then Gap := 10;
               if Gap <-10 then Gap :=-10;
               if targ.RaceServer = RC_USERHUMAN then MoC := 2;
               if Random(100) < (20 + (AddAbil.Slowdown - Gap) div Moc) then begin
                  Dur := (900 * AddAbil.Slowdown + 3300) div 1000;
                  targ.MakePoison(POISON_SLOW, Dur + 1, 1);
               end;
            // ...Áßµ¶ÆÇÁ¤...
            end else if (targ.Abil.Level < 60) and
                  (AddAbil.Poison > 0) and (Random(20) <= AddAbil.Poison) and
                  (6 >= Random(7 + targ.AntiPoison)) then begin
               MoC := 1;
               Gap := targ.Abil.Level - Abil.Level;
               if Gap > 10 then Gap := 10;
               if Gap <-10 then Gap :=-10;
               if targ.RaceServer = RC_USERHUMAN then MoC := 2;
               if Random(100) < (20 + (AddAbil.Poison - Gap) div Moc) then begin
                  targ.SendDelayMsg (self, RM_MAKEPOISON, POISON_DECHEALTH{wparam}, 5{pwr(time)}, integer(self), AddAbil.Poison, '', 1000);
               end;
            end;
         end;

      end else begin
         with WAbil do
            dam := GetAttackPower (Lobyte(DC), Integer(Hibyte(DC)-Lobyte(DC)));  //sonmg ¼öÁ¤(2006/02/14)
         //°Ë¹ýÀ¸·Î Çâ»óµÈ ÆÄ¿ö
         if (hitmode = HM_POWERHIT) and (BoAllowPowerHit) then begin
            BoAllowPowerHit := FALSE;
            dam := dam + HitPowerPlus;
            addplus := TRUE;
         end;
      end;

      //±ä °Å¸® °ø°Ý (¾î°Ë)
      if hitmode = HM_LONGHIT then begin
         seconddam := 0;
         if RaceServer = RC_USERHUMAN then begin
            if PLongHitSkill <> nil then
               seconddam := Round(dam / (PLongHitSkill.pDef.MaxTrainLevel+2) * (PLongHitSkill.Level+2));
         end else seconddam := dam;
         if seconddam > 0 then SwordLongAttack (seconddam);
      end;
      //ÁÖº¯ °ø°Ý  (¹Ý¿ù)
      if hitmode = HM_WIDEHIT then begin
         seconddam := 0;
         if RaceServer = RC_USERHUMAN then begin
            if PWideHitSkill <> nil then
               seconddam := Round(dam / (PWideHitSkill.pDef.MaxTrainLevel+10) * (PWideHitSkill.Level+2));
         end else seconddam := dam;
         if seconddam > 0 then SwordWideAttack (seconddam);
      end;
      //Å©·Î½º °ø°Ý -> ±¤Ç³Âü
      if hitmode = HM_CROSSHIT then begin
         seconddam := 0;
         if RaceServer = RC_USERHUMAN then begin
            if PCrossHitSkill <> nil then
               seconddam := Round(dam * g_seGALECHOP / (PCrossHitSkill.pDef.MaxTrainLevel+11) * (PCrossHitSkill.Level+3));
         end else seconddam := dam;
         if seconddam > 0 then SwordCrossAttack (seconddam);
      end;
      //½Ö·æÂü
      if (hitmode = HM_TWINHIT) and (targ <> nil) then begin
         dam := dam + HitPowerPlus;
         seconddam := dam;
         DirectAttack (targ, seconddam);
         // »óÅÂÀÌ»ó...½ºÅÏÆÇÁ¤
         if (targ.Abil.Level < 60) and
            (targ.StatusArr[POISON_STUN] = 0) and
            (Random(50) > targ.AntiMagic) then begin   // 100->50
            MoC := 1;
//            Gap := targ.Abil.Level - Abil.Level;
//            if Gap > 10 then Gap := 10;
//            if Gap <-10 then Gap :=-10;
            if targ.RaceServer = RC_USERHUMAN then MoC := 2;
            if ((MoC = 1) and (Random(100) < 5*(PTwinHitSkill.Level+1))) or
               ((MoC = 2) and (Random(100) < 2*(PTwinHitSkill.Level+1))) then begin
               Dur := Round(1.5 + 0.8 * PTwinHitSkill.Level);
               targ.MakePoison(POISON_STUN, Dur, 1);
            end;
         end;
         if BoAllowTwinHit = 1 then begin  //½Ö·æÂü ÇØÁ¦..
//            {$IFDEF KOREA} SysMsg ('½Ö·æÂüÀÌ ½ÃÀüµÇ¾ú½À´Ï´Ù.', 1);
//            {$ELSE}        SysMsg ('TwinDrakeBlade is used.', 1);   //ÀÌÅÂ¸®Ãø ¿äÃ»À¸·Î »èÁ¦(2004/09/22)
//            {$ENDIF}
            BoAllowTwinHit := 2;
         end;
      end;

      try
      //ÁÖÀ§¸ó½ºÅÍ µ¹µÊ  -> »çÀÚÈÄ
      if  hitmode = HM_STONEHIT  then begin
         seconddam := 0;
         if ( RaceServer = RC_USERHUMAN) and (PStoneHitSkill <> nil )then
         begin
            //¸ó½ºÅÍ µ¹µÇ´Â ½Ã°£ ¼³Á¤
            case PStoneHitSkill.Level of
            0 : seconddam := 5;
            1 : seconddam := 6;
            2 : seconddam := 7;
            3 : seconddam := 8;
            end;
            test := 4;

            targ := StoneAttack (seconddam);
            if targ <> nil then dam := 0;
         end;
      end;

      except
        MainOutMessage('EXCEPTION STONEHIT');
      end;

      if targ = nil then      //¾î°Ë, ¹Ý¿ù ÀÚµ¿¼ö·ÃÀ» ¸·±â À§ÇØ¼­
         exit;
      AllowPk:=true;
      //¾î°Ë,¹Ý¿ù µîÀº targ¿Í »ó°ü¾øÀÌ _Attack¾ÈÀ¸·Î µé¾î¿Â´Ù.
      if IsProperTarget (targ) then begin
         if AccuracyPoint > Random(targ.SpeedPoint) then begin
            ;
         end else
            dam := 0;
      end else
      begin
         dam := 0;
         AllowPk:=False;
      end;
      if dam > 0 then begin
         dam := targ.GetHitStruckDamage (self, dam);
         weapondamage := Random(5) + 2 - AddAbil.WeaponStrong;  //´Ü´ÜÇÑ ¹«±â´Â ³»±¸°¡ Àß ¾È´Ü´Ù.

         // ÇÁ¸®¹Ì¾ö ÀÌº¥Æ®(sonmg)
         dam := dam + PlusFinalDamage;
{$IFDEF DEBUG} //ÇÁ¸®¹Ì¾ö µð¹ö±×
//SysMsg('ÇÃ·¯½º ÆÄ¿ö : ' + IntToStr(PlusFinalDamage), 0);
{$ENDIF}
      end;

      if ( dam > 0) or (hitmode = HM_STONEHIT) then begin

         if ( hitmode <> HM_STONEHIT ) then
         begin
           targ.StruckDamage (dam, self);
           targ.SendDelayMsg (TCreature(RM_STRUCK), RM_REFMESSAGE, dam{wparam},
                    targ.WAbil.HP{lparam1}, targ.WAbil.MaxHP{lparam2}, Longint(self){hiter}, '', 200);

           //¶§¸®´ÂÀÚ°¡ ¸¶ºñÀÇ¹ÝÁö¸¦ ³¢°í ÀÖÀ½
           if BoAbilMakeStone then begin
              if Random(5 + targ.AntiPoison) = 0 then
                 targ.MakePoison (POISON_STONE, 5{½Ã°£}, 0);   //¸¶ºñ
           end;

           //¶§¸®´ÂÀÚ°¡ ¹ÐÈ­ ¼¼Æ®¸¦ ³¢°í ÀÖÀ½ (Ã¼·Â Èí¼ö)
           if SuckupEnemyHealthRate > 0 then begin
              SuckupEnemyHealth := SuckupEnemyHealth + (dam / 100 * SuckupEnemyHealthRate);
              if SuckupEnemyHealth >= 2 then begin
                 n := Trunc (SuckupEnemyHealth);
                 SuckupEnemyHealth := SuckupEnemyHealth - n;
                 DamageHealth (-n, 0);
//                 if  WAbil.HP = 0 then
//                   m_beidusi := False;
              end;
           end;

         end;

         //°Ë¼ú Çâ»ó
         if (PSwordSkill <> nil) and (targ.RaceServer >= RC_ANIMAL) then begin
            if PSwordSkill.Level < 3 then begin
               if Abil.Level >= PSwordSkill.pDef.NeedLevel[PSwordSkill.Level] then begin
                  TrainSkill (PSwordSkill, 1 + Random(3));
                  if not CheckMagicLevelup (PSwordSkill) then
                     SendDelayMsg (self, RM_MAGIC_LVEXP, 0, PSwordSkill.pDef.MagicId, PSwordSkill.Level, PSwordSkill.CurTrain, '', 3000);
               end;
            end;
         end;
         //°Ë¼ú Çâ»ó 2 (¿¹µµ°Ë¹ý)
         if addplus then begin
            if (PPowerHitSkill <> nil) and (targ.RaceServer >= RC_ANIMAL) then begin
               if PPowerHitSkill.Level < 3 then begin
                  if Abil.Level >= PPowerHitSkill.pDef.NeedLevel[PPowerHitSkill.Level] then begin
                     TrainSkill (PPowerHitSkill, 1 + Random(3));
                     if not CheckMagicLevelup (PPowerHitSkill) then
                        SendDelayMsg (self, RM_MAGIC_LVEXP, 0, PPowerHitSkill.pDef.MagicId, PPowerHitSkill.Level, PPowerHitSkill.CurTrain, '', 3000);
                  end;
               end;
            end;
         end;
         //°Ë¼ú Çâ»ó 3 (¾î°Ë¼ú)
         if (hitmode = HM_LONGHIT) and (PLongHitSkill <> nil) and (targ.RaceServer >= RC_ANIMAL) then begin
            if PLongHitSkill.Level < 3 then begin
               if Abil.Level >= PLongHitSkill.pDef.NeedLevel[PLongHitSkill.Level] then begin
                  TrainSkill (PLongHitSkill, 1);
                  if not CheckMagicLevelup (PLongHitSkill) then
                     UpdateDelayMsgCheckParam1 (self, RM_MAGIC_LVEXP, 0, PLongHitSkill.pDef.MagicId, PLongHitSkill.Level, PLongHitSkill.CurTrain, '', 3000);
               end;
            end;
         end;
         //°Ë¼ú Çâ»ó 4 (¹Ý¿ù°Ë¹ý)
         if (hitmode = HM_WIDEHIT) and (PWideHitSkill <> nil) and (targ.RaceServer >= RC_ANIMAL) then begin
            if PWideHitSkill.Level < 3 then begin
               if Abil.Level >= PWideHitSkill.pDef.NeedLevel[PWideHitSkill.Level] then begin
                  TrainSkill (PWideHitSkill, 1);
                  if not CheckMagicLevelup (PWideHitSkill) then
                     UpdateDelayMsgCheckParam1 (self, RM_MAGIC_LVEXP, 0, PWideHitSkill.pDef.MagicId, PWideHitSkill.Level, PWideHitSkill.CurTrain, '', 3000);
               end;
            end;
         end;
         //°Ë¼ú Çâ»ó 5 (¿°È­°á)
         if (hitmode = HM_FIREHIT) and (PFireHitSkill <> nil) and (targ.RaceServer >= RC_ANIMAL) then begin
            if PFireHitSkill.Level < 3 then begin
               if Abil.Level >= PFireHitSkill.pDef.NeedLevel[PFireHitSkill.Level] then begin
                  TrainSkill (PFireHitSkill, 1);
                  if not CheckMagicLevelup (PFireHitSkill) then
                     UpdateDelayMsgCheckParam1 (self, RM_MAGIC_LVEXP, 0, PFireHitSkill.pDef.MagicId, PFireHitSkill.Level, PFireHitSkill.CurTrain, '', 3000);
               end;
            end;
         end;
         //2003/03/15 ½Å±Ô¹«°ø
         //°Ë¼ú Çâ»ó 6 (±¤Ç³Âü)
         if (hitmode = HM_CROSSHIT) and (PCrossHitSkill <> nil) and (targ.RaceServer >= RC_ANIMAL) then begin
            if PCrossHitSkill.Level < 3 then begin
               if Abil.Level >= PCrossHitSkill.pDef.NeedLevel[PCrossHitSkill.Level] then begin
                  TrainSkill (PCrossHitSkill, 1);
                  if not CheckMagicLevelup (PCrossHitSkill) then
                     UpdateDelayMsgCheckParam1 (self, RM_MAGIC_LVEXP, 0, PCrossHitSkill.pDef.MagicId, PCrossHitSkill.Level, PCrossHitSkill.CurTrain, '', 3000);
               end;
            end;
         end;
         //°Ë¼ú Çâ»ó 7 (½Ö·æÂü)
         if (hitmode = HM_TWINHIT) and (PTwinHitSkill <> nil) and (targ.RaceServer >= RC_ANIMAL) then begin
            if PTwinHitSkill.Level < 3 then begin
               if Abil.Level >= PTwinHitSkill.pDef.NeedLevel[PTwinHitSkill.Level] then begin
                  TrainSkill (PTwinHitSkill, 1);
                  if not CheckMagicLevelup (PTwinHitSkill) then
                     UpdateDelayMsgCheckParam1 (self, RM_MAGIC_LVEXP, 0, PTwinHitSkill.pDef.MagicId, PTwinHitSkill.Level, PTwinHitSkill.CurTrain, '', 3000);
               end;
            end;
         end;
         test := 6;
         //°Ë¼úÇâ»ó 8 (»çÀÚÈÄ)
         if (hitmode = HM_STONEHIT) and (PStoneHitSkill <> nil) then begin
            if PStoneHitSkill.Level < 3 then begin
               if Abil.Level >= PStoneHitSkill.pDef.NeedLevel[PStoneHitSkill.Level] then begin
                  TrainSkill (PStoneHitSkill, 1);
                  if not CheckMagicLevelup (PStoneHitSkill) then
                     UpdateDelayMsgCheckParam1 (self, RM_MAGIC_LVEXP, 0, PStoneHitSkill.pDef.MagicId, PStoneHitSkill.Level, PStoneHitSkill.CurTrain, '', 3000);
               end;
            end;
         end;

         //¸Â¾Æ¾ß ¼º°ø
         Result := TRUE;
      end;

      if weapondamage > 0 then begin
         if UseItems[U_WEAPON].Index > 0 then begin //¹«±â¸¦ Â÷°í ÀÖÀ¸¸é
            DoDamageWeapon (weapondamage);
         end;
      end;

      //¸ó½ºÅÍÇÑÅ×´Â Á÷Á¢Àü´ÞÇØ¾ß ÇÔ..
      if AllowPk and (targ.RaceServer <> RC_USERHUMAN) then
         targ.SendMsg (targ, RM_STRUCK, dam, targ.WAbil.HP, targ.WAbil.MaxHP, Longint(self), '');
   except
      MainOutMessage ('[Exception] TCreature._Attack:'+IntTostr(Test));
   end;
end;


procedure TCreature.HitHit (target: TCreature; hitmode, dir: word);
   procedure IdentifyWeapon (var ui: TUserItem);
   begin
      if ui.Desc[0] + ui.Desc[1] + ui.Desc[2] < 7 then begin
         case ui.Desc[10] of
            10..13: ui.Desc[0] := ui.Desc[0] + (ui.Desc[10] - 9);
            20..23: ui.Desc[1] := ui.Desc[1] + (ui.Desc[10] - 19);
            30..33: ui.Desc[2] := ui.Desc[2] + (ui.Desc[10] - 29);
            1: ui.Index := 0;  //»Ç°³Áü
         end;
      end else
         ui.Index := 0;
      ui.Desc[10] := 0;
   end;
   procedure CheckWeaponUpgradeResult;
   var
      oldweapon: TUserItem;
      hum: TUserHuman;
   begin
      if UseItems[U_WEAPON].Desc[10] <> 0 then begin
         //¾ÆÀÌµ§Æ¼ÆÄÀÌ°¡ ¾ÈµÈ ¹«±â
         oldweapon := UseItems[U_WEAPON];
         IdentifyWeapon (UseItems[U_WEAPON]);
         if UseItems[U_WEAPON].Index = 0 then begin  //»Ç»çÁü
            SysMsg ('ÎäÆ÷ÆÆËé!', 0);
            hum := TUserHuman(self);
            hum.SendDelItem (oldweapon); //Å¬¶óÀÌ¾ðÆ®¿¡ ¾ø¾îÁø°Å º¸³¿
            SendRefMsg (RM_BREAKWEAPON, 0, 0, 0, 0, '');
            //¾÷±×·¹ÀÌµå ½ÇÆÐ·Î ¾ø¾îÁø°Å ·Î±× ³²±è
            AddUserLog ('21'#9 + //¾÷½Ç_ +
                        MapName + ''#9 +
                        IntToStr(CX) + ''#9 +
                        IntToStr(CY) + ''#9 +
                        UserName + ''#9 +
                        UserEngine.GetStdItemName (oldweapon.Index) + ''#9 +
                        IntToStr(oldweapon.MakeIndex) + ''#9 +
                        '1'#9 + ItemOptionToStr( oldweapon.Desc )
                        );
            FeatureChanged;
         end else begin  //¾÷±×·¹ÀÌµå ¼º°ø
            SysMsg ('Éý¼¶³É¹¦!', 1);
            hum := TUserHuman(self);
            hum.SendUpdateItem (UseItems[U_WEAPON]);
            //¾÷±×·¹ÀÌµå ¼º°ø ·Î±× ³²±è
            AddUserLog ('20'#9 + //¾÷¼º_ +
                        MapName + ''#9 +
                        IntToStr(CX) + ''#9 +
                        IntToStr(CY) + ''#9 +
                        UserName + ''#9 +
                        UserEngine.GetStdItemName (UseItems[U_WEAPON].Index) + ''#9 +
                        IntToStr(UseItems[U_WEAPON].MakeIndex) + ''#9 +
                        '1'#9 + ItemOptionToStr( UseItems[U_WEAPON].Desc )
                        );
            RecalcAbilitys;
            SendMsg (self, RM_ABILITY, 0, 0, 0, 0, '');
            SendMsg (self, RM_SUBABILITY, 0, 0, 0, 0, '');
         end;
      end;
   end;
   function GetSWSpell (pum: PTUserMagic): integer;
   begin
      Result := Round(pum.pDef.Spell / (pum.pDef.MaxTrainLevel+1) * (pum.Level+1));
   end;
var
   newdir, soundeff, msg: integer;
   targ: TCreature;
   bopower, bofire: Boolean;
begin
  if RaceServer = RC_USERHUMAN then begin
    if TUserHuman(Self).m_StallMgr.OnSale then begin

      Exit;
    end;
  end;

   if hitmode = HM_WIDEHIT then begin
      if PWideHitSkill <> nil then begin
         if WAbil.MP > 0 then begin
            DamageSpell (GetSWSpell(PWideHitSkill) + PWideHitSkill.pDef.DefSpell);
            HealthSpellChanged;
         end else
            hitmode := RM_HIT;  //¸¶·Â¾øÀ½...
      end;
   end;
   // 2003/03/15 ½Å±Ô¹«°ø
   if hitmode = HM_CROSSHIT then begin
      if PCrossHitSkill <> nil then begin
         if WAbil.MP > 0 then begin
            DamageSpell (GetSWSpell(PCrossHitSkill) + PCrossHitSkill.pDef.DefSpell);
            HealthSpellChanged;
         end else
            hitmode := RM_HIT;  //¸¶·Â¾øÀ½...
      end;
   end;
   if hitmode = HM_TWINHIT then begin
      if PTwinHitSkill <> nil then begin
         if WAbil.MP > 0 then begin
            DamageSpell (GetSWSpell(PTwinHitSkill) + PTwinHitSkill.pDef.DefSpell);
            HealthSpellChanged;
         end else
            hitmode := RM_HIT;  //¸¶·Â¾øÀ½...
      end;
   end;


	//¹æÇâÀ¸·Î Ä£´Ù.
   self.Dir := dir;
   if target = nil then targ := GetFrontCret
   else targ := target;

   if targ <> nil then begin
      if UseItems[U_WEAPON].Index <> 0 then begin
         //Á¦·ÃÀÌ ³¡³­ ¹«±âÀÇ Å×½ºÆ®(¼º°ø¿©ºÎ)
         CheckWeaponUpgradeResult;
      end;
   end;

   bopower := BoAllowPowerHit;  //
   bofire := BoAllowFireHit;    //_attack ¿¡¼­ ÇØÁ¦ µÊ

   if _Attack (hitmode, targ) then
      SelectTarget (targ);

   msg := RM_HIT;
   if RaceServer = RC_USERHUMAN then begin
      msg := RM_HIT;
      case hitmode of
         HM_HIT:  msg := RM_HIT;
         HM_HEAVYHIT:   msg := RM_HEAVYHIT;
         HM_BIGHIT:     msg := RM_BIGHIT;
         HM_POWERHIT:
            if bopower then begin
               msg := RM_POWERHIT;
            end;
         HM_LONGHIT:
            if PLongHitSkill <> nil then begin
               msg := RM_LONGHIT;
            end;
         HM_WIDEHIT:
            if PWideHitSkill <> nil then begin
               msg := RM_WIDEHIT;
            end;
         HM_FIREHIT:
            if bofire then begin
               msg := RM_FIREHIT;
            end;
         // 2003/03/15 ½Å±Ô¹«°ø
         HM_CROSSHIT:
            if PCrossHitSkill <> nil then begin
               msg := RM_CROSSHIT;
            end;
         HM_TWINHIT:
            if PTwinHitSkill <> nil then begin
               msg := RM_TWINHIT;
            end;

      end;
   end;
   //SendRefMsg (msg, self.Dir, CX, CY, 0, '');
   HitMotion (msg, self.Dir, CX, CY);

end;

procedure TCreature.HitMotion (hitmsg: integer; hitdir: byte; x, y: integer);
begin
   SendRefMsg (hitmsg, hitdir, x, y, 0, '');
end;

procedure  TCreature.HitHit2 (target: TCreature; hitpwr, magpwr: integer; all: Boolean);
begin
   HitHitEx2 (target, RM_HIT, hitpwr, magpwr, all );
end;

procedure  TCreature.HitHitEx2 (target: TCreature; rmmsg, hitpwr, magpwr: integer; all: Boolean );
var
   i, dam: integer;
   list: TList;
   cret: TCreature;
begin
   self.Dir := GetNextDirection (CX, CY, target.CX, target.CY);
   list := TList.Create;
   PEnvir.GetAllCreature (target.CX, target.CY, TRUE, list);
   for i:=0 to list.Count-1 do begin
      cret := TCreature(list[i]);
      if IsProperTarget (cret) then begin
         dam := 0;
         dam := dam + cret.GetHitStruckDamage (self, hitpwr);
         dam := dam + cret.GetMagStruckDamage (self, magpwr);
         if dam > 0 then begin
            cret.StruckDamage (dam, self);
            cret.SendDelayMsg (TCreature(RM_STRUCK), RM_REFMESSAGE, dam{wparam},
                     cret.WAbil.HP{lparam1}, cret.WAbil.MaxHP{lparam2}, Longint(self){hiter}, '', 200);
         end;
      end;
   end;
   list.Free;
   SendRefMsg (rmmsg, self.Dir, CX, CY, 0, '');
end;

//Result: ½ÇÁ¦·Î ¹Ð¸° Ä­
function  TCreature.CharPushed (ndir, pushcount: integer): integer;  //¾î¶² Èû¿¡ ÀÇÇØ¼­ ¹Ð·Á³ª´Ù.
var
   i, nx, ny, olddir, oldx, oldy: integer;
   flag: Boolean;
begin
   Result := 0;
   olddir := Dir;
   oldx := CX;
   oldy := CY;
   Dir := ndir;
   flag := FALSE;

   for i:=0 to pushcount-1 do begin
      GetFrontPosition (self, nx, ny);
      if PEnvir.CanWalk (nx, ny, FALSE{°âÄ§Çã¿ë¾ÈÇÔ}) then begin
         if PEnvir.MoveToMovingObject (CX, CY, self, nx, ny, FALSE) > 0 then begin
            CX := nx;
            CY := ny;
            SendRefMsg (RM_PUSH, GetBack(ndir), CX, CY, 0, '');
            Inc (Result);
            if RaceServer >= RC_ANIMAL then
               WalkTime := WalkTime + 800; //¹Ð¸®¸é¼­ ´Ê°Ô ¶§¸°´Ù.
            flag := TRUE;
         end else
            break;
      end else
         break;
   end;

   if flag then
      Dir := GetBack(ndir); //olddir;
end;

function  TCreature.CharRushRush (ndir, rushlevel: integer ; isHumanSkill : Boolean): Boolean;  //¹«ÅÂº¸
   function CanPush (cret: TCreature): Boolean;
   var
      levelgap: integer;
   begin
      Result := FALSE;
      if (Abil.Level > cret.Abil.Level) and (not cret.StickMode) then begin
         levelgap := Abil.Level - cret.Abil.Level;
         if (Random(20) < 6+rushlevel*3+levelgap) then begin  //¼ö·ÃÁ¤µµ¿¡ µû¶ó¼­
            if IsProperTarget(cret) then begin
               Result := TRUE;
            end;
         end;
      end;
   end;
var
   i, nx, ny, damage, damagelevel, mydamagelevel: integer;
   cret, cret2, attackcret: TCreature;
   crash, crash2, crash3: Boolean;
begin
   Result := FALSE;
   crash := TRUE;
   crash2 := False;
   crash3 := False;
   Dir := ndir;
   attackcret := nil;
   damagelevel := rushlevel + 1;
   mydamagelevel := damagelevel;
   cret := GetFrontCret;

   if cret <> nil then
   begin
      for i:=0 to _MAX(2,rushlevel+1) do begin
         cret := GetFrontCret;
         if cret <> nil then begin
            mydamagelevel := 0;
            if CanPush (cret) then begin
               if rushlevel >= 3 then
                  if GetNextPosition (PEnvir, CX, CY, Dir, 2, nx, ny) then begin
                       cret2 := TCreature (PEnvir.GetCreature (nx, ny, TRUE));
                       if (i = 0) then
                       begin
                         if (cret2 <> nil) then
                           crash3 := True
                           else crash3 := False;
                       end;
                       if not crash3 then
                       begin
                       if (cret2 <> nil) then begin
                         crash2 := False;
                         if (i = 0) then
                           crash2 := False
                           else crash2 := True;

                          if CanPush (cret2) and (not crash2) then begin
                             cret2.CharPushed (Dir, 1);
                           Inc(cret2.PushedCount);
                          end;
                       end else crash2 := False;
                       end else
                       begin
                       if (cret2 <> nil) then begin
                          if CanPush (cret2) then begin
                             cret2.CharPushed (Dir, 1);
                           Inc(cret2.PushedCount);
                          end;
                       end;
                       end;
                  end;
               attackcret := cret;
               if (cret.CharPushed (Dir, 1) = 1) and (not crash2) then begin
                  Inc(cret.PushedCount);
                  GetFrontPosition (self, nx, ny);
                  if PEnvir.MoveToMovingObject (CX, CY, self, nx, ny, FALSE) > 0 then begin
                     CX := nx;
                     CY := ny;
                     SendRefMsg (RM_RUSH, ndir, CX, CY, 0, '');
                     crash := FALSE;
                     Result := TRUE;
                  end;
                  Dec (damagelevel);
               end else begin
                  break;
               end;
            end else
               break;
         end;
      end;
   end
   else
   begin
      crash := FALSE;
      for i:=0 to _MAX(2,rushlevel+1) do
      begin
         GetFrontPosition (self, nx, ny);
         if PEnvir.MoveToMovingObject (CX, CY, self, nx, ny, FALSE) > 0 then
         begin
            CX := nx;
            CY := ny;
            SendRefMsg (RM_RUSH, ndir, CX, CY, 0, '');
            Dec (mydamagelevel);
         end
         else
         begin  //º®¿¡ ºÎLÈù °æ¿ì
            if PEnvir.CanWalk (nx, ny, TRUE) then
               mydamagelevel := 0  //»ç¶÷¶§¹®¿¡ ¸ø°¨
            else crash := TRUE; //º®¿¡ ºÎLÈû
            break;
         end;
      end;
   end;

   if ( attackcret <> nil ) and isHumanSkill then
   begin
      if damagelevel < 0 then damagelevel := 0;
      damage := (1+damagelevel)*4 + Random((1+damagelevel) * 5);
      with attackcret do
      begin
         damage := GetHitStruckDamage (self, damage);
         StruckDamage (damage);
         SendRefMsg (RM_STRUCK, damage{wparam}, WAbil.HP{lparam1}, WAbil.MaxHP{lparam2}, Longint(self){hiter}, '');
         //¸ó½ºÅÍÇÑÅ×´Â Á÷Á¢Àü´ÞÇØ¾ß ÇÔ..
         if RaceServer <> RC_USERHUMAN then
            SendMsg (attackcret, RM_STRUCK, damage, WAbil.HP, WAbil.MaxHP, Longint(self), '');
      end;
   end;

   if crash then begin
      //¿òÁ÷ÀÌ´Â ½Ã´¿ÇÑ´Ù.
      GetFrontPosition (self, nx, ny);
      SendRefMsg (RM_RUSHKUNG, Dir, nx, ny, 0, '');
      //SendRefMsg (RM_TURN, Dir, CX, CY, 0, '');
      if isHumanSkill then SysMsg ('È±·¦³å×²Á¦Á¿', 0);
   end;

   if ( mydamagelevel > 0 )and ( isHumanSkill )then
   begin
      if damagelevel < 0 then damagelevel := 0;
      damage := (1+damagelevel)*5 + Random((1+damagelevel) * 5);
      damage := GetHitStruckDamage (self, damage);
      StruckDamage (damage);
      if (crash) and (LastHiter <> nil) then LastHiter := nil; //±»Ò°Âù×²ÁË¼àÌý¶ÔÏóÏûÊ§
      SendRefMsg (RM_STRUCK, damage{wparam}, WAbil.HP{lparam1}, WAbil.MaxHP{lparam2}, 0{hiter}, '');
   end;
end;

function  TCreature.CharDrawingRush (ndir, rushlevel: integer ; isHumanSkill : Boolean): Boolean;  //²ø¾î´ç±è
   function CanPush (cret: TCreature): Boolean;
   var
      levelgap: integer;
   begin
      Result := FALSE;
      if (Abil.Level > cret.Abil.Level) and (not cret.StickMode) then begin
         levelgap := Abil.Level - cret.Abil.Level;
         if (Random(20) < 6+rushlevel*3+levelgap) then begin  //¼ö·ÃÁ¤µµ¿¡ µû¶ó¼­
            if IsProperTarget(cret) then begin
               Result := TRUE;
            end;
         end;
      end;
   end;
var
   i, nx, ny, damage, damagelevel, mydamagelevel: integer;
   cret, cret2, attackcret: TCreature;
   crash: Boolean;
begin
   Result := FALSE;
   crash := TRUE;
   Dir := ndir;
   attackcret := nil;
   damagelevel := rushlevel + 1;
   mydamagelevel := damagelevel;
   cret := GetFrontCret;

   if cret <> nil then
   begin
{ //Æ÷½Â°Ë ¼öÁ¤
      for i:=0 to _MAX(2,rushlevel+1) do begin
         cret := GetFrontCret;
         if cret <> nil then begin
            mydamagelevel := 0;
            if CanPush (cret) then begin
               if rushlevel >= 3 then
                  if GetNextPosition (PEnvir, CX, CY, Dir, 2, nx, ny) then begin
                     cret2 := TCreature (PEnvir.GetCreature (nx, ny, TRUE));
                     if cret2 <> nil then begin
                        if CanPush (cret2) then begin
                           cret2.CharPushed (Dir, 1);
                        end;
                     end;
                  end;
               attackcret := cret;
               if cret.CharPushed (Dir, 1) = 1 then begin
                  GetFrontPosition (self, nx, ny);
                  if PEnvir.MoveToMovingObject (CX, CY, self, nx, ny, FALSE) > 0 then begin
                     CX := nx;
                     CY := ny;
                     SendRefMsg (RM_RUSH, ndir, CX, CY, 0, '');
                     crash := FALSE;
                     Result := TRUE;
                  end;
                  Dec (damagelevel);
               end else begin
                  break;
               end;
            end else
               break;
         end;
      end;
}
   end
   else
   begin
      crash := FALSE;
      for i:=0 to _MAX(2,rushlevel+1) do
      begin
         GetFrontPosition (self, nx, ny);
         if PEnvir.MoveToMovingObject (CX, CY, self, nx, ny, FALSE) > 0 then
         begin
            CX := nx;
            CY := ny;
            SendRefMsg (RM_RUSH, ndir, CX, CY, 0, '');
            Dec (mydamagelevel);
         end
         else
         begin  //º®¿¡ ºÎLÈù °æ¿ì
            if PEnvir.CanWalk (nx, ny, TRUE) then
               mydamagelevel := 0  //»ç¶÷¶§¹®¿¡ ¸ø°¨
            else crash := TRUE; //º®¿¡ ºÎLÈû
            break;
         end;
      end;
   end;

   if ( attackcret <> nil ) and isHumanSkill then
   begin
      if damagelevel < 0 then damagelevel := 0;
      damage := (1+damagelevel)*4 + Random((1+damagelevel) * 5);
      with attackcret do
      begin
         damage := GetHitStruckDamage (self, damage);
         StruckDamage (damage);
         SendRefMsg (RM_STRUCK, damage{wparam}, WAbil.HP{lparam1}, WAbil.MaxHP{lparam2}, Longint(self){hiter}, '');
         //¸ó½ºÅÍÇÑÅ×´Â Á÷Á¢Àü´ÞÇØ¾ß ÇÔ..
         if RaceServer <> RC_USERHUMAN then
            SendMsg (attackcret, RM_STRUCK, damage, WAbil.HP, WAbil.MaxHP, Longint(self), '');
      end;
   end;

   if crash then begin
      //¿òÁ÷ÀÌ´Â ½Ã´¿ÇÑ´Ù.
      GetFrontPosition (self, nx, ny);
      SendRefMsg (RM_RUSHKUNG, Dir, nx, ny, 0, '');
      //SendRefMsg (RM_TURN, Dir, CX, CY, 0, '');
      if isHumanSkill then SysMsg ('È±·¦³å×²Á¦Á¿', 0);
   end;

   if ( mydamagelevel > 0 )and ( isHumanSkill )then
   begin
      if damagelevel < 0 then damagelevel := 0;
      damage := (1+damagelevel)*5 + Random((1+damagelevel) * 5);
      damage := GetHitStruckDamage (self, damage);
      StruckDamage (damage);
      if(crash) and (LastHiter <> nil) then LastHiter := nil;
      SendRefMsg (RM_STRUCK, damage{wparam}, WAbil.HP{lparam1}, WAbil.MaxHP{lparam2}, 0{hiter}, '');
   end;
end;

function  TCreature.SiegeCount: integer;
var
   i: integer;
   cret: TCreature;
begin
   Result := 0;
   for i:=0 to VisibleActors.Count-1 do begin
      cret := TCreature (PTVisibleActor(VisibleActors[i]).cret);
      if not cret.Death then begin
         if (abs(CX-cret.CX) <= 1) and (abs(CY-cret.CY) <= 1) then
            Inc (Result);
      end;
   end;
end;

function   TCreature.SiegeLockCount: integer;
var
   i, j, n: integer;
begin
   n := 0;
   for i:=-1 to 1 do
      for j:=-1 to 1 do begin
         if (not PEnvir.CanWalk (CX+i, CY+j, FALSE)) and (not ((i=0) and (j=0))) then
            Inc (n);
      end;
   Result := n;
end;


//µ¶À¸·Î °ø°ÝÇÔ.

function  TCreature.MakePoison (poison, sec, poisonlv: integer): Boolean;
var
   old: integer;
begin
   Result := FALSE;
   //µ¶¿¡ Áßµ¶µÇÁö ¾ÊÀ» Á¶°ÇÀÌ ÀÖ´Â°¡ °Ë»ç..

   sec := sec - PoisonRecover;
   if sec <= 0 then Exit;

   if poison in [0..STATUSARR_SIZE-1] then begin

      old := CharStatus;
      if StatusArr[poison] > 0 then begin
         if sec > StatusArr[poison] then
            StatusArr[poison] := sec;
      end else
         StatusArr[poison] := sec;
      StatusTimes[poison] := GetTickCount;
      CharStatus := GetCharStatus(poison, True);
      if poison = POISON_DAMAGEARMOR then begin
         RedPoisonLevel := _MIN(poisonlv, 256);
         //µ¶¿¡ ´ëÇÑ Ãß°¡ µ¥¹ÌÁö ¼Ó¼º Ãß°¡(sonmg 2005/10/28) »¡µ¶ 2.0
         if PlusPoisonFactor <> 0 then begin
            RedPoisonLevel := RedPoisonLevel * (PlusPoisonFactor div 100);
         end;
      end;
      PoisonLevel := _MIN(poisonlv, 256);
         //µ¶¿¡ ´ëÇÑ Ãß°¡ µ¥¹ÌÁö ¼Ó¼º Ãß°¡(sonmg 2005/10/28) ³ìµ¶ 2¹è
      if PlusPoisonFactor <> 0 then begin
         PoisonLevel := PoisonLevel * (PlusPoisonFactor div 100);
      end;
      if old <> CharStatus then
         CharStatusChanged;
      if RaceServer = RC_USERHUMAN then
         SysMsg ('ÄãÖÐ¶¾ÁË£¡', 0);
      Result := TRUE;
   end;
end;

procedure  TCreature.ClearPoison (poison: integer);
var
   old: integer;
begin
   if poison in [0..STATUSARR_SIZE-1] then begin
      old := CharStatus;
      if StatusArr[poison] > 0 then
         StatusArr[poison] := 0;
      CharStatus := GetCharStatus;
      if old <> CharStatus then
         CharStatusChanged;
   end;
end;


function  TCreature.GetFrontCret: TCreature;
var
	fx, fy: integer;
begin
	Result := nil;
	if GetFrontPosition (self, fx, fy) then begin
   	Result := TCreature (PEnvir.GetCreature (fx, fy, TRUE));
   end;
end;

function  TCreature.GetBackCret: TCreature;
var
	fx, fy: integer;
begin
	Result := nil;
	if GetBackPosition (self, fx, fy) then begin
   	Result := TCreature (PEnvir.GetCreature (fx, fy, TRUE));
   end;
end;

//¼ì²é½ÇÉ«µÄ×ù±êÊÇ·ñÔÚÖ¸¶¨Îó²î·¶Î§ÒÔÄÚ
//¼ì²é½ÇÉ«ÊÇ·ñÔÚÖ¸¶¨×ù±êµÄ1x1 ·¶Î§ÒÔÄÚ£¬Èç¹ûÔÚÔò·µ»ØTrue ·ñÔò·µ»Ø False
//Ä§·¨¹¥»÷·¶Î§  ÐÞÕýÎª 2*2
function TCreature.CretInNearXY (tagcret: TCreature; xx, yy: integer): Boolean;
var
	i, j, k: Longint;
   pm: PTMapInfo;
   inrange: Boolean;
   cret: TCreature;
begin
   Result := FALSE;
   for i:=xx-(sdfanwei) to xx+(sdfanwei) do
      for j:=yy-(sdfanwei) to yy+(sdfanwei) do begin
         inrange := PEnvir.GetMapXY (i, j, pm);
         if inrange then begin
            if pm.ObjList <> nil then
               for k:=0 to pm.ObjList.Count-1 do
                  {creature}
                  if PTAThing (pm.ObjList[k]).Shape = OS_MOVINGOBJECT then begin
                     cret := TCreature (PTAThing (pm.ObjList[k]).AObject);
                     if cret <> nil then
                        if (not cret.BoGhost) and (cret = tagcret) then begin
                           Result := TRUE;
                           exit;
                        end;
                  end;
         end;
      end;
end;

function   TCreature.MakeSlave (sname: string; slevel, max_slave, royaltysec: integer): TCreature;
var
   nx, ny: integer;
   mon: TCreature;
   AddPlus : integer;
begin
   Result := nil;

try
   AddPlus := 0;
   if (GetExistSlave( __AngelMob ) <> nil) or ( sname = __AngelMob ) then Inc(Addplus);
   if (GetExistSlave('»¢ÎÀ') <> nil) or (GetExistSlave('Ó¥ÎÀ') <> nil) then Inc(Addplus); //ÇÁ¸®¹Ì¾ö ÀÌº¥Æ®(2005/08/10)

   if (SlaveList.Count < (max_slave + AddPlus))then begin
      GetFrontPosition (self, nx, ny);
      mon := UserEngine.AddCreatureSysop (PEnvir.MapName, nx, ny, sname);
      if mon <> nil then begin
         mon.Master := self;
         mon.MasterRoyaltyTime := GetTickCount + longword(royaltysec) * 1000;
         mon.SlaveMakeLevel := slevel;
         mon.SlaveExpLevel := slevel;
         mon.MasterFeature := GetRelFeature( self); // ºÐ½Å
         mon.RecalcAbilitys; //ApplySlaveLevelAbilitys;
         if mon.WAbil.HP < mon.WAbil.MaxHP then begin
            mon.WAbil.HP := mon.WAbil.HP + (mon.WAbil.MaxHP - mon.WAbil.HP) div 2;
         end;
         mon.ChangeNameColor;
         SlaveList.Add (mon);
         Result := mon;
      end;
   end;

except
    MainOutMessage('EXCEPT MAKESLAVE');
end;

end;

// 2003/06/12 ½½·¹ÀÌºê ÆÐÄ¡
procedure TCreature.ClearAllSlaves;
var
   i: integer;
begin
   for i:=0 to SlaveList.Count-1 do begin
      if not TCreature(SlaveList[i]).Death then
      begin
         TCreature(SlaveList[i]).BoDisapear := true;
         TCreature(SlaveList[i]).MakeGhost(4);  //ºÎÇÏµéÀ» ¿ÏÀüÈ÷ ¾ø¾Ø´Ù. ÁÖ·Î ¼­¹öÀÌµ¿ÇÏ´Â °æ¿ì »ç¿ë
      end;
   end;
end;

procedure TCreature.KillAllSlaves;
var
   i: integer;
begin
   for i:=0 to SlaveList.Count-1 do begin
      if not TCreature(SlaveList[i]).Death then
      begin
         TCreature(SlaveList[i]).WAbil.HP := 0; //Die
      end;
   end;
end;

function TCreature.ExistAttackSlaves: Boolean;
var
   i: integer;
   cret: TCreature;
begin
   //°ø°Ý Å¸°ÙÀÌ ÀÖ´Â ¼ÒÈ¯¼ö°¡ ÀÖÀ¸¸é TRUE ¾øÀ¸¸é FALSE...
   Result := FALSE;
   for i:=0 to SlaveList.Count-1 do begin
      cret := TCreature(SlaveList[i]);
      if not cret.Death then
      begin
         if cret.TargetCret <> nil then begin
            if cret.TargetCret.RaceServer = RC_USERHUMAN then begin
               Result := TRUE;
               break;
            end;
         end;
      end;
   end;
end;

// ²¿ºÀÁ¸ÀçÀ¯¹« ÆÇ´Ü.

function  TCreature.GetExistSlave( MonName_ : string ):TCreature;
var
   TempCret : TCreature;
   i        : integer;
begin
   Result := nil;
   try
      for i := 0 to SlaveList.Count -1 do begin
         TempCret := TCreature(SlaveList[i]);
         if ( TempCret <> nil     ) and
            ( not TempCret.Death  ) and
            ( not TempCret.BoDisapear )and
            ( not TempCret.boGhost) and
            ( comparetext( TempCret.UserName , MonName_) = 0 ) then begin
            Result := TempCret;
            Exit;
         end;
      end;
   except
      MainOutMessage('EXCEPTION GETExistSlave');
   end;
end;

function  TCreature.EnableRecallMob( TargetMob : TCreature ;SkillLevel : integer ):Boolean;
var
   i : integer;
   KingSlaveCount : integer;
   AddPlus : integer;
begin
   Result := false;
   KingSlaveCount := 0;
   AddPlus := 0;
   if (not TargetMob.NoMaster) and
      (TargetMob.LifeAttrib = LA_CREATURE) and
      (TargetMob.RaceServer <> RC_CLONE  ) and
      (TargetMob.RaceServer <> RC_ANGEL  ) and
      (TargetMob.Abil.Level < g_MONLEVELTIAOJIE)   // (TargetMob.Abil.Level < MAXKINGLEVEL-1)
   then begin

      //È£À§º´, ±Ã¼öÈ£À§º´Àº ²¿½ÃÁö ¸øÇÔ(sonmg 2005/08/22)
      //if (TargetMob.UserName = '»¢ÎÀ') or (TargetMob.UserName = 'Ó¥ÎÀ') then exit;  //ÆôÓÃ´Ë¶ÎÊµÏÖ½ûÖ¹ÕÙ»½»¢ÎÀ

      // À¯Àú 52·¹º§ ¹®Á¦ ¼öÁ¤(sonmg 2004/09/08)
      // ¸÷ÀÇ ·¹º§ÀÌ 50ÀÌ»óÀÎ ¸÷Àº ÇÑ ¸¶¸®¸¸ ²¿½Ç ¼ö ÀÖ´Ù.(µÎ ¸¶¸® ÀÌ»óÀº È®·üÀû¿ë)
      if TargetMob.Abil.Level >= 50 then begin
         for i:=0 to SlaveList.Count-1 do begin
            if TCreature(SlaveList[i]).Abil.Level >= 50 then begin
               Inc(KingSlaveCount);
            end;
         end;
         //ÇöÀç ¼ÒÈ¯¸÷ Áß¿¡ ·¹º§ÀÌ 50ÀÌ»óÀÎ ¸÷ÀÇ ¼ö¸¶´Ù 1/3¾¿ È®·ü °¨¼Ò.
         if Random(3 * KingSlaveCount) > 0 then begin
            Result := FALSE;
            exit;
         end;
      end;

      // È¯¿µÇÑÈ£´Â 1¸¶¸®¸¸ ¼ÒÈ¯µÈ´Ù.
      if Targetmob.RaceServer = RC_GHOST_TIGER then begin
         if SlaveList.Count > 0 then begin
            Result := false;
            Exit;
         end;
      end else begin
         // È¯¿µÇÑÈ£´Â ´Ù¸¥³ÑÀÌ ²¿¼ÅÁ® ÀÖÀ¸¸é... ²¿½Ç¼ö ¾ø´Ù.
         if SlaveList.Count = 1 then begin
            if TCreature(SlaveList[0]).RaceServer = RC_GHOST_TIGER then begin
               Result := false;
               Exit;
            end;
         end;
         //È£À§º´/±Ã¼öÈ£À§º´(sonmg 2005/08/17)
         for i:=0 to SlaveList.Count-1 do begin
            if (TCreature(SlaveList[i]).UserName = '»¢ÎÀ') or (TCreature(SlaveList[i]).UserName = 'Ó¥ÎÀ') then begin
               Inc(AddPlus);
            end;
         end;
         // ÀÏ¹ÝÀûÀ¸·Î ²¿½Ç¼ö ÀÖ´Â ¸ó½ºÅÍ ¼ö Ã¼Å©
         if SlaveList.Count >= (2 + skilllevel + AddPlus) then begin
            Result := false;
            Exit;
         end;
      end;

      Result := true;
   end;

end;


{------------------------- ±×·ì °ü·Ã -----------------------------}


function  TCreature.IsGroupMember (cret: TCreature): Boolean;
var
   i: integer;
begin
   Result := FALSE;
   if GroupOwner <> nil then begin
      for i:=0 to GroupOwner.GroupMembers.Count-1 do begin
         if GroupOwner.GroupMembers.Objects[i] = cret then begin
            Result := TRUE;
            break;
         end;
      end;
   end;
end;

function  TCreature.CheckGroupValid: Boolean;
begin
   Result := TRUE;
   if GroupMembers.Count <= 1 then begin
      //¸¶Áö¸·¿¡ ³²Àº °ÍÀº ±×·ìÂ¯ÀÌ´Ù.
      GroupMsg ('ÄãµÄÐ¡×é±»½âÉ¢ÁË');
      GroupMembers.Clear;
      GroupOwner := nil;

      // ¹ß·»Å¸ÀÎ ÀÌº¥Æ®(¿¬ÀÎ ±×·ì ÀÌº¥Æ®)
      RecalcAbilitys;
      SendMsg (self, RM_ABILITY, 0, 0, 0, 0, '');

      Result := FALSE;
   end;
end;

procedure  TCreature.DelGroupMember (who: TCreature);
var
   i: integer;
   cret: TCreature;
   hum: TUserHuman;
begin
   if GroupOwner <> who then begin
      for i:=0 to GroupMembers.Count-1 do begin
         cret := TCreature(GroupMembers.Objects[i]);
         if cret = who then begin
            who.LeaveGroup;
            GroupMembers.Delete (i);
            break;
         end;
      end;

      if Self.RaceServer = RC_USERHUMAN then begin
         hum := TUserHuman(self);
         if not CheckGroupValid then begin
//            hum.SendDefMessage (SM_GROUPCANCEL, 0, 0, 0, 0, '');
            hum.SendMsg (self, RM_GROUPCANCEL, 0, 0, 0, 0, '');
         end;

         hum.RefreshGroupMembers;
      end;

   end else begin
      //Â¯ÀÌ Å»Åð, ±×·ì ÇØÃ¼µÊ
      for i:=GroupMembers.Count-1 downto 0 do begin
         hum := TUserHuman (GroupMembers.Objects[i]);
         if (hum <> nil) and (hum.RaceServer = RC_USERHUMAN) then begin
//            hum.SendDefMessage (SM_GROUPCANCEL, 0, 0, 0, 0, '');  //¹ö±× ÆÐÄ¡(sonmg)
            hum.SendMsg (self, RM_GROUPCANCEL, 0, 0, 0, 0, '');
            hum.LeaveGroup;
            GroupMembers.Delete (i);
         end;
      end;

      //±×·ìÂ¯ÀÌ Á×Àº ÈÄ¿¡ ·Î±×¾Æ¿ô ÇÒ ¶§ ±×·ì ÇØÃ¼ ¾ÈµÇ´Â ¹ö±× ¼öÁ¤
      if Self.RaceServer = RC_USERHUMAN then begin
         hum := TUserHuman(self);

         //¸¶Áö¸·¿¡ ³²Àº °ÍÀº ±×·ìÂ¯ÀÌ´Ù.
         GroupMsg ('ÄãµÄÐ¡×é±»½âÉ¢ÁË');
         GroupMembers.Clear;
         GroupOwner := nil;

//         hum.SendDefMessage (SM_GROUPCANCEL, 0, 0, 0, 0, '');
         hum.SendMsg (self, RM_GROUPCANCEL, 0, 0, 0, 0, '');
         hum.RefreshGroupMembers;
      end;

   end;
end;

procedure  TCreature.EnterGroup (gowner: TCreature);
begin
   GroupOwner := gowner;
   GroupMsg (UserName + ' ¼ÓÈëÐ¡×é');

   // ¹ß·»Å¸ÀÎ ÀÌº¥Æ®(¿¬ÀÎ ±×·ì ÀÌº¥Æ®)
   RecalcAbilitys;
   SendMsg (self, RM_ABILITY, 0, 0, 0, 0, '');
end;

procedure  TCreature.LeaveGroup;
begin
   GroupMsg (UserName + ' ÍË³öÐ¡×é');
   SendMsg (self, RM_GROUPCANCEL, 0, 0, 0, 0, '');
   GroupOwner := nil;

   // ¹ß·»Å¸ÀÎ ÀÌº¥Æ®(¿¬ÀÎ ±×·ì ÀÌº¥Æ®)
   RecalcAbilitys;
   SendMsg (self, RM_ABILITY, 0, 0, 0, 0, '');
end;

procedure  TCreature.DenyGroup;
begin
   if GroupOwner <> nil then begin
      if GroupOwner <> self then begin
         //Å»Åð
         GroupOwner.DelGroupMember (self);
         AllowGroup := FALSE;
      end else begin
         //¾ÈµÊ
         SysMsg ('Èç¹ûÄãÏëÍË³ö£¬ÇëÊ¹ÓÃ±à×éµÄÉ¾³ý¼ü', 0);
      end;
   end else begin
      AllowGroup := FALSE;
   end;
end;


{----------------------------------------------------------------}



function  TCreature.TargetInAttackRange (target: TCreature; var targdir: byte): Boolean;
begin
   Result := FALSE;
   if (target.CX >= (self.CX - 1)) and (target.CX <= (self.CX + 1)) and
      (target.CY >= (self.CY - 1)) and (target.CY <= (self.CY + 1)) and
      not ((target.CX = self.CX) and (target.CY = self.CY)) then begin
      Result := TRUE;
      while TRUE do begin
         if (target.CX = (self.CX - 1)) and (target.CY = self.CY) then begin
            targdir := DR_LEFT;
            break;
         end;
         if (target.CX = (self.CX + 1)) and (target.CY = self.CY) then begin
            targdir := DR_RIGHT;
            break;
         end;
         if (target.CX = self.CX) and (target.CY = (self.CY - 1)) then begin
            targdir := DR_UP;
            break;
         end;
         if (target.CX = self.CX) and (target.CY = (self.CY + 1)) then begin
            targdir := DR_DOWN;
            break;
         end;
         if (target.CX = self.CX - 1) and (target.CY = self.CY - 1) then begin
            targdir := DR_UPLEFT;
            break;
         end;
         if (target.CX = self.CX + 1) and (target.CY = self.CY - 1) then begin
            targdir := DR_UPRIGHT;
            break;
         end;
         if (target.CX = self.CX - 1) and (target.CY = self.CY + 1) then begin
            targdir := DR_DOWNLEFT;
            break;
         end;
         if (target.CX = self.CX + 1) and (target.CY = self.CY + 1) then begin
            targdir := DR_DOWNRIGHT;
            break;
         end;
         targdir := 0; {¿¹¿Ü, }
         break;
      end;
   end;
end;

function  TCreature.TargetInSpitRange (target: TCreature; var targdir: byte): Boolean;
var
   nx, ny: integer;
begin
   Result := FALSE;
   if (abs(target.CX-CX) <= 2) and (abs(target.CY-CY) <= 2) then begin
      nx := target.CX - CX;
      ny := target.CY - CY;
      if (abs(nx) <= 1) and (abs(ny) <= 1) then begin
         TargetInAttackRange (target, targdir);
         Result := TRUE;
      end else begin
         nx := nx + 2;
         ny := ny + 2;
         if (nx in [0..4]) and (ny in [0..4]) then begin
            targdir := GetNextDirection (CX, CY, target.CX, target.CY);
            if SpitMap[targdir, ny, nx] = 1 then begin
               Result := TRUE;
            end;
         end;
      end;
   end;
end;

function  TCreature.TargetInCrossRange (target: TCreature; var targdir: byte): Boolean;
var
   nx, ny: integer;
begin
   Result := FALSE;
   if (abs(target.CX-CX) <= 2) and (abs(target.CY-CY) <= 2) then begin
      nx := target.CX - CX;
      ny := target.CY - CY;
      if (abs(nx) <= 1) and (abs(ny) <= 1) then begin
         TargetInAttackRange (target, targdir);
         Result := TRUE;
      end else begin
         nx := nx + 2;
         ny := ny + 2;
         if (nx in [0..4]) and (ny in [0..4]) then begin
            targdir := GetNextDirection (CX, CY, target.CX, target.CY);
            if CrossMap[targdir, ny, nx] = 1 then begin
               Result := TRUE;
            end;
         end;
      end;
   end;
end;


function  TCreature.WalkTo (dir: integer; allowdup: Boolean): Boolean;
var
   prx, pry, nwx, nwy, masx, masy: integer;
   hum: TUserHuman;
   oldpenvir: TEnvirnoment;
   flag: Boolean;
   down : integer;
begin
   Result := FALSE;
   down := 0;
   if BoHolySeize then begin  //ÀÌµ¿ ¸øÇÔ..
      exit;
   end;

   try
   down := 1;
      prx := CX;
      pry := CY;
      oldpenvir := PEnvir;
      self.Dir := dir;
      nwx := 0; nwy := 0;
      case dir of
         DR_UP:      begin  nwx := CX;  nwy := CY-1; end;
         DR_DOWN:    begin  nwx := CX;  nwy := CY+1; end;
         DR_LEFT:    begin  nwx := CX-1;  nwy := CY; end;
         DR_RIGHT:   begin  nwx := CX+1;  nwy := CY; end;
         DR_UPLEFT:  begin  nwx := CX-1;  nwy := CY-1; end;
         DR_UPRIGHT: begin  nwx := CX+1;  nwy := CY-1; end;
         DR_DOWNLEFT:  begin  nwx := CX-1;  nwy := CY+1; end;
         DR_DOWNRIGHT: begin  nwx := CX+1;  nwy := CY+1; end;
      end;

   down := 2;
      if (nwx >= 0) and (nwx <= PEnvir.MapWidth-1) and (nwy >= 0) and (nwy <= PEnvir.MapHeight-1) then begin

   down := 3;
         flag := TRUE;
         if BoFearFire then  begin //ºÒÀ» ¹«¼­¿öÇÔ
   down := 4;
            if not PEnvir.CanSafeWalk (nwx, nwy) then
               flag := FALSE;
         end;
         if Master <> nil then begin  //ÁÖÀÎÀÌ ÀÖ´Â ¸÷, ÁÖÀÎÀÇ ¾ÕÀ» °¡·Î ¸·Áö ¾Ê´Â´Ù.
   down := 5;
            GetNextPosition (Master.PEnvir, Master.CX, Master.CY, Master.Dir, 1, masx, masy);
            if (nwx = masx) and (nwy = masy) then
               flag := FALSE;
         end;
         if flag then begin
   down := 6;
            if PEnvir.MoveToMovingObject (CX, CY, self, nwx, nwy, allowdup) > 0 then begin
               CX := nwx;
               CY := nwy;
            end;
         end;
      end;

      if (prx <> CX) or (pry <> CY) then begin
         if Walk(RM_WALK) then begin
   down := 7;
            //Àº½Å¼ú ÇØÁ¦
            if BoFixedHideMode then begin //°íÁ¤ Àº½Å¼ú..
               if BoHumHideMode then begin  //ÀÌµ¿ÇÑ°æ¿ì¿¡´Â Àº½Å¼úÀÌ Ç®¸°´Ù.
                  StatusArr[STATE_TRANSPARENT] := 1;
               end;
            end;

            Result := TRUE;
         end else begin

   down := 8;
            if ( 1 = PEnvir.DeleteFromMap (CX, CY, OS_MOVINGOBJECT, self) ) then
            begin
              PEnvir := oldpenvir;
              CX := prx;
              CY := pry;
              if ( nil = PEnvir.AddToMap (CX, CY, OS_MOVINGOBJECT, self) ) then
              begin
                 MainOutMessage('NOT ADDTOMAP WorkTo:'+PEnvir.MapName+','+IntToStr(CX)+','+IntToStr(CY));
              end;
            end

         end
      end;
   except
      MainOutMessage ('[Exception] TCreatre.WalkTo:'+Self.UserName+','+IntTOstr(down)+':'+
      IntToStr(CX)+','+IntToStr(CY)+','+intToStr(dir));
   end;
end;

function  TCreature.RunTo (dir: integer; allowdup: Boolean): Boolean;
var
   prx, pry: integer;
begin
   Result := FALSE;

   try
      prx := CX;
      pry := CY;
      self.Dir := dir;
      case dir of
         DR_UP:
            begin
               if CY > 1 then
                  if PEnvir.CanWalk(CX, CY-1, allowdup) and (PEnvir.CanWalk(CX, CY-2, allowdup)) then
                     if PEnvir.MoveToMovingObject (CX, CY, self, CX, CY-2, TRUE) > 0 then begin
                        CY := CY - 2;
                     end;
            end;
         DR_DOWN:
            begin
               if CY < PEnvir.MapHeight-2 then
                  if PEnvir.CanWalk(CX, CY+1, allowdup) and (PEnvir.CanWalk(CX, CY+2, allowdup)) then
                     if PEnvir.MoveToMovingObject (CX, CY, self, CX, CY+2, TRUE) > 0 then begin
                        CY := CY + 2;
                     end;
            end;
         DR_LEFT:
            begin
               if CX > 1 then
                  if PEnvir.CanWalk(CX-1, CY, allowdup) and (PEnvir.CanWalk(CX-2, CY, allowdup)) then
                     if PEnvir.MoveToMovingObject (CX, CY, self, CX-2, CY, TRUE) > 0 then begin
                        CX := CX - 2;
                     end;
            end;
         DR_RIGHT:
            begin
               if CX < PEnvir.MapWidth-2 then
                  if PEnvir.CanWalk(CX+1, CY, allowdup) and (PEnvir.CanWalk(CX+2, CY, allowdup)) then
                     if PEnvir.MoveToMovingObject (CX, CY, self, CX+2, CY, TRUE) > 0 then begin
                        CX := CX + 2;
                     end;
            end;
         DR_UPLEFT:
            begin
               if (CX > 1) and (CY > 1) then
                  if PEnvir.CanWalk(CX-1, CY-1, allowdup) and (PEnvir.CanWalk(CX-2, CY-2, allowdup)) then
                     if PEnvir.MoveToMovingObject (CX, CY, self, CX-2, CY-2, TRUE) > 0 then begin
                        CX := CX - 2;
                        CY := CY - 2;
                     end;
            end;
         DR_UPRIGHT:
            begin
               if (CX < PEnvir.MapWidth-2) and (CY > 1) then
                  if PEnvir.CanWalk(CX+1, CY-1, allowdup) and (PEnvir.CanWalk(CX+2, CY-2, allowdup)) then
                     if PEnvir.MoveToMovingObject (CX, CY, self, CX+2, CY-2, TRUE) > 0 then begin
                        CX := CX + 2;
                        CY := CY - 2;
                     end;
            end;
         DR_DOWNLEFT:
            begin
               if (CX > 1) and (CY < PEnvir.MapHeight-2) then
                  if PEnvir.CanWalk(CX-1, CY+1, allowdup) and (PEnvir.CanWalk(CX-2, CY+2, allowdup)) then
                     if PEnvir.MoveToMovingObject (CX, CY, self, CX-2, CY+2, TRUE) > 0 then begin
                        CX := CX - 2;
                        CY := CY + 2;
                     end;
            end;
         DR_DOWNRIGHT:
            begin
               if (CX < PEnvir.MapWidth-2) and (CY < PEnvir.MapHeight-2) then
                  if PEnvir.CanWalk(CX+1, CY+1, allowdup) and (PEnvir.CanWalk(CX+2, CY+2, allowdup)) then
                     if PEnvir.MoveToMovingObject (CX, CY, self, CX+2, CY+2, TRUE) > 0 then begin
                        CX := CX + 2;
                        CY := CY + 2;
                     end;
            end;
      end;

      if (prx <> CX) or (pry <> CY) then begin
         if Walk(RM_RUN) then begin
            Result := TRUE;
         end else begin
            CX := prx;  //½ÇÆÐ..
            CY := pry;
            if PEnvir.MoveToMovingObject (prx, pry, self, CX, CY, TRUE) <= 0 then
            begin
                MainOutMessage('ERROR DO NOT MOVINGOBJECT BACK :'+PEnvir.MapName+':'+IntToStr(CX)+':'+IntToStr(CY));
            end;
         end
      end;

   except
      MainOutMessage ('[Exception] TCreature.RunTo');
   end;
end;

function  TCreature.IsEnoughBag: Boolean;
begin
   if Itemlist.Count < MAXBAGITEM then Result := TRUE
   else Result := FALSE;
end;

procedure TCreature.WeightChanged;
begin
   WAbil.Weight := {CalcWearWeightEx (-1) +} CalcBagWeight;
   UpdateMsg (self, RM_WEIGHTCHANGED, 0, 0, 0, 0, '');
end;

procedure TCreature.GoldChanged;
begin
   if RaceServer = RC_USERHUMAN then
      UpdateMsg (self, RM_GOLDCHANGED, 0, 0, 0, 0, '');
end;

procedure TCreature.GameGoldChanged;
begin
   if RaceServer = RC_USERHUMAN then
      UpdateMsg (self, RM_GAMEGOLDCHANGED, 0, 0, 0, 0, '');
end;


procedure TCreature.PotCashChanged;
begin
   if RaceServer = RC_USERHUMAN then
      UpdateMsg (self, RM_POTCASHCHANGED, 0, 0, 0, 0, '');
end;

procedure  TCreature.GamePointChanged;
begin
   if RaceServer = RC_USERHUMAN then
      UpdateMsg (self, RM_GAMEPOINTCHANGED, 0, 0, 0, 0, '');
end;

procedure TCreature.HealthSpellChanged;
begin
   if RaceServer = RC_USERHUMAN then
      UpdateMsg (self, RM_HEALTHSPELLCHANGED, 0, 0, 0, 0, '');
   if BoOpenHealth then
      SendRefMsg (RM_HEALTHSPELLCHANGED, 0, 0, 0, 0, '');
end;

function  TCreature.IsAddWeightAvailable (addweight: integer): Boolean;
begin
   if WAbil.Weight + addweight <= WAbil.MaxWeight then Result := TRUE
   else Result := FALSE;
end;

function  TCreature.FindItemName (iname: string): PTUserItem;
var
   i: integer;
begin
   Result := nil;
   for i:=0 to ItemList.Count-1 do begin
      if CompareText (UserEngine.GetStdItemName (PTUserItem(ItemList[i]).Index), iname) = 0 then begin
         Result := PTUserItem(ItemList[i]);
         break;
      end;
   end;
end;

function  TCreature.FindItemNameEx (iname: string; var count, durasum, duratop: integer): PTUserItem;
var
   i: integer;
   ps: PTStdItem;
   pu: PTUserItem;
begin
   Result := nil;
   durasum := 0;
   duratop := 0;
   count := 0;
   ps := nil;
   pu := nil;
   for i:=0 to ItemList.Count-1 do begin
      pu := PTUserItem(ItemList[i]);
      if pu <> nil then begin
         ps := UserEngine.GetStdItem(pu.Index);
         if ps <> nil then begin
            if CompareText(ps.Name, iname) = 0 then begin
               if ps.OverlapItem >= 1 then begin
                  count := pu.Dura;
                  Result := pu;
               end else begin
                  //-----------------------------------------------------------
                  //ºÎÀûÀÌ¸é °³¼ö¸¦ Ã¼Å©ÇØ¼­ ¸ðÀÚ¸£¸é ´ÙÀ½ ¾ÆÀÌÅÛÀ¸·Î ³Ñ¾î°¨.
                  if ps.Name = GetUnbindItemName(SHAPE_AMULET_BUNCH) then begin
                     if pu.Dura < pu.DuraMax then
                        continue;
                  end;
                  //-----------------------------------------------------------

                  if pu.Dura > duratop then begin
                     duratop := pu.Dura;
                     Result := pu;
                  end;
                  durasum := durasum + pu.Dura;
                  if Result = nil then
                     Result := pu;
                  Inc(count);
               end;
            end;
         end;
      end;
   end;
end;

function  TCreature.FindItemEventGrade (grade, count: integer): Boolean;
var
   i: integer;
   ps: PTStdItem;
   pu: PTUserItem;
   existcount: integer;
begin
   Result := FALSE;
   ps := nil;
   pu := nil;
   existcount := 0;
   for i:=0 to ItemList.Count-1 do begin
      pu := PTUserItem(ItemList[i]);
      if pu <> nil then begin
         ps := UserEngine.GetStdItem(pu.Index);
         if ps <> nil then begin
            if ps.EffType2 = EFFTYPE2_EVENT_GRADE then begin
               if ps.EffValue2 = grade then begin
                  Inc(existcount);
               end;
            end;
         end;
      end;
   end;

   if existcount >= count then Result := TRUE;
end;

function  TCreature.FindItemWear (iname: string; var count: integer): PTUserItem;
var
   i: integer;
begin
   Result := nil;
   count := 0;
   for i:=0 to U_TRANS do begin // bug : 8->12
      if CompareText (UserEngine.GetStdItemName (UseItems[i].Index), iname) = 0 then begin
         Result := @(UseItems[i]);
         Inc (count);
      end;
   end;
end;

function  TCreature.CanAddItem: Boolean;
begin
   Result := FALSE;
   if Itemlist.Count < MAXBAGITEM then
      Result := TRUE;
end;

//pu´Â »õ·Î newÇØ¼­ ´Ã°Í(µû·Î new ÇÏÁö ¾ÊÀ½)
function  TCreature.AddItem (pu: PTUserItem): Boolean;
begin
   Result := FALSE;
   if Itemlist.Count < MAXBAGITEM then begin
      Itemlist.Add (pu);
      WeightChanged;
      Result := TRUE;
   end;
end;

function  TCreature.DelItem (svindex: integer; iname: string): Boolean;
var
   i: integer;
begin
   Result := FALSE;
   for i:=0 to ItemList.Count-1 do begin
      if PTUserItem(ItemList[i]).MakeIndex = svindex then begin
         if CompareText (UserEngine.GetStdItemName (PTUserItem(ItemList[i]).Index), iname) = 0 then begin
            Dispose (PTUserItem(ItemList[i]));
            ItemList.Delete (i);
            Result := TRUE;
            break;
         end;
      end;
   end;
   if Result then
      WeightChanged;
end;

function  TCreature.DelItemIndex (bagindex: integer): Boolean;
var
   i: integer;
begin
   Result := FALSE;
   if (bagindex >= 0) and (bagindex < ItemList.Count) then begin
      Dispose (PTUserItem(ItemList[bagindex]));
      ItemList.Delete (bagindex);
   end;
end;
function  TCreature.DeletePItemAndSend1(pcheckitem: PTUserItem): Boolean;
var
   i: integer;
   hum: TUserHuman;
begin
   Result := FALSE;
   for i:=0 to ItemList.Count-1 do begin
      if ItemList[i] = pcheckitem then begin
         if RaceServer = RC_USERHUMAN then begin
            hum := TUserHuman(self);
            hum.SendDelItem (PTUserItem(ItemList[i])^);
         end;
       //  Dispose (PTUserItem(ItemList[i]));
         ItemList.Delete (i);
         Result := TRUE;
         exit;
      end;
   end;
   for i:=0 to U_TRANS do begin // bug : 8->12
      if @(UseItems[i]) = pcheckitem then begin
         if RaceServer = RC_USERHUMAN then begin
            hum := TUserHuman(self);
            hum.SendDelItem (UseItems[i]);
         end;
         UseItems[i].Index := 0;
         Result := TRUE;
      end;
   end;
end;

function  TCreature.DeletePItemAndSend (pcheckitem: PTUserItem): Boolean;
var
   i: integer;
   hum: TUserHuman;
begin
   Result := FALSE;
   for i:=0 to ItemList.Count-1 do begin
      if ItemList[i] = pcheckitem then begin
         if RaceServer = RC_USERHUMAN then begin
            hum := TUserHuman(self);
            hum.SendDelItem (PTUserItem(ItemList[i])^);
         end;
         Dispose (PTUserItem(ItemList[i]));
         ItemList.Delete (i);
         Result := TRUE;
         exit;
      end;
   end;
   for i:=0 to U_TRANS do begin // bug : 8->12
      if @(UseItems[i]) = pcheckitem then begin
         if RaceServer = RC_USERHUMAN then begin
            hum := TUserHuman(self);
            hum.SendDelItem (UseItems[i]);
         end;
         UseItems[i].Index := 0;
         Result := TRUE;
      end;
   end;
end;

function  TCreature.DeletePItemAndSendWithFlag (pcheckitem: PTUserItem; wBreakdown: Word): Boolean;
var
   i: integer;
   hum: TUserHuman;
begin
   Result := FALSE;
   for i:=0 to ItemList.Count-1 do begin
      if ItemList[i] = pcheckitem then begin
         if RaceServer = RC_USERHUMAN then begin
            hum := TUserHuman(self);
            hum.SendDelItemWithFlag (PTUserItem(ItemList[i])^, wBreakdown);
         end;
         Dispose (PTUserItem(ItemList[i]));
         ItemList.Delete (i);
         Result := TRUE;
         exit;
      end;
   end;
   for i:=0 to U_TRANS do begin  // bug : 8->12
      if @(UseItems[i]) = pcheckitem then begin
         if RaceServer = RC_USERHUMAN then begin
            hum := TUserHuman(self);
            hum.SendDelItemWithFlag (UseItems[i], wBreakdown);
         end;
         UseItems[i].Index := 0;
         Result := TRUE;
      end;
   end;
end;

function  TCreature.CanTakeOn (index: integer; ps: PTStdItem): Boolean; //¼ºº°°ú ·¹º§, Á÷¾÷¿¡ ¸Â´ÂÁö °Ë»ç
var
   strtemp: string;
begin
   Result := FALSE;
   if ps.StdMode = 10 then //³²ÀÚ ¿Ê
      if Sex <> 0 then begin //³²ÀÚ°¡ ¾Æ´Ï¸é
         SysMsg ('ÄÐÐÔ·þÊÎ', 0);
         exit;
      end;
   if ps.StdMode = 11 then //¿©ÀÚ¿Ê
      if Sex <> 1 then begin
         SysMsg ('Å®ÐÔ·þÊÎ', 0);
         exit;
      end;

   //2005 »©»©·Î ÀÌº¥Æ® (2005/11/8~11/21)
   if ps.StdMode = 30 then begin
      if ps.Shape = SHAPE_OF_LOVEPEPERO then begin
         //»ç¶ûÀÇ»©»©·Î´Â ¿¬ÀÎÀÌ ¾øÀ¸¸é Âø¿ëÇÒ ¼ö ¾ø´Ù.
         if TUserHuman(self).fLover <> nil then begin
            strtemp := TUserHuman(self).fLover.GetLoverName;
            if strtemp = '' then begin
               SysMsg ('ÁµÈËÎÞ·¨´÷', 0);
               exit;
            end;
         end;
      end else if ps.Shape = SHAPE_OF_PUMPKINHEAD then begin
         //È£¹Ú¸Ó¸®´Â ¿¬ÀÎÀÌ ÀÖÀ¸¸é Âø¿ëÇÒ ¼ö ¾ø´Ù.
         if TUserHuman(self).fLover <> nil then begin
            strtemp := TUserHuman(self).fLover.GetLoverName;
            if strtemp <> '' then begin
               SysMsg ('ÁµÈË¿É´÷', 0);
               exit;
            end;
         end;
      end;
   end;

   //¹«°Ô °Ë»ç  index:Âø¿ëÇÒ°÷
   if (index = U_WEAPON) or (index = U_RIGHTHAND) then begin
      if ps.Weight > WAbil.MaxHandWeight then begin //µé ¼ö ÀÖ´Â ¹«±â ¹«°Ô ÃÊ°ú
         SysMsg ('Ì«ÖØÁË', 0);
         exit;
      end;
   end else begin
      if ps.Weight + CalcWearWeightEx (index) > WAbil.MaxWearWeight then begin //ÀÔ°í ÀÖ´Â ¾ÆÀÌÅÛÀÇ ¹«°Ô ÃÊ°ú
         SysMsg ('Ì«ÖØÁË', 0);
         exit;
      end;
   end;

   case ps.Need of
      0: //·¹º§ °Ë»ç
         begin
            if Abil.Level >= ps.NeedLevel then
               Result := TRUE;
         end;
      1: //DC
         begin
            if Hibyte(WAbil.DC) >= ps.NeedLevel then
               Result := TRUE;
         end;
      2: //MC
         begin
            if Hibyte(WAbil.MC) >= ps.NeedLevel then
               Result := TRUE;
         end;
      3: //SC
         begin
            if Hibyte(WAbil.SC) >= ps.NeedLevel then
               Result := TRUE;
         end;
      4: // ¼ì²âÉùÍûºÍÈËÎïµÈ¼¶
          begin
            if (m_btCreditPoint >= ps.ATKSPD) and (Abil.level >= ps.NeedLevel) then
              result := TRUE;
          end;
      5: // ¼ì²â»ý·ÖÈÙÓþºÍÈËÎïµÈ¼¶    //2023-2-13¼Ó
          begin
            if (GamePoint >= ps.EFFTYPE1) and (Abil.level >= ps.NeedLevel) then
              result := TRUE;
          end;
      70: begin     //É³³ÇÖ÷×¨ÓÃ
            if IsGuildMaster and (MyGuild = UserCastle.OwnerGuild) then begin
              if WAbil.Level >= ps.NeedLevel then begin
                Result := True;
              end else begin
                SysMsg('µÈ¼¶²»¹»¡£', 0);
              end;
            end else begin
              SysMsg('É³³Ç³ÇÖ÷²Å¿ÉÒÔÊ¹ÓÃ´ËÎïÆ·¡£', 0);
            end;
         end;
   end;
   if not Result then
      SysMsg ('²»ÊÊºÏÄãÊ¹ÓÃ', 0);
end;

function  TCreature.GetDropPosition (x, y, wide: integer; var dx, dy: integer): Boolean;
var
   i, j, k, dropcount, icount, ssx, ssy: integer;
   pm: PTMapItem;
begin
   icount := 999;
   Result := FALSE;
   ssx    := dx;
   ssy    := dy;
   for k:=1 to wide do begin
      for j:=-k to k do begin
         for i:=-k to k do begin
            dx := x + i;
            dy := y + j;
            if PEnvir.GetItemEx (dx, dy, dropcount) = nil then begin
               if PEnvir.BoCanGetItem then begin
                  Result := TRUE;
                  break;
               end;
            end else begin
               if PEnvir.BoCanGetItem then begin
                  if icount > dropcount then begin
                     icount := dropcount;
                     ssx := dx;
                     ssy := dy;
                  end;
               end;
            end;
         end;
         if Result then break;
      end;
      if Result then break;
   end;
   if not Result then begin //¾Æ´Ï¸é ÀÚ±â ÀÚ¸®...
      if icount < 8 then begin
         dx := ssx;
         dy := ssy;
      end else begin
         dx := x;// - wide + Random(wide*2+1);
         dy := y;// - wide + Random(wide*2+1);
      end;
   end;
end;

function  TCreature.GetRecallPosition (x, y, wide: integer; var dx, dy: integer): Boolean;
var
   i, j, k: integer;
   pm: PTMapItem;
begin
   Result := FALSE;
   if PEnvir.GetCreature (x, y, TRUE) = nil then begin
      Result := TRUE;
      dx := x;
      dy := y;
   end;
   if not Result then begin
      for k:=1 to wide do begin
         for j:=-k to k do begin
            for i:=-k to k do begin
               dx := x + i;
               dy := y + j;
               if PEnvir.GetCreature (dx, dy, TRUE) = nil then begin
                  Result := TRUE;
                  break;
               end;
            end;
            if Result then break;
         end;
         if Result then break;
      end;
   end;
   if not Result then begin //¾Æ´Ï¸é ÀÚ±â ÀÚ¸®...
      dx := x;// - wide + Random(wide*2+1);
      dy := y;// - wide + Random(wide*2+1);
   end;
end;

function  TCreature.DropItemDown (ui: TUserItem; scatterrange: integer; diedrop: Boolean; ownership, droper: TObject; IsDropFromBag : integer): Boolean;
var
   i, dx, dy, idura, temp: integer;
   pmi, pr: PTMapItem;
   ps: PTStdItem;
   logcap: string;
   decoitem : TAgitDecoItem;
   pricestr : string;
   countstr : string;
   ShowName : string;
begin
   Result := FALSE;
   countstr := '';
   ShowName := '';
    if RaceServer = RC_USERHUMAN then begin
    if TUserHuman(Self).m_StallMgr.OnSale then begin

      Exit;
    end;
  end;
   ps := UserEngine.GetStdItem (ui.Index);
   if ps <> nil then begin

      if ps.StdMode = 40 then begin //°í±â¸¦ ¶¥¿¡ ¶³¾î¶ß¸° °æ¿ì °í±â Ç°ÁúÀÌ ¶³¾îÁø´Ù.
         idura := ui.Dura; //wordÀÌ¹Ç·Î.
         idura := idura - 2000; //°í±â Ç°ÁúÀÌ ¶³¾îÁø´Ù.
         if idura < 0 then idura := 0;
         ui.Dura := idura;
      end;

      new (pmi);
      pmi.UserItem := ui;

      // Ä«¿îÆ® ¾ÆÀÌÅÛ
      if (ps.OverlapItem >= 1) then begin
         temp := ui.Dura;
         if temp > 1 then begin
            countstr := '(' + IntToStr(temp) + ')';   //·Î±×¸¦ À§ÇÑ ¾ÆÀÌÅÛ °³¼ö(sonmg 2005/01/07)
            pmi.Name := ps.Name + countstr;  // gadget :Ä«¿îÅÍ¾ÆÀÌÅÛ
         end else
            pmi.Name := ps.Name;
      end else
         pmi.Name := ps.Name;

      pmi.Looks := ps.Looks;
      if ps.StdMode = 45 then begin  //ÁÖ»çÀ§, ¸ñÀç
         pmi.Looks := GetRandomLook (pmi.Looks, ps.Shape);
      end;
      pmi.AniCount := ps.AniCount;
      pmi.Reserved := 0;
      pmi.Count := 1;
      pmi.Ownership := ownership;
      pmi.Droptime := GetTickCount;
      pmi.Droper := droper;

      for i:=0 to UserEngine.DropItemShowList.Count -1 do begin
        if (CompareText (UserEngine.DropItemShowList[i], ps.Name) = 0) and
          (TUserHuman(self).RaceServer <> RC_USERHUMAN) then begin
          GetValidStrNoVal (TUserHuman(self).UserName, ShowName);
          UserEngine.SysMsgAll (TUserHuman(self).PEnvir.MapTitle + 'µÄ' +ShowName +'±¬³ö£º' + ps.Name);
          Break;
        end;
      end;

      GetDropPosition (CX, CY, scatterrange, dx, dy);

      //-----------------------------------------
      //»óÇöÁÖ¸Ó´Ï¸¦ ¸Ê¿¡ ¶³¾î¶ß¸®´Â °æ¿ì
      if (ps.StdMode = STDMODE_OF_DECOITEM) and (ps.Shape = SHAPE_OF_DECOITEM) then begin
         if ui.Dura <= DecoItemList.Count then begin
            //µå·Ó À§Ä¡´Â ÀÚ±â ÀÚ½ÅÀÇ À§Ä¡·Î ¼³Á¤.
            dx := CX;
            dy := CY;

            pmi.Name := GuildAgitMan.GetDecoItemName(ui.Dura, pricestr) + '[' + IntToStr(Round(ui.DuraMax/1000)) + ']' + '/' + '1';  //µ¥ÄÚ¾ÆÀÌÅÛ
            pmi.Looks := ui.Dura;
            pmi.AniCount := ps.AniCount;
            pmi.Reserved := 0;
            pmi.Count := 1;
            pmi.Ownership := droper;  // ¶³¾î¶ß¸° »ç¶÷ÀÇ ¼ÒÀ¯...
            pmi.Droptime := GetTickCount;
            pmi.Droper := droper;

            //»óÇöÁÖ¸Ó´Ï ¼Ó¼º ¼³Á¤ ¹× List¿¡ ÀúÀå
            decoitem.Name := GuildAgitMan.GetDecoItemName(ui.Dura, pricestr);
            decoitem.Looks := ui.Dura;
            decoitem.MapName := PEnvir.MapName;
            decoitem.x := dx;
            decoitem.y := dy;
            decoitem.Maker := UserName;
            decoitem.Dura := ui.DuraMax;
         end else begin
            MainOutMessage('[DropItemDown] DecoItemList Error...');
         end;
      end else begin
         pmi.Name := pmi.Name + '/' +  '0';  //ÀÏ¹Ý¾ÆÀÌÅÛ(µ¥ÄÚ¾ÆÀÌÅÛÀÌ ¾Æ´Ô)
      end;
      //-----------------------------------------

      pr := Penvir.AddToMap (dx, dy, OS_ITEMOBJECT, TObject (pmi));  //ÇÑ¼¿¿¡ 5°³ ÀÌ»óÀÇ ¾ÆÀÌÅÛÀÌ ÀÖÀ¸¸é ½ÇÆÐÇÑ´Ù.
      if pr = pmi then begin
         //»óÇöÁÖ¸Ó´ÏÀÎ °æ¿ì ¸Ê¿¡ Á¦´ë·Î Ãß°¡°¡ µÇ¾úÀ¸¸é...
         if (ps.StdMode = STDMODE_OF_DECOITEM) and (ps.Shape = SHAPE_OF_DECOITEM) then begin
            if GuildAgitMan.AddAgitDecoMon(decoitem) then begin
               // Àå¿ø²Ù¹Ì±â ¿ÀºêÁ§Æ® °³¼ö Ãß°¡
               GuildAgitMan.IncAgitDecoMonCount( GetGuildNameHereAgit );
               //²Ù¹Ì±â ¾ÆÀÌÅÛ ¸®½ºÆ®¸¦ ÀúÀåÇÑ´Ù.
               GuildAgitMan.SaveAgitDecoMonList;
            end else begin
               MainOutMessage('[ErrorMsg]TCreature.DropItemDown : AddAgitDecoMon Failure!!!');
            end;
         end;

         //¾ÆÀÌÅÛÀº Ãß°¡ ¾Æ´Ï¸é ½ÇÆÐ..
         SendRefMsg (RM_ITEMSHOW, pmi.Looks, integer(pmi), dx, dy, pmi.Name);
         //¶³¾î¶ß¸²
         if diedrop then logcap := '15'#9  //¶³±À_
         else begin
            logcap := '7'#9;  //¹ö¸²_
            TUserHuman(self).LatestDropTime := GetTickCount;
         end;
         if not IsCheapStuff (ps.StdMode) then
            AddUserLog (logcap +
                        MapName + ''#9 +
                        IntToStr(CX) + ''#9 +
                        IntToStr(CY) + ''#9 +
                        UserName + ''#9 +
                        UserEngine.GetStdItemName (ui.Index) + ''#9 +
                        IntToStr(ui.MakeIndex) + ''#9 +
                        IntToStr(BoolToInt(RaceServer = RC_USERHUMAN)) + ''#9 +
                        IntToStr(IsDropFromBag) + countstr //°³¼ö·Î±×(sonmg 2005/01/07)
                        );
         Result := TRUE;
      end else begin
         //½ÇÆÐÀÎ°æ¿ì
         Dispose (pmi);
      end;
   end;
end;

//Gold°¡ ÁÙÁö´Â ¾ÊÀ½.
//diedrop = TRUE (Á×¾î¼­ ¶³±À) FALSE (¹ö¸²)
function  TCreature.DropGoldDown (goldcount: integer; diedrop: Boolean; ownership, droper: TObject): Boolean;
var
   dx, dy: integer;
   pmi, pr: PTMapItem;
   ps: PTStdItem;
   logcap: string;
begin
   Result := FALSE;
   new (pmi);
   FillChar (pmi^, sizeof(TMapItem), #0);
   pmi.Name := NAME_OF_GOLD{'½ð±Ò'};
   pmi.Count := goldcount;
   pmi.Looks := GetGoldLooks (goldcount);
   pmi.Ownership := ownership;
   pmi.Droptime := GetTickCount;
   pmi.Droper := droper;

   GetDropPosition (CX, CY, 3, dx, dy);
   pr := PEnvir.AddToMap (dx, dy, OS_ITEMOBJECT, TObject (pmi));
   if pr <> nil then begin
      if pr <> pmi then begin
         Dispose (pmi);
         pmi := pr;
      end;
      SendRefMsg (RM_ITEMSHOW, pmi.Looks, integer(pmi), dx, dy, NAME_OF_GOLD{'±ÝÀü'} + '/' + '0');   //Àå¿ø²Ù¹Ì±â·Î ÀÎÇØ Ãß°¡Á¤º¸ ºÙ¿©¼­ º¸³¿
      //¶³¾î¶ß¸²
      if RaceServer = RC_USERHUMAN then begin
         if diedrop then logcap := '15'#9  //¶³±À_
         else begin
            logcap := '7'#9;  //¹ö¸²_
            TUserHuman(self).LatestDropTime := GetTickCount;
         end;
         // 500 ÀÌ»ó¸¸ ·Î±×³²±è 2004-03-22
         if goldcount >= 500 then
         begin
           AddUserLog (logcap +
                       MapName + ''#9 +
                       IntToStr(CX) + ''#9 +
                       IntToStr(CY) + ''#9 +
                       UserName + ''#9 +
                       NAME_OF_GOLD{'½ð±Ò'} + ''#9 +
                       IntToStr(goldcount) + ''#9 +
                       IntToStr(BoolToInt(RaceServer = RC_USERHUMAN)) + ''#9 +
                       '0');
         end;
      end;
      Result := TRUE;
   end else begin
      //½ÇÆÐÀÎ°æ¿ì
      Dispose (pmi);
   end;
end;

//¶¥¹Ù´Ú¿¡ ¹ö¸²
function  TCreature.UserDropItem (itmname: string; itemindex: integer): Boolean;
var
   i: integer;
   pu: PTUserItem;
   pstd: PTStdItem;
   hum : TUserHuman;
   gname : string;
begin
   Result := FALSE;
  if RaceServer = RC_USERHUMAN then begin
    if TUserHuman(Self).m_StallMgr.OnSale then begin

      Exit;
    end;
  end;
   if BoGhost then begin
      MainOutMessage('Ghost tried UserDropItem!!!');
//      exit;
   end;
   // ¾ÆÀÌÅÛÀ» ¹ö¸± ¼ö ¾øÀ½(sonmg 2005/03/14)
   if PEnvir.NoThrowItem then exit;

   if pos(' ', itmname) >= 0 then
      GetValidStr3 (itmname, itmname, [' ']);
   if GetTickCount - DealItemChangeTime > 3000 then begin  //±³È¯Ã¢ÀÌ »ç¶óÁø ´ÙÀ½ ¾ÆÀÌÅÛÀ» ¿Ã¸®·Á´Ù ¶¥¿¡ ¶³±¸´Â °ÍÀ» ¹æÁö
      for i:=0 to ItemList.Count-1 do begin
         pu := PTUserItem(ItemList[i]);
         pstd := UserEngine.GetStdItem (pu.Index);  //´ë¸¸ ÀÌº¥Æ®, ¹ö¸± ¼ö ¾ø´Â ¾ÆÀÌÅÛ
         if pstd = nil then continue;
//         if (pstd.UniqueItem and $04) <> 0 then continue; //UNIQUEITEM ÇÊµå°¡ 00000100(2Áø¼ö)¸¦ Æ÷ÇÔÇÏ¸é ¶³±¼ ¼ö ¾ø´Â ¾ÆÀÌÅÛ(sonmg 2005/03/14)
         if pstd.StdMode <> TAIWANEVENTITEM then begin  //ÀÌº¥Æ® ¾ÆÀÌÅÛÀº ¸ø ¹ö¸°´Ù.
            if (pu.MakeIndex = itemindex) then begin
               if CompareText (UserEngine.GetStdItemName (pu.Index), itmname) = 0 then begin
                  //UNIQUEITEM ÇÊµå°¡ 00000100(2Áø¼ö)¸¦ Æ÷ÇÔÇÏ¸é ¹ö¸®¸é »ç¶óÁö´Â ¾ÆÀÌÅÛ(sonmg 2005/03/14)
                   if (pstd.UniqueItem and $32) <> 0 then begin
                     SysMsg('ÌáÊ¾£º¸ÃÎïÆ·ÎªÌØÊâÎïÆ·,²»ÄÜ¶ªÆú!', 0);    //UniqueItem 32 ²»ÔÊÐí¶ª³ö jindianadd 20220309
                     Exit;
                  end;
                  if (pstd.UniqueItem and $04) <> 0 then begin
                     Dispose (PTUserItem(ItemList[i]));
                     ItemList.Delete (i);
                     Result := TRUE;
                     break;
                  end;

                  //------------------------------------
                  //Àå¿ø²Ù¹Ì±â ¾ÆÀÌÅÛ ¸Ê¿¡ ¼³Ä¡(sonmg)
                  if (pstd.StdMode = STDMODE_OF_DECOITEM) and (pstd.Shape = SHAPE_OF_DECOITEM) then begin
                     if RaceServer = RC_USERHUMAN then begin
                        hum := TUserHuman (self);

                        // Àå¿øÀÎÁö Ã¼Å©
                        gname := hum.GetGuildNameHereAgit;
                        if gname <> '' then begin
                           // º»ÀÎÀÇ Àå¿øÀÎÁö Ã¼Å©
                           if MyGuild <> nil then begin
                              if TGuild(MyGuild).GuildName <> gname then begin
                                 hum.SysMsg('¸Ã×¯Ô°ÕýÔÚÊ¹ÓÃÖÐ', 0);
                                 break;
                              end;
                              if not GuildAgitMan.IsAvailableDecoMonCount(gname) then begin
                                 hum.SysMsg('ÎÞ·¨¼ÌÐø°²×°', 0);
                                 break;
                              end;
                              if not GuildAgitMan.IsMatchDecoItemInOutdoor(pu.Dura, MapName) then begin
                                 hum.SysMsg('ÕâÀï¿ÉÒÔÉèÖÃ', 0);
                                 break;
                              end;
                              // Àå¿ø²Ù¹Ì±â ¿ÀºêÁ§Æ® °³¼ö Ãß°¡(->À§Ä¡°¡ ºÎÀûÀýÇÔ ¿Å±è 2004/09/01)
//                              GuildAgitMan.IncAgitDecoMonCount( GetGuildNameHereAgit );
                           end;
                        end else begin
                           hum.SysMsg('¸Ã×¯Ô°ÖÐÊ¹ÓÃ', 0);
                           break;
                        end;
                     end;
                  end;

                  if DropItemDown (pu^, 1, FALSE, nil, self,0) then begin
                     Dispose (PTUserItem(ItemList[i]));
                     ItemList.Delete (i);
                     Result := TRUE;
                     break;
                  end;
               end;
            end;
         end;
      end;
      if Result then
         WeightChanged;
   end;
end;

function  TCreature.UserDropGold (dropgold: integer): Boolean;
begin
   Result := FALSE;
  if RaceServer = RC_USERHUMAN then begin
    if TUserHuman(Self).m_StallMgr.OnSale then begin

      Exit;
    end;
  end;
   if BoGhost then begin
      MainOutMessage('Ghost tried UserDropGold!!!');
//      exit;
   end;
   // ¾ÆÀÌÅÛÀ» ¹ö¸± ¼ö ¾øÀ½(sonmg 2005/03/14)
   if PEnvir.NoThrowItem then exit;

   if (dropgold > 0) and (dropgold <= Gold) then begin
//      Gold := Gold - dropgold;
      DecGold( dropgold );
      if not DropGoldDown (dropgold, FALSE, nil, self) then begin
//         Gold := Gold + dropgold;
         IncGold( dropgold );
      end;
      GoldChanged;
      Result := true;
   end;
end;

// Ä«¿îÆ® ¾ÆÀÌÅÛ
function TCreature.UserDropCountItem(itmname: string; dropidx, dropcnt: integer): Boolean;
var
   i, remain, t: integer;
   pu, newpu: PTUserItem;
   ps: PTStdItem;
begin
   Result := FALSE;
   if BoGhost then begin
      MainOutMessage('Ghost tried UserDropCountItem!!!');
//      exit;
   end;
   // ¾ÆÀÌÅÛÀ» ¹ö¸± ¼ö ¾øÀ½(sonmg 2005/03/14)
   if PEnvir.NoThrowItem then exit;

   if pos(' ', itmname) >= 0 then
      GetValidStr3(itmname, itmname, [' ']);
   if GetTickCount - DealItemChangeTime > 3000 then begin //±³È¯Ã¢ÀÌ »ç¶óÁø ´ÙÀ½ ¾ÆÀÌÅÛÀ» ¿Ã¸®·Á´Ù ¶¥¿¡ ¶³±¸´Â °ÍÀ» ¹æÁö
      for i := 0 to ItemList.Count - 1 do begin
         pu := PTUserItem(ItemList[i]);
         if pu.MakeIndex = dropidx then begin
            ps := UserEngine.GetStdItem (pu.Index);
            if ps <> nil then begin
               if ps.OverlapItem = 0 then continue;

//               if (ps.UniqueItem and $04) <> 0 then continue; //UNIQUEITEM ÇÊµå°¡ 00000100(2Áø¼ö)¸¦ Æ÷ÇÔÇÏ¸é ¶³±¼ ¼ö ¾ø´Â ¾ÆÀÌÅÛ(sonmg 2005/03/14)

               if CompareText(ps.Name, itmname) = 0 then begin
                  t := pu.Dura;
                  if dropcnt > t then dropcnt := pu.Dura;

                  remain := t - dropcnt;

                  if dropcnt > 0 then begin
                     if remain > 0 then begin
                        new(newpu);
                        if UserEngine.CopyToUserItemFromName(itmname, newpu^) then begin
                           newpu.Dura := dropcnt;
                           //UNIQUEITEM ÇÊµå°¡ 00000100(2Áø¼ö)¸¦ Æ÷ÇÔÇÏ¸é ¹ö¸®¸é »ç¶óÁö´Â ¾ÆÀÌÅÛ(sonmg 2005/03/14)
                           if (ps.UniqueItem and $04) <> 0 then begin
                              pu.Dura := remain;
                              SendMsg(self, RM_COUNTERITEMCHANGE, 0, pu.MakeIndex, remain {ÊýÁ¿}, 0, itmname);
                              WeightChanged;
                              Dispose(newpu);
                              break;
                           end;
                           if DropItemDown(newpu^, 1, FALSE, nil, self,0) then begin
                              pu.Dura := remain;
                              SendMsg(self, RM_COUNTERITEMCHANGE, 0, pu.MakeIndex, remain {ÊýÁ¿}, 0, itmname);
                              WeightChanged;
                              Dispose(newpu);
                              break;
                           end else begin
                              Dispose(newpu);
                              break;
                           end;
                        end else begin
                           Dispose(newpu);
                           break;
                        end;
                     end else begin
                        //UNIQUEITEM ÇÊµå°¡ 00000100(2Áø¼ö)¸¦ Æ÷ÇÔÇÏ¸é ¹ö¸®¸é »ç¶óÁö´Â ¾ÆÀÌÅÛ(sonmg 2005/03/14)
                        if (ps.UniqueItem and $04) <> 0 then begin
                           Dispose (PTUserItem(ItemList[i]));
                           ItemList.Delete (i);
                           WeightChanged;
                           Result := TRUE;
                           break;
                        end;
                        if DropItemDown(pu^, 1, FALSE, nil, self,0) then begin
                           Dispose(PTUserItem(ItemList[i]));
                           ItemList.Delete(i);
                           WeightChanged;
                           Result := TRUE;
                           break;
                        end;
                     end;
                  end;
               end;
            end;
         end;
      end;
   end;
end;

////////////////////////////////////////////////////////////////////////////////
// Ä«¿îÆ® ¾ÆÀÌÅÛ °³¼ö Ãß°¡
// ¼³¸í : °¡¹æÃ¢¿¡¼­ ÇØ´ç ¾ÆÀÌÅÛÀ» Ã£¾Æ¼­ Ä«¿îÆ®¸¦ ÇÕ»ê.
//        ¾øÀ» °æ¿ì³ª ÃÖ´ë °³¼ö¸¦ ³Ñ´Â °æ¿ì´Â FALSE¸¦ ¸®ÅÏ.
//        °°Àº ¾ÆÀÌÅÛÀÌ ¿©·µ ÀÖ´Ù¸é °³¼ö°¡ °¡Àå ÀÛÀº ¾ÆÀÌÅÛ¿¡ ÇÕ»êÇÏµµ·Ï ¼öÁ¤.(2004/1/7)
function TCreature.UserCounterItemAdd(StdMode, Looks, Cnt: integer; iName:string; bEnforce: Boolean; ExceptMakeIndex: integer) : Boolean;
var
   i: integer;
   pu: PTUserItem;
   ps: PTStdItem;
   idxMinimum: integer; // °¡Àå ÀÛÀº °³¼öÀÇ ¾ÆÀÌÅÛ ÀÎµ¦½º.
   countMinimum, temp: WORD; // °¡Àå ÀÛÀº °³¼ö
begin
   Result := FALSE;

   // °ª ÃÊ±âÈ­.
   idxMinimum := -1;
   countMinimum := 0;
   temp := 0;

   for i := 0 to Itemlist.Count - 1 do begin
      ps := UserEngine.GetStdItem(PTUserItem(Itemlist[i]).Index);

      if ps = nil then continue;
      if ps.OverlapItem = 0 then continue;
      // Ä«¿îÆ® ¾ÆÀÌÅÛÀÌ¸é¼­ °°Àº Á¾·ùÀÇ ¾ÆÀÌÅÛÀÌ¸é.
      if (ps.StdMode = StdMode) and (ps.Looks = Looks) and (ps.OverlapItem >= 1) then begin
         // ÀÌ¸§ÀÌ °°À¸¸é
         if CompareText(ps.Name, iName) = 0 then begin
            pu := PTUserItem(Itemlist[i]);

{  // ¹«°Ô Á¦ÇÑ ¾ø¾Ú.
            if ps.OverlapItem = 1 then begin
               if ((WAbil.Weight + (cnt div 10)) > WAbil.MaxWeight) then exit;
            end else begin
               if (WAbil.Weight + (ps.Weight * cnt) > WAbil.MaxWeight) then exit;
            end;
}

            // ÁöÁ¤ÇÑ makeindexÀÇ ¾ÆÀÌÅÛÀº Á¦¿Ü.
            if (ExceptMakeIndex <> -1) and (pu.MakeIndex = ExceptMakeIndex) then continue;

            // ¾ÆÀÌÅÛÀÇ °³¼ö¸¦ ÃÖ¼Ò°ª¿¡ ´ëÀÔ.
            // Ã³À½¿¡´Â ±×³É ´ëÀÔ. ÀÌÈÄ¿¡´Â °ªÀ» ºñ±³ÇØ¼­ ÀÛÀº °ªÀ» ´ëÀÔ.
            if idxMinimum = -1 then begin
               countMinimum := pu.Dura;
               idxMinimum := i;
            end else begin
               if countMinimum > pu.Dura then begin
                  countMinimum := pu.Dura;
                  idxMinimum := i;
               end;
            end;
         end;
      end;
   end;

   // ¾ÆÀÌÅÛÀÌ ¾øÀ¸¸é exit
   if idxMinimum < 0 then exit;

   // °³¼ö°¡ °¡Àå ÀÛÀº ¾ÆÀÌÅÛ.
   ps := UserEngine.GetStdItem(PTUserItem( Itemlist[idxMinimum] ).Index);
   if ps = nil then exit;
   pu := PTUserItem( Itemlist[idxMinimum] );

   // MAX_OVERLAPITEM³ÑÀ¸¸é FALSE ¸®ÅÏ.
   // °­Á¦ ¿É¼ÇÀÌ ÀÖÀ¸¸é ÃÖ´ë °³¼ö Á¦ÇÑÀ» ¹«½ÃÇÏ°í ¹«Á¶°Ç ÇÕ»ê.
   if (bEnforce = FALSE) and (pu.Dura + Cnt > MAX_OVERLAPITEM) then exit;

   // MAX_OVERFLOW ³ÑÀ¸¸é exit.
   if pu.Dura + Cnt > MAX_OVERFLOW then exit;

   // Dura¸¦ Count·Î »ç¿ë.
   // °³¼ö¸¦ ÇÕ»ê¿¡¼­ ´ëÀÔ.
   pu.Dura := _MIN(MAX_OVERFLOW, pu.Dura + Cnt);

   // ÇÕ»ê °á°ú¸¦ Å¬¶óÀÌ¾ðÆ®¿¡ Åëº¸.
   if RaceServer = RC_USERHUMAN then begin
      SendMsg(self, RM_COUNTERITEMCHANGE, 0, pu.MakeIndex, pu.Dura {ÊýÁ¿}, 1{Ôö¼Ó}, ps.Name);
   end;

   Result := TRUE;
end;


// °Å·¡ ¸ñ·Ï -> Ä«¿îÆ® ¾ÆÀÌÅÛ °³¼ö Ãß°¡
function TCreature.UserCounterDealItemAdd(StdMode, Looks, Cnt: integer; iName:string) : Integer;
const
   FAIL = 0;
   SUCCESS = 1;
   OVERFLOW = 2;
   OVERCOUNT = 3;
var
   i: integer;
   pu: PTUserItem;
   ps: PTStdItem;
begin
   Result := FAIL;

   for i := 0 to DealList.Count - 1 do begin
      ps := UserEngine.GetStdItem(PTUserItem(DealList[i]).Index);

      if ps = nil then continue;
      if ps.OverlapItem = 0 then continue;
      if (ps.StdMode = StdMode) and (ps.Looks = Looks) and (ps.OverlapItem >= 1) then begin
         if CompareText(ps.Name, iName) = 0 then begin
            pu := PTUserItem(DealList[i]);

{  // ¹«°Ô Á¦ÇÑ ¾ø¾Ú.
            if ps.OverlapItem = 1 then begin
               if ((WAbil.Weight + (cnt div 10)) > WAbil.MaxWeight) then exit;
            end else begin
               if (WAbil.Weight + (ps.Weight * cnt) > WAbil.MaxWeight) then exit;
            end;
}

            // °Å·¡ÇÒ ¶§´Â ÃÖ´ë °³¼ö°¡ ³Ñ¾îµµ ÅëÇÕÇÑ´Ù.
            if pu.Dura + Cnt > MAX_OVERLAPITEM then begin
               Result := OVERCOUNT;
               exit;
            end;

            // MAX_OVERFLOW ³Ñ´Â °æ¿ì.
            if pu.Dura + Cnt > MAX_OVERFLOW then begin
               Result := OVERFLOW;
               exit;
            end;

            // Dura¸¦ Count·Î »ç¿ë.
            pu.Dura := _MIN(MAX_OVERFLOW, pu.Dura + Cnt);
            if RaceServer = RC_USERHUMAN then begin
               SendMsg(self, RM_COUNTERITEMCHANGE, 0, pu.MakeIndex, pu.Dura {ÊýÁ¿}, 0, ps.Name);
            end;
            Result := SUCCESS;
            break;
         end;
      end;
   end;
end;


function  TCreature.PickUp: Boolean;
   function canpickup (ownership: TObject): Boolean;
   begin
      if (ownership = nil) or (ownership = self) then
         Result := TRUE
      else
         Result := FALSE;
   end;
   function cangrouppickup (ownership: TObject): Boolean;
   var
      i: integer;
      cret: TCreature;
   begin
      Result := FALSE;
      if GroupOwner <> nil then
         for i:=0 to GroupOwner.GroupMembers.Count-1 do begin
            cret := TCreature(GroupOwner.GroupMembers.Objects[i]);
            if (cret = ownership) then begin
               Result := TRUE;
               break;
            end;
         end;
   end;
var
   i, wg: integer;
   pu: PTUserItem;
   pmi: PTMapItem;
   ps: PTStdItem;
   hum: TUserHuman;
   questnpc: TMerchant;
   dropername: string;
   flag: Boolean;
   decoitem: TAgitDecoItem;
   pricestr : string;
   countstr : string;
begin
   Result := FALSE;
   wg := 0;
   ps := nil;
   countstr := '';

   if BoDealing then exit;  //±³È¯Áß¿¡´Â ¹°°ÇÀ» ÁÖ¿ï ¼ö ¾ø´Ù.
   hum := nil;
   pmi := PEnvir.GetItem (CX, CY);
   if pmi <> nil then
   begin
       ps := UserEngine.GetStdItem(pmi.UserItem.Index); // gadget: Ä«¿îÆ®¾ÆÀÌÅÛ
       if (ps<>nil) and (WAbil.Weight+ps.Weight>WAbil.MaxWeight) then
          begin
     //        SysMsg ('°ü¹ü¹ýÖØ', 0);
             Exit;
          end;

      //¸ÔÀÚ ¸·´Â ·çÆ¾
      if (GetTickCount - pmi.droptime > ANTI_MUKJA_DELAY) then
         pmi.ownership := nil;

      if canpickup (pmi.ownership) or cangrouppickup(pmi.ownership) then begin
         if CompareText (pmi.Name, NAME_OF_GOLD{'½ð±Ò'}) = 0 then begin
            if PEnvir.DeleteFromMap (CX, CY, OS_ITEMOBJECT, TObject(pmi)) = 1 then begin
               if IncGold (pmi.Count) then begin
                  SendRefMsg (RM_ITEMHIDE, 0, integer(pmi), CX, CY, '');
                  //·Î±×³²±è
                  // 500 ¿ø ÀÌ»ó¸¸ ³²±ä´Ù. 2004-03-22
                  if pmi.Count >= 500 then begin
                     AddUserLog ('4'#9 + //ÁÝ±â_
                                MapName + ''#9 +
                                IntToStr(CX) + ''#9 +
                                IntToStr(CY) + ''#9 +
                                UserName + ''#9 +
                                NAME_OF_GOLD{'½ð±Ò'} + ''#9 +
                                IntToStr(pmi.count) + ''#9 +
                                '1'#9 +
                                '0');
                  end;
                  GoldChanged;
                  Dispose (pmi);
               end else
                  PEnvir.AddToMap (CX, CY, OS_ITEMOBJECT, TObject(pmi));
            end;
         end else
            ps := UserEngine.GetStdItem(pmi.UserItem.Index); // gadget: Ä«¿îÆ®¾ÆÀÌÅÛ

            if ps <> nil then begin
               // Ä«¿îÆ® ¾ÆÀÌÅÛÀÌ¸é ±âÁ¸ ¾ÆÀÌÅÛ¿¡ °³¼ö¸¸ ´õÇÑ´Ù.
               // ±âÁ¸ ¾ÆÀÌÅÛÀÌ ¾øÀ¸¸é µû·Î »ý¼ºÇÑ´Ù.
               if ps.OverlapItem >= 1 then begin
                  countstr := '(' + IntToStr(pmi.UserItem.Dura) + ')';  //·Î±×¸¦ À§ÇÑ ¾ÆÀÌÅÛ °³¼ö(sonmg 2005/01/07)
                  if PEnvir.DeleteFromMap(CX, CY, OS_ITEMOBJECT, TObject(pmi)) = 1 then begin
                     if UserCounterItemAdd(ps.StdMode, ps.Looks, pmi.UserItem.Dura, ps.Name, FALSE) then begin
                        SendMsg(self, RM_ITEMHIDE, 0, integer(pmi), CX, CY, '');
                        WeightChanged;
                        Dispose(pmi);   //memory leak
                        exit;
                     end else begin
                        PEnvir.AddToMap(CX, CY, OS_ITEMOBJECT, TObject(pmi));
                     end;
                  end;
               end;

               if IsEnoughBag then begin
                  flag := TRUE;
                  //------»óÇöÁÖ¸Ó´Ï----------------------
                  if (ps.StdMode = STDMODE_OF_DECOITEM) and (ps.Shape = SHAPE_OF_DECOITEM) then begin
                     //¼ÒÀ¯ÀÚ°¡ ¾øÀ¸¸é ¹®ÁÖ¸¸ ÁÖ¿ï ¼ö ÀÖ°í, ¼ÒÀ¯ÀÚ°¡ ÀÖÀ¸¸é ¼ÒÀ¯ÀÚ¸¸ ÁÖ¿ï ¼ö ÀÖ´Ù.
                     if ((pmi.Ownership = nil) and (IsMyGuildMaster)) or ((pmi.Ownership <> nil) and (pmi.Ownership = self)) then begin
                        //³»±¸°¡ 1ÀÌÇÏÀÌ¸é ÁÝÁö ¸øÇÑ´Ù.
//                        if Round(pmi.UserItem.DuraMax/1000) > 1 then begin
                           //¸®½ºÆ®¿¡¼­ »èÁ¦ÇÑ´Ù.
                           if GuildAgitMan.DeleteAgitDecoMon(PEnvir.MapName, CX, CY) then begin
                              GuildAgitMan.SaveAgitDecoMonList;
                              //»óÇöÁÖ¸Ó´Ï¸¦ ÁÝ´Â °æ¿ì ³»±¸¸¦ 1¾¿ ±ð´Â´Ù.
//                              pmi.UserItem.DuraMax := pmi.UserItem.DuraMax - 1000;
                              //Àå¿ø²Ù¹Ì±â ¿ÀºêÁ§Æ® °³¼ö °¨¼Ò
//                              GuildAgitMan.DecAgitDecoMonCount( GetGuildNameHereAgit );
                              flag := TRUE;
                           end else begin
                              flag := FALSE;
                           end;
//                        end else begin
//                           SysMsg('³»±¸°¡ ³·¾Æ¼­ ÁýÀ» ¼ö ¾ø½À´Ï´Ù.', 0);
//                           flag := FALSE;
//                        end;
                     end else begin
                        flag := FALSE;
                     end;
                  end;
                  //--------------------------------------

                  if flag then begin
                     if PEnvir.DeleteFromMap (CX, CY, OS_ITEMOBJECT, TObject(pmi)) = 1 then begin
                        new (pu);
                        pu^ := pmi.UserItem;
                        ps := UserEngine.GetStdItem (pu.Index);

                        if ps <> nil then
                        begin

                          if ps.OverlapItem = 1 then
                             wg := (pmi.UserItem.Dura) div 10
                          else if ps.OverlapItem >= 2 then
                             wg := (ps.Weight * pmi.UserItem.Dura)
                          else
                             wg := ps.Weight;

                        end;

                        if (ps <> nil) { and IsAddWeightAvailable (wg) } then begin
                           SendMsg (self, RM_ITEMHIDE, 0, integer(pmi), CX, CY, '');
                           AddItem (pu);

                           //¸ÊÄù½ºÆ®°¡ ÀÖ´ÂÁö
                           if PEnvir.HasMapQuest then begin
                              dropername := '';
                              if pmi.Droper <> nil then
                                 dropername := TCreature (pmi.Droper).UserName;
                              questnpc := TMerchant (PEnvir.GetMapQuest (self, dropername, ps.Name, FALSE));
                              if questnpc <> nil then
                                 questnpc.UserCall (self);
                           end;


                           //·Î±×³²±è
                           if not IsCheapStuff (ps.StdMode) then begin
                              AddUserLog ('4'#9 + //ÁÝ±â_
                                          MapName + ''#9 +
                                          IntToStr(CX) + ''#9 +
                                          IntToStr(CY) + ''#9 +
                                          UserName + ''#9 +
                                          UserEngine.GetStdItemName (pu.Index) + ''#9 +
                                          IntToStr(pu.MakeIndex) + ''#9 +
                                          '1'#9 +
                                          '0' + countstr);  //°³¼ö·Î±×(sonmg 2005/01/07)
                           end;

                           if RaceServer = RC_USERHUMAN then begin
                              if self is TUserHuman then begin
                                 hum := TUserHuman(self);
                                 TUserHuman(hum).SendAddItem (pu^);
                              end;
                           end;

                           if ps.StdMode = TAIWANEVENTITEM then begin  //´ë¸¸ ÀÌº¥Æ®, ÀÌº¥Æ® ¾ÆÀÌÅÛÀ» ÁÖÀ¸¸é Ç¥½Ã³²
                              if hum <> nil then begin
                                hum.TaiwanEventItemName := ps.Name;
                                hum.BoTaiwanEventUser := TRUE;
                                //Ä³¸¯ÀÇ »ö±òÀ» ¹Ù²Û´Ù.
                                StatusArr[STATE_BLUECHAR] := 60000;  //Å¸ÀÓ ¾Æ¿ô ¾øÀ½;
                                CharStatus := GetCharStatus;
                                CharStatusChanged;
                                Light := GetMyLight;
                                SendRefMsg (RM_CHANGELIGHT, 0, 0, 0, 0, '');
                                UserNameChanged;
                              end;
                           end;

                           Dispose (pmi);
                           Result := TRUE;
                        end else begin
                           Dispose (pu);
                           PEnvir.AddToMap (CX, CY, OS_ITEMOBJECT, TObject(pmi));
                        end;
                     end;//if PEnvir.DeleteFromMap
                  end;//flag
               end;
            end;
      end else begin
         SysMsg ('Ò»¶¨Ê±¼ä·¶Î§ÄÚ£¬²»ÄÜÊ°È¡¡£', 0);
      end;
   end;
end;

function  TCreature.EatItem (std: TStdItem; pu: PTUserItem): Boolean;
var
   boneedrecalc: Boolean;
   hum, humlover : TUserHuman;
   pstd : PTStdItem;
   i : integer;
   flag : Boolean;
   cret: TCreature;
begin
   pstd := nil;
   Result := FALSE;
     if RaceServer = RC_USERHUMAN then begin
    if TUserHuman(Self).m_StallMgr.OnSale then begin
      SysMsg ('°ÚÌ¯ÖÐÎÞ·¨Ê¹ÓÃ', 0);
      Exit;
    end;
  end;
   if PEnvir.NoDrug then begin  ///MapName = '0137' then begin  //¾àÀ» ¸ÔÀ» ¼ö ¾ø´Â ´ë·Ã ¸Ê
      SysMsg ('ÔÚÕâÀïÄúÎÞ·¨Ê¹ÓÃ', 0);
      exit;
   end;


   case std.StdMode of
      0: //½Ã¾à·ù
         begin
            case std.Shape of
               FASTFILL_ITEM: //¼±È­¼ö
                  begin
                     IncHealthSpell (std.AC{+hp}, std.MAC{+mp});
                     IncHealthSpell (WAbil.MaxHP * std.DC div 100{+hp%}, WAbil.MaxMP * std.MC div 100{+mp%}); // Ã¼·Â,¸¶·Â %Çâ»ó Ãß°¡(sonmg 2005/03/09)
                     Result := TRUE;
                  end;
               FREE_UNKNOWN_ITEM: //¹ÌÁöÀÇ¾ÆÀÌÅÛÀ» ÀåÂøÇØÁ¦ ½ÃÅ´
                  begin
                     BoNextTimeFreeCurseItem := TRUE;
                     Result := TRUE;
                  end;
               else
                  begin                       // 500 -> 1000  2003-11-3 :PDS
                     if (IncHealth + std.AC < 1000) and (std.AC > 0) then begin
                        IncHealth := IncHealth + std.AC;
                     end;
                                              // 500 -> 1000
                     if (IncSpell + std.MAC < 1000) and (std.MAC > 0) then begin
                        IncSpell := IncSpell + std.MAC;
                     end;

                     Result := TRUE;
                  end;
            end;
         end;
      1: //°í±â·ù
         begin
            Result := TRUE;
         end;
      2: //½Ä´ç À½½Ä
         begin
            case std.Shape of
            SHAPE_BUNCH_OF_FLOWERS:
               begin
                  SendRefMsg (RM_LOOPNORMALEFFECT, integer(self), 10000, 0, NE_FLOWERSEFFECT, '');
               end;
            end;

            Result := TRUE;
         end;
      3: //½ºÅ©·Ñ ·ù
         begin
            case std.Shape of
               INSTANTABILUP_DRUG:
                  //´É·ÂÄ¡ »ó½Â Áö¼Ó½Ã°£ ºÐ´ÜÀ§ Ãß°¡(DCMAX) (sonmg 2005/01/13)
                  begin //12, ¼ø°£ÀûÀ¸·Î ´É·ÂÄ¡¸¦ »ó½Â½ÃÅ°´Â ¹°¾à
                     boneedrecalc := FALSE;
                     //ÆÄ±«, ¸¶·Â, µµ·Â MCMAX(%) ¸¸Å­ »ó½Â(sonmg 2006/02/02)
                     if HIBYTE(std.MC) > 0 then begin
                        //½Ã°£Àº ÃÊ±âÈ­ ÈÄ¿¡ ´Ù½Ã °è»êÇÑ´Ù.(sonmg 2006/02/14)
                        ExtraAbilTimes[EABIL_DCUP] := 0;
                        ExtraAbilTimes[EABIL_MCUP] := 0;
                        ExtraAbilTimes[EABIL_SCUP] := 0;
                        //¹Ýº¹»ó½ÂÀ» ¸·±â À§ÇØ¼­ ExtraAbil°ªÀ» »« °ªÀ¸·ÎºÎÅÍ °è»êÇÑ´Ù.
                        EnhanceExtraAbility( EABIL_DCUP, _MAX(0, (Integer(HIBYTE(WAbil.DC)) * Integer(HIBYTE(std.MC)) div 100) - ExtraAbil[EABIL_DCUP]), HIBYTE(std.DC), HIBYTE(std.MAC) );
                        EnhanceExtraAbility( EABIL_MCUP, _MAX(0, (Integer(HIBYTE(WAbil.MC)) * Integer(HIBYTE(std.MC)) div 100) - ExtraAbil[EABIL_MCUP]), HIBYTE(std.DC), HIBYTE(std.MAC) );
                        EnhanceExtraAbility( EABIL_SCUP, _MAX(0, (Integer(HIBYTE(WAbil.SC)) * Integer(HIBYTE(std.MC)) div 100) - ExtraAbil[EABIL_SCUP]), HIBYTE(std.DC), HIBYTE(std.MAC) );
                        boneedrecalc := TRUE;
                     end else begin
                        if lobyte(std.DC) > 0 then begin  //ÆÄ±« »ó½Â ¹°¾à
                           //ÃßÈÄ¿¡ ¾Æ·¡ ÄÚµåµµ EnhanceExtraAbility·Î ¹Ù²ã¾ßÇÔ(sonmg)
                           EnhanceExtraAbility( EABIL_DCUP, LOBYTE(std.DC), HIBYTE(std.DC), HIBYTE(std.MAC) );
                           boneedrecalc := TRUE;
                        end;
                        if lobyte(std.MC) > 0 then begin  //¸¶·Â »ó½Â ¹°¾à
                           EnhanceExtraAbility( EABIL_MCUP, LOBYTE(std.MC), HIBYTE(std.DC), HIBYTE(std.MAC) );
                           boneedrecalc := TRUE;
                        end;
                        if lobyte(std.SC) > 0 then begin  //µµ·Â »ó½Â ¹°¾à
                           EnhanceExtraAbility( EABIL_SCUP, LOBYTE(std.SC), HIBYTE(std.DC), HIBYTE(std.MAC) );
                           boneedrecalc := TRUE;
                        end;
                        if hibyte(std.AC) > 0 then begin  //°ø°Ý¼Óµµ »ó½Â ¹°¾à
                           EnhanceExtraAbility( EABIL_HITSPEEDUP, HIBYTE(std.AC), HIBYTE(std.DC), HIBYTE(std.MAC) );
                           boneedrecalc := TRUE;
                        end;
                        if lobyte(std.AC) > 0 then begin  //Ã¼·Â »ó½Â ¹°¾à
                           EnhanceExtraAbility( EABIL_HPUP, LOBYTE(std.AC), HIBYTE(std.DC), HIBYTE(std.MAC) );
                           boneedrecalc := TRUE;
                        end;
                        if lobyte(std.MAC) > 0 then begin  //¸¶·Â »ó½Â ¹°¾à
                           EnhanceExtraAbility( EABIL_MPUP, LOBYTE(std.MAC), HIBYTE(std.DC), HIBYTE(std.MAC) );
                           boneedrecalc := TRUE;
                        end;
                     end;

                     if boneedrecalc then begin
                        RecalcAbilitys;
                        SendMsg (self, RM_ABILITY, 0, 0, 0, 0, '');
                     end;
                     Result := TRUE;
                  end;
               INSTANT_EXP_DRUG:
                  begin
                     //°æÇèÄ¡ ¹°¾à(DB ÇÊµå ±âÁØ)
                     // 1.   AC * 100ÀÇ °æÇèÄ¡ È¹µæ
                     // 2.   MAC°¡ 0º¸´Ù Å« °æ¿ì : AC~MAC »çÀÌÀÇ ·£´ý °ª * 100ÀÇ °æÇèÄ¡ È¹µæ
                     // 2-1. DC(0~100)ÀÇ È®·ü·Î MACÀÇ 2¹èÀÇ °æÇèÄ¡ È¹µæ
                     if LOBYTE(std.MAC) > 0 then begin
                        if Random(100) < LOBYTE(std.DC) then begin
                           //2-1.
                           WinExp ( LOBYTE(std.MAC) * 2 * 100 );
                        end else begin
                           //2.
                           if LOBYTE(std.MAC) >= lobyte(std.AC) then begin
                              WinExp ( ( Integer(Random(LOBYTE(std.MAC) - lobyte(std.AC))) + Integer(lobyte(std.AC)) ) * 100);
                           end else begin
                              WinExp ( ( Integer(Random(LOBYTE(std.AC) - lobyte(std.MAC))) + Integer(lobyte(std.MAC)) ) * 100);
                           end;
                        end;
                     end else begin
                        //1.
                        WinExp (lobyte(std.AC) * 100);
                     end;
                     Result := TRUE;
                  end;
               SHAPE_COUPLE_ALIVE_STONE:  //¿¬ÀÎºÎÈ°¼®
                  begin
                     flag := FALSE;
                     //°í±ÞÄ¿ÇÃ¹ÝÁö Âø¿ë Ã¼Å©
                     for i:=0 to U_TRANS do begin
                        pstd := UserEngine.GetStdItem(UseItems[i].Index);
                        if pstd <> nil then begin
                           if (pstd.StdMode = 22) and (pstd.Shape = SHAPE_ADV_COUPLERING) then begin
                              flag := TRUE;
                              break;
                           end;
                        end;
                     end;
                     if flag then begin
                        flag := FALSE;
                        //±³Á¦ÀÏ 365ÀÏ ÀÌ»ó Ã¼Å©
                        hum := TUserHuman(self);
                        if hum <> nil then begin
                           if Str_ToInt(hum.fLover.GetLoverDays, 0) >= 365 then begin
                              flag := TRUE;
                           end;
                        end;
                     end;
                     if flag then begin
                        flag := FALSE;
                        //¿¬ÀÎ°ú 1Ä­ ¿·¿¡ ÀÖ´ÂÁö Ã¼Å©
                        hum := TUserHuman(self);
                        if hum <> nil then begin
                           humlover := UserEngine.GetUserHuman(hum.fLover.GetLoverName);
                           if humlover <> nil then begin
                              if (Abs(hum.CX-humlover.CX) <= 1) and (Abs(hum.CY-humlover.CY) <= 1) then begin
                                 //¸ðµç Á¶°ÇÀÌ ÃæÁ·µÇ¸é Á×Àº ¿¬ÀÎ ºÎÈ°
                                 if humlover.Death then begin
                                    //¿¬ÀÎÀÇ Ã¼·Â 10% º¸Ãæ
                                    humlover.WAbil.HP := humlover.WAbil.MaxHP div 10;
                                    humlover.Alive;
                                    //ÀÚ½ÅÀÇ Ã¼·Â ¸¶·Â 90% °¨¼Ò
                                    hum.WAbil.HP := hum.WAbil.HP div 10;
                                    hum.WAbil.MP := hum.WAbil.MP div 10;
                                    Result := TRUE;
                                 end;
                              end;
                           end;
                        end;
                     end;
                  end;
               else
                  Result := UseScroll (std.Shape);
            end;
         end;
      8: //»ç¿ë ¾ÆÀÌÅÛ
         begin
            case std.Shape of
               SHAPE_OF_INVITATION:
                  begin
                     //ÃÊ´ëÀå ±â´É ±¸Çö(sonmg).
                     // ±â°£ÀÌ ¸¸·áµÇ¾úÀ¸¸é ÀÌµ¿ÇÏÁö ¾ÊÀ½.
                     // ±â°£ÀÌ À¯È¿ÇÏ¸é ÃÊ´ëÀå¿¡ ½áÀÖ´Â Àå¿ø ¹øÈ£·Î ÀÌµ¿
                     if RaceServer = RC_USERHUMAN then begin
                        hum := TUserHuman (self);

                        // ¸¸·á±â°£ Ã¼Å©
                        if hum.GuildAgitInvitationTimeOutCheck( pu ) then begin
                           hum.CmdGuildAgitFreeMove( pu.Dura );   // ÇØ´ç¹øÈ£ÀÇ Àå¿øÀ¸·Î ÀÌµ¿.
                        end else begin
                           hum.SysMsg('ÑûÇëµÄÓÐÐ§ÆÚ¹ýÁË', 0);
                        end;

                        Result := TRUE;
                     end;
                  end;
               SHAPE_OF_TELEPORTTAG:   //¿Õ¹æ ÀÌµ¿ ¸¶ÆÐ
                  begin
                     UserSpaceMove( std.Reference, IntToStr(std.HpAdd), IntToStr(std.MpAdd) );
                     Result := TRUE;
                  end;
               SHAPE_OF_GIFTBOX:
                  begin
                     if IsEnoughBag then begin
                        GetGiftFromBox;   //¼±¹°»óÀÚ
                        Result := TRUE;
                     end;
                  end;
               SHAPE_OF_OLDBOX:
                  begin
                     if IsEnoughBag then begin
                        GetGiftFromOldBox;   //³°Àº±ËÂ¦
                        Result := TRUE;
                     end;
                  end;
            end;
         end;
      70: //¾ÛÁéÖé
         begin
            case std.Shape of
//               PAIN_SERIES_SHAPE:
//                  begin
//                     if pu.Dura > 0 then begin
//                        WinExpEx (pu.Dura * 10000);
//                        Result := TRUE;
//                     end;
//                  end;
               0: begin
                     PlayerKillingPoint := 0;
                     ChangeNameColor;
                     SysMsg ('PKÖµÒÑÇåÁã', 1);
                  end;
               1: begin
                     if SlaveList.Count= 0 then begin
                        SysMsg('ÄúÃ»ÓÐÕÙ»½±¦±¦,²»ÄÜÊ¹ÓÃ´ËÎïÆ·!',  1);
                        Exit;
                     end;
                     if SlaveList.Count > 0 then begin
                        for I := 0 to SlaveList.Count - 1 do begin
                           cret := TCreature(SlaveList.Items[I]);
                           if not (cret.RaceServer in [100,113,114]) then Continue;
                           if cret.SlaveExpLevel < 7 then begin
                              cret.SlaveExpLevel:= 7;
                              cret.ApplySlaveLevelAbilitys;
                              cret.UserNameChanged;
                              Result:= True;
                              SysMsg('ÔÚÉñÃØµÄÁ¦Á¿Ó°ÏìÏÂ, ÄúµÄ³èÎï:'+cret.UserName+' ³É³¤Îª7¼¶', 6);
                              Break;
                           end;
                        end;
                     end;
                  end;
//               2: begin
//                     if RepaireAllEquipPerfect then begin
//                        Result := TRUE;
//                     end;
//                  end;
               3: begin
                     if pu.Dura > 0 then begin
                        hum := TUserHuman(self);
                        hum.IncPotCash(std.DuraMax);
                        hum.PotCashChanged;
                        hum.SysMsg(IntToStr(std.DuraMax)+' ¸ö' + NAME_OF_PC+'Ôö¼Ó', 0);     //Ôª±¦Ôö¼ÓµÄÌáÊ¾
                        Result := TRUE;
                     end;
                  end;
               4: begin
                     hum := TUserHuman(self);
                     hum.CmdChangeHair (std.SpecialPwr);
                     hum.FeatureChanged;
                     if std.SpecialPwr = 1 then
                          hum.SysMsg('¹§Ï²£ºÄãµÄ·¢ÐÍÒÑ¾­»Ö¸´ÁË£¡', 2)
                     else hum.SysMsg('¹§Ï²£ºÄãµÄ·¢ÐÍÒÑ¾­¸Ä±äÁË£¡', 2);
                     Result := TRUE;
                  end;
//               4: begin
//                     if StartupQuestNpc <> nil then begin
//                        hum := TUserHuman(self);
//                        hum.WareHouseTime := GetTickCount;
//                        hum.WareHouseOpen := True;
//                        StartupQuestNpc.NpcSayTitle(Self, '@WareHouse');
//                        Result := TRUE;
//                     end;
//                  end;
               5: begin
                     hum := TUserHuman(self);
                     if hum.Hair <> 0 then begin
                        hum.Hair := 0;
                        FeatureChanged;
                        Result := TRUE;
                     end;
                  end;
               6: begin
                     hum := TUserHuman(self);
                     if hum.Hair <> 1 then begin
                        hum.Hair := 1;
                        FeatureChanged;
                        Result := TRUE;
                     end;
                  end;

            end;
         end;
      88:begin
           hum := TUserHuman(self);
            if QFunctionNpc <> nil then
               QFunctionNpc.NpcSayTitle(TUserHuman(Self), '@StdModeFunc'+IntToStr(std.AniCount));
           Result := TRUE;

          AddUserLog ('51'#9 + //Ë«»÷ÎïÆ·´¥·¢
                      MapName + ''#9 +
                      IntToStr(CX) + ''#9 +
                      IntToStr(CY) + ''#9 +
                      UserName + ''#9 +
                      std.Name + ''#9 +
                      IntToStr(pu.MakeIndex) + ''#9 +
                      '1'#9 +
                      '0');
         end;
   end;
end;

function  TCreature.IsMyMagic (magid: integer): Boolean;
var
   i: integer;
begin
   Result := FALSE;
   for i:=0 to MagicList.Count-1 do begin
      if PTUserMagic(MagicList[i]).MagicId = magid then begin
         Result := TRUE;
         break;
      end;
   end;
end;

function  TCreature.ReadBook (std: TStdItem): Boolean;
var
   pdm: PTDefMagic;
   pum: PTUserMagic;
   hum: TUserHuman;
begin
   Result := FALSE;
   pdm := UserEngine.GetDefMagic (std.Name);
   if pdm <> nil then begin
      if not IsMyMagic (pdm.MagicId) then begin
         if ((pdm.Job = 99) or (pdm.Job = Job)) and (Abil.Level >= pdm.NeedLevel[0]) then begin
            new (pum);
            pum.pDef := pdm;
            pum.MagicId := pdm.MagicId;
            pum.Key := #0;
            pum.Level := 0;
            pum.CurTrain := 0;
            MagicList.Add (pum);   //¸¶¹ýÀ» »õ·Î ¹è¿ò..
            RecalcAbilitys;
            if RaceServer = RC_USERHUMAN then begin
               hum := TUserHuman (self);
               hum.SendAddMagic (pum);    //¸¶¹ý Ãß°¡¸¦ Å¬¶óÀÌ¾ðÆ®¿¡ ¾Ë¸²
            end;
            Result := TRUE;
         end;
      end;
   end;
end;

function TCreature.GetSpellPoint (pum: PTUserMagic): integer;
begin
   //Å¬¶óÀÌ¾ðÆ®¿Í ÀÏÄ¡½ÃÄÑ¾ß ÇÔ(sonmg)
   Result := Round(pum.pDef.Spell / (pum.pDef.MaxTrainLevel+1) * (pum.Level+1))
             + pum.pDef.DefSpell;
end;

//Å¸°ÙÀÇ ÀûÀýÇÔÀº ¹Ì¸® °ËÁõÇØ¾ßÇÔ.
function  TCreature.DoSpell (pum: PTUserMagic; xx, yy: integer; target: TCreature): Boolean;
var
   spell: integer;
begin
   Result := FALSE;
  if RaceServer = RC_USERHUMAN then begin
    if TUserHuman(Self).m_StallMgr.OnSale then begin

      Exit;
    end;
  end;

   if MagicMan.IsSwordSkill (pum.MagicId) then exit;

   //ÇÊ¿ä SpellÀÌ ÃæºÐÇÑ°¡?
   spell := GetSpellPoint (pum);
   if (spell > 0) then begin
      if (WAbil.MP >= spell) then begin
         DamageSpell (spell);
         if pum.MagicId <> 42 then // ºÐ½Å¼úÀÌ ¾Æ´Ï¸é Àü¼Û
             HealthSpellChanged;
      end else
         exit;  //¸¶·ÂÀÌ ºÎÁ·ÇÔ.
   end;

   Result := MagicMan.SpellNow (self, pum, xx, yy, target,spell);

   if pum.MagicId = 42 then // ºÐ½Å¼úÀÌ¸é Àü¼Û
   begin
     HealthSpellChanged;
   end;

end;


{------------------------------ ¸¶¹ý È¿°ú -----------------------------}

//½ÃÀÛÀ§Ä¡¿¡¼­ ´ÙÀ½ À§Ä¡±îÁöÀÇ Àû¿¡°Ô Å¸°ÝÀ» ÀÔÈù´Ù.
//Result: ¸ÂÀº ¸¶¸®¼ö
function  TCreature.MagPassThroughMagic (sx, sy, tx, ty, ndir, magpwr: integer; undeadattack: Boolean): integer;
var
   i, tcount, acpwr: integer;
   cret: TCreature;
begin
   tcount := 0;
   for i:=0 to 12 do begin
      cret := TCreature (PEnvir.GetCreature (sx, sy, TRUE));
      if cret <> nil then begin
         //if (RaceServer = RC_USERHUMAN) and (cret.RaceServer = RC_USERHUMAN) and ((cret.InSafeZone) or (InSafeZone)) then
         //   continue;  //¾ÈÀüÁö´ë
         if IsProperTarget (cret) then begin
            if cret.AntiMagic <= Random(50) then begin  //¸¶¹ý È¸ÇÇ°¡ ÀÖÀ½
               if undeadattack then  //¾ðµ¥µå ¸ó½ºÅÍ¿¡°Ô °ø°Ý·Â °­È­ÀÎ °æ¿ì
                  acpwr := Round (magpwr * 1.5)
               else
                  acpwr := magpwr;
               cret.SendDelayMsg (self, RM_MAGSTRUCK, 0, acpwr, 0, 0, '', 600);
               Inc (tcount);
            end;
         end;
      end;
      if not ((abs(sx-tx) <= 0) and (abs(sy-ty) <= 0)) then begin
         ndir := GetNextDirection (sx, sy, tx, ty);
         if not GetNextPosition (PEnvir, sx, sy, ndir, 1, sx, sy) then
            break;
      end else
         break;
   end;
   Result := tcount;
end;

function  TCreature.MagCanHitTarget (sx, sy: integer; target: TCreature): Boolean;
var
   i, ndir, dis, olddis: integer;
begin
   Result := FALSE;
   if target <> nil then begin
      olddis := (abs(sx-Target.CX) + abs(sy-Target.CY));
      for i:=0 to 12 do begin
         ndir := GetNextDirection (sx, sy, target.CX, target.CY);
         if not GetNextPosition (PEnvir, sx, sy, ndir, 1, sx, sy) then
            break;
         if not PEnvir.CanFireFly(sx, sy) then
            break;
         if (sx=target.CX) and (sy=target.CY) then begin
            Result := TRUE;
            break;
         end;
         dis := (abs(sx-Target.CX) + abs(sy-Target.CY));
         if dis > olddis then begin
            Result := TRUE;
            break;
         end;
         dis := olddis;
      end;
   end;
end;

function  TCreature.MagDefenceUp (sec, value: integer): Boolean;  //°É¸®´Â ½Ã°£
begin
   Result := FALSE;
   if StatusArr[STATE_DEFENCEUP] > 0 then begin
      if sec > StatusArr[STATE_DEFENCEUP] then begin
         StatusArr[STATE_DEFENCEUP] := sec;
         Result := TRUE;
      end;
   end else begin
      StatusArr[STATE_DEFENCEUP] := sec;
      Result := TRUE;
   end;
   StatusTimes[STATE_DEFENCEUP] := GetTickCount;
   StatusValue[STATE_DEFENCEUP] := _MIN(255, value);

   SysMsg ('·ÀÓùÁ¦Ôö¼Ó£º' + IntTostr(sec) + 'Ãë', 1);
   RecalcAbilitys;
   SendMsg (self, RM_ABILITY, 0, 0, 0, 0, '');
end;

function  TCreature.MagMagDefenceUp (sec, value: integer): Boolean;  //°É¸®´Â ½Ã°£
begin
   Result := FALSE;
   if StatusArr[STATE_MAGDEFENCEUP] > 0 then begin
      if sec > StatusArr[STATE_MAGDEFENCEUP] then begin
         StatusArr[STATE_MAGDEFENCEUP] := sec;
         Result := TRUE;
      end;
   end else begin
      StatusArr[STATE_MAGDEFENCEUP] := sec;
      Result := TRUE;
   end;
   StatusTimes[STATE_MAGDEFENCEUP] := GetTickCount;
   StatusValue[STATE_MAGDEFENCEUP] := _MIN(255, value);

   SysMsg ('¿¹Ä§Á¦Ôö¼Ó£º' + IntTostr(sec) + 'Ãë', 1);
   RecalcAbilitys;
   SendMsg (self, RM_ABILITY, 0, 0, 0, 0, '');
end;

function  TCreature.MagBubbleDefenceUp (mlevel, sec: integer): Boolean;
var
   old: integer;
begin
   Result := FALSE;
   if StatusArr[STATE_BUBBLEDEFENCEUP] = 0 then begin
      old := CharStatus;
      StatusArr[STATE_BUBBLEDEFENCEUP] := sec;
      StatusTimes[STATE_BUBBLEDEFENCEUP] := GetTickCount;
      CharStatus := GetCharStatus;
      if old <> CharStatus then
         CharStatusChanged;
      BoAbilMagBubbleDefence := TRUE;
      MagBubbleDefenceLevel := mlevel;
      Result := TRUE;
   end;
end;

procedure  TCreature.DamageBubbleDefence;
begin
   if StatusArr[STATE_BUBBLEDEFENCEUP] > 0 then begin
      if StatusArr[STATE_BUBBLEDEFENCEUP] > 3 then
         StatusArr[STATE_BUBBLEDEFENCEUP] := StatusArr[STATE_BUBBLEDEFENCEUP] - 3
      else
         StatusArr[STATE_BUBBLEDEFENCEUP] := 1;
   end;
end;


//ÏÈÌìÆø¹¦
function  TCreature.CelestialUp (modds, mlevel, sec: integer): Boolean;
var
   old: integer;
begin
   Result := FALSE;
   if StatusArr[STATE_CELESTIALUP] = 0 then begin
      old := CharStatus;
      StatusArr[STATE_CELESTIALUP] := sec;
      StatusTimes[STATE_CELESTIALUP] := GetTickCount;
      CharStatus := GetCharStatus;
      if old <> CharStatus then
         CharStatusChanged;
      BoAbilCelestial := TRUE;
      CelestialOdds := modds;
      CelestialLevel := mlevel;
      CelestialDamage := sec;
      Result := TRUE;
   end;
end;

function  TCreature.MagBloodDragonSword (mlevel, sec: integer): Boolean;
var
   old: integer;
begin
   Result := FALSE;
   if StatusArr[STATE_BLOODDRAGONSWORD] = 0 then begin
      old := CharStatus;
      StatusArr[STATE_BLOODDRAGONSWORD] := sec;
      StatusTimes[STATE_BLOODDRAGONSWORD] := GetTickCount;
      CharStatus := GetCharStatus;
      if old <> CharStatus then
         CharStatusChanged;
      Result := TRUE;
   end;
end;

function   TCreature.MagHitSpeedUp (sec, pwr: integer): Boolean;
var
   i, UpHitSpeed : integer;
   cret: TCreature;
begin
   UpHitSpeed := pwr;

   ExtraAbil[EABIL_HITSPEEDUP] := _MIN( 255, _MAX(ExtraAbil[EABIL_HITSPEEDUP], UpHitSpeed) );
   ExtraAbilFlag[EABIL_HITSPEEDUP] := 0;
   ExtraAbilTimes[EABIL_HITSPEEDUP] := _MAX(ExtraAbilTimes[EABIL_HITSPEEDUP], GetTickCount + LongWord(sec * 1000)); //ÃÊ´ÜÀ§
   {$IFDEF KOREA} SysMsg ('¹¥»÷ËÙ¶ÈÌáÉý'{ + IntToStr((ExtraAbilTimes[EABIL_HITSPEEDUP] - GetTickCount) div 1000 div 60) + '·Ö '} + IntToStr((ExtraAbilTimes[EABIL_HITSPEEDUP] - GetTickCount) div 1000{ mod 60}) + 'Ãë', 1);
   {$ELSE}        SysMsg ('Physical Attack Power Increased for ' + IntToStr((ExtraAbilTimes[EABIL_HITSPEEDUP] - GetTickCount) div 1000 div 60) + 'min. ' + IntToStr((ExtraAbilTimes[EABIL_HITSPEEDUP] - GetTickCount) div 1000 mod 60) + 'sec.', 1);
   {$ENDIF}
   RecalcAbilitys;
   SendMsg (self, RM_ABILITY, 0, 0, 0, 0, '');
   Result := TRUE;
end;

procedure  TCreature.DamageCelestial;
begin
   if StatusArr[STATE_CELESTIALUP] > 0 then begin
      if StatusArr[STATE_CELESTIALUP] > 3 then
         StatusArr[STATE_CELESTIALUP] := StatusArr[STATE_CELESTIALUP] - 3
      else
         StatusArr[STATE_CELESTIALUP] := 1;
   end;
end;


function  TCreature.MagDcUpEx (sec, pwr: integer): Boolean;
var
   i, UpDC : integer;
   cret: TCreature;
   old: integer;
begin
   UpDC := pwr;
   Result := FALSE;

   ExtraAbil[EABIL_MAGICDCUP] := _MIN( 255, UpDC);
   ExtraAbilFlag[EABIL_MAGICDCUP] := 0;
   ExtraAbilTimes[EABIL_MAGICDCUP] := _MAX(ExtraAbilTimes[EABIL_MAGICDCUP], GetTickCount + LongWord(sec * 1000)); //ÃÊ´ÜÀ§
   SysMsg ('¹¥»÷Á¦Ìá¸ß ' + IntToStr((ExtraAbilTimes[EABIL_MAGICDCUP] - GetTickCount) div 1000 mod 60) + 'Ãë', 1);
   RecalcAbilitys;
   SendMsg (self, RM_ABILITY, 0, 0, 0, 0, '');
   Result := TRUE;
end;


function   TCreature.MagAcUpEx (sec, pwr: integer): Boolean;
var
   i, UpAC : integer;
   cret: TCreature;
begin
   UpAC := pwr;
   Result := FALSE;

   ExtraAbil[EABIL_MAGICACUP] := _MIN( 255, _MAX(ExtraAbil[EABIL_MAGICACUP], UpAC) );
   ExtraAbilFlag[EABIL_MAGICACUP] := 0;
   ExtraAbilTimes[EABIL_MAGICACUP] := _MAX(ExtraAbilTimes[EABIL_MAGICACUP], GetTickCount + LongWord(sec * 1000)); //ÃÊ´ÜÀ§
   SysMsg ('·ÀÓùÁ¦Ôö¼Ó£º' + IntToStr((ExtraAbilTimes[EABIL_MAGICACUP] - GetTickCount) div 1000 div 60) + '·Ö ' + IntToStr((ExtraAbilTimes[EABIL_MAGICACUP] - GetTickCount) div 1000 mod 60) + 'Ãë', 1);
   RecalcAbilitys;
   SendMsg (self, RM_ABILITY, 0, 0, 0, 0, '');
   Result := TRUE;
end;



function   TCreature.SlashingBust (sx, sy, tx, ty, ndir, magpwr: integer; undeadattack: Boolean): integer;
var
   i: integer;
   cret: TCreature;
begin
   Result := 0;
//   for i:=0 to 12 do begin
     cret := TCreature (PEnvir.GetCreature (sx, sy, TRUE));
     if cret <> nil then begin
       if IsProperTarget (cret) then begin
         if cret.RaceServer = RC_USERHUMAN then
             magpwr := Round (magpwr * 3.0)     //»ç¶÷Àº ÆÄ¿ö X 3¹è
           else magpwr := Round (magpwr * 5.0); //¸ó½ºÅÍ´Â ÆÄ¿ö X 5¹è

          //cret.SendMsg (self, RM_MAGSTRUCK, 0, magpwr, 0, 1, '');
           cret.SendDelayMsg (self, RM_MAGSTRUCK, 0, magpwr, 0, 0, '', 600);
           Result := 1;
       end;
     end;
//     if not ((abs(sx-tx) <= 0) and (abs(sy-ty) <= 0)) then begin
//       ndir := GetNextDirection (sx, sy, tx, ty);
//         if not GetNextPosition (PEnvir, sx, sy, ndir, 1, sx, sy) then
//            break;
//     end else
//       break;
//   end;
end;



//ÁÖº¯¿¡ »ç¶÷µéÀÇ ¹æ¾î·Â ¹× ¸¶¹ý ¹æ¾î·ÂÀ» ÀÏ½ÃÀûÀ¸·Î ¿Ã·ÁÁØ´Ù.
//Result: °É¸° ¼ö
//BoMag: TRUE(¸¶¹ý¹æ¾î), FALSE(¹æ¾î)
function  TCreature.MagMakeDefenceArea (xx, yy, range, sec: integer; BoMag: Boolean): integer;
var
   i, j, k, stx, sty, enx, eny, tcount: integer;
   pm: PTMapInfo;
   inrange: Boolean;
   cret: TCreature;
begin
   tcount := 0;
   stx := xx-range;
   enx := xx+range;
   sty := yy-range;
   eny := yy+range;
   for i:=stx to enx do begin
      for j:=sty to eny do begin
         inrange := PEnvir.GetMapXY (i, j, pm);
         if inrange then
            if pm.ObjList <> nil then begin
               for k:=0 to pm.ObjList.Count-1 do begin
                  if PTAThing (pm.ObjList[k]).Shape = OS_MOVINGOBJECT then begin
                     cret := TCreature (PTAThing (pm.ObjList[k]).AObject);
                     if cret <> nil then begin
                        if (not cret.BoGhost) then begin
                           if IsProperFriend (cret) then begin
                              if not BoMag then cret.MagDefenceUp (sec, (LOBYTE(WAbil.SC) div 9) + Random(HIBYTE(WAbil.SC) div 9))
                              else cret.MagMagDefenceUp (sec, (LOBYTE(WAbil.SC) div 9) + Random(HIBYTE(WAbil.SC) div 9));
                              Inc (tcount);
                           end;
                        end;
                     end;
                  end;
               end;
            end;
      end;
   end;
   Result := tcount;
end;

function  TCreature.MagMakeCurseArea (xx, yy, range, sec , pwr , skilllevel: integer; BoMag: Boolean): integer;
var
   i, j, k, stx, sty, enx, eny, tcount: integer;
   pm: PTMapInfo;
   inrange: Boolean;
   cret: TCreature;
   isNormalAttack : boolean;
   isAttack : Boolean;
   targetsec : integer;
begin
   tcount := 0;
   stx := xx-range;
   enx := xx+range;
   sty := yy-range;
   eny := yy+range;
   for i:=stx to enx do begin
      for j:=sty to eny do begin
         inrange := PEnvir.GetMapXY (i, j, pm);
         if inrange then
            if pm.ObjList <> nil then begin
               for k:=0 to pm.ObjList.Count-1 do begin
                  if PTAThing (pm.ObjList[k]).Shape = OS_MOVINGOBJECT then begin
                     cret := TCreature (PTAThing (pm.ObjList[k]).AObject);
                     if cret <> nil then begin
                        if (not cret.BoGhost) and (not cret.Death) then begin
                           //¸ó½ºÅÍÀÇ ¸¶¹ýÀÎ °æ¿ì
                           if not BoMag then begin
                              if IsProperTarget (cret) then begin
//                              if ( (cret.Master <> nil) and (cret.Master.RaceServer = RC_USERHUMAN) )
//                                    or (cret.RaceServer = RC_USERHUMAN) then begin
                                 //Áßµ¶ È¸º¹
                                 targetsec := (sec div 6) - cret.PoisonRecover;
                                 isAttack := false;

                                 //È®·ü°è»ê
                                 if ( Random(90 + (cret.AntiPoison * 2) ) < ( 14 + (skilllevel + 1) * 8) ) then
                                    isAttack := true;

                                 if isAttack and ( targetsec > 0 )then begin
                                    cret.SendDelayMsg (self, RM_CURSE, targetsec, pwr, 0, 0, '', 1200);
                                    cret.SendDelayMsg (cret, RM_STRUCK, 1, WAbil.HP, WAbil.MP, integer(self), '', 1200);

                                    //cret.MagCurse (sec , pwr);
                                    Inc (tcount);
                                 end;
                              end;
                           end else begin
                              if IsProperTarget (cret) then begin
                                 // È®·ü°è»êÇÏ±¸
                                 isNormalAttack := true;
                                 targetsec      := sec;
                                 if cret.RaceServer = RC_USERHUMAN then begin
                                    isNormalAttack := false;
                                    //Áßµ¶ È¸º¹
                                    targetsec := (sec div 6 ) - cret.PoisonRecover;
                                 end else begin
                                    if cret.Abil.Level >= 60 then begin
                                       isNormalAttack := false;
                                       targetsec := (sec div 4 );
                                    end;
                                 end;

                                 // ÀÏ¹Ý¸÷È®·ü: Random(70)<14+(skill_level+1)*5+lvgap
                                 //  60·¹º§ÀÌ»ó&À¯ÀúÈ®·ü: Random(40)<14+(skill_level+1)*5+lvgap
                                 isAttack := false;
                                 // AntiPoison := ;
                                 if isNormalAttack then begin
                                    if ( Random(80) < ( 14 + ( skilllevel + 1) * 3 + (integer(Abil.Level) - integer( cret.Abil.level) )) ) then
                                       isAttack := true;
                                 end else begin
                                    if ( Random(90 + (cret.AntiPoison * 2) ) < ( 14 + ( skilllevel + 1) * 3 + (integer(Abil.level) - integer(cret.Abil.Level) )) ) then
                                       isAttack := true;
                                 end;

                                 if isAttack and ( targetsec > 0 )then begin
                                    cret.SendDelayMsg (self, RM_CURSE, targetsec , pwr, 0, 0, '', 1200);
                                    cret.SendDelayMsg (cret, RM_STRUCK, 1, WAbil.HP, WAbil.MP, integer(self), '', 1200);

                                    //cret.MagCurse (sec , pwr);
                                    Inc (tcount);
                                 end;
                              end;
                           end;
                        end;
                     end;
                  end;
               end;
            end;
      end;
   end;
   Result := tcount;
end;

//2003/03/15 ½Å±Ô¹«°ø Ãß°¡
function   TCreature.MagDcUp (sec, pwr: integer): Boolean;
//var
//   i, UpSC : integer;
//   cret: TCreature;
//begin
//   UpsC := pwr;//((Hibyte(WAbil.SC)-1) div 5) + 1;
//   if(UpSC > 75) then UpSC := 75;
//
//   if      (WAbil.SC) <=  5 then UpSC := 5
//   else if (WAbil.SC) <= 10 then UpSC := 10
//   else if (WAbil.SC) <= 15 then UpSC := 15
//   else if (WAbil.SC) <= 20 then UpSC := 20
//   else if (WAbil.SC) <= 25 then UpSC := 25
//   else if (WAbil.SC) <= 30 then UpSC := 30
//   else if (WAbil.SC) <= 35 then UpSC := 35
//   else if (WAbil.SC) <= 40 then UpSC := 40
//   else if (WAbil.SC) <= 45 then UpSC := 45
//   else if (WAbil.SC) <= 55 then UpSC := 50
//   else if (WAbil.SC) <= 55 then UpSC := 55
//   else if (WAbil.SC) <= 60 then UpSC := 60
//   else if (WAbil.SC) <= 65 then UpSC := 65
//   else if (WAbil.SC) <= 70 then UpSC := 70
//   else if (WAbil.SC) <= 75 then UpSC := 75;
//
//   ExtraAbil[EABIL_SCUP] := _MIN( 255, _MAX(ExtraAbil[EABIL_SCUP], UpsC) );
//   ExtraAbilFlag[EABIL_SCUP] := 0;
//   ExtraAbilTimes[EABIL_SCUP] := _MAX(ExtraAbilTimes[EABIL_SCUP], GetTickCount + LongWord(sec * 100)); //ÃÊ´ÜÀ§
//   {$IFDEF KOREA} SysMsg ('µÀÊõË²Ê±ÌáÉý:' + IntToStr((ExtraAbilTimes[EABIL_SCUP] - GetTickCount) div 1000 div 60) + '·Ö' + IntToStr((ExtraAbilTimes[EABIL_SCUP] - GetTickCount) div 1000 mod 60) + 'Ãë', 1);
//   {$ELSE}        SysMsg ('Physical Attack Power Increased for ' + IntToStr((ExtraAbilTimes[EABIL_SCUP] - GetTickCount) div 1000 div 60) + 'min. ' + IntToStr((ExtraAbilTimes[EABIL_SCUP] - GetTickCount) div 1000 mod 60) + 'sec.', 1);
//   {$ENDIF}
//   RecalcAbilitys;
//   SendMsg (self, RM_ABILITY, 0, 0, 0, 0, '');
var
   i, UpSC : integer;
   cret: TCreature;
begin
   UpSC := pwr;//((Hibyte(WAbil.SC)-1) div 5) + 1;
   //if(UpDC > 8) then UpDC := 8;
{
   if      (WAbil.SC) <=  5 then UpDC := 1
   else if (WAbil.SC) <= 10 then UpDC := 2
   else if (WAbil.SC) <= 15 then UpDC := 3
   else if (WAbil.SC) <= 20 then UpDC := 4
   else if (WAbil.SC) <= 25 then UpDC := 5
   else if (WAbil.SC) <= 30 then UpDC := 6
   else if (WAbil.SC) <= 35 then UpDC := 7
   else                          UpDC := 8;
}
   ExtraAbil[EABIL_SCUP] := _MIN( 255, _MAX(ExtraAbil[EABIL_SCUP], UpSC) );
   ExtraAbilFlag[EABIL_SCUP] := 0;
   ExtraAbilTimes[EABIL_SCUP] := _MAX(ExtraAbilTimes[EABIL_SCUP], GetTickCount + LongWord(sec * 1000)); //ÃÊ´ÜÀ§
   {$IFDEF KOREA} SysMsg ('µÀÊõË²Ê±ÌáÉý'+ IntToStr(ExtraAbil[EABIL_SCUP]) + '£¬³ÖÐø ' + IntToStr((ExtraAbilTimes[EABIL_SCUP] - GetTickCount) div 1000 div 60) + '·Ö' + IntToStr((ExtraAbilTimes[EABIL_DCUP] - GetTickCount) div 1000 mod 60) + 'Ãë', 1);
   {$ELSE}        SysMsg ('Physical Attack Power Increased for ' + IntToStr((ExtraAbilTimes[EABIL_SCUP] - GetTickCount) div 1000 div 60) + 'min. ' + IntToStr((ExtraAbilTimes[EABIL_DCUP] - GetTickCount) div 1000 mod 60) + 'sec.', 1);
   {$ENDIF}
   RecalcAbilitys;
   SendMsg (self, RM_ABILITY, 0, 0, 0, 0, '');

   if SlaveList.Count >= 1 then begin
      for i := 0 to SlaveList.Count -1 do begin
         cret := TCreature(SlaveList[i]);
         if (cret <> nil) then begin
            cret.ExtraAbil[EABIL_SCUP] := _MIN( 255, _MAX(cret.ExtraAbil[EABIL_SCUP], UpSC) );
            cret.ExtraAbilFlag[EABIL_SCUP] := 0;
            cret.ExtraAbilTimes[EABIL_SCUP] := _MAX(cret.ExtraAbilTimes[EABIL_SCUP], GetTickCount + LongWord(sec * 1000)); //ÃÊ´ÜÀ§
            cret.ExtraAbil[EABIL_MCUP] := _MIN( 255, _MAX(cret.ExtraAbil[EABIL_MCUP], UpSC) );
            cret.ExtraAbilFlag[EABIL_MCUP] := 0;
            cret.ExtraAbilTimes[EABIL_MCUP] := _MAX(cret.ExtraAbilTimes[EABIL_MCUP], GetTickCount + LongWord(sec * 1000)); //ÃÊ´ÜÀ§
            cret.RecalcAbilitys;
         end;
      end;
   end;

   Result := TRUE;
end;

function   TCreature.MagScUp (sec, pwr: integer): Boolean;       //ÎÞ¼«ÕæÆø
var
   i, UpSC : integer;
begin
   Result := FALSE;
   if (ExtraAbil[EABIL_SCUP] = 0) then begin //Ê±¼ä¼ä¸ô
     UpSC := pwr;
     ExtraAbil[EABIL_SCUP] := _MIN( 255, _MAX(ExtraAbil[EABIL_SCUP], UpSC));
     ExtraAbilFlag[EABIL_SCUP] := 0;
     ExtraAbilTimes[EABIL_SCUP] := _MAX(ExtraAbilTimes[EABIL_SCUP], GetTickCount + LongWord(sec * 1000)); //ÃÊ´ÜÀ§
     SysMsg ('µÀÊõË²Ê±ÌáÉý' + IntToStr(ExtraAbil[EABIL_SCUP]) + '£¬³ÖÐø ' + IntTostr(sec) + ' Ãë', 1);
     RecalcAbilitys;
     SendMsg (self, RM_ABILITY, 0, 0, 0, 0, '');
     Result := TRUE;

   end else begin
     SysMsg('¾«ÉñÁ¦Äý¾ÛÊ§°Ü', 1);
     Result := FALSE;
  end;
end;

procedure TCreature.MagCurse(sec , pwrrate: integer);
begin

   MakePoison( POISON_SLOW, sec , 1 );

   if ExtraAbilTimes[EABIL_PWRRATE] < ( GetTickCount + LongWord(sec * 1000)) then begin

      ExtraAbil[EABIL_PWRRATE] := pwrrate;
      ExtraAbilTimes[EABIL_PWRRATE] := GetTickCount + LongWord(sec * 1000); //ÃÊ´ÜÀ§

      if pwrrate < 100 then begin
         {$IFDEF KOREA} SysMsg('¹¥»÷£¬Ä§·¨£¬µÀÊõ¼õÉÙ'+IntToStr(100-pwrrate) + '% ' +'³ÖÐø'+ IntToStr(sec) + 'Ãë', 1);
         {$ELSE}        SysMsg('Attack Ability '+IntToStr(100-pwrrate) + '% decreased ' + IntToStr(sec) + 'Secs', 1);
         {$ENDIF}
      end else begin
         {$IFDEF KOREA} SysMsg('¹¥»÷Á¦Ôö¼Ó'+IntToStr(pwrrate-100) + '% ' +'³ÖÐø'+ IntToStr(sec) + 'Ãë', 1);
         {$ELSE}        SysMsg('Attack Ability '+IntToStr(pwrrate-100) + '% increased ' + IntToStr(sec) + 'Secs', 1);
         {$ENDIF}
      end;

      RecalcAbilitys;
      SendMsg (self, RM_ABILITY, 0, 0, 0, 0, '');

   end;

end;

function  TCreature.CheckMagicLevelup (pum: PTUserMagic): Boolean;
var
   lv: integer;
begin
   Result := FALSE;
   if (pum.Level in [0..3]) and (pum.Level <= pum.pDef.MaxTrainLevel) then lv := pum.Level
   else lv := 0;

   if pum.Level < pum.pDef.MaxTrainLevel then begin
      if pum.CurTrain >= pum.pDef.MaxTrain[lv] then begin
         if pum.Level < pum.pDef.MaxTrainLevel then begin //·¹º§ ¿Ã·Á¾ßÇÔ.
            pum.CurTrain := pum.CurTrain - pum.pDef.MaxTrain[lv];
            pum.Level := pum.Level + 1;
            UpdateDelayMsgCheckParam1 (self, RM_MAGIC_LVEXP, 0, pum.pDef.MagicId, pum.Level, pum.CurTrain, '', 800);
            CheckMagicSpecialAbility (pum);
         end else begin //´Ù ¿Ã·ÈÀ½
            pum.CurTrain := pum.pDef.MaxTrain[lv];
         end;
         Result := TRUE;
      end;
   end;
end;

procedure TCreature.CheckMagicSpecialAbility (pum: PTUserMagic);
begin
   if pum.pDef.MagicId = 28 then begin //Å½±âÆÄ¿¬
      if pum.Level >= 2 then begin
         //Å½±âÆÄ¿¬ 2´Ü°è ÀÌ»ó ¼ö·ÃÇßÀ» °æ¿ì
         BoAbilSeeHealGauge := TRUE;
      end;
   end;
end;





function   TCreature.GetDailyQuest: integer;   //ÇöÀç ¹Þ°í ÀÖ´Â ÀÏÀÏÄù½ºÆ® °ªÀ» ¾ò¾î ¿Â´Ù. Áö³µ°Å³ª, ¾øÀ¸¸é 0
var
   ayear, amon, aday: word;
   calcdate: word;
begin
   DecodeDate (Date, ayear, amon, aday);
   calcdate := amon * 31 + aday;
   if (DailyQuestNumber = 0) or (DailyQuestGetDate <> calcdate) then
      Result := 0
   else
      Result := DailyQuestNumber;
end;

procedure  TCreature.SetDailyQuest (qnumber: integer);  //»õ·ÎÈ÷ ÀÏÀÏÄù½ºÆ®¸¦ ¼³Á¤ÇÑ´Ù.
var
   ayear, amon, aday: word;
begin
   DecodeDate (Date, ayear, amon, aday);
   DailyQuestNumber := qnumber;
   DailyQuestGetDate := amon * 31 + aday;
end;



{%%%%%%%%%%%%%%%%%%% *RunMsg* %%%%%%%%%%%%%%%%%%%%}

procedure TCreature.RunMsg (msg: TMessageInfo);
var
   str: string;
   n, v1, v2, magx, magy, magpwr, range: integer;
   hiter, target: TCreature;
   plusdamage: integer;
   test : integer;
begin
   plusdamage := 0;
   test := 0;
   case msg.Ident of
      RM_REFMESSAGE:
         begin
            with msg do
               SendRefMsg (Integer(Sender), wParam, lParam1, lParam2, lParam3, Description);
            if Integer(msg.Sender) = RM_STRUCK then
               if RaceServer <> RC_USERHUMAN then begin
                  with msg do
                     SendMsg (self, Integer(msg.Sender), wParam, lParam1, lParam2, lParam3, Description);
               end;
         end;
      RM_DELAYMAGIC:
         begin
            magpwr := msg.wParam;
            magx := Loword (msg.lparam1);
            magy := Hiword (msg.lparam1);
            range := msg.lparam2;
            target := TCreature(msg.lparam3);
            if target <> nil then
            begin
               // È­·æÀÏ¶§´Â ½ºÆ®·°Æ®¸¦ ¸Ô°Ô ÇÏÀÚ.
               if (Target.RaceServer = RC_FIREDRAGON) or (Target.RaceServer = RC_DRAGONBODY) then
               begin
                  if ( ABS( self.CX - target.CX ) <= 8) and ( ABS ( self.CY - target.CY ) <= 8) then
                  begin
                     target.SendMsg (self, RM_DRAGON_EXP, 0, random(3)+1, 0, 0, '');
                  end;
               end;

               n := target.GetMagStruckDamage (self, magpwr);  //¸¶Ç×·ÂÀ» Àû¿ëÇßÀ»¶§ÀÇ µ¥¹ÌÁö·Î °Ë»ç
               if n > 0 then begin
//                  SelectTarget (target);  //RM_DELAYMAGIC¿¡¼­ RM_MAGSTRUCKÀ¸·Î ¿Å±è(sonmg 2004/08/25)
                  if target.RaceServer >= RC_ANIMAL then begin
                     magpwr := Round(magpwr * 1.2);  //µ¿¹°(¸ó½ºÅÍ)ÀÎ°æ¿ì ¸¶¹ý Å¸°Ý·ÂÀÌ 120%
                  end;
                  if (abs(magx-target.CX) <= range) and (abs(magy-target.CY) <= range) then
                     target.SendMsg (self, RM_MAGSTRUCK, 0, magpwr, 0, 0, '');
               end;
               SelectTarget(target);
            end;
         end;
      RM_MAGSTRUCK,
      RM_MAGSTRUCK_MINE:
         begin
            if RaceServer = RC_USERHUMAN then begin
              if TUserHuman(Self).m_StallMgr.OnSale then begin

                Exit;
              end;
            end;
            hiter := TCreature(msg.sender);

            //ÇÁ¸®¹Ì¾ö ÀÌº¥Æ®(sonmg)
            if hiter <> nil then begin
               plusdamage := hiter.PlusFinalDamage;
            end else begin
               plusdamage := 0;
            end;

            //³ªÀÇ ¸¶¹æ Àû¿ë
            if (msg.Ident = RM_MAGSTRUCK) and (RaceServer >= RC_ANIMAL) and (not RushMode) then begin
               //¸¶¹ýÀ¸·Î °ø°Ý´çÇÏ¸é ÀÌµ¿¿¡ Áö¿¬À» ¹Þ´Â´Ù.
               //2003/02/11 ÃÖ´ë·¡¹ë Àû¿ë
               if Abil.Level < g_MONLEVELTIAOJIE then     //50   //  if Abil.Level < MAXKINGLEVEL-1 then
                  WalkTime := WalkTime + g_seMONJISHU + Random(g_seMONSUIJIZHI);
            end;

            //v1 := Lobyte(WAbil.MAC) + Random(ShortInt(Hibyte(WAbil.MAC)-Lobyte(WAbil.MAC)) + 1);
            //v1 := _MAX(msg.lparam1 - v1, 0);
            //if msg.Ident = RM_MAGSTRUCK_MINE then  //¹æ¾î°¡ Àû¿ë ¾ÈµÈ°æ¿ì
            v1 := GetMagStruckDamage (nil, msg.lparam1);

            if v1 > 0 then begin
               target := TCreature(msg.sender);
               SelectTarget (target);  //RM_DELAYMAGIC¿¡¼­ RM_MAGSTRUCKÀ¸·Î ¿Å±è(sonmg 2004/08/25)
               StruckDamage (v1 + plusdamage);
               HealthSpellChanged;
               SendRefMsg (RM_STRUCK_MAG, v1 + plusdamage, WAbil.HP, WAbil.MP, integer(msg.sender), '');
               if RaceServer <> RC_USERHUMAN then begin
                  if BoAnimal then begin //°í±â°¡ ³ª¿À´Â µ¿¹°ÀÎ °æ¿ì..
                     MeatQuality := MeatQuality - v1 * 1000;  //¸¶¹ýÀ» ¸ÂÀ¸¸é °í±âÁúÀÌ Ä¡¸íÀûÀ¸·Î ³ªºüÁø´Ù.
                  end;
                  SendMsg (self, RM_STRUCK, v1 + plusdamage, WAbil.HP, WAbil.MP, integer(msg.sender), '');
               end;
            end;
         end;
      RM_MAGHEALING:
         begin
            if IncHealing + msg.lparam1 < 300 then begin
               if RaceServer = RC_USERHUMAN then begin
                  IncHealing := IncHealing + msg.lparam1;
                  PerHealing := 5;
               end else begin
                  IncHealing := IncHealing + msg.lparam1;
                  ///IncHealing := IncHealing + msg.lparam1 div 2;
                  PerHealing := 5;
               end;
            end else IncHealing := 300;
            //v1 := msg.lparam1;
            //DamageHealth (-v1);
            //HealthSpellChanged;
         end;
      RM_MAKEPOISON:
         begin
            hiter := TCreature(msg.lparam2);
            test := 1;
            if hiter <> nil then begin
               test := 2;
               if IsProperTarget (hiter) then begin
                  test := 3;
                  SelectTarget (hiter);
{
                  if (RaceServer = RC_USERHUMAN) and (hiter.RaceServer = RC_USERHUMAN) then begin
                     test := 4;
                     //Á¤´ç¹æ¾î¸¦ À§ÇÑ ±â·Ï..
                     AddPkHiter (hiter);
                     SetLastHiter (hiter);
                     //testcode(³ìµ¶·Î±×)
                     MainOutMessage('[TestCode1]°¥ÇÇ : ' + UserName + ', Hiter : ' + hiter.UserName);
                  end else begin
}
                     // 2003/06/12  Ê©¶¾Êõ¶¾ËÀÍõ¼¶±ðµÄ¸ø²»¸ø¾­Ñé...
                      //if Abil.Level < 60 then
                        SetLastHiter (hiter);
//                  end;
               end;
               //³ªÁß¿¡ ¿Å°Üµµ µÉÁö Å×½ºÆ®...
               if (RaceServer = RC_USERHUMAN) and (hiter.RaceServer = RC_USERHUMAN) then begin
                  test := 5;
                  //Á¤´ç¹æ¾î¸¦ À§ÇÑ ±â·Ï..
                  AddPkHiter (hiter);
                  SetLastHiter (hiter);
               end else if (Master <> nil) then begin
                  //Áßµ¶µÈ ¼ÒÈ¯¸÷ÀÇ ÁÖÀÎÀÌ ¶§¸°»ç¶÷ÀÌ ¾Æ´Ï¸é
                  if Master <> hiter then begin
                     //Á¤´ç¹æ¾î¸¦ À§ÇÑ ±â·Ï..
                     AddPkHiter (hiter);
                     SetLastHiter (hiter);
                  end;
               end;
               //Áßµ¶
               MakePoison (msg.wparam{poison id}, msg.lparam1{time}, msg.lparam3{poison level}); //POISON_DECHEALTH, 60);
            end else begin
               MakePoison (msg.wparam{poison id}, msg.lparam1{time}, msg.lparam3{poison level}); //POISON_DECHEALTH, 60);
            end;
         end;
      RM_DOOPENHEALTH:
         begin
            MakeOpenHealth;
         end;
      RM_TRANSPARENT:
         begin
            MagicMan.MagMakePrivateTransparent (self, msg.lparam1);
         end;
      RM_RANDOMSPACEMOVE:
         begin
            RandomSpaceMove (msg.Description, msg.wParam);
         end;
      // 2003/04/01 A/I º¯°æ
      RM_DECREFOBJCOUNT:
         begin
            DecRefObjCount;
         end;
      RM_DRAGON_EXP:
         begin
             if gFireDragon <> nil then
             begin
                  gFireDragon.ChangeExp( msg.lParam1 );
             end;
         end;
      RM_CURSE:
         begin
            MagCurse (msg.wParam, msg.lparam1);
         end;

   end;
end;

//¹¦ÄÜ£º
//¡¡¡¡¡¡×Ô¶¨ÒåÀ¯ÖòÎïÆ·µô³Ö¾Ã¿ØÖÆ.Ö§³Ö°´Ê±¼äµô³Ö¾Ã»òÓëÆÕÍ¨×°±¸Ò»ÑùÊÜ¹¥»÷µô³Ö¾Ã
//
//ÓÃ·¨£º
//¡¡¡¡¡¡°´Ê±¼äµô³Ö¾Ã£ºÊýÆ·Êý¾Ý¿âÖÐSource×Ö¶ÎÎª 0
//¡¡¡¡¡¡ÊÜ¹¥»÷µô³Ö¾Ã£ºÎïÆ·Êý¾Ý¿âÖÐSource×Ö¶ÎÎª 1
procedure TCreature.UseLamp;
var
   old, dura: integer;
   hum: TUserHuman;
   ps: pTStdItem;
begin
   try
      if UseItems[U_RIGHTHAND].index > 0 then
    begin
       ps := UserEngine.GetStdItem(UseItems[U_RIGHTHAND].Index);
    if (ps = nil) or (ps.specialpwr <> 0) then Exit;          //ÈÙÓþÑ«ÕÂÉèÖÃ    2021/7/24
      Old := Round(UseItems[U_RIGHTHAND].Dura / 1000);
      // 2003/03/04 0.5ÃÊ¿¡¼­ 1ÃÊ·Î ¹Ù²ñ¿¡ µû¶ó ³»±¸¸¦ -1¿¡¼­ -2·Î Á¶Á¤
      Dura := integer(UseItems[U_RIGHTHAND].Dura) - 2; // 1;
         if dura <= 0 then begin
            UseItems[U_RIGHTHAND].Dura := 0;
            //ÃÊ°¡ »ç¶óÁø´Ù.
            if RaceServer = RC_USERHUMAN then begin
               hum := TUserHuman(self);
               hum.SendDelItem (UseItems[U_RIGHTHAND]); //Å¬¶óÀÌ¾ðÆ®¿¡ ¾ø¾îÁø°Å º¸³¿
            end;
            UseItems[U_RIGHTHAND].Index := 0;

            Light := GetMyLight;
            SendRefMsg (RM_CHANGELIGHT, 0, 0, 0, 0, '');
            SendMsg (self, RM_LAMPCHANGEDURA, 0, UseItems[U_RIGHTHAND].Dura, 0, 0, '');

            // ÃÊÀÇ ´É·ÂÄ¡ º¯°æ Àû¿ë(sonmg 2005/11/10)
            RecalcAbilitys;
            SendMsg (self, RM_ABILITY, 0, 0, 0, 0, '');
         end else
            UseItems[U_RIGHTHAND].Dura := dura;
         if old <> Round(dura / 1000) then begin
            //³»±¸¼ºÀÌ º¯ÇÔ
            SendMsg (self, RM_LAMPCHANGEDURA, 0, UseItems[U_RIGHTHAND].Dura, 0, 0, '');
         end;
      end;
   except
      MainOutMessage ('[Exception] TCreature.UseLamp');
   end;
end;

{%%%%%%%%%%%%%%%%%%%%% *Run* %%%%%%%%%%%%%%%%%%%%%}

procedure TCreature.Run;
var
   msg: TMessageInfo;
   i, n, hp, mp, ablmask, plus, waittime: integer;
   inchstime: longword;
   cret, lhiter, lmaster: TCreature;
   chg, needrecalc: Boolean;
   test , identbackup : integer;
   bcheckDeath : Boolean;
   DuringIllegalTime: longword;
   hum : TUserHuman;
   nSecond: Integer;
   nPayType: Integer;
begin
    test := 0;
    IdentBackup := 0;
	try
      {extract message to behavior and so ..}
      while GetMsg (msg) do
      begin
         IdentBackup := msg.Ident;
         RunMsg (msg);
      end;
   except
   	MainOutMessage ('[Exception] TCreature.Run 0 : '+ IntToStr(IdentBackup)+':'+IntToStr(msg.Ident));
   end;

   try
      test := 1;
      if NeverDie then begin
         WAbil.HP := WAbil.MaxHP; //Àý´ë·Î Á×Áö ¾ÊÀ½.  NPC
         WAbil.MP := WAbil.MaxMP;
      end;
      if RaceServer = RC_USERHUMAN then begin
        if TUserHuman(Self).m_StallMgr.OnSale then begin

          if bosafe°ÚÌ¯ and TUserHuman(Self).InSafeZone then begin

            WAbil.HP := WAbil.MaxHP; //Àý´ë·Î Á×Áö ¾ÊÀ½.  NPC
            WAbil.MP := WAbil.MaxMP;
          end;
        end;
      end;
      test := 2;
      // 2003/07/03 ÀÌº¥Æ®¿ë ÄÚµå
      if ((UseItems[U_DRESS].Index = 468) or
          (UseItems[U_DRESS].Index = 469) or
          (UseItems[U_DRESS].Index = 470) or
          (UseItems[U_DRESS].Index = 471) or
          (UseItems[U_DRESS].Index = 695) or
          (UseItems[U_DRESS].Index = 696) ) and (UseItems[U_DRESS].Dura > 0) then
          n := (GetTickCount - ticksec) div 13  //ÃÊ´ç 75
      else
//      test := 3;
         n := (GetTickCount - ticksec) div 20;  //ÃÊ´ç 50

      ticksec := GetTickCount;
      Inc (HealthTick, n);
      Inc (SpellTick, n);

      test := 4;
      if not Death then begin
         if WAbil.HP < WAbil.MaxHP then begin
            if HealthTick >= HEALTHFILLTICK then begin
               plus := WAbil.MaxHP div 75 + 1;  //plus := WAbil.MaxHP div 15 + 1;
               // HealthRecover Àû¿ë(sonmg 2004/02/20)
               plus := plus + ( ( plus * HealthRecover ) div 10 );
               if WAbil.HP+plus < WAbil.MaxHP then WAbil.HP := WAbil.HP + plus
               else WAbil.HP := WAbil.MaxHP;
               //UpdateMsg (self, RM_HEALTHSPELLCHANGED, 0, 0, 0, 0, '');
               HealthSpellChanged;
            end;
         end;
          test := 5;

         if WAbil.MP < WAbil.MaxMP then begin
            if SpellTick >= SPELLFILLTICK then begin
               plus := WAbil.MaxMP div 18 + 1;
               // SpellRecover Àû¿ë(sonmg 2004/02/20)
               plus := plus + ( ( plus * SpellRecover ) div 10 );
               if WAbil.MP+plus < WAbil.MaxMP then WAbil.MP := WAbil.MP + plus
               else WAbil.MP := WAbil.MaxMP;
               //UpdateMsg (self, RM_HEALTHSPELLCHANGED, 0, 0, 0, 0, '');
               HealthSpellChanged;
            end;
         end;

        test := 6;
         if WAbil.HP = 0 then begin
            if BoAbilRevival then begin //Àç»ý ´É·ÂÀÌ ÀÖ´Ù.
               if GetTickCount - LatestRevivalTime > 60 * 1000 then begin
                  LatestRevivalTime := GetTickCount;
                  //¹ÝÁö¸¦ ´â°Ô ÇÑ´Ù.
                  ItemDamageRevivalRing;
                  WAbil.HP := WAbil.MaxHP;
                  HealthSpellChanged;
                  SysMsg ('½äÖ¸µÄÁ¦Á¿ÁîÄú¸´»îÁË', 1);
               end;
            end;
            if WAbil.HP = 0 then
               Die;
         end;
         if HealthTick >= HEALTHFILLTICK then HealthTick := 0;
         if SpellTick >= SPELLFILLTICK then SpellTick := 0;
      end else begin
      test := 7;

         if GetTickCount - DeathTime > 3 * 60 * 1000 then begin
            MakeGhost(5);
         end;
//         if DEATH and not Death2 then
//           SendRefMsg (RM_DEATH, Dir, CX, CY, 1, '');
      end;
   except
   	MainOutMessage ('[Exception] TCreature.Run 1 > '+IntTostr(Test));
   end;


   try
      if (not Death) and ((IncSpell > 0) or (IncHealth > 0) or (IncHealing > 0)) then begin
         inchstime := 600 - _MIN(400, Abil.Level * 10);
         // 2003/07/03 ÀÌº¥Æ®¿ë ÄÚµå
         if ((UseItems[U_DRESS].Index = 468) or
             (UseItems[U_DRESS].Index = 469) or
             (UseItems[U_DRESS].Index = 470) or
             (UseItems[U_DRESS].Index = 471) or
             (UseItems[U_DRESS].Index = 695) or
             (UseItems[U_DRESS].Index = 696) )and (UseItems[U_DRESS].Dura > 0) then
            inchstime := inchstime div 2;
         if (GetTickCount - IncHealthSpellTime >= inchstime) and
            (not Death) then begin  //Ã¼¾à,¸¶¾àÀ» ¸ÔÀ¸¸é ÃµÃµÈ÷ Âù´Ù.

            n := _MIN(200, (GetTickCount - IncHealthSpellTime) - inchstime);
            IncHealthSpellTime := GetTickCount + longword(n);

            if (IncHealth > 0) or (IncSpell > 0) or (PerHealing > 0) then begin
               if PerHealth <= 0 then PerHealth := 1;
               if PerSpell <= 0 then PerSpell := 1;
               if PerHealing <= 0 then PerHealing := 1;
               if IncHealth < PerHealth then begin
                  hp := IncHealth;
                  IncHealth := 0;
               end else begin
                  hp := PerHealth;
                  IncHealth := IncHealth - PerHealth;
               end;
               if IncSpell < PerSpell then begin
                  mp := IncSpell;
                  IncSpell := 0;
               end else begin
                  mp := PerSpell;
                  IncSpell := IncSpell - PerSpell;
               end;
               if IncHealing < PerHealing then begin
                  hp := hp + IncHealing;
                  IncHealing := 0;
               end else begin
                  hp := hp + PerHealing;
                  IncHealing := IncHealing - PerHealing;
               end;
               PerHealth  := 5 + (Abil.Level div 10);
               PerSpell   := 5 + (Abil.Level div 10);
               PerHealing := 5;

               IncHealthSpell (hp, mp);

               if WAbil.HP = WAbil.MaxHP then begin
                  IncHealth := 0;
                  IncHealing := 0;
               end;
               if WAbil.MP = WAbil.MaxMP then begin
                  IncSpell := 0;
               end;
            end;
         end;
      end else begin
         IncHealthSpellTime := GetTickCount;
      end;

      if HealthTick < -HEALTHFILLTICK then begin
         if WAbil.HP > 1 then begin
            WAbil.HP := WAbil.HP - 1;
            HealthTick := HealthTick + HEALTHFILLTICK;
            //UpdateMsg (self, RM_HEALTHSPELLCHANGED, 0, 0, 0, 0, '');
            HealthSpellChanged;
         end;
      end;
   except
   	MainOutMessage ('[Exception] TCreature.Run 2');
   end;

   test := 0;
   try
      if TargetCret <> nil then begin
         if (GetTickCount - TargetFocusTime > 60 * 1000) or   //¹ÖÎï¹éÊôÄ¿±ê
            (TargetCret.Death) or (TargetCret.BoGhost) or
            (Abs(TargetCret.CX-CX) > 15) or
            (Abs(TargetCret.CY-CY) > 15) then begin
            TargetCret := nil;
         end;
      end;

      if  Master <> nil then begin
        if TargetCret <> nil then begin
           if TargetCret.InSafeZone and (TargetCret.Master <> nil)then begin
              TargetCret := nil;
              LastHiter := nil;
              Master.TargetCret := nil;
              Master.LastHiter := nil;
           end;
        end;
      end;

      test := 1;
      if LastHiter <> nil then begin
          if RaceServer <> RC_USERHUMAN then
            DuringIllegalTime := 30 * 1000    //±¦±¦¹¥»÷¹ÖÎï¸ø¾­Ñé±¬ÂÊ¼ä¸ôÊ±¼ä  30
          else
            DuringIllegalTime := 60 * 1000;   //ÈËÎï¹¥»÷¹ÖÎï¸ø¾­Ñé±¬ÂÊ¼ä¸ôÊ±¼ä   60

         if (GetTickCount - LastHitTime > DuringIllegalTime) then begin
            LastHiter := nil;
         end else if (LastHiter.Death) or (LastHiter.BoGhost) then begin
            LastHiter := nil;
         end;
      end;


      test := 2;
      if ExpHiter <> nil then begin
         if (GetTickCount - ExpHitTime > 60 * 1000) or (ExpHiter.Death) or (ExpHiter.BoGoodCrazyMode) or (ExpHiter.BoGhost) then
             ExpHiter := nil;
      end;


      test := 3;
      if Master <> nil then begin
         BoNoItem := TRUE;

         test := 4;
         waittime := 1000;
         if Master.RaceServer = RC_USERHUMAN then begin
             if TUserHuman(Master).BoChangeServer then
                 waittime := 15 * 1000;
         end;

         test := 5;
         if (Master.Death and (GetTickCount > 1000 + Master.DeathTime)) or
            (Master.BoGhost and (GetTickCount > LongWord( waittime ) + Master.GhostTime)) then begin
            WAbil.HP := 0; //Die;
            //Master := nil;
         end;
      end;
      test := 6;

      for i:=SlaveList.Count-1 downto 0 do begin
         // nil °Ë»ç Ãß°¡  2003-09-18  PDS
         try // ¿¡·¯³ª¸é ±×³É ¾ø¿¡¹ö¸²
            bcheckDeath := TCreature(SlaveList[i]).Death;
         except
             SlaveList.Delete (i);
             MainOutMessage ('MEMORY CHECK ERROR! TCreature.Run 2:6');
             continue;
         end;

         if ( SlaveList[i] = nil ) or
             TCreature(SlaveList[i]).Death or
             TCreature(SlaveList[i]).BoGhost or
             (TCreature(SlaveList[i]).Master <> self) then
         begin
            SlaveList.Delete (i);
         end;

      end;
      test := 7;

      if BoHolySeize then begin
         if GetTickCount - HolySeizeStart > HolySeizeTime then begin
            BreakHolySeize;
         end;
      end;
      test := 8;

      if BoCrazyMode or BoGoodCrazyMode then begin
         if GetTickCount - CrazyModeStart > CrazyModeTime then begin
            BreakCrazyMode;
         end;
      end;
      test := 9;

      if BoOpenHealth then begin
         if GetTickCount - OpenHealthStart > OpenHealthTime then begin
            BreakOpenHealth;
         end;
      end;
   except
      MainOutMessage ('[Exception] TCreature.Run 3:'+IntToStr(test));
   end;

   try
      //------------------------------------------------
      //·Î±×ÀÎ¼­¹ö¿¡ ½Ã°£°èÁ¤ Ã¼Å© ½ÅÈ£ º¸³¿
      //4½Ã°£->1½Ã°£¿¡ ÇÑ¹ø Æ½
      if GetTickCount - time1hour > {4 *} 60 * 60 * 1000 then begin
         time1hour := GetTickCount;

         if RaceServer = RC_USERHUMAN then begin
            hum := TUserHuman(self);
            if hum <> nil then begin
               // Å×½ºÆ® ¼­¹ö°¡ ¾Æ´Ï¸é ½Ã°£ °èÁ¤ Ã¼Å©(2004/09/06 sonmg)
               if not BoTestServer then begin
                  // Á¤·®Á¦ÀÎ °æ¿ì¸¸ Ã¼Å©
                  if (hum.AvailableMode = 2) or (hum.AvailableMode = 6) or (hum.AvailableMode = 7) or (hum.AvailableMode = 8)
                        or (hum.AvailableMode = 9) or (hum.AvailableMode = 10) then begin
                     // Ä«¿îÆ®°¡ ½ÃÀÛµÇÁö ¾Ê¾ÒÀ» ¶§¸¸ º¸³½´Ù.
                     if hum.FExpireCount = 0 then begin
                        FrmIDSoc.SendCheckTimeAccount (hum.UserId, hum.Certification);
                     end;
                  end;
               end;
               //3½Ã°£ÀÌ °æ°úÇÏÁö ¾Ê¾ÒÀ» ¶§ °æ°í¸Þ½ÃÁö
               Inc(ElapsedHours);
               if ElapsedHours < 3 then begin
                  //SysMsg(IntToStr(ElapsedHours) + 'Ð¡Ê±Ê±¼ä¹ýÈ¥ÁË£¬Çë×¢ÒâÐÝÏ¢£¡', 0);
               end else begin
                  //SysMsg(IntToStr(ElapsedHours) + 'Ð¡Ê±Ê±¼ä¹ýÈ¥ÁË£¬ÐÝÏ¢Ò»»á°É£¡', 0);
               end;
            end;
         end;
      end;
      //------------------------------------------------

      //2ºÐ¿¡ ÇÑ¹ø Æ½
      if GetTickCount - time10min > 1000 * 60 then begin     //PKÖµ2·ÖÖÓµô1µã¸Ä1·ÖÖÓ 2 * 1000 *60
         time10min := GetTickCount;

         //PKµã¼õÉÙ1.
         if PlayerKillingPoint > 0 then begin
            DecPkPoint ((Pkzhi));      //Ô­À´ÊÇ1  µôPKÖµ¿ØÖÆ
         end;

      end;

      //0.5ÃÊ¿¡ ÇÑ¹ø Æ½
      // 2003/03/04 1ÃÊ¿¡ ÇÑ¹ø Æ½À¸·Î º¯°æ
      if GetTickCount - time500ms > 1000 then begin    // 500
         time500ms := time500ms + 1000;                // 500;
         if RaceServer = RC_USERHUMAN then begin
            //ÃÊ°¡ Å¸´Â °Í..
            UseLamp;
            // 2003/03/04 5ÃÊ¿¡ ÇÑ¹øÂÊÀ¸·Î ÀÌµ¿
//          CheckTimeOutPkHiterList;
         end;
         // 2003/07/15 »óÅÂÀÌ»ó Ãß°¡
//         if StatusArr[POISON_SLOW] > 0 then begin
//          MainOutMessage ('[»óÅÂÀÌ»ó] ½½·Î¿ì ¹ß»ý');
//            WalkTime := WalkTime + 700;      //´Ê°Ô ¿òÁ÷ÀÎ´Ù
//            HitTime  := HitTime + 1500;      //´Ê°Ô ¶§¸°´Ù
//         end;
      end;

      //5ÃÊ¿¡ ÇÑ¹ø
      if GetTickCount - time5sec > 5 * 1000 then begin
         time5sec := GetTickCount;
         // 2003/03/04 0.5ÃÊ¿¡ ÇÑ¹øÂÊ¿¡¼­ ÀÌµ¿
         if RaceServer = RC_USERHUMAN then
            CheckTimeOutPkHiterList;
      end;

      //10ÃÊ¿¡ ÇÑ¹ø
      if GetTickCount - time10sec > 10 * 1000 then begin
         time10sec := GetTickCount;

         //if BoTestServer then begin
            //ºÎÇÏ¸¦ ´ë¸®°í ÀÖÀ¸¸é, ¸¶·ÂÀÌ ¼Ò¸ðµÈ´Ù.
            //if (SlaveList.Count >= 2) and not BoSlaveRelax then begin
            //   n := 0;
            //   for i:=0 to SlaveList.Count-1 do
            //      n := n + TCreature(SlaveList[i]).Abil.MaxHP;
            //   DamageSpell (n div 60);
            //   HealthSpellChanged;
            //end;
         //end;

         if Master <> nil then begin
            //¹è½Å °Ë»ç
            if GetTickCount > MasterRoyaltyTime then begin
               for i:=Master.SlaveList.Count-1 downto 0 do begin
                  if Master.SlaveList[i] = self then begin
                     Master.SlaveList.Delete (i);
                     break;
                  end;
               end;
              Master := nil; //¹è½ÅÇÑ´Ù.
            //   WAbil.HP := WAbil.HP div 10;  //ÅÑ±äºóHP³ýÓÚ10£¬·¨Ê¦±¦±¦ÅÑ±äºóµÄÑªÁ¿
             if boBbpbsiwang then  begin

               WAbil.HP := 0;  // ÅÑ±äºóµÄÑªÁ¿Îª0£¬¼´·¨Ê¦±¦±¦ÅÑ±äºóËÀÍö
               UserNameChanged;
             end else
             WAbil.HP := WAbil.HP div 10;  //ÅÑ±äºóHP³ýÓÚ10£¬·¨Ê¦±¦±¦ÅÑ±äºóµÄÑªÁ¿
             UserNameChanged;
            end;





            //Á×À» ½Ã°£ °Ë»ç (²¿¼ÅÁøÁö 12½Ã°£ÀÌ Áö³ª¸é Á×´Â´Ù.)
            if SlaveLifeTime <> 0 then
               if GetTickCount - SlaveLifeTime > 12 * 60 * 60 * 1000 then
               begin
                  WAbil.HP := 0;
                  BoDisapear := true;
               end;
         end;

      end;

      if (RaceServer = RC_USERHUMAN) then
      begin
        hum := TUserHuman(self);
        if boSecondCardSystem then
        begin
          if (Abil.Level > g_nExpErienceLevel) then
          begin
            if hum.iDay <= 0 then
              if hum.SecondsCard <= 0  then
              AvailableGold := 100000
             else
             if AvailableGold <> BAGGOLD then
               AvailableGold := BAGGOLD;
            if (hum.iDay <= 0) then
            begin
              nSecond := 0;
              if hum.iHours > 0 then begin
                nSecond := hum.iHours;
                nPayType := 1;
              end else
              if hum.SecondsCard > 0 then begin
                nSecond := hum.SecondsCard;
                nPayType := 2;
              end;

              if GetTickCount - time60sec > 30 * 1000 then begin  //µã¿¨¼ì²â»ùÊý
                time60sec := GetTickCount;
                 if (nSecond <= 0) and (PEnvir.MapName <> g_sRechargingMap) then begin
                   if AvailableGold <> 100000 then
                     AvailableGold := 100000;
                   nSecond := 0;
                   SysMsg ('[ÕË»§ÐÅÏ¢]µ±Ç°ÕË»§³äÖµÊ±¼äÒÑµ½ÆÚ', 0);
                   if RaceServer = RC_USERHUMAN   then begin
                   if GrobalEnvir.GetEnvir (g_sRechargingMap) <> nil then begin
                     SendRefMsg (RM_SPACEMOVE_HIDE, 0, 0, 0, 0, '');
                     RandomSpaceMove (g_sRechargingMap, 0); //¹«ÀÛÀ§ °ø°£ÀÌµ¿
                   end;
                  end;
                 end else begin
                   if (nSecond > 0) and (PEnvir.MapName <> g_sRechargingMap) and not (InSafeZone) then begin
                      if AvailableGold <> BAGGOLD then
                        AvailableGold := BAGGOLD;
                      Dec(nSecond, 30);//ÕâÀïÒª¶ÔÓ¦°¡//µã¿¨¼ì²â»ùÊý
                      if nSecond <= 0 then
                      begin
                        if AvailableGold <> 100000 then
                          AvailableGold := 100000;
                        nSecond := 0;
                        SysMsg ('[ÕË»§ÐÅÏ¢]µ±Ç°ÕË»§³äÖµÊ±¼äÒÑµ½ÆÚ', 0);
                        if RaceServer = RC_USERHUMAN   then begin
                        if GrobalEnvir.GetEnvir (g_sRechargingMap) <> nil then begin
                          SendRefMsg (RM_SPACEMOVE_HIDE, 0, 0, 0, 0, '');
                          RandomSpaceMove (g_sRechargingMap, 0); //¹«ÀÛÀ§ °ø°£ÀÌµ¿
                        end;
                       end;
                      end else
                      if nSecond <= (60 * 5) then begin
                        SysMsg (Format('µ±Ç°Ãë¿¨Ê£Óà: %dÃë',[nSecond]), 1); //µã¿¨¼ì²â»ùÊý
                      end;
                   end;
                 end;
              end;

              case nPayType of
                1: hum.iHours := nSecond;
                2: hum.SecondsCard := nSecond;
              end;
            end
            else
            begin
             if AvailableGold <> BAGGOLD then
               AvailableGold := BAGGOLD;
            end;
          end
          else
          begin
            if hum.iDay <= 0 then
            begin
              if hum.SecondsCard <= 0  then
                AvailableGold := 100000
              else
               if AvailableGold <> BAGGOLD then
                 AvailableGold := BAGGOLD;
            end
            else begin
             if AvailableGold <> BAGGOLD then
               AvailableGold := BAGGOLD;
            end;
          end;
        end
        else
        begin
          if AvailableGold <> BAGGOLD then
            AvailableGold := BAGGOLD;
        end;
      end;

      //30ÃÊ¿¡ ÇÑ¹ø
      if GetTickCount - time30sec > 30 * 1000 then begin
         time30sec := GetTickCount;
         if GroupOwner <> nil then
            if {GroupOwner.Death or} GroupOwner.BoGhost then begin
               GroupOwner := nil;
            end;
         if GroupOwner = self then
            for i:=GroupMembers.Count-1 downto 0 do begin
               cret := TCreature(GroupOwner.GroupMembers.Objects[i]);
               if cret.Death or cret.BoGhost then
                  GroupMembers.Delete (i);
            end;
         if DealCret <> nil then
            if DealCret.BoGhost then begin
               DealCret := nil;
            end;

         PEnvir.VerifyMapTime (CX, CY, self);
      end;

   except
      MainOutMessage ('[Exception] TCreature.Run 4');
   end;

   try
      //»óÅÂ... ½Ã°£ÀÌ ´Ù µÇ¾ú´ÂÁö È®ÀÎÇÔ.
      chg := FALSE;
      needrecalc := FALSE;
      for i:=0 to STATUSARR_SIZE-1 do begin
         if StatusArr[i] > 0 then begin
            if StatusArr[i] < 60000 then
               if GetTickCount - StatusTimes[i] > 1000 then begin
                  StatusArr[i] := StatusArr[i] - 1;
                  StatusTimes[i] := StatusTimes[i] + 1000;
                  if StatusArr[i] = 0 then begin
                     chg := TRUE;
                     case i of
                        STATE_DEFENCEUP:
                           begin
                              needrecalc := TRUE;
                              SysMsg ('·ÀÓùÁ¦»Ö¸´Õý³£', 4);
                           end;
                        STATE_MAGDEFENCEUP:
                           begin
                              needrecalc := TRUE;
                              SysMsg ('¿¹Ä§Á¦»Ö¸´Õý³£', 4);
                           end;
                        STATE_TRANSPARENT:
                           begin
                              BoHumHideMode := FALSE;
                           end;
                        STATE_BUBBLEDEFENCEUP:
                           begin
                              BoAbilMagBubbleDefence := FALSE;
                           end;
                         STATE_CELESTIALUP:
                           begin
                              BoAbilCelestial := FALSE;
                           end;
                        else ;
                     end;
                  end else if StatusArr[i] = 10 then begin
                     // 10ÃÊÀü ¸Þ½ÃÁö(sonmg 2005/02/23)
                     case i of
                        STATE_DEFENCEUP:
                           begin
                             // SysMsg ('·ÀÓùÁ¦»¹Ê£'+ IntToStr(StatusArr[i]) +'Ãë', 1);
                             SysMsg ('·ÀÓùÁ¦ '+ IntToStr(StatusArr[i]) +'Ãëºó»Ö¸´Õý³£', 1);
                           end;
                        STATE_MAGDEFENCEUP:
                           begin
                             // SysMsg ('¿¹Ä§Á¦»¹Ê£'+ IntToStr(StatusArr[i]) +'Ãë', 1);
                             SysMsg ('¿¹Ä§Á¦ '+ IntToStr(StatusArr[i]) +'Ãëºó»Ö¸´Õý³£', 1);
                           end;
                     end;
                  end;
               end;
         end;
      end;
      for i:=0 to EXTRAABIL_SIZE -1 do begin
         if ExtraAbil[i] > 0 then begin
            if GetTickCount > ExtraAbilTimes[i] then begin
               ExtraAbil[i] := 0;
               ExtraAbilFlag[i] := 0;
               needrecalc := TRUE;
               case i of
                  EABIL_DCUP        :  SysMsg ('¹¥»÷Á¦»Ö¸´Õý³£', 4);
                  EABIL_MCUP        :  SysMsg ('Ä§·¨Á¦»Ö¸´Õý³£', 4);
                  EABIL_SCUP        :  SysMsg ('¾«ÉñÁ¦»Ö¸´Õý³£', 4);
                  EABIL_HITSPEEDUP  :  SysMsg ('¹¥»÷ËÙ¶È»Ö¸´Õý³£', 4);
                  EABIL_HPUP        :  SysMsg ('HPÖµ»Ö¸´Õý³£', 4);
                  EABIL_MPUP        :  SysMsg ('MPÖµ»Ö¸´Õý³£', 4);
                  EABIL_PWRRATE     :  SysMsg ('½ø¹¥ÄÜÁ¦»Ö¸´Õý³£', 4);
                  EABIL_MAGICACUP   :  SysMsg ('·ÀÓùÁ¦»Ö¸´Õý³£', 4);
                  EABIL_MAGICDCUP   :  SysMsg ('¹¥»÷Á¦»Ö¸´Õý³£', 4);
               end;
            end else if (ExtraAbilFlag[i] = 0) and (GetTickCount > ExtraAbilTimes[i] - 10000) then begin
               ExtraAbilFlag[i] := 1;
               case i of
                  EABIL_DCUP        :  SysMsg ('¹¥»÷Á¦10Ãëºó»Ö¸´Õý³£', 1);
                  EABIL_MCUP        :  SysMsg ('Ä§·¨Á¦10Ãëºó»Ö¸´Õý³£', 1);
                  EABIL_SCUP        :  SysMsg ('¾«ÉñÁ¦10Ãëºó»Ö¸´Õý³£', 1);
                  EABIL_HITSPEEDUP  :  SysMsg ('¹¥»÷ËÙ¶È10Ãëºó»Ö¸´Õý³£', 1);
                  EABIL_HPUP        :  SysMsg ('HPÖµ10Ãëºó»Ö¸´Õý³£', 1);
                  EABIL_MPUP        :  SysMsg ('MPÖµ10Ãëºó»Ö¸´Õý³£', 1);
                  EABIL_PWRRATE     :  SysMsg ('½ø¹¥ÄÜÁ¦10Ãëºó»Ö¸´Õý³£', 1);
                  EABIL_MAGICACUP   :  SysMsg ('·ÀÓùÁ¦10Ãëºó»Ö¸´Õý³£', 1);
                  EABIL_MAGICDCUP   :  SysMsg ('¹¥»÷Á¦10Ãëºó»Ö¸´Õý³£', 1);
               end;
            end;
         end;
      end;

      for I := Low(m_TempAbil) to High(m_TempAbil) do begin //changeHumAbilityÊôÐÔ¼Óµã
          if (m_TempAbil[I].nAddWord > 0) and (m_TempAbil[I].nAddTick > 0) and
            (GetTickCount > m_TempAbil[I].nAddTick) then
          begin
            m_TempAbil[I].nAddWord := 0;
            m_TempAbil[I].nAddTick := 0;
            needrecalc := True;
          end;
      end;

      if chg then begin
         CharStatus := GetCharStatus;
         CharStatusChanged;
      end;
      if needrecalc then begin
         RecalcAbilitys;
         SendMsg (self, RM_ABILITY, 0, 0, 0, 0, '');
      end;
   except
      MainOutMessage ('[Exception] TCreature.Run 5');
   end;
   try
      //»óÅÂ... Áßµ¶(Ã¼·ÂÀÌ °¨¼Ò)
      if GetTickCount - poisontime > 2500 then begin
         poisontime := GetTickCount;
         if StatusArr[POISON_DECHEALTH] > 0 then begin
            if BoAnimal then begin //°í±â°¡ ³ª¿À´Â µ¿¹°ÀÎ °æ¿ì..
               MeatQuality := MeatQuality - 1000;  //°í±âÁúÀÌ Ä¡¸íÀûÀ¸·Î ³ªºüÁø´Ù.
            end;
            // ³ìµ¶ °É¸° ³ÑÀÌ »ç¶÷ÀÌ°í ³¯ ¶§¸° ³ÑÀÌ »ç¶÷ÀÎµ¥ Ã¼Å©ÇÒ ¼ö ¾øÀ» ¶§...
            // Ã¼·Â 1 ÀÌÇÏ·Î ±ðÀÌÁö ¾Ê°Ô(Á×Áö ¾Ê°Ô) sonmg 2004/07/14
            if (RaceServer = RC_USERHUMAN) then begin
               if (LastHiter = nil) and (LastHiterRace = RC_USERHUMAN) then begin
                  //¸¶Áö¸· ¶§¸° ³ÑÀÌ ´©±ºÁö ¸ð¸£Áö¸¸ »ç¶÷ÀÏ ¶§´Â Á×Áö ¾Ê´Â´Ù.
                  DamageHealth (1 + PoisonLevel, 1); //1 + Random(3));
               end else begin
                  //¸¶Áö¸· ¶§¸° ³ÑÀÌ »ç¶÷ÀÌ ¾Æ´Ò ¶§...
                  DamageHealth (1 + PoisonLevel, 0); //1 + Random(3));
               end;
            end else begin
               //¸ó½ºÅÍ°¡ Áßµ¶µÇ¾úÀ» ¶§...
               DamageHealth (1 + PoisonLevel, 0); //1 + Random(3));
//               if  WAbil.HP = 0 then
//                 m_beidusi := True;
            end;

            HealthTick := 0;  //Ã¼·Â È¸º¹ ¾ÈµÊ
            SpellTick := 0;   //¸¶·Â È¸º¹ ¾ÈµÊ
            HealthSpellChanged;
            if TargetCret <> nil then    //Ê©¶¾Êõ¶¾ËÀ¹ÖÎï²»¼Ó¾­Ñé
               SetLastHiter(TargetCret);
            //if RaceServer = RC_USERHUMAN then //»ç¶÷ÀÌ¸é µ¶À¸·Î Á×Àº°Ç PKÀÌ·Î ÀÎÁ¤ ¾ÈÇÔ
            //   LastHiter := nil;
         end;
      end;
	except
   	MainOutMessage ('[Exception] TCreature.Run 6');
   end;

end;


function  TCreature.CheckAttackRule2 (target: TCreature): Boolean;
var
   hum: TUserHuman;
begin
   Result := TRUE;
   if target = nil then exit;

   if (InSafeZone) or (target.InSafeZone) then begin
      Result := FALSE;
   end;
                  //È¡ÏûºìÃû²»ÄÜ¹¥»÷10¼¶ÒÔÏÂÍæ¼Ò
//   if not target.BoInFreePKArea then begin  //°ø¼ºÀü Áö¿ª¿¡¼­´Â Á¦¿Ü µÈ´Ù.
//      if (PKLevel >= 2) and (Abil.Level > 10) then begin //°í·¦ »¡°»ÀÌµé
//         if (target.Abil.Level <= 10) and (target.PKLevel < 2) then //Àú·¾ ÂøÇÑ ÃÊº¸¸¦ °ø°Ý ¸øÇÑ´Ù.
//            Result := FALSE;
//      end;
//      if (Abil.Level <= 10) and (PKLevel < 2) then begin //Àú·¾ ÂøÇÑ ÃÊº¸
//         if (target.PKLevel >= 2) and (target.Abil.Level > 10) then //°í·¾ »¡°»ÀÌµéÀ» °ø°Ý¸øÇÑ´Ù.
//            Result := FALSE;
//      end;
//   end;

   //¸Ê ÀÌµ¿ÈÄ 3ÃÊ µ¿¾ÈÀº °ø°Ý ¸øÇÏ°í ¾È ´çÇÔ
   if (GetTickCount - MapMoveTime < 3000) or (GetTickCount - target.MapMoveTime < 3000) then
      Result := FALSE;

   {
   // 2003/04/25 Ã¼ÇèÄÉ¸¯Àº »ç¶÷À» °ø°Ý ¸øÇÏ°í °ø°Ý¹ÞÁö ¾ÊÀ½
   hum := TUserHuman(self);
   if (hum.ApprovalMode <> 2) and (hum.ApprovalMode <> 3) then begin
      Result := FALSE;
      exit;
   end;
   hum := TUserHuman(target);
   if (hum.ApprovalMode <> 2) and (hum.ApprovalMode <> 3) then begin
      Result := FALSE;
      exit;
   end;
   }
end;

//target <> nil
function  TCreature._IsProperTarget (target: TCreature): Boolean;
   function GetNonPKServerRule (rslt: Boolean): Boolean;
   begin
      Result := rslt;
      if target.RaceServer = RC_USERHUMAN then begin
         if (not PEnvir.FightZone) and (not PEnvir.Fight2Zone) and (not PEnvir.Fight3Zone) and (not PEnvir.Fight4Zone) and (target.RaceServer = RC_USERHUMAN) then
            Result := FALSE;
         if UserCastle.BoCastleUnderAttack then
            if (BoInFreePKArea) or (UserCastle.IsCastleWarArea (PEnvir, CX, CY)) then
               Result := TRUE;
         if (MyGuild <> nil) and (target.MyGuild <> nil) then
            if GetGuildRelation (self, target) = 2 then //¹®Àü(¹®ÆÄÀü)ÁßÀÓ
               Result := TRUE;
      end;
   end;
   var ATemTarget: TCreature;
begin
   Result := FALSE;
   if target = nil then exit;
   if target = self then exit;
   if RaceServer >= RC_ANIMAL then begin  //ÀÚ½ÅÀÌ µ¿¹°
      if Master <> nil then begin
         //ÁÖÀÎÀÌ ÀÖ´Â ¸÷
         //if (target.RaceServer >= RC_ANIMAL) and (target.Master = nil) then
         //   Result := TRUE;
         if (Master.LastHiter = target) or (Master.ExpHiter = target) or (Master.TargetCret = target) then
            Result := TRUE;
         if target.TargetCret <> nil then begin
            if (target.TargetCret = Master) or  //ÁÖÀÎÀ» °ø°Ý
               (target.TargetCret.Master = Master) and (target.RaceServer <> 0) //µ¿·á¸¦ °ø°Ý, »ç¶÷ÀÎ°æ¿ì Á¦¿Ü
            then
               Result := TRUE;
         end;
         if (target.TargetCret = self) and (target.RaceServer >= RC_ANIMAL) then  //¸÷ÀÌ¸é¼­ ÀÚ½ÅÀ» °ø°ÝÇÏ´Â ÀÚ
            Result := TRUE;
         if target.Master <> nil then begin  //»ó´ë°¡ ¼ÒÈ¯¸÷
            if (target.Master = Master.LastHiter) or (target.Master = Master.TargetCret) then
               Result := TRUE;
         end;
         if target.Master = Master then Result := FALSE;  //ÁÖÀÎÀÌ °°À¸¸é °ø°Ý¾ÈÇÔ
         if target.BoHolySeize then Result := FALSE;  //°á°è¿¡ °É·Á ÀÖÀ¸¸é °ø°Ý¾ÈÇÔ
         if Master.BoSlaveRelax then Result := FALSE;
         if target.BoGoodCrazyMode then Result := FALSE; //»ó´ë°¡ °ö°Ô¹ÌÄ£»óÅÂ¸é °ø°Ý¾ÈÇÔ(sonmg)
         if target.RaceServer = RC_USERHUMAN then begin  //»ó´ë°¡ »ç¶÷ÀÎ °æ¿ì
            //»ó´ë ¶Ç´Â ÀÚ½ÅÀÌ ¾ÈÀüÁö´ë¿¡ ÀÖ´Â °æ¿ì sonmg(2004/10/04)
            if (InSafeZone) or (target.InSafeZone) then begin  //»ó´ë°¡ ¾ÈÀüÁö´ë¿¡ ÀÖ´Â °æ¿ì
               Result := FALSE;
            end;
         end;
         // Å¸°Ù°ú ¸ÊÀÌ ´Ù¸£¸é °ø°ÝÇÒ ¼ö ¾ø´Ù.(sonmg 2005/01/21 -> 2005/03/31Àç¼öÁ¤)
         if MapName <> target.MapName then Result := FALSE;
         BreakCrazyMode;  //ÁÖÀÎÀÖ´Â ¸÷..
      end else begin
         //ÀÏ¹Ý ¸÷
         if target.RaceServer = RC_USERHUMAN then
            Result := TRUE;
         if (RaceServer > RC_PEACENPC) and (RaceServer < RC_ANIMAL) then begin //°ø°Ý·ÂÀ» °¡Áø NPC´Â ¾Æ¹«³ª °ø°ÝÇÑ´Ù.
            Result := TRUE;
         end;
         if target.Master <> nil then
            Result := TRUE;
      end;
      if BoCrazyMode then  //¹ÌÄ§, ¾Æ¹«³ª °ø°Ý, Àû ¾È°¡¸²... (¼ÒÈ¯¸÷¿¡°Ôµµ ÅëÇÑ´Ù.)
         Result := TRUE;
      if BoGoodCrazyMode then begin
         //°ö°Ô¹ÌÄ£»óÅÂ, »ç¶÷°ú ¼ÒÈ¯¸÷Àº °ø°Ý ¾ÈÇÏ°í ´Ù¸¥ ¸ó½ºÅÍ¸¸ °ø°ÝÇÑ´Ù.
         if (target.RaceServer = RC_USERHUMAN) or (target.Master <> nil) then begin
            Result := FALSE;
         end else begin
            Result := TRUE;
         end;
      end;
   end else begin //npcÈ¤Àº »ç¶÷ÀÎ°æ¿ì
      if RaceServer = RC_USERHUMAN then begin
         //°ø°ÝÇüÅÂ ¼³Á¤¿¡ µû¶ó ´Ù¸§
         case HumAttackMode of
            HAM_ALL: begin
                  if not ((target.RaceServer >= RC_NPC) and (target.RaceServer <= RC_PEACENPC)) then
                     Result := TRUE;
                  if BoNonPKServer then
                     Result := GetNonPKServerRule (Result);
               end;
            HAM_PEACE: begin
                  if (target.Master<>NIL) and (target.Master.RaceServer=RC_USERHUMAN) then
                     Result := False
                     else if target.RaceServer >= RC_ANIMAL then
                     Result := TRUE;
               end;
            HAM_GROUP: begin
                  if (target.Master<>NIL) and (target.Master.RaceServer=RC_USERHUMAN) then
                     begin
                        ATemTarget:=target.Master;
                        if IsGroupMember (ATemTarget) then
                            Result := FALSE
                            else
                            Result := TRUE;
                     end
                     else
                     begin
                        if not ((target.RaceServer >= RC_NPC) and (target.RaceServer <= RC_PEACENPC)) then
                           Result := TRUE;
                        if target.RaceServer = RC_USERHUMAN then
                           if IsGroupMember (target) then
                              Result := FALSE;
                     end;
                    if BoNonPKServer then
                       Result := GetNonPKServerRule (Result);
               end;
            HAM_GUILD: begin
                  if (target.Master<>NIL) and (target.Master.RaceServer=RC_USERHUMAN) then
                     begin
                        ATemTarget:=target.Master;
                           if MyGuild <> nil then begin
                              if TGuild(MyGuild).IsMember(ATemTarget.UserName) then
                                 Result := FALSE;
                              if BoGuildWarArea and (ATemTarget.MyGuild <> nil) then begin  //¹®ÆÄÀü,°ø¼ºÀü Áö¿ª¿¡ ÀÖÀ½
                                 if TGuild(MyGuild).IsAllyGuild(TGuild(ATemTarget.MyGuild)) then
                                    Result := FALSE;
                              end;
                           end;
                     end
                     else
                     begin
                        if not ((target.RaceServer >= RC_NPC) and (target.RaceServer <= RC_PEACENPC)) then
                           Result := TRUE;
                        if target.RaceServer = RC_USERHUMAN then
                           if MyGuild <> nil then begin
                              if TGuild(MyGuild).IsMember(target.UserName) then
                                 Result := FALSE;
                              if BoGuildWarArea and (target.MyGuild <> nil) then begin  //¹®ÆÄÀü,°ø¼ºÀü Áö¿ª¿¡ ÀÖÀ½
                                 if TGuild(MyGuild).IsAllyGuild(TGuild(target.MyGuild)) then
                                    Result := FALSE;
                              end;
                           end;
                     end;
                  if BoNonPKServer then
                     Result := GetNonPKServerRule (Result);
               end;
            HAM_PKATTACK: begin
                  if (target.Master<>NIL) and (target.Master.RaceServer=RC_USERHUMAN) then
                     begin
                        ATemTarget:=target.Master;
                           if self.PKLevel >= 2 then begin  //°ø°ÝÇÏ´Â ÀÚ°¡ »¡°»ÀÌ
                              if ATemTarget.PKLevel < 2 then Result := TRUE
                              else Result := FALSE;
                           end else begin
                              //°ø°ÝÇÏ´Â ÀÚ°¡ ÈòµÕÀÌ
                              if ATemTarget.PKLevel >= 2 then Result := TRUE
                              else Result := FALSE;
                           end;
                     end
                     else
                     begin
                        if not ((target.RaceServer >= RC_NPC) and (target.RaceServer <= RC_PEACENPC)) then
                           Result := TRUE;
                        if target.RaceServer = RC_USERHUMAN then begin
                           if self.PKLevel >= 2 then begin  //°ø°ÝÇÏ´Â ÀÚ°¡ »¡°»ÀÌ
                              if target.PKLevel < 2 then Result := TRUE
                              else Result := FALSE;
                           end else begin
                              //°ø°ÝÇÏ´Â ÀÚ°¡ ÈòµÕÀÌ
                              if target.PKLevel >= 2 then Result := TRUE
                              else Result := FALSE;
                           end;
                        end;
                     end;
                  if BoNonPKServer then
                     Result := GetNonPKServerRule (Result);
               end;
         end;
      end else
         Result := TRUE;
   end;

   // Ãß°¡ 2004-1-7 ¼û¾îÀÖ´Â ³ÑµéÀº °ø°ÝÇÒ ¼ö ¾ø´Ù. target.HideMode Ãß°¡
   if target.BoSysopMode or target.BoStoneMode or target.HideMode then  //¿î¿µÀÚ, µ¹·ÎµÈ »óÅÂ
      Result := FALSE;
end;


function  TCreature.IsProperTarget (target: TCreature): Boolean;
begin
   Result := FALSE;
   if target = nil then exit;

   Result := _IsProperTarget (target);
   if Result then
      if (RaceServer = RC_USERHUMAN) and (target.RaceServer = RC_USERHUMAN) then begin
         Result := CheckAttackRule2 (target);  //Áö¿ª µû¶ó¼­ PK ¿©ºÎ
         if target.BoTaiwanEventUser then   //ÀÌº¥Æ® ¾ÆÀÌÅÛÀ» °¡Áö°í ÀÖ´Â À¯Àú´Â °ø°ÝÀÌ µÊ
            Result := TRUE;
      end;

   if (target <> nil) and (RaceServer = RC_USERHUMAN) then begin  //³ª´Â »ç¶÷
      if (target.Master <> nil) and (target.RaceServer <> RC_USERHUMAN) then begin  //ÁÖÀÎÀÌ ÀÖ´Â ¸ó½ºÅÍ
         //´ë»óÀÌ ¸ó½ºÅÍ
         if target.Master = self then begin  //³» ºÎÇÏ
            if HumAttackMode <> HAM_ALL then  //¸ðµÎ °ø°Ý ÀÏ¶§¸¸ ºÎÇÏ°¡ °ø°ÝµÊ
               Result := FALSE;
         end else begin
            //´Ù¸¥ ÀÌÀÇ ºÎÇÏ
            Result := _IsProperTarget(target.Master);
            if (InSafeZone) or (target.InSafeZone) then begin
               Result := FALSE;
            end;
         end;
      end;
   end;
end;


function  TCreature.IsProperFriend (target: TCreature): Boolean;
   function IsFriend (cret: TCreature): Boolean;
   begin
      Result := FALSE;
      if cret.RaceServer = RC_USERHUMAN then begin  //´ë»óÀÌ »ç¶÷ÀÎ °æ¿ì¸¸
         //°ø°ÝÇüÅÂ ¼³Á¤¿¡ µû¶ó ´Ù¸§
         case HumAttackMode of
            HAM_ALL:  Result := TRUE;
            HAM_PEACE: Result := TRUE;
            HAM_GROUP:
               begin
                  if cret = self then
                     Result := TRUE;
                  if IsGroupMember (cret) then
                     Result := TRUE;
               end;
            HAM_GUILD:
               begin
                  if cret = self then
                     Result := TRUE;
                  if MyGuild <> nil then begin
                     if TGuild(MyGuild).IsMember(cret.UserName) then
                        Result := TRUE;
                     if BoGuildWarArea and (cret.MyGuild <> nil) then begin  //¹®ÆÄÀü,°ø¼ºÀü Áö¿ª¿¡ ÀÖÀ½
                        if TGuild(MyGuild).IsAllyGuild(TGuild(cret.MyGuild)) then
                           Result := TRUE;
                     end;
                  end;
               end;
            HAM_PKATTACK:
               begin
                  if cret = self then Result := TRUE;
                  if PKLevel >= 2 then begin //³»°¡ »¡°»ÀÌ
                     if cret.PKLevel >= 2 then Result := TRUE;
                  end else begin  //³»°¡ ÈòµÕÀÌ
                     if cret.PKLevel < 2 then Result := TRUE;
                  end;
               end;
         end;
      end;
   end;
begin
   Result := FALSE;
   if target = nil then exit;
   if RaceServer >= RC_ANIMAL then begin  //ÀÚ½ÅÀÌ µ¿¹°
      if target.RaceServer >= RC_ANIMAL then
         Result := TRUE;
      if target.Master <> nil then  //¼ÒÈ¯¸÷Àº Èú,µîÀÌ ¾ÈµÈ´Ù.
         Result := FALSE;
   end else begin //npcÈ¤Àº »ç¶÷ÀÎ°æ¿ì
      if RaceServer = RC_USERHUMAN then begin
         //°ø°ÝÇüÅÂ ¼³Á¤¿¡ µû¶ó ´Ù¸§
         Result := IsFriend (target);
         if target.RaceServer >= RC_ANIMAL then begin
            if target.Master = self then  //ÀÚ±â ºÎÇÏÀÎ °æ¿ì.
               Result := TRUE
            else if target.Master <> nil then
               Result := IsFriend (target.Master);
         end;
      end else
         Result := TRUE;
   end;
end;

procedure TCreature.SelectTarget (target: TCreature);
begin
   TargetCret := target;
   TargetFocusTime := GetTickCount;
end;

procedure TCreature.LoseTarget;
begin
   TargetCret := nil;
end;

function TCreature.GetPurity: integer;
var
   hum: TUserHuman;
begin
   //À¯Àú°¡ ±¤¼®À» Ä¶ ¶§.
   if RaceServer = RC_USERHUMAN then begin
      //¹«±â ³»±¸°¡ 0ÀÌ¸é ±¤¼® ¼øµµ´Â ±Þ°ÝÈ÷ ¶³¾îÁø´Ù.
      if UseItems[U_WEAPON].Dura = 0 then begin
         Result := 1000 + Random(5000);
      end else begin
         Result := 3000 + Random(13000);
         if Random(20) = 0 then
            Result := Result + Random(10000);
      end;

      // Ã¼ÇèÆÇ À¯ÀúÀÏ °æ¿ì¿¡´Â ±¤¼® ¼øµµ¸¦ 10À¸·Î Á¦ÇÑÇÔ(sonmg 2005/03/04)
      hum := TUserHuman(self);
      if hum <> nil then begin
         if hum.ApprovalMode = 1 then begin
            Result := _MIN(10000, Result);
         end;
      end;
   end else begin
      //¸ó½ºÅÍ°¡ ±¤¼®À» ¶³±¼ ¶§.
      Result := 3000 + Random(11000);
      if Random(20) = 0 then
         Result := Result + Random(10000);
   end;

// ¹Ì³×¶ö ÀÌº¥Æ®
//        Result := 6000 + Random(12000);
//        if Random(10) = 0 then
//           Result := Result + Random(10000);
end;

function TCreature.IncFamePoint(point : integer; onlyFameCur : Boolean) : Boolean;
var
   hum : TUserHuman;
   FameGrade: integer;
begin
   Result := FALSE;

   //-----------------------------------------
   //¸í¼ºÄ¡°¡ ½×ÀÎ´Ù.(ÇöÀç°ª, ´©Àû°ª)
   //-----------------------------------------

   //À½¼ö´Â Ãë±Þ ¾ÈÇÔ.
   if point <= 0 then exit;
   //º¯µ¿Ä¡ ÇÑ°è
   if point > 10000 then point := 10000;

   //Overflow Check
   if Abil.FameCur > Abil.FameCur + point then exit;
   if Abil.FameBase > Abil.FameBase + point then exit;

   //ÇÑ°èÄ¡ Àû¿ë(ÃÖ´ë¸í¼ºÄ¡ 4Ãµ¸¸ Á¦ÇÑ)
   if Abil.FameCur + point > 40000000 then exit;
   if Abil.FameBase + point > 40000000 then exit;

   //-----------------------
   //Æ÷ÀÎÆ® °è»ê
   Abil.FameCur := Abil.FameCur + point;

   if Abil.FameCur > Abil.FameBase then begin
      //FameBase´Â ¾È¿À¸£°í FameCur°ª¸¸ ¿À¸£´Â ¿É¼Ç
      if onlyFameCur then
         Abil.FameCur := Abil.FameBase
      else
         Abil.FameBase := Abil.FameCur;
   end;
   //-----------------------

   if RaceServer = RC_USERHUMAN then begin
      hum := TUserHuman(self);
      if hum <> nil then
         SendMsg (self, RM_CHANGEFAMEPOINT, 0, Abil.FameCur, 0, 0, hum.GetFameName(FameGrade));
   end;

   Result := TRUE;
end;

function TCreature.DecFamePoint(point : integer) : Boolean;
var
   hum : TUserHuman;
   FameGrade: integer;
begin
   Result := FALSE;

   //-----------------------------------------
   //¸í¼ºÄ¡°¡ ±ðÀÎ´Ù.(ÇöÀç°ª, ´©Àû°ª)
   //-----------------------------------------

   //À½¼ö´Â Ãë±Þ ¾ÈÇÔ.
   if point <= 0 then exit;
   //º¯µ¿Ä¡ ÇÑ°è
   if point > 10000 then point := 10000;

   //-----------------------
   //Æ÷ÀÎÆ® °è»ê
   if Abil.FameBase <= point then Abil.FameBase := 0
   else Abil.FameBase := Abil.FameBase - point;

   if Abil.FameCur > Abil.FameBase then Abil.FameCur := Abil.FameBase;
   //-----------------------

   if RaceServer = RC_USERHUMAN then begin
      hum := TUserHuman(self);
      if hum <> nil then
         SendMsg (self, RM_CHANGEFAMEPOINT, 0, Abil.FameCur, 0, 0, hum.GetFameName(FameGrade));
   end;

   Result := TRUE;
end;

procedure TCreature.ZeroFamePoint;
begin
   //¸í¼ºÄ¡¸¦ ¸ðµÎ 0À¸·Î ¸¸µç´Ù.
   Abil.FameCur := 0;
   Abil.FameBase := 0;
end;

function TCreature.UseCurrentFamePoint(usepoint : integer) : Boolean;
var
   hum : TUserHuman;
   FameGrade: integer;
begin
   Result := FALSE;

   //-----------------------------------------
   //¸í¼ºÄ¡¸¦ »ç¿ëÇÑ´Ù.(ÇöÀç°ª)
   //-----------------------------------------

   //À½¼ö´Â Ãë±Þ ¾ÈÇÔ.
   if usepoint <= 0 then exit;

   if Abil.FameCur <= usepoint then Abil.FameCur := 0
   else Abil.FameCur := Abil.FameCur - usepoint;

   if RaceServer = RC_USERHUMAN then begin
      hum := TUserHuman(self);
      if hum <> nil then
         SendMsg (self, RM_CHANGEFAMEPOINT, 0, Abil.FameCur, 0, 0, hum.GetFameName(FameGrade));
   end;

   Result := TRUE;
end;

procedure TCreature.DecWeaponBadLuck;
var
   hum: TUserHuman;
begin
   if UseItems[U_WEAPON].Index <> 0 then begin
      if UseItems[U_WEAPON].Desc[4] - UseItems[U_WEAPON].Desc[3] > 0 then begin //ÀúÁÖ°¡ ºÙ¾îÀÖÀ» ¶§
         UseItems[U_WEAPON].Desc[4] := _MAX(0, UseItems[U_WEAPON].Desc[4] - 1);

         if RaceServer = RC_USERHUMAN then begin
            RecalcAbilitys;
            hum := TUserHuman(self);
            hum.SysMsg('ÎäÆ÷µÄ×çÖä¼õÉÙÁË£¡', 2);
            hum.SendUpdateItem (UseItems[U_WEAPON]);
            SendMsg (self, RM_ABILITY, 0, 0, 0, 0, '');
            SendMsg (self, RM_SUBABILITY, 0, 0, 0, 0, '');
         end;
      end;
   end;
end;

//¼±¹°»óÀÚ
//º¯°æ(2005 Ê¥µ®»î¶¯)
procedure TCreature.GetGiftFromBox;
var
   pi: PTUserItem;
   hum: TUserHuman;
   itemname: string;
begin
   if RaceServer <> RC_USERHUMAN then exit;
   hum := TUserHuman(self);
   if hum = nil then exit;

   if Itemlist.Count < MAXBAGITEM then begin
      //---------------------------
      case Random(250000) of
         1:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÓÂÃÍµÄÐÂ¹É', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         2:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('µÄÐÂ¹É', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         3:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÏÉ½çµÄÐÂ¹É', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         4:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('¼²·çµÄÐÂ¹É', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         5:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('»Ø±ÜµÄÐÂ¹É', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         6:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('¼¯ÖÐµÄÐÂ¹É', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         7:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÑÏº®µÄÐÂ¹É', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         8:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('°¢¼ºÀÇ½ÅÁÖ', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         9:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('¾õÐÑµÄÐÂ¹É', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         10:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÊØ»¤µÄÐÂ¹É', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         11:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÎÒµÄÐÂ¹É', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         12:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('Ç¿»¯ÐÂ¹É', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         13..22:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('¼²·çÖ®±¦Óñ', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         23..32:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('»Ø±ÜµÄ±¦Óñ', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         33..42:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('¼¯ÖÐµÄ±¦Óñ', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         43..52:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÑÏº®µÄ±¦Óñ', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         53..61:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('¾õÐÑµÄ±¦Óñ', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         62..70:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÄÍÐÄµÄ±¦Óñ', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         71..79:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÓÂÃÍµÄ±¦Óñ', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         80..89:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÎÒÊ¡µÄ±¦Óñ', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         90..99:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÏÉ¾³Ö®±¦Óñ', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         100..109:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÊØ»¤Ö®±¦Óñ', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         110..116:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÎÒµÄ±¦Óñ', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         117..122:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('Ç¿»¯µÄ±¦Óñ', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         123..632:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('×£¸£ÓÍ', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         633..3132:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('Õ½ÉñÓÍ', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         3133..5632:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ºÚÌú¿óÊ¯', pi^) then begin
                  //--------------------
                  // ±¤¼® ¼øµµ Á¶Àý.
                  pi.Dura := GetPurity;
                  //--------------------

                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         5633..10632:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('½ð¿ó', pi^) then begin
                  //--------------------
                  // ±¤¼® ¼øµµ Á¶Àý.
                  pi.Dura := GetPurity;
                  //--------------------

                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         10633..11882:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ºìÁ×£¨´ó£©', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         11883..13132:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÇåÔÉÊ¯£¨´ó£©', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         13133..14382:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('µØÐÄ£¨´ó£©', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         14383..15632:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÇåÀ¶£¨´ó)', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         15633..16882:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('É¤×Ó£¨´ó£©', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         16883..18132:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('µí·Û£¨´ó£©', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
      	18133..19382:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ºìÁ×£¨ÖÐ£©', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         19383..20632:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÇåÔÉÊ¯£¨ÖÐ£©', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         20633..21882:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('µØÐÄ£¨ÖÐ£©', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         21883..23132:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÇåÀ¶£¨ÖÐ£©', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         23133..24382:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('É¤×Ó£¨ÖÐ£©', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         24383..25632:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('µí·Û£¨ÖÐ£©', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
      	25633..28132:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ºìÁ×£¨Å££©', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         28133..30632:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÇåÔÉÊ¯£¨Å££©', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         30633..33132:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('µØÐÄ£¨Å££©', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         33133..35632:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÇåÀ¶£¨Å££©', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         35633..38132:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('É¤×Ó£¨Å££©', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         38133..40632:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('µí·Û£¨Å££©', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         40633..40643:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('Ê¹³¼×°äêºÐ', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         40644..40653:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÇàÍ­ÊÖÌ×', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         40654..40663:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÖäÊõµÄÊÖïí', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         40664..40673:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÓÂÊ¿µÄÊÖïí', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
          40674..40683:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÂÖ', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
          40684..40693:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÎÒµÄÂíÂÖ', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
          40694..40703:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÁúÖ÷»·', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
          40704..40713:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÏóÐÎÍè', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         40714..40723:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÇÝÁúÍè', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         40724..40733:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÅÉÏ·¾çµÄ½äÖ¸', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         40734..40743:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÄÔÁ¦Íè', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         40744..40753:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('Ì«¼«Íè', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         40754..40763:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ºÅµÄÏîÁ´', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         40764..40773:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('À×ÈË', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         40774..40783:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('²¼¾©É©×Ó', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         40784..40793:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('Â¹ÎÝ', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         40794..40803:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÂíµÄÁåîõ', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         40804..40813:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ËÄ·¿µÄÏîÁ´', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         40814..55813:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('Èí·çÊý', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
        55814..70813:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÏÉ½çÊý', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
      	70814..85813:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÐÇËÞ', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
      	85814..100813:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÎäÊý', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
      	100814..130813:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÌåÁ¦»Ö¸´Ò©£¨ÌØ£©', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
      	130814..160813:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('Ä§Á¦»Ö¸´Ò©£¨ÌØ£©', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
      	160814..188313:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÌåÁ¦Ô¼Êø', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
      	188314..215813:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÂíÁ¦Ô¼Êø', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
      	215814..235841:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('µç»°ÖÐ', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         else //³ª¸ÓÁö
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÖÐÈý', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
      end;
      //---------------------------

      //È¹µæ ¾ÆÀÌÅÛ ·Î±×·Î ³²±è(sonmg 2005/12/20)
      if pi <> nil then begin
         itemname := UserEngine.GetStdItemName(pi.Index);
         if itemname <> '' then begin
            //·Î±× ³²±è
            AddUserLog ('4'#9 + //ÁÝ±â_
                        MapName + ''#9 +
                        IntToStr(CX) + ''#9 +
                        IntToStr(CY) + ''#9 +
                        UserName + ''#9 +
                        itemname + ''#9 +
                        IntToStr(pi.MakeIndex) + ''#9 +
                        '2'#9 + //¾ÆÀÌÅÛ(¼±¹°»óÀÚ)¿¡¼­ ¾ò±â
                        '0');
         end;
      end;
   end;
end;

//ºÎÈ°Àý ´Þ°¿
procedure TCreature.GetGiftFromEgg;
var
   pi: PTUserItem;
   hum: TUserHuman;
begin
   if RaceServer <> RC_USERHUMAN then exit;
   hum := TUserHuman(self);
   if hum = nil then exit;

   if Itemlist.Count < MAXBAGITEM then begin
      case Random(300000) of
         1:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÓÂÃÍµÄÐÂ¹É', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         2:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('µÄÐÂ¹É', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         3:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÏÉ½çµÄÐÂ¹É', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         4..7:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('¼²·çÖ®±¦Óñ', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         8..12:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('»Ø±ÜµÄ±¦Óñ', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         13..17:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('¼¯ÖÐµÄ±¦Óñ', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         18..22:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÖÐ¶¾µÄ±¦Óñ', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         23..27:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÑÏº®µÄ±¦Óñ', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         28..32:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('¾õÐÑµÄ±¦Óñ', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         33..37:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÄÍÐÄµÄ±¦Óñ', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         38..46:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÓÂÃÍµÄ±¦Óñ', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         47..56:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÎÒµÄ±¦Óñ', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         57..66:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÏÉ¾³Ö®±¦Óñ', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         67..76:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÊØ»¤Ö®±¦Óñ', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         77..86:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÎÒµÄ±¦Óñ', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         87..96:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('Ç¿»¯µÄ±¦Óñ', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         97..6095:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('×£¸£ÓÍ', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         6096..10594:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('Öá°×½ð', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         10595..15094:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('½ð¿ó', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         15095..18094:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ºìÁ×£¨´ó£©', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         18095..21094:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÇåÔÉÊ¯£¨´ó£©', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         21095..24094:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('µØÐÄ£¨´ó£©', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         24095..27094:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÇåÀ¶£¨´ó£©', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         27095..30094:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('É¤×Ó£¨´ó£©', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         30095..33094:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('µí·Û£¨´ó£©', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         33095..37593:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('Ê¹³¼×°äêºÐ', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         37594..41313:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÇàÍ­ÊÖÌ×', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         41314..45093:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÖäÊõµÄÊÖïí', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         45094..48843:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÌúÉ°ÊÖïí', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         48844..52593:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÐÞÑøµÄ½äÖ¸', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         52594..56343:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('Ä§·¨µÄ½äÖ¸', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         56344..60093:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('Éºº÷Ê¯°å', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         60094..63843:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÍËÁË½äÖ¸', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         63844..67593:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('±ÌÊ¯ÏîÁ´', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         67594..71343:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('»¨¹£', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         71344..75093:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ËÀµÄ', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         75094..88593:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÌåÁ¦Ô¼Êø£¨ÌØ£©', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         88594..102093:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÂíÁ¦Ô¼Êø£¨ÌØ£©', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         102094..120093:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('Éþ×Ó', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         120094..142593:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÌåÁ¦Ô¼Êø', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         142594..165093:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÂíÁ¦Ô¼Êø', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         165094..171843:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÎäÉñÓÍ', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         171844..181968:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÌåÁ¦»Ö¸´Ò©£¨ÌØ£©', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         181969..192093:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('Ä§Á¦»Ö¸´Ò©£¨ÌØ£©', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         192094..205593:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('Ä§Á¦»Ö¸´Ò©£¨ÌØ£©', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         205594..219093:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('Ä§Á¦»Ö¸´Ò©£¨ÌØ£©', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         219094..246093:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÐûºÍ£¨ÖÐ£©', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         246094..249093:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÐûºÍ£¨ÖÐ£©', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         else //³ª¸ÓÁö
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('ÐûºÍ£¨ÖÐ£©', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
      end;
   end;
end;

//³°Àº±ËÂ¦(2006³â 3.1Àý ÀÌº¥Æ®)
procedure TCreature.GetGiftFromOldBox;
var
   pi: PTUserItem;
   hum: TUserHuman;
   itemname: string;
begin
   if RaceServer <> RC_USERHUMAN then exit;
   hum := TUserHuman(self);
   if hum = nil then exit;

   if Itemlist.Count < MAXBAGITEM then begin
      //---------------------------
      case Random(250000) of
         1..11:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('º«°æÎïÆ·', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         12..22:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('º«°æÎïÆ·', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         23..33:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('º«°æÎïÆ·', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         34..44:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('º«°æÎïÆ·', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         45..55:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('º«°æÎïÆ·', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         56..66:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('º«°æÎïÆ·', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         67..77:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('º«°æÎïÆ·', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         78..88:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('º«°æÎïÆ·', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         89..99:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('º«°æÎïÆ·', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         100..110:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('º«°æÎïÆ·', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         111..121:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('º«°æÎïÆ·', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         122..132:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('º«°æÎïÆ·', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         133..633:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('º«°æÎïÆ·', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         634..2634:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('º«°æÎïÆ·', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         2635..3835:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('º«°æÎïÆ·', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         3836..5036:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('º«°æÎïÆ·', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         5037..6237:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('º«°æÎïÆ·', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         6238..7438:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('º«°æÎïÆ·', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         7439..8639:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('º«°æÎïÆ·', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         8640..9840:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('º«°æÎïÆ·', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         9841..11041:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('º«°æÎïÆ·', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         11042..12242:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('º«°æÎïÆ·', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         12243..13443:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('º«°æÎïÆ·', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         13444..15944:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('º«°æÎïÆ·', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         15945..18445:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('º«°æÎïÆ·', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         18446..20946:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('º«°æÎïÆ·', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         20947..23447:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('º«°æÎïÆ·', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         23448..25948:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('º«°æÎïÆ·', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         25949..28449:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('º«°æÎïÆ·', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         28450..33450:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('º«°æÎïÆ·', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         33451..38451:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('º«°æÎïÆ·', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         38452..43452:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('º«°æÎïÆ·', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         43453..61453:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('º«°æÎïÆ·', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         61454..79454:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('º«°æÎïÆ·', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
      	79455..104455:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('º«°æÎïÆ·', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         104456..129456:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('º«°æÎïÆ·', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         129457..159457:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('º«°æÎïÆ·', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         159458..189458:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('º«°æÎïÆ·', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
         189459..224459:
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('º«°æÎïÆ·', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;

         else //³ª¸ÓÁö
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName ('º«°æÎïÆ·', pi^) then begin
                  ItemList.Add (pi);
                  WeightChanged;
                  hum.SendAddItem (pi^);
               end else
                  Dispose (pi);
            end;
      end;
      //---------------------------

      //È¹µæ ¾ÆÀÌÅÛ ·Î±×·Î ³²±è(sonmg 2005/12/20)
      if pi <> nil then begin
         itemname := UserEngine.GetStdItemName(pi.Index);
         if itemname <> '' then begin
            //·Î±× ³²±è
            AddUserLog ('4'#9 + //ÁÝ±â_
                        MapName + ''#9 +
                        IntToStr(CX) + ''#9 +
                        IntToStr(CY) + ''#9 +
                        UserName + ''#9 +
                        itemname + ''#9 +
                        IntToStr(pi.MakeIndex) + ''#9 +
                        '2'#9 + //¾ÆÀÌÅÛ¿¡¼­ ¾ò±â
                        '³°Àº±ËÂ¦');
         end;
      end;
   end;
end;

//¼ø°£ ´É·ÂÄ¡ »ó½Â
//ÆÄ¶ó¹ÌÅÍ : Á¾·ù, ´É·ÂÄ¡, ºÐ, ÃÊ
procedure TCreature.EnhanceExtraAbility( kind, amount: integer; min, sec: DWORD );
var
   currenttime : LongWord;
   headstr, minutestr, secondstr : string;
begin
   if kind < 0 then exit;
   if kind >= sizeof(ExtraAbil) then exit;

   currenttime := GetTickCount;
//   ExtraAbil[kind] := _MIN( 255, _MAX(ExtraAbil[kind], amount) );
   ExtraAbil[kind] := _MIN( 255, amount );   //¼öÁ¤(sonmg 2006/02/14)
   ExtraAbilFlag[kind] := 0;
   ExtraAbilTimes[kind] := _MAX(ExtraAbilTimes[kind], currenttime + min * 60 * 1000{ºÐ´ÜÀ§} + sec * 1000); //ÃÊ´ÜÀ§
   //»ç¶÷¿¡°Ô´Â ¸Þ½ÃÁö Ãâ·Â
   if RaceServer = RC_USERHUMAN then begin
      case kind of
         EABIL_DCUP:
            begin
               {$IFDEF KOREA} headstr := '¹¥»÷Á¦Ë²¼äÌá¸ß ';
               {$ELSE}        headstr := '¹¥»÷Á¦Ë²¼äÌá¸ß ';
               {$ENDIF}
            end;
         EABIL_MCUP:
            begin
               {$IFDEF KOREA} headstr := 'Ä§·¨Á¦Ë²¼äÌá¸ß ';
               {$ELSE}        headstr := 'Ä§·¨Á¦Ë²¼äÌá¸ß ';
               {$ENDIF}
            end;
         EABIL_SCUP:
            begin
               {$IFDEF KOREA} headstr := '¾«ÉñÁ¦Ë²¼äÌá¸ß ';
               {$ELSE}        headstr := '¾«ÉñÁ¦Ë²¼äÌá¸ß ';
               {$ENDIF}
            end;
         EABIL_HITSPEEDUP:
            begin
               {$IFDEF KOREA} headstr := '¹¥»÷ËÙ¶ÈË²¼äÌá¸ß ';
               {$ELSE}        headstr := '¹¥»÷ËÙ¶ÈË²¼äÌá¸ß ';
               {$ENDIF}
            end;
         EABIL_HPUP:
            begin
               {$IFDEF KOREA} headstr := 'ÌåÁ¦ÖµË²¼äÌá¸ß ';
               {$ELSE}        headstr := 'ÌåÁ¦ÖµË²¼äÌá¸ß ';
               {$ENDIF}
            end;
         EABIL_MPUP:
            begin
               {$IFDEF KOREA} headstr := 'Ä§·¨ÖµË²¼äÌá¸ß ';
               {$ELSE}        headstr := 'Ä§·¨ÖµË²¼äÌá¸ß ';
               {$ENDIF}
            end;
         else
            begin
               //¸ð¸£´Â Á¾·ùÀÇ ´É·ÂÄ¡
               {$IFDEF KOREA} headstr := 'ÔÝÊ±Ò»Ð©ÄÜÁ¦Ôö¼ÓÆÚ¼ä';
               {$ELSE}        headstr := 'Temporarily some ability increased during ';
               {$ENDIF}
            end;
      end;

      {$IFDEF KOREA}
      minutestr := '·Ö';
      secondstr := 'Ãë';
      {$ELSE}
      minutestr := 'min. ';
      secondstr := 'sec.';
      {$ENDIF}
      SysMsg (headstr + IntToStr((ExtraAbilTimes[kind] - currenttime) div 1000 div 60) + minutestr + IntToStr((ExtraAbilTimes[kind] - currenttime) div 1000 mod 60) + secondstr, 1);
   end;
end;

procedure TCreature.SendUnBind;
var
  I: Integer;
  UnbindInfo: TUnbindInfo;
  sMsg: string;
  msg: TDefaultMessage;
  hum : TUserHuman;
begin
  hum := TUserHuman(self);
  if hum = nil then exit;
  sMsg := '';
  if UnbindItemList.Count > 0 then begin
    for I := 0 to UnbindItemList.Count - 1 do begin
      UnbindInfo.sItemName := UnbindItemList.Strings[I];
      UnbindInfo.nUnbindCode := Integer(UnbindItemList.Objects[I]);
      sMsg := sMsg + EncodeBuffer(@UnbindInfo, SizeOf(TUnbindInfo)) + '/';
    end;
  end;
  if sMsg <> '' then begin
    msg := MakeDefaultMsg(SM_SERVERUNBIND, 0, 0, 0, 0, 0);
    hum.SendSocket(@msg, sMsg);
  end;
end;

procedure TCreature.SendCreditPoint;
var
  I: Integer;
  UnbindInfo: TUnbindInfo;
  sMsg: string;
  msg: TDefaultMessage;
  hum : TUserHuman;
begin
  m_btCreditPoint := g_DBSQL.GetCreditPoint(UserName);
  hum := TUserHuman(self);
  if hum = nil then exit;

  msg := MakeDefaultMsg(SM_CREDITPOINT, m_btCreditPoint, 0, 0, 0, 0);
  hum.SendSocket(@msg, sMsg);
end;


{%%%%%%%%%%%%%%%%%%%%%% *TAnimal* %%%%%%%%%%%%%%%%%%%}


constructor TAnimal.Create;
begin
   inherited Create;
   TargetX := -1; //°¡¾ßÇÒ °÷ÀÌ ¾øÀ½
   FindPathRate := 1000 + Random(4) * 500;
   FindpathTime := GetTickCount;
   RaceServer := RC_ANIMAL;
   HitTime := GetCurrentTime - Random(3000);
   WalkTime := GetCurrentTime - Random(3000);
   SearchEnemyTime := GetTickCount;
   BoRunAwayMode := FALSE;
   RunAwayStart := GetTickCount;
   RunAwayTime := 0;

end;

procedure TAnimal.RunMsg (msg: TMessageInfo);
var
   str: string;
begin
   case msg.Ident of
      RM_STRUCK:
         begin
            if (msg.Sender = self) and (msg.lParam3 <> 0) then begin
               SetLastHiter (TCreature(msg.lparam3));
               Struck (TCreature(msg.lParam3));
               BreakHolySeize;
               if (Master <> nil) and (TCreature(msg.lparam3) <> Master) then begin //ÁÖÀÎÀÌ ÀÖ´Â ¸÷
                  if TCreature(msg.lparam3).RaceServer = RC_USERHUMAN then begin //ÁÖÀÎ¿¡°Ô Á¤´ç¹æÀ§
                     //Á¤´ç¹æ¾î¸¦ À§ÇÑ ±â·Ï..
//º¸·ù                     if TCreature(msg.lparam3).IsProperTarget(self) then  //sonmg(2004/10/04)
                        Master.AddPkHiter (TCreature(msg.lparam3));
                  end;
               end;
               MonsterSayMsg(TCreature(msg.lparam3), s_UnderFire);
            end;
         end;
      else
         inherited RunMsg (msg);
   end;
end;

procedure TAnimal.Run;
begin
   inherited Run;
end;

procedure TAnimal.Attack (target: TCreature; dir: byte);
begin
   { inherited }
  if RaceServer = RC_USERHUMAN then begin
    if TUserHuman(Self).m_StallMgr.OnSale then begin

      Exit;
    end;
  end;
//   if RaceServer >= RC_ANIMAL then begin
//     if Master <> nil then begin
//        if (target <> nil) and (target.InSafeZone) then begin
//         if (Master.LastHiter <> nil) or (Master.ExpHiter <> nil) or
//           (Master.TargetCret <> nil) or (TargetCret <> nil) then begin
//            Master.TargetCret := nil;
//            TargetCret := nil;
//            target := nil;
//            exit;
//         end;
//       end;
//     end;
//   end;
   HitHit (target, HM_HIT, dir);
end;


procedure TAnimal.Struck (hiter: TCreature);
var
   targdir: byte;
begin
   StruckTime := GetTickCount;
   if hiter <> nil then begin
      if (TargetCret = nil) or (not TargetInAttackRange (TargetCret, targdir)) or (Random(6) = 0) then
         if IsProperTarget (hiter) then
            SelectTarget (hiter);
   end;
   if BoAnimal then begin
      MeatQuality := MeatQuality - Random (300);  //µ¿¹°ÀÌ ¸ÂÀ¸¸é ¸ÂÀ» ¼ö·Ï °í±â Ç°ÁúÀÌ ¶³¾îÁü
      if MeatQuality < 0 then MeatQuality := 0;
   end;
   if Abil.Level < g_MONLEVELTIAOJIE then    //50   //  if Abil.Level < MAXKINGLEVEL-1 then
      HitTime  := HitTime + (150 - _MIN(130, Abil.Level * 4)); //ÇÑ¹æ¿¡ ms¾¿ ´Ê°Ô ¶§¸°´Ù.
   //WalkTime := WalkTime + (300 - _MIN(200, (Abil.Level div 5) * 20));
end;

procedure TAnimal.LoseTarget;
begin
   inherited LoseTarget;
   TargetX := -1;
   TargetY := -1;
end;

function TAnimal.GetNearMonster : TCreature;   //°¡Àå °¡±î¿î »ý¹°Ã¼ ¾ò¾î¿À±â...
var
   i, d, dis: integer;
   cret, nearcret: TCreature;
begin
   Result := nil;
   nearcret := nil;
   dis := 999;
   for i:=0 to VisibleActors.Count-1 do begin
      cret := TCreature (PTVisibleActor(VisibleActors[i]).cret);
      if (not cret.Death) and (IsProperTarget(cret)) and (not cret.BoHumHideMode or BoViewFixedHide) then begin
         d := abs(CX-cret.CX) + abs(CY-cret.CY);
         if d < dis then begin
            dis := d;
            nearcret := cret;
         end;
      end;
   end;

   Result := nearcret;
end;

procedure TAnimal.MonsterNormalAttack;   //¿©±â¼­´Â select¸¸ ÇÑ´Ù....
var
   i, d, dis: integer;
   cret, nearcret: TCreature;
begin
   nearcret := nil;
   dis := 999;
   for i:=0 to VisibleActors.Count-1 do begin
      cret := TCreature (PTVisibleActor(VisibleActors[i]).cret);
      if (not cret.Death) and (IsProperTarget(cret)) and (not cret.BoHumHideMode or BoViewFixedHide) then begin
         d := abs(CX-cret.CX) + abs(CY-cret.CY);
         if d < dis then begin
            dis := d;
            nearcret := cret;
         end;
      end;
   end;
   if nearcret <> nil then
      SelectTarget (nearcret);
end;

procedure TAnimal.MonsterDetecterAttack;
var
   i, d, dis: integer;
   cret, nearcret: TCreature;
begin
   nearcret := nil;
   dis := 999;
   for i:=0 to VisibleActors.Count-1 do begin
      cret := TCreature (PTVisibleActor(VisibleActors[i]).cret);
      if (not cret.Death) and (IsProperTarget(cret)) then begin
         d := abs(CX-cret.CX) + abs(CY-cret.CY);
         if d < dis then begin
            dis := d;
            nearcret := cret;
         end;
      end;
   end;
   if nearcret <> nil then
      SelectTarget (nearcret);
end;

procedure TAnimal.SetTargetXY (x, y: integer);
begin
   TargetX := x;
   TargetY := y;
end;

procedure TAnimal.GotoTargetXY;
var
   wantdir, i, targx, targy, oldx, oldy, rand: integer;
begin
   if BoDontMove then exit;

   //°É¾î°¥ ¸ñÇ¥°¡ ÀÖ´Â °æ¿ì
   //if GetCurrentTime - FindPathTime > FindPathRate then begin
   if (CX <> TargetX) or (CY <> TargetY) then begin
      targx := TargetX;
      targy := TargetY;
      //±æ Ã£À» ½Ã°£
      FindPathTime := GetCurrentTime;
      wantdir := DR_DOWN;
      while TRUE do begin
         if targx > self.CX then begin
            wantdir := DR_RIGHT;
            if targy > self.CY then
               wantdir := DR_DOWNRIGHT;
            if targy < self.CY then
               wantdir := DR_UPRIGHT;
            break;
         end;
         if targx < self.CX then begin
            wantdir := DR_LEFT;
            if targy > self.CY then
               wantdir := DR_DOWNLEFT;
            if targy < self.CY then
               wantdir := DR_UPLEFT;
            break;
         end;
         if targy > self.CY then begin
            wantdir := DR_DOWN;
            break;
         end;
         if targy < self.CY then begin
            wantdir := DR_UP;
            break;
         end;
         break;
      end;

      oldx := self.CX;
      oldy := self.CY;
      WalkTo (wantdir, FALSE);
      rand := Random (3);
      for i:=1 to 7 do begin
         if (oldx = self.CX) and (oldy = self.CY) then begin
            {¾ÕÀÌ ¸·Çô ÀÖÀ½}
            if rand <> 0 then Inc (wantdir)
            else if wantdir > 0 then Dec (wantdir)
            else wantdir := 7;
            if wantdir > 7 then wantdir := 0;
            WalkTo (wantdir, FALSE);
         end else
            break;
      end;
   end;
end;

procedure TAnimal.Wondering;
begin
   if BoDontMove then exit;

   if Random(20) = 0 then begin
      if Random(4) = 1 then Turn (Random(8))  {8 direction}
      else begin
         {inherited}
         WalkTo (self.Dir, FALSE);
      end;
   end;


end;


{%%%%%%%%%%%%%%%%%%%%%% *TUserHuman* %%%%%%%%%%%%%%%%%%%}


constructor TUserHuman.Create;
begin
   inherited Create;
   RaceServer := RC_USERHUMAN;
   EmergencyClose := FALSE;
   BoChangeServer := FALSE;
   SoftClosed := FALSE;
   UserRequestClose := FALSE;
   UserSocketClosed := FALSE;
   ReadyRun := FALSE; //·Îµù,ÃÊ±âÈ­,.. ¿Ï·áµÇ¸é ReadyRunÀº TRUE°¡ µÈ´Ù.
   PriviousCheckCode := 0;
   CrackWanrningLevel := 0; //ÆÐÅ¶ duplication°°Àº Àå³­À» Ä¡´ÂÁö ¿©ºÎ..
   // 2003-08-08 :PDS
   // »ç¶÷ÀÌ ¸ô¸±¶§ ´ëºñ ÀúÀå½Ã°£À» 5ºÐ°£°ÝÀ¸·Î ·£´ý Á¶Á¤ÇÑ´Ù.
   // Ã³À½Á¢¼ÓÇÑ »ç¶÷Àº 15ºÐ±îÁö ÀúÀåÅ¸ÀÓÀÌ ´Ã¾î³¯¼ö ÀÖ´Ù. ±×ÈÄ¿¡´Â 10ºÐ¿¡ ÇÑ¹ø¾¿ ÀúÀå
   LastSaveTime := GetTickCount + LongWord( Random( 5 * 60 * 1000 ) );
   WantRefMsg := TRUE;
   BoSaveOk := FALSE;
   MustRandomMove := FALSE;
   CurQuest := nil;
   CurSayProc := nil;

   BoTimeRecall := FALSE;
   BoTimeRecallGroup := FALSE;
   TimeRecallMap := '';
   TimeRecallX := 0;
   TimeRecallY := 0;

   FillChar(m_nSval, SizeOf(m_nSval), #0);

   RunTime := GetCurrentTime;
   RunNextTick := 250;
   SearchRate := 200;
   SearchTime := GetTickCount;
   ViewRange := 12;//ÕâÀï  ÕâÁ½¸ö12ÒªÏàÍ¬    ÕâÀï¶àÉÙ¸Õ²ÅÄÇÀï¾Í¶àÉÙ  ¾ßÌå ÄãÒÔºó×Ô¼º¸ù¾ÝÒªÇó¸Ä
   FirstTimeConnection := FALSE;
   LoginSign := FALSE;
   BoServerShifted := FALSE;
   BoAccountExpired := FALSE;

   BoSendNotice := FALSE;
   operatetime := GetTickCount;
   operatetime_sec := GetTickCount;
   operatetime_500m := GetTickCount;
   boGuildwarsafezone := FALSE;

   ClientMsgCount := 0;
   ClientSpeedHackDetect := 0;
   LatestSpellTime := GetTickCount;
   LatestSpellDelay := 0;
   LatestHitTime := GetTickCount;
   LatestWalkTime := GetTickCount;
   LatestDropTime := GetTickCount;
   HitTimeOverCount := 0;
   HitTimeOverSum := 0;
   SpellTimeOverCount := 0;
   WalkTimeOverCount := 0;
   WalkTimeOverSum := 0;
   SpeedHackTimerOverCount := 0;

   SendBuffers := TList.Create;
   // 2003/06/12 ½½·¹ÀÌºê ÆÐÄ¡
   PrevServerSlaves := TList.Create; //¼­¹ö ÀÌµ¿ÇÏ¸é¼­ ¿Å°Ü´Ù´Ï´Â ºÎÇÏ

   LatestSayStr := '';
   BombSayCount := 0;
   BombSayTime := GetTickCount;
   BoShutUpMouse := FALSE;
   ShutUpMouseTime := GetTickCount;

   LoginDateTime := Now;
   LoginTime := GetTickCount;
   ServerShiftTime := GetTickCount;

   FirstClientTime := 0;
   FirstServerTime := 0;

   BoChangeServer := FALSE;
   BoChangeServerNeedDelay := FALSE;
   WriteChangeServerInfoCount := 0;

   LineNoticeTime := GetTickCount;
   LineNoticeNumber := 0;

   NotReadTag      := 0;
   // ¿¬ÀÎ »çÁ¦
   fLover  := TRelationShipMgr.Create;
   fMaster := TMasterMgr.Create;

   FExpireTime  := 0;
   FExpirecount := 0;

   FirstGold := 0;
   FirstGoldCount := 0;
   RufuseMaster := False;
   FUserMarket      := TMarketItemManager.Create;;
   FMarketNPC       := nil;
   BoFlagUserMarket := FALSE;
   FlagReadyToSellCheck := FALSE;
   m_StallMgr := TStallMgr.Create;

   SecondsCard := 0;
   iDay := 0;
   iHours := 0;
   iHoursTime:= GetTickCount;
   FillChar(m_btGetShopItem, 6, #0);

   SecondsCard := 0;
   TimeLabelList := TList.Create; //ÑÓÊ±ÁÐ±í
   bStorageType := 0;
end;

destructor TUserHuman.Destroy;
var
   i: integer;
begin
   for i:=0 to SendBuffers.Count-1 do
      FreeMem (SendBuffers[i]);
   SendBuffers.Free;
   // 2003/06/12 ½½·¹ÀÌºê ÆÐÄ¡
   PrevServerSlaves.Free;

   // ¿¬ÀÎ »çÁ¦ ¸Þ¸ð¸® »èÁ¦
   fLover.Free;
   fMaster.Free;

   // À§Å¹»óÁ¡ ÇØÁ¦
   if FUserMarket <> nil then FUserMarket.Free;
     m_StallMgr.Free; //120806

       for i := 0 to TimeLabelList.Count - 1 do
  begin
    Dispose(pTTimeLabel(TimeLabelList.Items[i]));
  end;
  TimeLabelList.Free;
   inherited Destroy;
end;

function  TUserHuman.GetUserMassCount: integer;
begin
   Result := UserEngine.GetAreaUserCount (PEnvir, CX, CY, 10);
end;

procedure TUserHuman.ResetCharForRevival;  //Á×Àº °æ¿ì »óÅÂ ¸®¼Â
begin
   FillChar (StatusArr, sizeof(word)*STATUSARR_SIZE, #0);  //»óÅÂ ¸®¼Â
   FillChar (StatusValue, sizeof(byte)*STATUSARR_SIZE, #0);  //»óÅÂ ¸®¼Â Ãß°¡(sonmg 2005/06/03)
end;

procedure  TUserHuman.Clear_5_9_bugitems;
var
   i: integer;
begin
   for i:=ItemList.Count-1 downto 0 do begin
      if PTUserItem(ItemList[i]).Index >= 164 then begin
         Dispose (PTUserItem(ItemList[i]));
         ItemList.Delete (i);
      end;
   end;
   for i:=SaveItems.Count-1 downto 0 do begin
      if PTUserItem(SaveItems[i]).Index >= 164 then begin
         Dispose (PTUserItem(SaveItems[i]));
         SaveItems.Delete (i);
      end;
   end;
end;

procedure TUserHuman.Reset_6_28_bugitems;
var
   i: integer;
   ps: PTStdItem;
begin
   // 2003/03/15 ¾ÆÀÌÅÛ ÀÎº¥Åä¸® È®Àå
   for i:=0 to U_TRANS do begin     // 8->12
      if UseItems[i].DuraMax = 0 then begin
         ps := UserEngine.GetStdItem (UseItems[i].Index);
         if ps <> nil then
            UseItems[i].DuraMax := ps.DuraMax;
      end;
   end;
   for i:=ItemList.Count-1 downto 0 do begin
      if PTUserItem(ItemList[i]).DuraMax = 0 then begin
         ps := UserEngine.GetStdItem (PTUserItem(ItemList[i]).Index);
         if ps <> nil then
            PTUserItem(ItemList[i]).DuraMax := ps.DuraMax;
      end;
   end;
   for i:=SaveItems.Count-1 downto 0 do begin
      if PTUserItem(SaveItems[i]).Index >= 164 then begin
         ps := UserEngine.GetStdItem (PTUserItem(SaveItems[i]).Index);
         if ps <> nil then
            PTUserItem(SaveItems[i]).DuraMax := ps.DuraMax;
         //Dispose (PTUserItem(SaveItems[i]));
         //SaveItems.Delete (i);
      end;
   end;
end;

procedure  TUserHuman.Initialize;
var
   i, k, sidx: integer;
   iname: string;
   pi: PTUserItem;
   u: TUserItem;
   ps: PTStdItem;
   plsave: PTSlaveInfo;
begin
   FirstGold := Gold;
   //------------------------------
   // ÃÊ±â ±ÝÀü·® Ã¼Å© °æ°í
   if (FirstGold >= EXORBITANT_GOLD) and (Abil.Level <= 1) then begin
      MainOutMessage('½ð±ÒÒì³£µ÷²é: ' + UserId + ' / ' + UserName + ' (Lv.' + IntToStr(Abil.Level) + ')  ' + GetGoldStr(FirstGold) + '½ð±Ò');
      AddUserConAlarmLog('ÓµÓÐ½ðÇ®ºÍÍ¶×Ê½Ó´¥ ' + UserId + ' / ' + UserName + ' (Lv.' + IntToStr(Abil.Level) + ')  ' + GetGoldStr(FirstGold) + '½ð±Ò');
   end;
   //------------------------------

   if BoTestServer then begin
      if Abil.Level < TestLevel then begin   //Å×½ºÆ® ¼­¹öÀÎ°æ¿ì
         Abil.Level := TestLevel;  //Å×½ºÆ® ¼­¹öÀÇ ±âº» ·¹º§
      end;
      if Gold < TestGold then begin
         Gold := TestGold;   //Å×½ºÆ® ¼­¹öÀÇ ±âº» µ·
      end;
   end;
   if BoTestServer or BoServiceMode then begin
     // 2003/03/18 Å×½ºÆ® ¼­¹ö ÀÎ¿øÁ¦ÇÑ (À¯·á»ç¿ëÀÚ ¹«Á¦ÇÑ, ¹«·á ÀÎ¿øÁ¦ÇÑ)
//   ApprovalMode := 3;  //¹«·á ¸ðµå,... ½Ã°£ ±ïÀÓ ¾øÀ½.
     if ApprovalMode = 1 then
        ApprovalMode := 4
     else
        ApprovalMode := 3; //¹«·á ¸ðµå,... ½Ã°£ ±ïÀÓ ¾øÀ½.
   end;

   MapMoveTime := GetTickCount;
   LoginDateTime := Now;
   LoginTime := GetTickCount;
   ServerShiftTime := GetTickCount;

   inherited Initialize;

   //¾ÆÀÌÅÛÁß¿¡ »ç¶óÁø ¾ÆÀÌÅÛ(Name='')ÀÌ ¾ø´ÂÁö È®ÀÎÇØ¾ß ÇÑ´Ù.
   for i:=ItemList.Count-1 downto 0 do begin
      if UserEngine.GetStdItemName (PTUserItem(ItemList[i]).Index) = '' then begin
         Dispose (PTUserItem(ItemList[i]));
         ItemList.Delete (i);
         continue;
      end;
      //Desc, Ãß°¡ ´É·ÂÄ¡¿¡ ¹ö±× ¹ß»ý...
      //pi := PTUserItem(ItemList[i]);
      //if (pi.Desc[0] > 10) or (pi.Desc[1] > 10) or (pi.Desc[2] > 10) or (pi.Desc[3] > 10) then
      //   FillChar (pi.Desc, 12, #0);
   end;
   //for i:=0 to U_CHARM do begin   // 8->12
   //   pi := @UseItems[i];
   //   if pi.Index > 0 then
   //      if (pi.Desc[0] > 10) or (pi.Desc[1] > 10) or (pi.Desc[2] > 10) or (pi.Desc[3] > 10) then
   //         FillChar (pi.Desc, 12, #0);
   //end;

   // °¡¹æ¿¡¼­ ¾ÆÀÌÅÛ °³¼ö°¡ 0 ÀÎ ´©Àû¾ÆÀÌÅÛ ¾ø¿¡ÀÚ
   for i:=ItemList.Count-1 downto 0 do begin
      ps := UserEngine.GetStdItem (PTUserItem(ItemList[i]).Index);
      if ( ps <> nil ) and ( ps.OverlapItem >=1) and (PTUserItem(ItemList[i]).dura = 0) then
      begin
         Dispose (PTUserItem(ItemList[i]));
         ItemList.Delete (i);
         continue;
      end;
   end;
   //Ã¢°í ¾ÆÀÌÅÛ Áß¿¡¼­ °³¼ö°¡ 0 ÀÎ ´©Àû ¾ÆÀÌÅÛ ¾ø¿¡ÀÚ
   for i:=SaveItems.Count-1 downto 0 do begin
      ps := UserEngine.GetStdItem (PTUserItem(SaveItems[i]).Index);
      if ( ps <> nil ) and ( ps.OverlapItem >=1) and (PTUserItem(SaveItems[i]).dura = 0) then
      begin
         Dispose (PTUserItem(SaveItems[i]));
         SaveItems.Delete (i);
         continue;
      end;
   end;

   //Ä³¸¯ÅÍ »óÅÂ ½Ã°£ º¯¼ö ¼³Á¤
   for i:=0 to STATUSARR_SIZE-1 do begin
      if StatusArr[i] > 0 then begin
         StatusTimes[i] := GetTickCount;
      end;
   end;
   CharStatus := GetCharStatus; //»óÅÂ ¾ò¾î¿È

   //Àß¸øµÈ ¾ÆÀÌÅÛÀÌ °è¼Ó Âø¿ëµÇ´Â°ÍÀ» Ã¼Å©ÇÔ
   // 2003/03/15 ¾ÆÀÌÅÛ ÀÎº¥Åä¸® È®Àå
   for i:=0 to U_TRANS do begin     // 8->12
      if UseItems[i].Index > 0 then begin
         ps := UserEngine.GetStdItem (UseItems[i].Index);
         if ps <> nil then begin
            if not IsTakeOnAvailable (i, ps) then begin //(¿¹)Ä®¿¡ ¿ÊÀÌ ¿ÀÁö ¸øÇÏ°Ô °Ë»ç
               new (pi);
               pi^ := UseItems[i];
               AddItem (pi);
               UseItems[i].Index := 0;
            end;
         end else
            UseItems[i].Index := 0;
      end;
   end;

   for i:=0 to ItemList.Count-1 do begin  //ÀÌº¥Æ® ¾ÆÀÌÅÛ °Ë»ç
      ps := UserEngine.GetStdItem (PTUserItem(ItemList[i]).Index);
      if ps <> nil then begin
         if not BoServerShifted then begin  //¸Ç Á¢¼Ó
            if ps.StdMode = TAIWANEVENTITEM then begin //´ë¸¸ ÀÌº¥Æ® ¾ÆÀÌÅÛÀº Á×À¸¸é ¶³±¸±â ¶§¹®¿¡ Á¢¼Ó½Ã¿¡ µé ¼ö ¾ø´Ù.
               Dispose (PTUserItem(ItemList[i]));
               ItemList.Delete(i);
               continue;
            end;
         end else begin //¼­¹ö ÀÌµ¿À¸·Î Á¢¼Ó
            if ps.StdMode = TAIWANEVENTITEM then begin
               TaiwanEventItemName := ps.Name;
               BoTaiwanEventUser := TRUE;
               StatusArr[STATE_BLUECHAR] := 60000;  //Å¸ÀÓ ¾Æ¿ô ¾øÀ½;
               Light := GetMyLight;
               SendRefMsg (RM_CHANGELIGHT, 0, 0, 0, 0, '');
               CharStatus := GetCharStatus;
            end;
         end;
      end;
   end;

   //°¡¹æ¿¡ Áßº¹µÈ ¾ÆÀÌµðÀÇ ¾ÆÀÌÅÛÀÌ ÀÖ´ÂÁö °Ë»ç.
   //Àß ¸ø µÈ ¾ÆÀÌÅÛ, Áö¿öÁ®¾ß ÇÒ ¾ÆÀÌÅÛ »èÁ¦
   for i:=ItemList.Count-1 downto 0 do begin
      iname := UserEngine.GetStdItemName (PTUserItem(ItemList[i]).Index);
      sidx  := PTUserItem(ItemList[i]).MakeIndex;
      for k:=i-1 downto 0 do begin
         pi := PTUserItem(ItemList[k]);
         if (iname = UserEngine.GetStdItemName (pi.Index)) and (sidx = pi.MakeIndex) then begin
            Dispose (pi);
            ItemList.Delete(k);
            break;
         end;
      end;
   end;

   //ÇÁ¸®¹Ì¾ö À¯Àú Ã¼Å©(sonmg 2005/07/29)
   FrmIDSoc.SendPremiumCheck (UserName, UserId, Certification);

   //ComeBack2005 LoginID Ã¼Å©(sonmg 2005/12/27)
   FrmIDSoc.SendEventCheck (UserName, UserId, Certification);

   FrmIDSoc.SendRechargeInfo (UserName, UserId, Certification);

   SendMsg (self, RM_LOGON, 0, 0, 0, 0, '');

{$IFDEF FOR_ABIL_POINT}
//4/16ÀÏºÎÅÍ Àû¿ë
   //º¸³Ê½º Æ÷ÀÎÆ®°¡ ÀÖÀ¸¸é
   if BonusPoint > 0 then
      SendMsg (self, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
{$ENDIF}

   //³Ê¹« ¸¹ÀÌ ¹ÐÁýµÇ¾î ÀÖÀ¸¸é ´Ù¸¥ °÷À¸·Î ÀÌµ¿ ½ÃÅ²´Ù.
   // 2004/04/22 Ã¼ÇèÆÇ ·¹º§ º¯°æ
   if boSecondCardSystem then
   begin
   if Abil.Level <= g_nExpErienceLevel then begin   // 7
      if (GetUserMassCount >= 80) then begin
         // ÀÏ´Ü ¹üÀ§ ¼öÁ¤.(sonmg 2004/06/23)
//         RandomSpaceMove (PEnvir.MapName, 0);
         RandomSpaceMoveInRange (0, 15, 30);
      end;
   end;
   end;

   //¹®ÆÄ ´ë·Ã ÀÌº¥Æ® ¹æ¿¡¼­ »ì¾Æ ³­ °æ¿ì
   if MustRandomMove then begin
      RandomSpaceMove (PEnvir.MapName, 0);
   end;

   //ReadyRun := TRUE;
   UserDegree := UserEngine.GetMyDegree (UserName);
   CheckHomePos;  //ÇÇÄÉÀÌ´Â ÇÇÄÉÀÌ ¶¥¿¡¼­ ½ÃÀÛ

   //¸¶¹ý °Ë»ç,..  ¸¶¹ýÀÇ Æ¯¼ö ´É·Â °Ë»ç
   for i:=0 to MagicList.Count-1 do begin
      CheckMagicSpecialAbility (PTUserMagic (MagicList[i]));
   end;

   //Ã³À½ ½ÃÀÛÇÒ¶§, ¸ñ°Ë 1°³ Æò¹Îº¹ ÇÑ¹ú¾¿, µ· 0Àü..
   if FirstTimeConnection then begin
      new (pi);
      if UserEngine.CopyToUserItemFromName (__Candle, pi^) then
         ItemList.Add (pi)
      else Dispose (pi);
      new (pi);
      if UserEngine.CopyToUserItemFromName (__BasicDrug, pi^) then
         ItemList.Add (pi)
      else Dispose (pi);
      new (pi);
      if UserEngine.CopyToUserItemFromName (__WoodenSword, pi^) then
         ItemList.Add (pi)
      else Dispose (pi);
      if Sex = 0 then begin //³²ÀÚ;
         new (pi);
         if UserEngine.CopyToUserItemFromName (__ClothsForMan, pi^) then
            ItemList.Add (pi)
         else Dispose (pi);
      end else begin
         new (pi);
         if UserEngine.CopyToUserItemFromName (__ClothsForWoman, pi^) then
            ItemList.Add (pi)
         else Dispose (pi);
      end;
   end;

   RecalcLevelAbilitys;
   RecalcAbilitys;  //¶Ç È£Ãâ ÇØ¾ß ÇÔ..
   Abil.MaxExp := GetNextLevelExp (Abil.Level);
   // TO PDS;
   Wabil.MaxExp := Abil.MaxExp;

   if FreeGulityCount = 0 then begin
      PlayerKillingPoint := 0;
      Inc (FreeGulityCount);
   end;

   //°¡¹æ¿¡ µ·´Â MAXGOLDÀü ±îÁö µé ¼ö ÀÖ´Ù.
   if Gold > BAGGOLD*2 then Gold := BAGGOLD*2;

   if not BoServerShifted then begin
{$IFNDEF TIAOSHI}
      if (ClientVersion < VERSION_NUMBER) or
         (ClientVersion <> LoginClientVersion) or
         ((ClientCheckSum <> ClientCheckSumValue1) and
          (ClientCheckSum <> ClientCheckSumValue2) and
          (ClientCheckSum <> ClientCheckSumValue3)
          ) then
      begin
         SysMsg ('¿Í»§¶Ë°æ±¾ºÅ´íÎóÇëÖØÐÂÏÂÔØ', 0);

         if CHINAVERSION then
            SysMsg ('(http://www.legendofmir.com.cn)', 0);
         if KOREANVERSION then
            SysMsg ('(http://www.mir2c.com)', 0);
         if ENGLISHVERSION then
            SysMsg ('(http://www.legendofmir.net)', 0);
         if PHILIPPINEVERSION then
            SysMsg ('(http://www.mir2.com.ph)', 0);
         if TAIWANVERSION then
            SysMsg ('(http://www.mir2.com.tw)', 0);
       //  SysMsg ('¿Í»§¶ËÓ¦ÓÃ³ÌÐò°æ±¾²»Æ¥Åä£¬µÇÂ¼¹ÙÍøÏÂÔØ×îÐÂ¿Í»§¶Ë:http://www.mir2c.com', 0);
       //SysMsg ('Çëµ½¹Ù·½ÍøÕ¾ÏÂÔØ×îÐÂµÇÂ¼Æ÷http://www.mir2i.com', 0);
{$IFNDEF DEBUG}
         if not BoClientTest then begin
            SysMsg ('Á¬½Ó±»ÖÕÖ¹.', 0);
            EmergencyClose := TRUE;
            exit;
         end;
{$ENDIF}
      end;
{$ENDIF}
                      if boSecondCardSystem then  begin
                       if (iHours > 0) and (SecondsCard > 0) then  //ÔÂ¿¨Ã»ÓÐºó£¬ÉÏ·þÌáÊ¾ºì×Ö
                            SecondsCard := 0;
                         //  SysMsg ('[ÕË»§ÐÅÏ¢]µ±Ç°ÕË»§³äÖµÊ±¼äÒÑµ½ÆÚ', 0);


                          SysMsg ('Äã±»Í¨¹ý¹Ì¶¨Ê±¼äÕË»§³äÖµ. ',5);


                      end;

      case HumAttackMode of
         HAM_ALL:    SysMsg ('[¹¥»÷Ä£Ê½£ºÈ«Ìå¹¥»÷]', 1);
         HAM_PEACE:  SysMsg ('[¹¥»÷Ä£Ê½£ººÍÆ½¹¥»÷]', 1);
         HAM_GROUP:  SysMsg ('[¹¥»÷Ä£Ê½£º±à×é¹¥»÷]', 1);
         HAM_GUILD:  SysMsg ('[¹¥»÷Ä£Ê½£ºÐÐ»á¹¥»÷]', 1);
         HAM_PKATTACK: SysMsg ('[¹¥»÷Ä£Ê½£ºÉÆ¶ñ¶Ô¹¥]', 1);
      end;
      SysMsg ('¸ü¸Ä¹¥»÷Ä£Ê½£ºCTRL-H', 1);
      SendMsg(Self, RM_ATTACKMODE, 0,HumAttackMode, 0, 0, '');
      //SysMsg ('Ê¹ÓÃ@°ïÖúÃüÁî¶Ò»»Ôª±¦ÒÔ¼°²éÑ¯ÓÎÏ·°ïÖúÐÅÏ¢', 1);
      if BoTestServer then begin
      // SysMsg ('»¶Ó­À´µ½´«ÆæÕýÊ½·þÎñÆ÷£¬ÇëÉÏ¹ÙÍøhttp://www.mir2i.comÁË½â¸ü¶àÓÎÏ·¹æÔò', 1);

         //ÀÎ¿ø Á¦ÇÑ
         // 2003/03/18 Å×½ºÆ® ¼­¹ö ÀÎ¿ø Á¦ÇÑ
         if (ApprovalMode = 4) and (UserEngine.FreeUserCount > TestServerMaxUser) then begin
//       if UserEngine.GetUserCount > TestServerMaxUser then begin
            if UserDegree < UD_OBSERVER then begin
               SysMsg ('·þÎñÆ÷ÈËÊýÒÑ´ïÉÏÏÞ', 0);
               SysMsg ('Á¬½ÓÖÐ¶Ï', 0);
               EmergencyClose := TRUE;
            end;
         end;
      end;
//      if boSecondCardSystem then
//      if (iDay > 0) then
//        SysMsg ('Äã±»Í¨¹ý¹Ì¶¨Ê±¼äÕË»§³äÖµ. ', 3)
//      else
//      if SecondsCard > 0  then
//        SysMsg (Format('µ±Ç°¿¨ÄÚÊ£Óà: %dÃë',[SecondsCard]), 1);
//
//
////      if boSecondCardSystem then
////      begin
////      if (RaceServer = RC_USERHUMAN) and (Abil.Level > g_nExpErienceLevel) then begin
////          if (iDay <= 0) then begin
////             SecondsCard := 0;
////             SysMsg ('[ÕË»§ÐÅÏ¢]µ±Ç°ÕË»§³äÖµÊ±¼äÒÑµ½ÆÚ', 0);
////             if (GrobalEnvir.GetEnvir (g_sRechargingMap) <> nil) and (PEnvir.MapName <> g_sRechargingMap) then begin
////                SendRefMsg (RM_SPACEMOVE_HIDE, 0, 0, 0, 0, '');
////                RandomSpaceMove (g_sRechargingMap, 0); //¹«ÀÛÀ§ °ø°£ÀÌµ¿
////             end;
////          end
////          else
////          if (SecondsCard <= 0) then begin
////             SecondsCard := 0;
////             SysMsg ('[ÕË»§ÐÅÏ¢]µ±Ç°ÕË»§³äÖµÊ±¼äÒÑµ½ÆÚ', 0);
////             if (GrobalEnvir.GetEnvir (g_sRechargingMap) <> nil) and (PEnvir.MapName <> g_sRechargingMap) then begin
////                SendRefMsg (RM_SPACEMOVE_HIDE, 0, 0, 0, 0, '');
////                RandomSpaceMove (g_sRechargingMap, 0); //¹«ÀÛÀ§ °ø°£ÀÌµ¿
////             end;
////          end;
////      end;
////      end;
//      if boSecondCardSystem then
//      begin
//      if (ApprovalMode = 1) and (SecondsCard <= 0) then begin //Ã¼ÇèÆÇ »ç¿ëÀÚ, Å×½ºÆ® ¼­¹ö´Â °øÂ¥
//         // 2004/04/22 Ã¼Çè·¡¹ë 7->20, 10¸¸Àü -> 500¸¸Àü
//         // 2005/03/22 Ã¼Çè±ÝÀü 500¸¸Àü -> 50¸¸Àü
//         if not BoServerShifted then
//           if (Abil.Level <= g_nExpErienceLevel) then
//           begin
//            SysMsg (Format('ÄãÏÖÔÚ´¦ÓÚÌåÑéÄ£Ê½ÖÐ£¬Äã¿ÉÒÔÔÚ%d¼¶Ç°Ê¹ÓÃ£¬µ«ÊÇ»áÏÞÖÆÄãµÄÒ»Ð©¹¦ÄÜ', [g_nExpErienceLevel]), 1);  //Äã¿ÉÒÔÔÚ'+IntToStr(EXPERIENCELEVEL)+'¼¶Ç°Ê¹ÓÃ£¬
//            AvailableGold := 100000; //Î´³äÖµÓÃ»§±³°ü½ð±ÒÉÏÏÞ
//           end;
//        { if (Abil.Level > EXPERIENCELEVEL) then begin  //Ã¼ÇèÆÇÀ¸·Î Á¢¼ÓÀÌ ¾ÈµÊ
//            if EXPERIENCELEVEL = 0 then
//               SysMsg ('Çë¸¶·Ñ³äÖµºóÔÙÊ¹ÓÃ', 0)
//            else
//               SysMsg ('ÌåÑéÄ£Ê½¿ÉÒÔÊ¹ÓÃµ½7¼¶', 0);
//          //SysMsg ('Á¬½ÓÖÐ¶Ï£¬Çëµ½±¾ÓÎÏ·ÍøÕ¾²é¿´ÊÕ·ÑÏà¹ØÐÅÏ¢http://www.mir2i.com', 0);
////            EmergencyClose := TRUE;      //ÓÎÏ·µ½ÆÚºóµôÏß
//         end; }
//      end;
//      end;
      // 2003/03/18 Å×½ºÆ® ¼­¹ö ÀÎ¿ø Á¦ÇÑ
      if (ApprovalMode > 3) and (SecondsCard <= 0) then begin //¹«·á»ç¿ëÀÚ, 20ÀÏ ÇÑÁ¤ »ç¿ëÀÚ
//    if ApprovalMode = 3 then begin //¹«·á»ç¿ëÀÚ, 20ÀÏ ÇÑÁ¤ »ç¿ëÀÚ
         if not BoServerShifted then
            SysMsg ('Ãâ·ÑÌåÑéÁ¬½Ó', 1);
      end;

      if BoVentureServer then begin  //¸ðÇè¼­¹ö
         SysMsg ('»¶Ó­ÄãÀ´µ½Ã°ÏÕ·þÎñÆ÷...', 1);
      end;

   end;

   Bright := MirDayTime;
   SendMsg (self, RM_ABILITY, 0, 0, 0, 0, '');
   SendMsg (self, RM_SUBABILITY, 0, 0, 0, 0, '');
   SendMsg (self, RM_DAYCHANGING, 0, 0, 0, 0, '');
   SendMsg (self, RM_SENDUSEITEMS, 0, 0, 0, 0, '');
   SendMsg (self, RM_SENDMYMAGIC, 0, 0, 0, 0, '');

   //¹®ÆÄ¿¡ °¡ÀÔµÇ¾î ÀÖ´ÂÁö..
   MyGuild := GuildMan.GetGuildFromMemberName (UserName);
   if MyGuild <> nil then begin  //±æµå¿¡ °¡ÀÔµÇ¾î ÀÖ´Â °æ¿ì
      GuildRankName := TGuild (MyGuild).MemberLogin (self, GuildRank);
      //SendMsg (self, RM_CHANGEGUILDNAME, 0, 0, 0, 0, '');
      for i:=0 to TGuild(MyGuild).KillGuilds.Count-1 do begin
         SysMsg (TGuild(MyGuild).KillGuilds[i] + 'ÐÐ»áÕýÔÚºÍÄúµÄÐÐ»á½øÐÐÐÐ»áÕ½Õù', 1);
      end;

      // ¼­¹ö ÀÌµ¿ÀÌ ¾Æ´Ñ »õ·Î Á¢¼ÓÇßÀ» ¶§¸¸ Àû¿ë.
      if not BoServerShifted then begin
         // ¹®ÁÖ/¹®ÆÄ¿øÀÌ Á¢¼ÓÇßÀ» ¶§ Àå¿øÀÌ ¿¬Ã¼µÇ¾î ÀÖ´Ù¸é Áö³­±â°£/³²Àº±â°£À» ¾Ë·ÁÁÜ.
         if GuildAgitMan.IsDelayed( TGuild(MyGuild).GuildName ) then
            CmdGuildAgitRemainTime;

         // Á¢¼ÓÇßÀ» ¶§ ¹®ÆÄ¸Þ½ÃÁö(sonmg 2005/08/05)
         TGuild(MyGuild).GuildMsg ('(!)' + UserName + ' ÒÑÁ¬½ÓÉÏÏß', UserName);    // ÐÐ»á³ÉÔ±ÉÏÏßÌáÐÑ
         UserEngine.SendInterMsg (ISM_GUILDMSG, ServerIndex, TGuild(MyGuild).GuildName + '/' + '(!)' + UserName + ' ÒÑÁ¬½ÓÉÏÏß');
      end;
   end;

   // ¹®ÆÄ °¡ÀÔ ¿©ºÎ¿¡ »ó°ü¾øÀÌ...
   // ¼­¹ö ÀÌµ¿ÀÌ ¾Æ´Ñ »õ·Î Á¢¼ÓÇßÀ» ¶§¸¸ Àû¿ë.
   if not BoServerShifted then begin
      // °Ë»öÇÏ¿© ÇÒ´çµÈ Àå¿øÀÌ ¾ø´Âµ¥ Àå¿ø ¸Ê ¾È¿¡ ÀÖ´Ù¸é ÁöÁ¤ ¸Ê/ÁÂÇ¥·Î °­Á¦ ÀÌµ¿½ÃÅ´.
      CmdGuildAgitExpulsionMyself;

      //ÃÖÃÊ Á¢¼ÓÇÏ¸é DecoItemList¸¦ º¸³»ÁØ´Ù.
      SendDecoItemList;
   end;

   if PLongHitSkill <> nil then
      if not BoAllowLongHit then begin
         BoAllowLongHit := TRUE;
         SendSocket (nil, '+LNG');  //¿ø°Å¸® °ø°ÝÀ» ÇÏ°Ô ÇÑ´Ù.
      end;
   {if PWideHitSkill <> nil then  //
      if not BoAllowWideHit then begin
         BoAllowWideHit := TRUE;
         SendSocket (nil, '+WID');  //
      end;}

   //ÀçÁ¢ÀÌ ¾ÈµÇ´Â ¸Ê(¼­¹ö ÀÌµ¿½Ã¿¡´Â Æ¨±âÁö ¾Êµµ·Ï ¼öÁ¤ sonmg 2005/03/11)
   if (PEnvir.NoReconnect) and (not BoServerShifted) then begin
      RandomSpaceMove (PEnvir.BackMap, 0);
   end;

   // 2003/06/12 ½½·¹ÀÌºê ÆÐÄ¡
   //¼ÒÈ¯ ¸÷ ºÎ¸¥´Ù.
   if PrevServerSlaves.Count > 0 then begin
      for i:=0 to PrevServerSlaves.Count-1 do begin
          plsave := PTSlaveInfo(PrevServerSlaves[i]);
          RmMakeSlaveProc(plsave);
          Dispose(plsave);
      end;
      PrevServerSlaves.Clear;
   end;

   if not BoServerShifted then begin  ////
      SendMsg (self, RM_DOSTARTUPQUEST, 0, 0, 0, 0, '');

   end;

   // Å×½ºÆ® ¼­¹ö°¡ ¾Æ´Ï¸é ½Ã°£ °èÁ¤ Ã¼Å©(2004/09/06 sonmg)
   if not BoTestServer then begin
      // Á¤·®Á¦ÀÎ °æ¿ì¸¸ Ã¼Å©
      if (AvailableMode = 2) or (AvailableMode = 6) or (AvailableMode = 7) or (AvailableMode = 8)
            or (AvailableMode = 9) or (AvailableMode = 10) then begin
         FrmIDSoc.SendCheckTimeAccount (UserId, Certification);
      end;
   end;

   // ÀÐÁö¾ÊÀº ÂÊÁö°¡ ÀÖÀ½À» Àü¼Û
   if NotReadTag > 0 then
   begin
      // Å¬¶óÀÌ¾ðÆ®¿¡ µ¥ÀÌÅÍ Àü¼Û
      SendMsg(Self, RM_TAG_ALARM, 0,NotReadTag, 0, 0, '');

      NotReadTag := 0;
   end;
   //¿¬ÀÎ »çÁ¦ µ¥ÀÌÅÍ ºÒ¸£±â
   SendMsg( Self, RM_LM_DBWANTLIST, 0, 0, 0, 0, '');
   SendMsg( Self, RM_MAA_DBWANTLIST, 0, 0, 0, 0, '');    // Ê¦Í½Êý¾Ý
end;

procedure  TUserHuman.Finalize;
begin
   try
      if ReadyRun then Disappear(5); //·Î±×ÀÎ ¼º°ø Çß¾î¾ß.
   except
   end;

   if BoFixedHideMode then begin //°íÁ¤ Àº½Å¼ú.. ÀÌµ¿ÇÑ°æ¿ì¿¡´Â Àº½Å¼úÀÌ Ç®¸°´Ù.
      if BoHumHideMode then begin  // Á¢¼ÓÀ» ²÷À¸¸é Åõ¸íÀÌ Ç®¸²
         StatusArr[STATE_TRANSPARENT] := 0;
      end;
   end;
   if BoTaiwanEventUser then begin
      StatusArr[STATE_BLUECHAR] := 0;
   end;

   try
      //³»°¡ ±×·ìÂ¯ÀÌ ¾Æ´Ï¸é...
      if GroupOwner <> nil then begin
         GroupOwner.DelGroupMember (self);
      end else begin
         //³»°¡ ±×·ì Â¯ÀÌ¸é...
         DelGroupMember(self);
      end;
   except
   end;

   try
      if MyGuild <> nil then
         TGuild (MyGuild).MemberLogout (self);
   except
   end;

   //Á¢¼Ó ±â·ÏÀ» ³²±ä´Ù.
   WriteConLog;

   inherited Finalize;
end;

procedure TUserHuman.WriteConLog;    //Á¢¼Ó ±â·Ï.........
var
   contime: longword;
begin
   if (AvailableMode = 1) or (ApprovalMode = 2) or (BoTestServer) then begin //À¯·á»ç¿ëÀÚ (Å×½ºÆ® ¼­¹ö Å×½ºÆ®¿ë)
      contime := (GetTickCount - LoginTime){ div 1000};  //ÃÊ ´ÜÀ§
   end else begin
      contime := 0;
   end;

   AddConLog (UserAddress + ''#9 +
              UserId + ''#9 +
              UserName + ''#9 +
              IntToStr(contime) + ''#9 +
              FormatDateTime('yyyy-mm-dd hh:mm:ss', LoginDateTime) + ''#9 +
              FormatDateTime('yyyy-mm-dd hh:mm:ss', Now) + ''#9 +
              IntToStr(AvailableMode));

   // 2003.01.22 ±¹³» ¼­ºñ½º¿¡ ¹«¿ëÇÑ ·çÆ¾ÀÌ¹Ç·Î ¸®¸¶Å© Ã³¸®
   if (AvailableMode = 1) or (AvailableMode = 2) or (AvailableMode = 6) then  //°³ÀÎ Á¤·® ÀÎ °æ¿ì
      FrmIDSoc.SendGameTimeOfTimeCardUser (UserId, contime{ div 60});

end;

procedure TUserHuman.SendSocket (pmsg: PTDefaultMessage; body: string);
var
   packetlen: integer;
   header: TMsgHeader;
   pbuf: PAnsiChar;
   ansibody: AnsiString;
begin
   pbuf := nil;
   try
   header.Code := integer($aa55aa55);
   header.SNumber := Userhandle;
   header.UserGateIndex := UserGateIndex;
   header.Ident := GM_DATA;
   ansibody := AnsiString(body);
   if pmsg <> nil then begin
      if ansibody <> '' then begin
         header.Length := sizeof(TDefaultMessage) + Length(ansibody) + 1;
         packetlen := sizeof(TMsgHeader) + header.Length;
         GetMem (pbuf, packetlen + 4);
         Move (packetlen, pbuf^, 4);
         Move (header, (@pbuf[4])^, sizeof(TMsgHeader));
         Move (pmsg^, (@pbuf[4+sizeof(TMsgHeader)])^, sizeof(TDefaultMessage));
         Move ((@ansibody[1])^, (@pbuf[4+sizeof(TMsgHeader)+sizeof(TDefaultMessage)])^, Length(ansibody)+1);
      end else begin
         header.Length := sizeof(TDefaultMessage);
         packetlen := sizeof(TMsgHeader) + header.Length;
         GetMem (pbuf, packetlen + 4);
         Move (packetlen, pbuf^, 4);
         Move (header, (@pbuf[4])^, sizeof(TMsgHeader));
         Move (pmsg^, (@pbuf[4+sizeof(TMsgHeader)])^, sizeof(TDefaultMessage));
      end;
   end else begin
      if ansibody <> '' then begin  //°£´ÜÇÑ ¸Þ¼¼Áö
         header.Length := - (Length(ansibody) + 1);  //±æÀÌ°¡ ¸¶ÀÌ³Ê½º °ªÀ¸·Î ³Ñ¾î°£´Ù.
         packetlen := sizeof(TMsgHeader) + abs(header.Length);
         GetMem (pbuf, packetlen + 4);
         Move (packetlen, pbuf^, 4);
         Move (header, (@pbuf[4])^, sizeof(TMsgHeader));
         Move ((@ansibody[1])^, (@pbuf[4+sizeof(TMsgHeader)])^, Length(ansibody)+1);
      end;
   end;

   HumanLock.Enter;
   try
   RunSocket.SendUserSocket (GateIndex, pbuf);
   finally
   HumanLock.Leave;
   end;

   except
      MainOutMessage ('Exception SendSocket..');
   end;
end;

procedure TUserHuman.SendDefMessage (msg, recog, param, tag, series: integer; addstr: string);
begin
   Def := MakeDefaultMsg (msg, recog, param, tag, series);
   if addstr <> '' then
      SendSocket (@Def, EncodeString (addstr))
   else SendSocket (@Def, '');
end;

procedure  TUserHuman.GuildRankChanged (rank: integer; rname: string);
begin
   GuildRank := rank;
   GuildRankName := rname;
   SendMsg (self, RM_CHANGEGUILDNAME, 0, 0, 0, 0, '');
end;


{----------------------------------------------}

function  TUserHuman.TurnXY (x, y, dir: integer): Boolean;
begin
   Result := FALSE;
  if RaceServer = RC_USERHUMAN then begin
    if TUserHuman(Self).m_StallMgr.OnSale then begin

      Exit;
    end;
  end;
   if (x = self.CX) and (y = self.CY) then begin
      self.Dir := dir;
      if Walk(RM_TURN) then begin
         Result := TRUE;
      end;
   end;
end;

function  TUserHuman.WalkXY (x, y: integer): Boolean;
var
   ndir, oldx, oldy, dis: integer;
   allowdup: Boolean;
begin
   Result := FALSE;
  if RaceServer = RC_USERHUMAN then begin
    if TUserHuman(Self).m_StallMgr.OnSale then begin

      Exit;
    end;
  end;

   if GetTickCount - LatestWalkTime < 600 then begin
      Inc (WalkTimeOverCount);
      Inc (WalkTimeOverSum);

      // Critical Speedhack Check
      if g_SpeedHackCheck > 0 then begin
         dis := GetTickCount - LatestWalkTime;
         if (dis < g_SpeedHackCheck) and (WalkTimeOverSum > 1) then begin
//            WalkTimeOverCount := 4;
//            WalkTimeOverSum := 6;
//            SpeedHackTimerOverCount := 8;
            MainOutMessage('¼ì²éÈËÔ± Walk : ' + IntToStr(dis) + ' : ' + IntToStr(WalkTimeOverCount) + ',' + IntToStr(WalkTimeOverSum) + ',' + IntToStr(SpeedHackTimerOverCount) + '  ' + UserName);
            if BoTestServer then
               exit;
         end;
      end;
   end else begin
      WalkTimeOverCount := 0;
      if WalkTimeOverSum > 0 then
         Dec (WalkTimeOverSum);
   end;

   if (UserName = g_SpeedHackCheckChar) then begin
      dis := GetTickCount - LatestWalkTime;
      MainOutMessage (IntToStr(dis));
   end;

   LatestWalkTime := GetTickCount;

   if (WalkTimeOverCount < 4) and (WalkTimeOverSum < 6) then begin
      SpaceMoved := FALSE;
      oldx := self.CX;
      oldy := self.CY;
      ndir := GetNextDirection (CX, CY, x, y);

      allowdup := FALSE;  //Æò»ó½Ã¿¡´Â ¶Û¶§ °ãÄ¥ ¼ö ÀÖÀ½
      //if UserCastle.BoCastleUnderAttack then begin  //°ø¼ºÀü ÁßÀÎ °æ¿ì
      //   if BoInFreePKArea then //ÇÁ¸®ÇÇÄÉÀÌÁ¸(ÀüÀïÅÍ)¿¡ ÀÖÀ½, °ø¼º Áö¿ª¿¡ ÀÖÀ½
      //      allowdup := FALSE;  //°ø¼ºÀü Áö¿ª¿¡¼­´Â °ãÄ¥ ¼ö ¾øÀ½
      //end;

      if WalkTo (ndir, allowdup) then begin  //°ãÃÄÁöÁö ¾Ê°Ô ÇÔ.
         if SpaceMoved or (CX = x) and (CY = y) then
            Result := TRUE;
         Dec (HealthTick, 10);   //20
      end else begin           //°È±â ½ÇÆÐ
         WalkTimeOverCount := 0;
         WalkTimeOverSum := 0;
      end;
   end else begin
      Inc (SpeedHackTimerOverCount);
      if SpeedHackTimerOverCount > 8 then
         EmergencyClose := TRUE;

      if BoViewHackCode then
         MainOutMessage ('[11002-Walk] ' + IntToStr(WalkTimeOverCount) + ',' + IntToStr(WalkTimeOverSum) + '  ' + UserName + ' ' + TimeToStr(Time));
   end;
end;

function  TUserHuman.RunXY (x, y: integer): Boolean;
var
   ndir: byte;
   dis: integer;
   allowdup: Boolean;
begin
   Result := FALSE;
  if RaceServer = RC_USERHUMAN then begin
    if TUserHuman(Self).m_StallMgr.OnSale then begin

      Exit;
    end;
  end;

   if GetTickCount - LatestWalkTime < 600 then begin
      Inc (WalkTimeOverCount);
      Inc (WalkTimeOverSum);

      // Critical Speedhack Check
      if g_SpeedHackCheck > 0 then begin
         dis := GetTickCount - LatestWalkTime;
         if (dis < g_SpeedHackCheck) and (WalkTimeOverSum > 1) then begin
//            WalkTimeOverCount := 4;
//            WalkTimeOverSum := 6;
//            SpeedHackTimerOverCount := 8;
            MainOutMessage('¼ì²éÈËÔ± Run : ' + IntToStr(dis) + ' : ' + IntToStr(WalkTimeOverCount) + ',' + IntToStr(WalkTimeOverSum) + ',' + IntToStr(SpeedHackTimerOverCount) + '  ' + UserName);
            if BoTestServer then
               exit;
         end;
      end;
   end else begin
      WalkTimeOverCount := 0;
      if WalkTimeOverSum > 0 then
         Dec (WalkTimeOverSum);
   end;

   if (UserName = g_SpeedHackCheckChar) then begin
      dis := GetTickCount - LatestWalkTime;
      MainOutMessage (IntToStr(dis));
   end;

   LatestWalkTime := GetTickCount;

   if (WalkTimeOverCount < 4) and (WalkTimeOverSum < 6) then begin
      SpaceMoved := FALSE;
      ndir := GetNextDirection (CX, CY, x, y);

      allowdup := FALSE;  //Æò»ó½Ã¿¡´Â ¶Û¶§ °ãÄ¥ ¼ö ÀÖÀ½
      if UserCastle.BoCastleUnderAttack then begin  //°ø¼ºÀü ÁßÀÎ °æ¿ì
         if BoInFreePKArea then //ÇÁ¸®ÇÇÄÉÀÌÁ¸(ÀüÀïÅÍ)¿¡ ÀÖÀ½, °ø¼º Áö¿ª¿¡ ÀÖÀ½
            allowdup := FALSE;  //°ø¼ºÀü Áö¿ª¿¡¼­´Â °ãÄ¥ ¼ö ¾øÀ½
      end;

      if RunTo (ndir, allowdup) then begin
         if BoFixedHideMode then begin //°íÁ¤ Àº½Å¼ú..
            if BoHumHideMode then begin  //ÀÌµ¿ÇÑ°æ¿ì¿¡´Â Àº½Å¼úÀÌ Ç®¸°´Ù.
               StatusArr[STATE_TRANSPARENT] := 1;
            end;
         end;
         if SpaceMoved or (CX = x) and (CY = y) then
            Result := TRUE;
         Dec (HealthTick, 60); //150
         Dec (SpellTick, 10);  SpellTick := _MAX(0, SpellTick);
         Dec (PerHealth);
         Dec (PerSpell);
      end else begin
         WalkTimeOverCount := 0;
         WalkTimeOverSum := 0;
      end;
   end else begin
      Inc (SpeedHackTimerOverCount);
      if SpeedHackTimerOverCount > 8 then
         EmergencyClose := TRUE;
      if BoViewHackCode then
         MainOutMessage ('[11002-Run] ' + IntToStr(WalkTimeOverCount) + ',' + IntToStr(WalkTimeOverSum) + '  ' + UserName + ' ' + TimeToStr(Time));
   end;
end;

procedure TUserHuman.GetRandomMineral;
var
   pi: PTUserItem;
begin
   if Itemlist.Count < MAXBAGITEM then begin
      case Random(120) of
         1..2: //±Ý±¤¼®
//         1..3: //±Ý±¤¼®
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName (__GoldStone, pi^) then begin
                  //±¤¼®ÀÇ ¼øµµ Àû¿ë....
                  pi.Dura := GetPurity;
                  ItemList.Add (pi);
                  WeightChanged;
                  SendAddItem (pi^);
                  SysMsg('´¿¶È' + IntTostr(Round(pi.Dura/1000)) + 'µÄ' + __GoldStone + 'ÍÚµ½ÁË',2);
               end else
                  Dispose (pi);
            end;
         3..20: //Àº±¤¼®
//         4..24: //Àº±¤¼®
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName (__SilverStone, pi^) then begin
                  //±¤¼®ÀÇ ¼øµµ Àû¿ë....
                  pi.Dura := GetPurity;
                  ItemList.Add (pi);
                  WeightChanged;
                  SendAddItem (pi^);
                  SysMsg('´¿¶È' + IntTostr(Round(pi.Dura/1000)) + 'µÄ' + __SilverStone + 'ÍÚµ½ÁË',2);
               end else
                  Dispose (pi);
            end;
         21..45: //Ã¶±¤¼®
//         25..54: //Ã¶±¤¼®
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName (__SteelStone, pi^) then begin
                  //±¤¼®ÀÇ ¼øµµ Àû¿ë....
                  pi.Dura := GetPurity;
                  ItemList.Add (pi);
                  WeightChanged;
                  SendAddItem (pi^);
                  SysMsg('´¿¶È' + IntTostr(Round(pi.Dura/1000)) + 'µÄ' + __SteelStone + 'ÍÚµ½ÁË',2);
               end else
                  Dispose (pi);
            end;
         46..56: //ÈæÃ¶
//         55..66: //ÈæÃ¶
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName (__BlackStone, pi^) then begin
                  //±¤¼®ÀÇ ¼øµµ Àû¿ë....
                  pi.Dura := GetPurity;
                  ItemList.Add (pi);
                  WeightChanged;
                  SendAddItem (pi^);
                  SysMsg('´¿¶È' + IntTostr(Round(pi.Dura/1000)) + 'µÄ' + __BlackStone + 'ÍÚµ½ÁË',2);
               end else
                  Dispose (pi);
            end;
         else //µ¿±¤¼®
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName (__CopperStone, pi^) then begin
                  //±¤¼®ÀÇ ¼øµµ Àû¿ë....
                  pi.Dura := GetPurity;
                  ItemList.Add (pi);
                  WeightChanged;
                  SendAddItem (pi^);
                  SysMsg('´¿¶È' + IntTostr(Round(pi.Dura/1000)) + 'µÄ' + __CopperStone + 'ÍÚµ½ÁË',2);
               end else
                  Dispose (pi);
            end;
      end;
   end;
end;

procedure TUserHuman.GetRandomGems;
var
   pi: PTUserItem;
begin
   if Itemlist.Count < MAXBAGITEM then begin
      case Random(120) of
         1..2: //¹é±Ý
//         1..3: //¹é±Ý
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName (__Gem1Stone, pi^) then begin
                  //±¤¼®ÀÇ ¼øµµ Àû¿ë....
                  pi.Dura := GetPurity;
                  ItemList.Add (pi);
                  WeightChanged;
                  SendAddItem (pi^);
                  SysMsg('´¿¶È' + IntTostr(Round(pi.Dura/1000)) + 'µÄ' + __Gem1Stone + 'ÍÚµ½ÁË',2);
               end else
                  Dispose (pi);
            end;
         3..20: //¿¬¿Á
//         5..24: //¿¬¿Á
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName (__Gem2Stone, pi^) then begin
                  //±¤¼®ÀÇ ¼øµµ Àû¿ë....
                  pi.Dura := GetPurity;
                  ItemList.Add (pi);
                  WeightChanged;
                  SendAddItem (pi^);
                  SysMsg('´¿¶È' + IntTostr(Round(pi.Dura/1000)) + 'µÄ' + __Gem2Stone + 'ÍÚµ½ÁË',2);
               end else
                  Dispose (pi);
            end;
         21..45: //È«¿Á¼®
//         25..54: //È«¿Á¼®
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName (__Gem4Stone, pi^) then begin
                  //±¤¼®ÀÇ ¼øµµ Àû¿ë....
                  pi.Dura := GetPurity;
                  ItemList.Add (pi);
                  WeightChanged;
                  SendAddItem (pi^);
                  SysMsg('´¿¶È' + IntTostr(Round(pi.Dura/1000)) + 'µÄ' + __Gem4Stone + 'ÍÚµ½ÁË',2);
               end else
                  Dispose (pi);
            end;
         else //ÀÚ¼öÁ¤
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName (__Gem3Stone, pi^) then begin
                  //±¤¼®ÀÇ ¼øµµ Àû¿ë....
                  pi.Dura := GetPurity;
                  ItemList.Add (pi);
                  WeightChanged;
                  SendAddItem (pi^);
                  SysMsg('´¿¶È' + IntTostr(Round(pi.Dura/1000)) + 'µÄ' + __Gem3Stone + 'ÍÚµ½ÁË',2);
               end else
                  Dispose (pi);
            end;
      end;
   end;
end;

//»õ·Î Ãß°¡µÈ MINE3 ¼Ó¼º¿¡¼­ ³ª¿À´Â ±¤¼®µé...(2004/11/03)
procedure TUserHuman.GetRandomMineral3;
var
   pi: PTUserItem;
begin
   if Itemlist.Count < MAXBAGITEM then begin
      case Random(240) of
//         1..4: //±Ý±¤¼®
         1..6: //±Ý±¤¼®
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName (__GoldStone, pi^) then begin
                  //±¤¼®ÀÇ ¼øµµ Àû¿ë....
                  pi.Dura := GetPurity;
                  ItemList.Add (pi);
                  WeightChanged;
                  SendAddItem (pi^);
                  SysMsg('´¿¶È' + IntTostr(Round(pi.Dura/1000)) + 'µÄ' + __GoldStone + 'ÍÚµ½ÁË',2);
               end else
                  Dispose (pi);
            end;
//         5..22: //Àº±¤¼®
         7..30: //Àº±¤¼®
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName (__SilverStone, pi^) then begin
                  //±¤¼®ÀÇ ¼øµµ Àû¿ë....
                  pi.Dura := GetPurity;
                  ItemList.Add (pi);
                  WeightChanged;
                  SendAddItem (pi^);
                  SysMsg('´¿¶È' + IntTostr(Round(pi.Dura/1000)) + 'µÄ' + __SilverStone + 'ÍÚµ½ÁË',2);
               end else
                  Dispose (pi);
            end;
//         23..47: //Ã¶±¤¼®
         31..66: //Ã¶±¤¼®
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName (__SteelStone, pi^) then begin
                  //±¤¼®ÀÇ ¼øµµ Àû¿ë....
                  pi.Dura := GetPurity;
                  ItemList.Add (pi);
                  WeightChanged;
                  SendAddItem (pi^);
                  SysMsg('´¿¶È' + IntTostr(Round(pi.Dura/1000)) + 'µÄ' + __SteelStone + 'ÍÚµ½ÁË',2);
               end else
                  Dispose (pi);
            end;
//         48..67: //ÈæÃ¶
         67..91: //ÈæÃ¶
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName (__BlackStone, pi^) then begin
                  //±¤¼®ÀÇ ¼øµµ Àû¿ë....
                  pi.Dura := GetPurity;
                  ItemList.Add (pi);
                  WeightChanged;
                  SendAddItem (pi^);
                  SysMsg('´¿¶È' + IntTostr(Round(pi.Dura/1000)) + 'µÄ' + __BlackStone + 'ÍÚµ½ÁË',2);
               end else
                  Dispose (pi);
            end;
//         68..140: //µ¿±¤¼®
         92..131: //µ¿±¤¼®
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName (__CopperStone, pi^) then begin
                  //±¤¼®ÀÇ ¼øµµ Àû¿ë....
                  pi.Dura := GetPurity;
                  ItemList.Add (pi);
                  WeightChanged;
                  SendAddItem (pi^);
                  SysMsg('´¿¶È' + IntTostr(Round(pi.Dura/1000)) + 'µÄ' + __CopperStone + 'ÍÚµ½ÁË',2);
               end else
                  Dispose (pi);
            end;
//         141..144: //¹é±Ý
         132..137: //¹é±Ý
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName (__Gem1Stone, pi^) then begin
                  //±¤¼®ÀÇ ¼øµµ Àû¿ë....
                  pi.Dura := GetPurity;
                  ItemList.Add (pi);
                  WeightChanged;
                  SendAddItem (pi^);
                  SysMsg('´¿¶È' + IntTostr(Round(pi.Dura/1000)) + 'µÄ' + __Gem1Stone + 'ÍÚµ½ÁË',2);
               end else
                  Dispose (pi);
            end;
//         145..162: //¿¬¿Á
         138..161: //¿¬¿Á
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName (__Gem2Stone, pi^) then begin
                  //±¤¼®ÀÇ ¼øµµ Àû¿ë....
                  pi.Dura := GetPurity;
                  ItemList.Add (pi);
                  WeightChanged;
                  SendAddItem (pi^);
                  SysMsg('´¿¶È' + IntTostr(Round(pi.Dura/1000)) + 'µÄ' + __Gem2Stone + 'ÍÚµ½ÁË',2);
               end else
                  Dispose (pi);
            end;
//         163..187: //È«¿Á¼®
         162..197: //È«¿Á¼®
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName (__Gem4Stone, pi^) then begin
                  //±¤¼®ÀÇ ¼øµµ Àû¿ë....
                  pi.Dura := GetPurity;
                  ItemList.Add (pi);
                  WeightChanged;
                  SendAddItem (pi^);
                  SysMsg('´¿¶È' + IntTostr(Round(pi.Dura/1000)) + 'µÄ' + __Gem4Stone + 'ÍÚµ½ÁË',2);
               end else
                  Dispose (pi);
            end;
         else //ÀÚ¼öÁ¤
            begin
               new (pi);
               if UserEngine.CopyToUserItemFromName (__Gem3Stone, pi^) then begin
                  //±¤¼®ÀÇ ¼øµµ Àû¿ë....
                  pi.Dura := GetPurity;
                  ItemList.Add (pi);
                  WeightChanged;
                  SendAddItem (pi^);
                  SysMsg('´¿¶È' + IntTostr(Round(pi.Dura/1000)) + 'µÄ' + __Gem3Stone + 'ÍÚµ½ÁË',2);
               end else
                  Dispose (pi);
            end;
      end;
   end;
end;

//±¤¼®À» Ä³´Ù.
function  TUserHuman.DigUpMine (x, y: integer): Boolean;
var
   event, ev2: TEvent;
   desc: string;
begin
   Result := FALSE;
   desc := '';
   event := TEvent (PEnvir.GetEvent (x, y));
   if event <> nil then begin
      if (event.EventType = ET_MINE) or (event.EventType = ET_MINE2) or (event.EventType = ET_MINE3) then
         if TStoneMineEvent(event).MineCount > 0 then begin
            TStoneMineEvent(event).MineCount := TStoneMineEvent(event).MineCount - 1;
            if Random((wakuang1)) = 0 then begin  //ÍÚ¿ó¼¸ÂÊ£¬Ä¬ÈÏÊÇ4 ÃüÖÐÂÊ
               ev2 := TEvent (PEnvir.GetEvent (CX, CY));
               if ev2 = nil then begin
                  ev2 := TPileStones.Create (PEnvir, CX, CY, ET_PILESTONES, 5 * 60 * 1000, TRUE);
                  EventMan.AddEvent (ev2);
               end else begin
                  if ev2.EventType = ET_PILESTONES then
                     TPileStones(ev2).EnlargePile;
               end;
               if Random((wakuang2)) = 0 then begin  //ÍÚ¿ó¼¸ÂÊ£¬Ä¬ÈÏÊÇ12 ³ö»õ¼¸ÂÊ
                  if event.EventType = ET_MINE then GetRandomMineral
                  else if event.EventType = ET_MINE2 then GetRandomGems
                  else GetRandomMineral3;
               end;
               desc := '1';
               DoDamageWeapon (5+Random(15));
               Result := TRUE;
            end;
         end else begin
            if GetTickCount - TStoneMineEvent(event).RefillTime > 10 * 60 *1000 then
               TStoneMineEvent(event).Refill;
         end;
   end;
   SendRefMsg (RM_HEAVYHIT, self.Dir, CX, CY, 0, desc);
end;
{       // ÇÔ¼ö°¡ ¾ÈºÒ·ÁÁö´Â °ü°è·Î »èÁ¦ÇÔ 2003-09-23 PDS OBJ_TYPE µµ °Ë»ç¾ÈÇÔ
function  TUserHuman.TargetInSwordLongAttackRange: Boolean;
var
   i, j, k, xx, yy: integer;
   pm: PTMapInfo;
   inrange: Boolean;
   cret: TCreature;
begin
   Result := FALSE;
   if GetNextPosition (PEnvir, CX, CY, Dir, 2, xx, yy) then begin //2Ä­¾Õ
      for i:=xx-1 to xx+1 do
         for j:=yy-1 to yy+1 do begin
            inrange := PEnvir.GetMapXY (i, j, pm);
            if inrange then begin
               if pm.ObjList <> nil then
                  for k:=0 to pm.ObjList.Count-1 do begin      // OBJ_TYPE À» Ã¼Å©¾ÈÇÏ´Âµ¥ ÀÌÇÔ¼ö ÀÚÃ¼°¡ ¾ÈºÒ·ÁÁü
                     cret := TCreature (PTAThing (pm.ObjList[k]).AObject);
                     if cret <> nil then
                        if (not cret.BoGhost) and (not cret.Death) and (cret <> self) and ((abs(CX-cret.CX) >= 2) or (abs(CY-cret.CY) >= 2)) then begin
                           if IsProperTarget (cret) then begin
                              Result := TRUE;
                              exit;
                           end;
                        end;
                  end;
            end;
         end;
   end;
end;
}
function  TUserHuman.HitXY (hitid, x, y, dir: integer): Boolean;
var
   fx, fy: integer;
   pstd: PTStdItem;
begin
   Result := FALSE;
  if RaceServer = RC_USERHUMAN then begin
    if TUserHuman(Self).m_StallMgr.OnSale then begin

      Exit;
    end;
  end;
   //MainOutMessage ('Hit ' + IntToStr(GetTickCount - LatestHitTime));
   if GetTickCount - LatestHitTime < longword(900) - longword(HitSpeed * 60) then begin //600 then
      Inc (HitTimeOverCount);
      Inc (HitTimeOverSum);
   end else begin
      HitTimeOverCount := 0;
      if HitTimeOverSum > 0 then
         Dec (HitTimeOverSum);
   end;

   if (HitTimeOverCount < 4) and (HitTimeOverSum < 6) then begin
      if not self.Death then begin
         if (x = self.CX) and (y = self.CY) then begin    //ÀÚ±âÀÚ¸®¿¡¼­¸¸ °ø°Ý°¡´É
            Result := TRUE;
            LatestHitTime := GetTickCount; //hitÀÌ ¼º°øÇßÀ»¶§¸¸

            if (hitid = CM_HEAVYHIT) and  //¿¹µµ°Ë¹ý¿¡
               (UseItems[U_WEAPON].Index > 0) and  //¹«±âµé µé°í ÀÖ°í
               GetFrontPosition (self, fx, fy)  //¾Õ¿¡ ÀÚ¸®°¡ ÀÖÀ½
            then begin
               if not PEnvir.CanWalk (fx, fy, FALSE{°ãÄ§Çã¿ë¾ÈÇÔ}) then begin  //¾ÕÀÌ ¸·Èù°÷..
                  //°î±ªÀÌÁúÀÎÁö °Ë»çÇÑ´Ù.
                  pstd := UserEngine.GetStdItem (UseItems[U_WEAPON].Index);
                  if pstd <> nil then begin
                     if pstd.Shape = 19 then begin //°î±ªÀÌ
                        if DigUpMine (fx, fy) then //Ä³³»´Ù..
                           SendSocket (nil, '=DIG');
                        Dec (HealthTick, 30); //50
                        Dec (SpellTick, 50);  SpellTick := _MAX(0, SpellTick);
                        Dec (PerHealth, 2);
                        Dec (PerSpell, 2);
                        exit;
                     end;
                  end;
               end;
            end;
            if hitid = CM_HIT       then {inherited} HitHit (nil, HM_HIT, dir);
            if hitid = CM_HEAVYHIT  then {inherited} HitHit (nil, HM_HEAVYHIT, dir);
            if hitid = CM_BIGHIT    then {inherited} HitHit (nil, HM_BIGHIT, dir);
            if hitid = CM_POWERHIT  then {inherited} HitHit (nil, HM_POWERHIT, dir);
            if hitid = CM_LONGHIT   then {inherited} HitHit (nil, HM_LONGHIT, dir);
            if hitid = CM_WIDEHIT   then {inherited} HitHit (nil, HM_WIDEHIT, dir);
            if hitid = CM_FIREHIT   then {inherited} HitHit (nil, HM_FIREHIT, dir);
            // 2003/03/15 ½Å±Ô¹«°ø
            if hitid = CM_CROSSHIT  then {inherited} HitHit (nil, HM_CROSSHIT, dir);
            if hitid = CM_TWINHIT   then {inherited} HitHit (nil, HM_TWINHIT, dir);

            //Power HitÀ» Ä¥¼ö ÀÖ´Â °Ë¹ýÀ» ÀÍÇû°í, °Ë(¹«±â)À» µé°í ÀÖ´Â °æ¿ì
            //³ªÁß¿¡ °Ë°ú, µµ³¢(5, 6)¸¦ ±¸ºÐÇÏ¿© °Ë¹ýÀ» ¸¸µç´Ù.
            if (PPowerHitSkill <> nil) and (UseItems[U_WEAPON].Index > 0) then begin
               Dec (AttackSkillCount);
               if AttackSkillPointCount = AttackSkillCount then begin
                  BoAllowPowerHit := TRUE;
                  SendSocket (nil, '+PWR');  //Å¬¶óÀÌ¾ðÆ®¿¡ ´ÙÀ½¹ø¿¡ powerhitÀ» ¶§¸®µµ·Î ÇÔ
               end;
               if AttackSkillCount <= 0 then begin
                  AttackSkillCount := 7 - PPowerHitSkill.Level;
                  AttackSkillPointCount := Random(AttackSkillCount);
               end;
            end;

            Dec (HealthTick, 30); //100
            Dec (SpellTick, 100);  SpellTick := _MAX(0, SpellTick);
            Dec (PerHealth, 2);
            Dec (PerSpell, 2);
         end else
            Result := FALSE;
      end;
   end else begin
      LatestHitTime := GetTickCount;

      Inc (SpeedHackTimerOverCount);
      if SpeedHackTimerOverCount > 8 then
         EmergencyClose := TRUE;
      if BoViewHackCode then
         MainOutMessage ('[11000-Hit] ' + IntToStr(HitTimeOverCount) + ',' + IntToStr(HitTimeOverSum) + '  ' + UserName + ' ' + TimeToStr(Time));

      //SysMsg ('ÇØÅ· ÇÁ·Î±×·¥ »ç¿ëÀÚ·Î ±â·ÏµÇ¾ú½À´Ï´Ù.', 0);
      //SysMsg ('°èÁ¤ÀÌ ¿µ±¸ ¾Ð·ùµÉ ¼ö ÀÖÀ½À» ¾Ë·Áµå¸³´Ï´Ù.', 0);

      //SysMsg ('CODE=11000 ¿î¿µÀÚ¿Í ¿¬¶ôÇÏ½Ã±â ¹Ù¶ø´Ï´Ù.(mir2master@wemade.com)', 0);
      //EmergencyClose := TRUE;
   end;
end;

function TUserHuman.GetMagic (mid: integer): PTUserMagic;
var
   i: integer;
begin
   Result := nil;
   for i:=0 to MagicList.Count-1 do begin
      if PTUserMagic(MagicList[i]).pDef.MagicId = mid then begin
         Result := PTUserMagic(MagicList[i]);
         break;
      end;
   end;
end;

function  TUserHuman.SpellXY (magid, targetx, targety, targcret: integer): Boolean;
var
   i, ndir, magnum, spell: integer;
   targ: TCreature;
   pum: PTUserMagic;
   fail: Boolean;
begin
   Result := FALSE;
   if RaceServer = RC_USERHUMAN then begin
    if TUserHuman(Self).m_StallMgr.OnSale then begin
      Exit;
    end;
  end;
   //MainOutMessage ('Delay ' + InttoStr(GetTickCount - LatestSpellTime) + ' ' + IntToStr(LatestSpellDelay));
   if (StatusArr[POISON_STONE] <> 0) or
      (StatusArr[POISON_STUN] <> 0) or
      (StatusArr[POISON_ICE] <> 0) then begin  //¸¶ºñµÈ »óÅÂÀÎ °æ¿ì
      exit;
   end;

   if GetTickCount - LatestSpellTime > longword(LatestSpellDelay) then
      SpellTimeOverCount := 0
   else
      Inc (SpellTimeOverCount);

   if SpellTimeOverCount < 2 then begin
      //magid·Î magnum¸¦ ¾ò¾î¿È.
      pum := nil;
      Dec (SpellTick, 450); SpellTick := _MAX(0, SpellTick);

      pum := GetMagic (magid);
      if pum <> nil then begin
         if MagicMan.IsSwordSkill (pum.MagicId) then
            LatestSpellDelay := 0 //pum.pDef.DelayTime + 200  //°Ë¹ý µô·¹ÀÌ
         else
            LatestSpellDelay := pum.pDef.DelayTime + 800; //¸¶¹ý µô·¹ÀÌ
         LatestSpellTime := GetTickCount;  //¸¶Áö¸·À¸·Î ¸¶¹ýÀ» ¾´ ½Ã°£ÀÌ ÀÌÈÄ·Î ºÎÅÍ ¸¶¹ý µô·¹ÀÌ
                                  //ÀÌÈÄ¿¡ µé¾î¿Â ¸¶¹ý¸¸À» Çã¿ëÇÑ´Ù.
         case pum.MagicId of
            SWD_LONGHIT:  //¾î°Ë¼ú
               begin
                  if PLongHitSkill <> nil then begin
                     if not BoAllowLongHit then begin
                        SetAllowLongHit (TRUE);
                        SendSocket (nil, '+LNG');  //¿ø°Å¸® °ø°ÝÀ» ÇÏ°Ô ÇÑ´Ù.
                     end else begin
                        SetAllowLongHit (FALSE);
                        SendSocket (nil, '+ULNG');  //¿ø°Å¸® °ø°ÝÀ» ¾ÈÇÏ°Ô ÇÑ´Ù.
                     end;
                  end;
                  Result := TRUE;
               end;
            SWD_WIDEHIT:  //¹Ý¿ù°Ë¹ý
               begin
                  if PWideHitSkill <> nil then begin
                     if not BoAllowWideHit then begin
                        if BoAllowCrossHit then begin
                           SetAllowCrossHit (FALSE);
                           SendSocket (nil, '+UCRS');  // ±¤Ç³Âü »ç¿ë¾ÈÇÔ
                        end;
                        SetAllowWideHit (TRUE);
                        SendSocket (nil, '+WID');  // ¹Ý¿ù°Ë¹ý »ç¿ë
                     end else begin
                        SetAllowWideHit (FALSE);
                        SendSocket (nil, '+UWID');  // ¹Ý¿ù°Ë¹ý »ç¿ë¾ÈÇÔ
                     end;
                  end;
                  Result := TRUE;
               end;
            SWD_FIREHIT:  //¿°È­°á
               begin
                  if PFireHitSkill <> nil then begin
                     if SetAllowFireHit then begin
                        spell := GetSpellPoint (pum);
                        if (WAbil.MP >= spell) then begin
                           if (spell > 0) then begin
                              DamageSpell (spell);
                              HealthSpellChanged;
                           end;
                           SendSocket (nil, '+FIR');
                        end else
                           ;
                     end;
                     Result := TRUE;
                  end;
               end;
            SWD_RUSHRUSH:  //Ò°Âù³å×²
               begin
                  Result := TRUE;
                  if GetTickCount - LatestRushRushTime > 3000 then begin
                     LatestRushRushTime := GetTickCount;
                     Dir := targetx; //¹æÇâ ÀüÈ¯
                     //if GetTickCount - LatestRushRushTime >= 3000
                     spell := GetSpellPoint (pum);
                     if (spell > 0) then begin
                        if (WAbil.MP >= spell) then begin
                           DamageSpell (spell);
                           HealthSpellChanged;
                        end else
                           exit;  //¸¶·Â¸ðÀÚ¶÷
                     end;
                     if CharRushRush (Dir, pum.Level,true) then begin
                        if (pum.Level < 3) then
                           if Abil.Level >= pum.pDef.NeedLevel[pum.Level] then begin
                              //¼ö·Ã·¹º§¿¡ µµ´ÞÇÑ °æ¿ì
                              TrainSkill (pum, 1 + Random(3));
                              if not CheckMagicLevelup (pum) then
                                 SendDelayMsg (self, RM_MAGIC_LVEXP, 0, pum.pDef.MagicId, pum.Level, pum.CurTrain, '', 1000);
                           end;
                     end;
                  end;
               end;
            // 2003/03/15 ½Å±Ô¹«°ø
            SWD_CROSSHIT:   // ±¤Ç³Âü
               begin
                  if PCrossHitSkill <> nil then begin
                     if not BoAllowCrossHit then begin
                        if BoAllowWideHit then begin
                           SetAllowWideHit (FALSE);
                           SendSocket (nil, '+UWID');  // ¹Ý¿ù°Ë¹ý »ç¿ë¾ÈÇÔ
                        end;
                        SetAllowCrossHit (TRUE);
                        SendSocket (nil, '+CRS');  // ±¤Ç³Âü »ç¿ë
                     end else begin
                        SetAllowCrossHit (FALSE);
                        SendSocket (nil, '+UCRS');  // ±¤Ç³Âü »ç¿ë¾ÈÇÔ
                     end;
                  end;
                  Result := TRUE;
               end;
            SWD_TWINHIT:  //½Ö·æÂü
               begin
                  if PTwinHitSkill <> nil then begin
                     if SetAllowTwinHit then begin
                        spell := GetSpellPoint (pum);
                        if (WAbil.MP >= spell) then begin
                           if (spell > 0) then begin
                              DamageSpell (spell);
                              HealthSpellChanged;
                           end;
                           SendSocket (nil, '+TWN');
                        end else
                           ;
                     end;
                     Result := TRUE;
                  end;
               end;

            else begin
               ndir := GetNextDirection (CX, CY, targetx, targety);
               Dir := ndir;
               targ := nil;
               if CretInNearXY (TCreature(targcret), targetx, targety) then begin
                  targ := TCreature (targcret);
                  targetx := targ.CX;
                  targety := targ.CY;
               end;
               if not DoSpell (pum, targetx, targety, targ) then
                  SendRefMsg (RM_MAGICFIRE_FAIL, 0, 0, 0, 0, '');
               Result := TRUE;
            end;

         end;
      end;
   end else begin
      pum := GetMagic (magid);
      if pum <> nil then begin
         if MagicMan.IsSwordSkill (pum.MagicId) then begin
            SpellTimeOverCount := 0;
            exit;  //°Ë¹ýÅ°..
         end;
      end;
      LatestSpellTime := GetTickCount;

      Inc (SpeedHackTimerOverCount);
      if SpeedHackTimerOverCount > 8 then
         EmergencyClose := TRUE;

      if BoViewHackCode then
         MainOutMessage ('[11001-Mag] ' + IntToStr(SpellTimeOverCount) + '  ' + UserName + ' ' + TimeToStr(Time));

      //SysMsg ('ÇØÅ· ÇÁ·Î±×·¥ »ç¿ëÀÚ·Î ±â·ÏµÇ¾ú½À´Ï´Ù.', 0);
      //SysMsg ('°èÁ¤ÀÌ ¿µ±¸ ¾Ð·ùµÉ ¼ö ÀÖÀ½À» ¾Ë·Áµå¸³´Ï´Ù.', 0);
      //MakePoison (POISON_DECHEALTH, 30, 1);
      //MakePoison (POISON_STONE, 5, 0); //Áßµ¶¿¡ °É¸®°Ô ÇÔ
      //SysMsg ('CODE=11001 ¿î¿µÀÚ¿Í ¿¬¶ôÇÏ½Ã±â ¹Ù¶ø´Ï´Ù.(mir2master@wemade.com)', 0);
      //EmergencyClose := TRUE;
   end;
end;

function  TUserHuman.SitdownXY (x, y, dir: integer): Boolean;
begin
   SendRefMsg (RM_SITDOWN, 0, 0, 0, 0, '');
   Result := TRUE;
end;


{----------------------------------------------------------}

//¿î¿µÀÚ ¸í·É¾î...

procedure TUserHuman.ChangeSkillLevel (magname: string; lv: byte);
var
   i: integer;
begin
   lv := _MIN(3, lv);
   for i:=MagicList.Count-1 downto 0 do begin
      if CompareText (PTUserMagic(MagicList[i]).pDef.MagicName, magname) = 0 then begin
         PTUserMagic(MagicList[i]).Level := lv;
         SendMsg (self, RM_MAGIC_LVEXP, 0,
                  PTUserMagic(MagicList[i]).pDef.MagicId,
                  PTUserMagic(MagicList[i]).Level,
                  PTUserMagic(MagicList[i]).CurTrain,
                  '');
         SysMsg (magname + 'ÐÞÁ¶µÈ¼¶±ä¸üÎª' + IntToStr(lv) + '¼¶', 1);
      end;
   end;
end;

procedure TUserHuman.CmdMakeFullSkill (magname: string; lv: byte);
begin
   ChangeSkillLevel (magname, lv);
end;

procedure TUserHuman.CmdMakeOtherChangeSkillLevel (who, magname: string; lv: byte);
var
   hum: TUserHuman;
begin
   hum := UserEngine.GetUserHuman (who);
   if hum <> nil then begin
      hum.ChangeSkillLevel (magname, lv);
   end else
      SysMsg (who + ' ÎÞ·¨²éÕÒ', 0);
end;

function  TUserHuman.CmdDeletePKPoint (whostr: string) : Boolean;
var
   hum: TUserHuman;
begin
   Result := FALSE;
   hum := UserEngine.GetUserHuman (whostr);
   if hum <> nil then begin
      hum.PlayerKillingPoint := 0; //¸éÁË
      hum.ChangeNameColor;
      SysMsg (whostr + ' : PK point = 0.', 1);
      Result := TRUE;
   end else
      SysMsg (whostr + ' ÎÞ·¨²éÕÒ', 0);
end;

procedure TUserHuman.CmdSendPKPoint (whostr: string ; value : integer );
var
   hum: TUserHuman;
begin
   hum := UserEngine.GetUserHuman (whostr);
   if hum <> nil then
   begin
      if value > 0 then
          hum.PlayerKillingPoint := value;
      SysMsg (whostr + ' PK point = ' + IntToStr(hum.PlayerKillingPoint), 1)
   end else
      SysMsg (whostr + ' ÎÞ·¨²éÕÒ', 0);
end;

procedure TUserHuman.CmdChangeJob (jobname: string);
begin
   if (CompareText (jobname, 'Õ½Ê¿') = 0) or (CompareText (jobname, 'Warrior') = 0) then Job := 0;
   if (CompareText (jobname, '·¨Ê¦') = 0) or (CompareText (jobname, 'Wizard') = 0) then Job := 1;
   if (CompareText (jobname, 'µÀÊ¿') = 0) or (CompareText (jobname, 'Taoist') = 0) then Job := 2;
end;

procedure TUserHuman.CmdChangeHair (value: integer);
begin
  if value = 0 then hair := 0
  else hair := 1;
end;

procedure TUserHuman.CmdChangeSex;
begin
   if Sex = 0 then Sex := 1
   else Sex := 0;
end;

procedure TUserHuman.CmdCallMakeMonster (monname, param: string);
var
   nx, ny, i, count: integer;
begin
   // ¸¶¸®¼ö ¸ÇÃ³À½ÀÚ¸®¿¡ 0ÀÌ ºÙ¾îÀÖÀ¸¸é ¿¡·¯.
   if param <> '' then begin
      if param[1] = '0' then exit;
   end;

   count := _MIN (100, Str_ToInt (param, 1));

   if KOREANVERSION then begin
      // ¸¶¸®¼ö Á¦ÇÑ.
      if count > 50 then exit; //GMË¢¹ÖÎïÊýÁ¿
   end;

   GetFrontPosition (self, nx, ny);
   for i:=0 to count-1 do begin
      UserEngine.AddCreatureSysop (MapName, nx, ny, monname);
   end;
end;

procedure TUserHuman.CmdCallMakeSlaveMonster (monname, param: string; makelv, explv: byte);
var
   nx, ny, i, count: integer;
   cret: TCreature;
begin
   count := Str_ToInt (param, 1);
   if not (makelv in [0..7]) then makelv := 0;
   if not (explv in [0..7]) then explv := 0;
   for i:=0 to count-1 do begin
      if SlaveList.Count < 20 then begin
         GetFrontPosition (self, nx, ny);
         cret := UserEngine.AddCreatureSysop (MapName, nx, ny, monname);
         if cret <> nil then begin
            //if cret.LifeAttrib <> LA_UNDEAD then begin
               cret.Master := self;  //¼ÒÈ¯¸÷À» »¯¾î¿Â´Ù.
               cret.MasterRoyaltyTime := GetTickCount + 10 * 24 * 60 * 60 * 1000;
               cret.SlaveMakeLevel := makelv;
               cret.SlaveExpLevel := explv;
               cret.MasterFeature := GetRelFeature(self); // ºÐ½Å
               cret.UserNameChanged;
               // 2003/03/04 ¸®ÄÝ¸÷ ´É·ÂÄ¡ Àç°è»ê
               cret.RecalcAbilitys;

               SlaveList.Add (cret);
            //end;
         end;
      end;
   end;
end;

procedure TUserHuman.CmdMissionSetting (xstr, ystr: string);
var
   xx, yy: integer;
begin
   if xstr = '' then begin
      BoSysHasMission := FALSE;
      SysMsg ('Mission cancelled.', 1);
   end else begin
      xx := Str_ToInt (xstr, 0);
      yy := Str_ToInt (ystr, 0);
      BoSysHasMission := TRUE;
      SysMission_Map := MapName;
      SysMission_X := xx;
      SysMission_Y := yy;
      SysMsg ('ÈÎÎñ£º¹¥»÷Ä¿±ê' + MapName + ' ' + IntToStr(xx) + ':' + IntToStr(yy), 1);
   end;
end;

procedure TUserHuman.CmdCallMakeMonsterXY (xstr, ystr, monname, countstr: string);
var
   i, count, xx, yy: integer;
   penv: TEnvirnoment;
   cret: TCreature;
begin
   if not BoSysHasMission then begin
      SysMsg ('Ã»ÓÐÖ¸¶¨ÈÎÎñ', 0);
      exit;
   end;
   count := _MIN(500, Str_ToInt (countstr, 0));
   xx := Str_ToInt (xstr, 0);
   yy := Str_ToInt (ystr, 0);
   penv := GrobalEnvir.GetEnvir (SysMission_Map);
   if (penv <> nil) and (count > 0) and (xx > 0) and (yy > 0) then begin
      for i:=0 to count-1 do begin
         cret := UserEngine.AddCreatureSysop (SysMission_Map, xx, yy, monname);
         if (cret <> nil) and (BoSysHasMission) then begin
            cret.BoHasMission := TRUE;
            cret.Mission_X := SysMission_X;
            cret.Mission_Y := SysMission_Y;
         end;
      end;
      SysMsg (SysMission_Map + ' ' + IntToStr(xx) + ':' + IntToStr(yy) + ' => ' + monname + ' ' + IntToStr(count) + 'Ö»', 1);
   end else
      SysMsg ('ÃüÁî´íÎó£º X Y ¹ÖÎï ÊýÁ¿', 0);
end;


procedure TUserHuman.CmdShowEffect(cmdstr, effectstr: string);
var
  etype: Integer;
  FlowerEvent: TFlowerEvent;
begin
  etype := Str_ToInt(effectstr, -1);
  case etype of
    79: FlowerEvent := TFlowerEvent.Create(PEnvir, CX, CY, ET_FIREFLOWER_1, 4000);
    80: FlowerEvent := TFlowerEvent.Create(PEnvir, CX, CY, ET_FIREFLOWER_2, 4000);
    81: FlowerEvent := TFlowerEvent.Create(PEnvir, CX, CY, ET_FIREFLOWER_3, 4000);
    82: FlowerEvent := TFlowerEvent.Create(PEnvir, CX, CY, ET_FIREFLOWER_4, 4000);
    83: FlowerEvent := TFlowerEvent.Create(PEnvir, CX, CY, ET_FIREFLOWER_5, 4000);
    84: FlowerEvent := TFlowerEvent.Create(PEnvir, CX, CY, ET_FIREFLOWER_6, 4000);
    85: FlowerEvent := TFlowerEvent.Create(PEnvir, CX, CY, ET_FIREFLOWER_7, 4000);
    86: FlowerEvent := TFlowerEvent.Create(PEnvir, CX, CY, ET_FIREFLOWER_8, 4000);
    87: FlowerEvent := TFlowerEvent.Create(PEnvir, CX, CY, ET_FIREFLOWER_9, 4000);// ÈçÃÎËÆÎíÑÌ»¨
  else
    FlowerEvent := nil;
  end;
  case etype of
    79..87: EventMan.AddEvent(FlowerEvent);
  else
  end;
end;


procedure TUserHuman.CmdMakeItem (itmname: string; count: integer);
var
   i: integer;
   pu, putemp: PTUserItem;
   pstd: PTStdItem;
   Num : integer;
begin
   //ÇÑ¹ø¿¡ ¸¸µé ¼ö ÀÖ´Â ¾ÆÀÌÅÛ °³¼ö Á¦ÇÑ.
   if count > MAX_OVERLAPITEM then
      exit;

   for i:=0 to count-1 do begin
      if ItemList.Count >= MAXBAGITEM then break;
      new (pu);
      if UserEngine.CopyToUserItemFromName (itmname, pu^) then begin
         pstd := UserEngine.GetStdItem (pu.Index);

         if pstd <> nil then
         begin
            if pstd.Price >= 15000 then begin  //°¡°ÝÀÌ 15000¿ø ÀÌ»óÀº superadmin¸¸ ¸¸µé ¼ö ÀÖ´Ù.
               if not BoTestServer and (UserDegree < UD_SUPERADMIN) then begin
                  Dispose (pu);
                  exit;
               end;
            end;

            //pu.Dura := Round((pu.Dura / 100) * (100 + Random(100)));

            if Random(10) = 2 then      //GMÖ¸ÁîÖÆÔìÎïÆ·¼«Æ·¼¸ÂÊ£¬Ä¬ÈÏif Random(10) = 2 then
               UserEngine.RandomUpgradeItem (pu);

            //¹ÌÁö ½Ã¸®Áî ¾ÆÀÌÅÛÀÎ °æ¿ì
            if pstd.StdMode in [15,19,20,21,22,23,24,26,52,53,54] then begin
               if (pstd.Shape = RING_OF_UNKNOWN) or
                  (pstd.Shape = BRACELET_OF_UNKNOWN) or
                  (pstd.Shape = HELMET_OF_UNKNOWN)
               then begin
                  UserEngine.RandomSetUnknownItem (pu);
               end;
            end;

            //ÃÊ´ëÀåÀ» ¸¸µå´Â °æ¿ì(sonmg)
            if pstd.StdMode = 8 then begin
               if pstd.Shape = SHAPE_OF_INVITATION then begin
                  if GuildAgitInvitationItemSet( pu ) = FALSE then begin
                     SysMsg('ÄãÖ»ÄÜÔÚ×ÔÒÑÐÐ»áÁìÊ¿ÉÏµÃµ½ÑûÇë.', 0);
                     Dispose (pu);
                     exit;
                  end;
               end;
            end;

            //»óÇöÁÖ¸Ó´Ï(DecoItem)¸¦ ¸¸µå´Â °æ¿ì(sonmg)
            if (pstd.StdMode = STDMODE_OF_DECOITEM) and (pstd.Shape = SHAPE_OF_DECOITEM) then begin
               // ÀÓ½Ã·Î ¼³Á¤.
               Num := count;//Random(16);   //ÀÓ½Ã
               if GuildAgitDecoItemSet( pu, Num ) = FALSE then begin
//                   SysMsg('µî·ÏµÈ Àå¿ø¿¡¼­¸¸ ¾ÆÀÌÅÛÀ» ¾òÀ» ¼ö ÀÖ½À´Ï´Ù.', 0);
                  Dispose (pu);
                  exit;
               end;
            end;


            // gadget:Ä«¿îÆ®¾ÆÀÌÅÛ
            if pstd.OverlapItem >= 1 then begin
               pu.Dura := count;

               ItemList.Add (pu);
               SendAddItem (pu^);
            end else begin
               // ±¤¼® ¼øµµ Á¶Àý
               if pstd.StdMode = 43 then begin
                  pu.Dura := GetPurity;
               end;

               ItemList.Add (pu);
               SendAddItem (pu^);
            end;

            if BoEcho then begin
               //MainOutMessage ('ÖÆÔìÎïÆ· [' + UserName + '] ' + itmname + ' ' + IntToStr(pu.MakeIndex));
               //·Î±×³²±è
               AddUserLog ('5'#9 + //¿î¸¸_
                           MapName + ''#9 +
                           IntToStr(CX) + ''#9 +
                           IntToStr(CY) + ''#9 +
                           UserName + ''#9 +
                           UserEngine.GetStdItemName (pu.Index) + ''#9 +
                           IntToStr(pu.MakeIndex) + ''#9 +
                           '1'#9 +
                           '0');
            end;

            // Ä«¿îÆ®¾ÆÀÌÅÛÀº 1¹ø¸¸ ¸¸µç´Ù.
            if pstd.OverlapItem >= 1 then break;  // gadget:Ä«¿îÆ®¾ÆÀÌÅÛ
            // »óÇöÁÖ¸Ó´Ïµµ 1¹ø¸¸ ¸¸µç´Ù.
            if (pstd.StdMode = STDMODE_OF_DECOITEM) and (pstd.Shape = SHAPE_OF_DECOITEM) then break;
         end;
      end else begin
         Dispose (pu);
         break;
      end;
   end;

   WeightChanged;
end;

procedure TUserHuman.CmdSmakeItem (nWhere, nValueType, nValue: Integer);
var
  sShowMsg                  : string;
  StdItem                   : pTStdItem;
begin
  if (nWhere in [0..U_TRANS]) and (nValueType in [0..15]) and (nValue in [0..255]) then begin
    if UseItems[nWhere].Index > 0 then begin
      StdItem := UserEngine.GetStdItem(UseItems[nWhere].Index);
      if StdItem = nil then Exit;

      if nValueType > 13 then begin
        nValue := _MIN(65, nValue);
        if nValueType = 14 then UseItems[nWhere].Dura := nValue * 1000;
        if nValueType = 15 then UseItems[nWhere].DuraMax := nValue * 1000;
      end else begin
        UseItems[nWhere].Desc[nValueType] := nValue;
      end;
      RecalcAbilitys();
      SendUpdateItem(UseItems[nWhere]);
      {sShowMsg := IntToStr(UseItems[nWhere].Index) + '-' + IntToStr(UseItems[nWhere].MakeIndex) + ' ' +
        IntToStr(UseItems[nWhere].Dura) + '/' + IntToStr(UseItems[nWhere].DuraMax) + ' ' +
        IntToStr(UseItems[nWhere].Desc[0]) + '/' +
        IntToStr(UseItems[nWhere].Desc[1]) + '/' +
        IntToStr(UseItems[nWhere].Desc[2]) + '/' +
        IntToStr(UseItems[nWhere].Desc[3]) + '/' +
        IntToStr(UseItems[nWhere].Desc[4]) + '/' +
        IntToStr(UseItems[nWhere].Desc[5]) + '/' +
        IntToStr(UseItems[nWhere].Desc[6]) + '/' +
        IntToStr(UseItems[nWhere].Desc[7]) + '/' +
        IntToStr(UseItems[nWhere].Desc[8]) + '/' +
        IntToStr(UseItems[nWhere].Desc[9]) + '/' +
        IntToStr(UseItems[nWhere].Desc[10]) + '/' +
        IntToStr(UseItems[nWhere].Desc[11]) + '/' +
        IntToStr(UseItems[nWhere].Desc[12]) + '/' +
        IntToStr(UseItems[nWhere].Desc[13]);
        SysMsg(sShowMsg, 0); }
        //MainOutMessage('[ÎïÆ·µ÷Õû] ' + UserName + '(' + StdItem.Name + ' -> ' + sShowMsg + ')');
    end else begin
      SysMsg('ÉíÉÏÃ»ÓÐÕÒµ½Ö¸¶¨ÎïÆ·', 0)
    end;
  end;
end;


procedure TUserHuman.CmdRefineWeapon (dc, mc, sc, acc: integer);
begin
   if dc + mc + sc > 255 then exit;
   if UseItems[U_WEAPON].Index > 0 then begin
      UseItems[U_WEAPON].Desc[0] := dc;
      UseItems[U_WEAPON].Desc[1] := mc;
      UseItems[U_WEAPON].Desc[2] := sc;
      UseItems[U_WEAPON].Desc[5] := acc;
      SendUpdateItem (UseItems[U_WEAPON]);
      RecalcAbilitys;
      SendMsg (self, RM_ABILITY, 0, 0, 0, 0, '');
      SendMsg (self, RM_SUBABILITY, 0, 0, 0, 0, '');
   end;
end;

procedure TUserHuman.CmdDeleteUserGold (whostr, goldstr: string);
var
   hum: TUserHuman;
   igold, svidx: integer;
begin
   hum := UserEngine.GetUserHuman (whostr);
   igold := Str_ToInt (goldstr, 0);
   if igold <= 0 then exit;
   if hum <> nil then begin
      if hum.Gold > igold then //hum.Gold := hum.Gold - igold
         hum.DecGold( igold )
      else begin
         igold := hum.Gold; //½ÇÁ¦·Î »ç¶óÁø¾ç
         hum.Gold := 0;
      end;
      hum.GoldChanged;
      SysMsg (whostr + 'µÄ½ð±Ò ' + IntToStr(igold) + '±»¼õÉÙ', 1);
      //·Î±×³²±è
      AddUserLog ('13'#9 + //µ·»è_
                  MapName + ''#9 +
                  IntToStr(CX) + ''#9 +
                  IntToStr(CY) + ''#9 +
                  UserName + ''#9 +
                  NAME_OF_GOLD{'½ð±Ò'} + ''#9 +
                  IntToStr(igold) + ''#9 +
                  '1'#9 +
                  whostr);
   end else begin
      if UserEngine.FindOtherServerUser (whostr, svidx) then begin
         SysMsg (whostr + 'ÊÇ' + IntToStr(svidx) + '¶Ô·½ÔÚÄÇÌ¨ËÅ·þÆ÷ÉÏ', 1);
      end else
         FrontEngine.ChangeUserInfos (UserName, whostr, -igold);
      //SysMsg (whostr + '´ÔÀÇ µ·À» ' + IntToStr(igold) + 'Àü »èÁ¦ ¸í·É ¼öÇà', 1);
   end;
end;

procedure TUserHuman.CmdStartQuest(Cmd, sQuestName: string);
begin
//  if (m_btPermission < Cmd.nPermissionMin) then begin
//    SysMsg(g_sGameCommandPermissionTooLow, c_Red);
//    Exit;
//  end;
  if (sQuestName = '') then begin
    SysMsg('ÃüÁî¸ñÊ½: @' + Cmd + ' ÎÊ´ðÃû³Æ', 0);
    Exit;
  end;
  UserEngine.SendQuestMsg(sQuestName);
end;

procedure TUserHuman.CmdAddUserGold (whostr, goldstr: string);
var
   hum: TUserHuman;
   igold, svidx: integer;
begin
   hum := UserEngine.GetUserHuman (whostr);
   igold := Str_ToInt (goldstr, 0);
   if igold <= 0 then exit;
   if hum <> nil then begin
      if hum.Gold + igold < AvailableGold then //hum.Gold := hum.Gold + igold
         hum.IncGold( igold )
      else begin
         igold := AvailableGold - hum.Gold; //½ÇÁ¦·Î »ç¶óÁø¾ç
         hum.Gold := AvailableGold;
      end;
      hum.GoldChanged;
      SysMsg (whostr + 'ÒÑÔö¼Ó' + IntToStr(igold) + '½ð±Ò', 1);
      //·Î±×³²±è
//      AddUserLog ('14'#9 + //µ·Ãß_
//                  MapName + ''#9 +
//                  IntToStr(CX) + ''#9 +
//                  IntToStr(CY) + ''#9 +
//                  UserName + ''#9 +
//                  NAME_OF_GOLD{'½ð±Ò'} + ''#9 +
//                  IntToStr(igold) + ''#9 +
//                  '1'#9 +
//                  whostr);
   end else begin
      if UserEngine.FindOtherServerUser (whostr, svidx) then begin
         SysMsg (whostr + 'ÊÇ' + IntToStr(svidx) + '¶Ô·½ÔÚÄÇÌ¨ËÅ·þÆ÷ÉÏ', 1);
      end else
         FrontEngine.ChangeUserInfos (UserName, whostr, igold);
      //SysMsg ('´ÔÀ» Ã£À» ¼ö ¾ø½À´Ï´Ù.', 0);
   end;
end;

procedure TUserHuman.RCmdUserChangeGoldOk (whostr: string; igold: integer);
var
   cmdstr, msgstr: string;
begin
   if igold > 0 then begin
      cmdstr := '14'#9; //µ·Ãß_;
      msgstr := 'Ôö¼ÓÍê³É';
   end else begin
      cmdstr := '13'#9; //µ·»è_;
      msgstr := 'É¾¼õÍê³É';
      igold := -igold;
   end;
   SysMsg (whostr + 'µÄ½ð±Ò' + IntToStr(igold) + '½ð±Ò ' + msgstr, 1);
   //·Î±× ³²±è
//   AddUserLog (cmdstr +
//               MapName + ''#9 +
//               IntToStr(CX) + ''#9 +
//               IntToStr(CY) + ''#9 +
//               UserName + ''#9 +
//               NAME_OF_GOLD{'½ð±Ò'} + ''#9 +
//               IntToStr(igold) + ''#9 +
//               '1'#9 +
//               whostr);
end;

procedure TUserHuman.CmdGameGold(whostr, sctr: string; ival: integer);
var
  svidx: integer;
  Ctr: Char;
  hum: TUserHuman;
begin
  Ctr := '1';
  if (sctr <> '') then Ctr := sctr[1];
  if (whostr = '') or not (Ctr in ['=', '+', '-']) or (ival < 0) or (ival > 2100000000) or ((whostr <> '') and (whostr[1] = '?')) then begin

    Exit;
  end;
  hum := UserEngine.GetUserHuman(whostr);
  if hum <> nil then
  begin
    case sCtr[1] of
      '=': begin
          hum.PotCash := ival;
        end;
      '+': begin
          if (High(Integer) - hum.PotCash) >= ival then
            hum.PotCash := hum.PotCash + ival
          else
          begin
            ival := High(Integer) - hum.PotCash;
            hum.PotCash := High(Integer);
          end;

        end;
      '-': begin
          if hum.PotCash >= ival then
            Dec(hum.PotCash, ival)
          else hum.PotCash := 0;
        end;
    end;
    hum.PotCashChanged;
    SysMsg(whostr +': '+ sCtr[1] + IntToStr(ival) + ' Ôª±¦.', 1);
    {AddUserLog('100'#9 +
      MapName + ''#9 +
      IntToStr(CX) + ''#9 +
      IntToStr(CY) + ''#9 +
      UserName + ''#9 +
      'Ôª±¦' + ''#9 +
      IntToStr(ival) + ''#9 +
      '1'#9 +
      whostr);}
  end else
      SysMsg('ÌáÊ¾: Ã»ÓÐÕÒµ½ÔÚÏßÓÃ»§ ' + whostr + '.', 1);
end;


procedure TUserHuman.CmdGamePoint(whostr, sctr: string; ival: integer);
var
  svidx: integer;
  Ctr: Char;
  hum: TUserHuman;
begin
  Ctr := '1';
  if (sctr <> '') then Ctr := sctr[1];
  if (whostr = '') or not (Ctr in ['=', '+', '-']) or (ival < 0) or (ival > 2100000000) or ((whostr <> '') and (whostr[1] = '?')) then begin

    Exit;
  end;
  hum := UserEngine.GetUserHuman(whostr);
  if hum <> nil then
  begin
    case sCtr[1] of
      '=': begin
          hum.GamePoint := ival;
        end;
      '+': begin
          if (High(Integer) - hum.GamePoint) >= ival then
            hum.GamePoint := hum.GamePoint + ival
          else
          begin
            ival := High(Integer) - hum.GamePoint;
            hum.GamePoint := High(Integer);
          end;

        end;
      '-': begin
          if hum.GamePoint >= ival then
            Dec(hum.GamePoint, ival)
          else hum.GamePoint := 0;
        end;
    end;
    hum.GamePointChanged;
    SysMsg(whostr +': '+ sCtr[1] + IntToStr(ival) + ' »ý·Ö.', 1);
    {AddUserLog('101'#9 +
      MapName + ''#9 +
      IntToStr(CX) + ''#9 +
      IntToStr(CY) + ''#9 +
      UserName + ''#9 +
      '»ý·Ö' + ''#9 +
      IntToStr(ival) + ''#9 +
      '1'#9 +
      whostr); }
  end else
      SysMsg('ÌáÊ¾: Ã»ÓÐÕÒµ½ÔÚÏßÓÃ»§ ' + whostr + '.', 1);
end;


procedure TUserHuman.CmdFreeSpaceMove (map, xstr, ystr: string);
var
   x, y: integer;
   pev: TEnvirnoment;
begin
   pev := GrobalEnvir.GetEnvir (map);
   if pev <> nil then begin
      x := Str_ToInt(xstr, 0);
      y := Str_ToInt(ystr, 0);
      if pev.CanWalk (x, y, TRUE) then begin
         SpaceMove (map, x, y, 0);
      end else
         SysMsg ('Fail', 0);
   end else
      SysMsg ('Fail', 0);
end;

procedure TUserHuman.CmdCharSpaceMove (CharName_: string);
var
   hum : TUserHuman;
   svidx : integer;
begin
   hum := UserEngine.GetUserHuman( Charname_ );

   if hum <> nil then begin
      SpaceMove( hum.PEnvir.MapName , hum.CX , hum.CY + 1 , 0);
   end else begin
      if UserEngine.FindOtherServerUser (Charname_, svidx) then begin
         UserEngine.SendInterMsg (ISM_REQUEST_RECALL, svidx, Charname_ + '/' + UserName);
      end else begin
         SysMsg (CharName_ + ' ÎÞ·¨²éÕÒ.', 0);
      end;
   end;

end;

function TUserHuman.CmdLoverCharSpaceMove (CharName_: string): Boolean;
var
   hum : TUserHuman;
   svidx : integer;
begin
   Result := FALSE;
   hum := UserEngine.GetUserHuman( Charname_ );

   if (hum <> nil) and (PEnvir = hum.PEnvir) then begin
      if {not hum.PEnvir.NoRecall and} not PEnvir.NODEARRECALL then begin    //2023-2-11ÐÞ¸Ä
         SpaceMove( hum.PEnvir.MapName , hum.CX , hum.CY + 1 , 0);
         Result := TRUE;
      end else begin
        SysMsg ('ÎÞ·¨´«ËÍÖÁ '+ CharName_ + ' µÄÇøÓò', 0);
      end;
   end else begin
      if UserEngine.FindOtherServerUser (Charname_, svidx) then begin
         UserEngine.SendInterMsg (ISM_REQUEST_LOVERRECALL, svidx, Charname_ + '/' + UserName);
      end else begin
         SysMsg (CharName_ + ' ÎÞ·¨²éÕÒ', 0);
      end;
   end;

end;

procedure TUserHuman.CmdBreakLoverRelation;
var
   svidx : Integer;
   ReqType : integer;
   OtherName : string;
   hum : TUserHuman;
   strPayment : string;
begin
   // À§ÀÚ·á ³¾ µ·ÀÌ ÀÖ´ÂÁö È®ÀÎ
   if Gold < COMPENSATORY_PAYMENT_ONEWAY then begin
      strPayment := IntToStr(COMPENSATORY_PAYMENT_ONEWAY div 10000);
      BoxMsg('´òÆÆÁµÈË¹ØÏµÐèÒª' + strPayment + 'Íò½ð±Ò', 0);
      exit;
   end;

   if fLover = nil then exit;

   OtherName := fLover.GetLoverName;
   if OtherName = '' then exit;

   ReqType := RsState_Lover;

   //¿¬ÀÎ ÀÏ¹æ ÇØÁ¦(2004/12/13)
   if RelationShipDeleteOther( ReqType , OtherName ) then begin

      //À§ÀÚ·á ÁöºÒ
      if Gold >= COMPENSATORY_PAYMENT_ONEWAY then begin
         DecGold(COMPENSATORY_PAYMENT_ONEWAY);
         GoldChanged;
      end;
      //»óÅÂ º¯°æ(µÐÈ­)
      MakePoison( POISON_SLOW , 3 ,1 );
      //HP, MP º¯°æ(10%)
      WAbil.HP := _MAX(1, WAbil.HP div 10);
      WAbil.MP := _MAX(1, WAbil.MP div 10);

      //Ãæ°Ý ¸Þ½ÃÁö
      SysMsg('¡°ÁµÈË¡±µÄ¹ØÏµÆÆÁÑÁË.ÁµÈË¹ØÏµ½áÊøËùÔì³ÉµÄ³å»÷.', 0);

      hum := UserEngine.GetUserHuman( OtherName );
      if hum <> nil then begin
         hum.RelationShipDeleteOther( ReqType , UserName );

         //·Î±×³²±è
         AddUserLog ('47'#9 + //¿¬ÀÎ_
                     MapName + ''#9 +
                     IntToStr(CX) + ''#9 +
                     IntToStr(CY) + ''#9 +
                     UserName + ''#9 +
                     '0'#9 +
                     '0'#9 +
                     '1'#9 +  //ÀÏ¹æÇØÁ¦:1
                     OtherName);
         ///////////////////////////////////////////////////////////
         //ÀÏ¹æÀûÀÎ ÇØÁ¦ÀÎ °æ¿ì¿¡´Â »ó´ë¿¡°Ô Ãæ°ÝÀÌ ÀüÇØÁöÁö ¾ÊÀ½.
         ///////////////////////////////////////////////////////////
      end else begin
         if UserEngine.FindOtherServerUser (OtherName, svidx) then begin
            UserEngine.SendInterMsg (ISM_LM_DELETE, svidx, OtherName + '/' + UserName + '/' + IntToStr(ReqType));
         end
      end;

   end else begin
      SendDefMessage (SM_LM_RESULT, ReqType, RsError_DontDelete, 0, 0, OtherName);
   end;
end;


procedure TUserHuman.CmdStealth;
begin
    bStealth := not bStealth;

    if bStealth then
         SysMsg ('Stealth On',0)
    else
         SysMsg ('Stealth Off',0);
end;

procedure TUserHuman.CmdCharMove( CharName_ : string ; MapName: string);
var
    hum : TUserHuman;
begin
    hum := UserEngine.GetUserHuman( CharName_ );

    if hum <> nil then
    begin
       if GrobalEnvir.GetEnvir (MapName) <> nil then
       begin
           hum.SendRefMsg (RM_SPACEMOVE_HIDE, 0, 0, 0, 0, '');
           hum.RandomSpaceMove (MapName, 0); //¹«ÀÛÀ§ °ø°£ÀÌµ¿
       end;
    end
    else
    begin
         SysMsg (CharName_ + ' ÎÞ·¨²éÕÒ', 0);
    end;

end;

procedure TUserHuman.CmdRushAttack;
begin
   CharRushRush (Dir, 3,true);
end;

procedure TUserHuman.CmdManLevelChange (man: string; level: integer);
var
   oldlv: integer;
   hum: TUserHuman;
begin
   hum := UserEngine.GetUserHuman (man);
   if hum <> nil then begin
      //MainOutMessage ('µÈ¼¶µ÷Õû [' + man + '] ' + IntToStr(hum.Abil.Level) + ' ±ä¸üÎª ' + IntToStr(level) + ' ²Ù×÷Ô±: ' + UserName);
      oldlv := hum.Abil.Level;
      hum.ChangeLevel (level);
      hum.HasLevelUp (oldlv);
      //·Î±×¸¦ ³²±ä´Ù
      {AddUserLog ('17'#9 + //Å¸·¹_
                  man + ''#9 +
                  IntToStr(oldlv) + ''#9 +
                  IntToStr(level) + ''#9 +
                  UserName + ''#9 +
                  '0'#9 +
                  '0'#9 +
                  '1'#9 +
                  '0'); }
      SysMsg ('[µÈ¼¶µ÷Õû] ' + man + ' ' + IntToStr(oldlv) + '->' + IntToStr(level), 1);
   end;
end;

procedure TUserHuman.CmdManExpChange (man: string; exp: integer);
var
   hum: TUserHuman;
   oldexp: integer;
begin
   hum := UserEngine.GetUserHuman (man);
   if hum <> nil then begin
      //MainOutMessage ('¾­Ñéµ÷Õû [' + man + '] ' + IntToStr(hum.Abil.Exp) + ' ±ä¸üÎª ' + IntToStr(Exp) + ' ²Ù×÷Ô±: ' + UserName);
      oldexp := hum.Abil.Exp;
      hum.Abil.Exp := exp;  //ChangeLevel (level);
      hum.HasLevelUp (Abil.Level);
      //·Î±×¸¦ ³²±ä´Ù
      {AddUserLog ('18'#9 + //Å¸°æ_
                  man + ''#9 +
                  IntToStr(oldexp) + ''#9 +
                  IntToStr(exp) + ''#9 +
                  UserName + ''#9 +
                  '0'#9 +
                  '0'#9 +
                  '1'#9 +
                  '0'); }
      SysMsg ('[¾­ÑéÖµµ÷Õû] ' + man + ' ' + IntToStr(exp), 1);
   end;
end;

procedure TUserHuman.CmdEraseItem (itmname, countstr: string);
var
   i, k, count: integer;
   pu: PTUserItem;
begin
   count := Str_ToInt(countstr, 1);
   for k:=1 to count do begin
      for i:=0 to ItemList.Count-1 do begin
         pu := PTUserItem(ItemList[i]);
         if CompareText (UserEngine.GetStdItemName (pu.Index), itmname) = 0 then begin
            //·Î±×³²±è
            AddUserLog ('6'#9 + //¿î»è_ +
                        MapName + ''#9 +
                        IntToStr(CX) + ''#9 +
                        IntToStr(CY) + ''#9 +
                        UserName + ''#9 +
                        UserEngine.GetStdItemName (pu.Index) + ''#9 +
                        IntToStr(pu.MakeIndex) + ''#9 +
                        '1'#9 +
                        '0');
            SendDelItem (pu^);
            Dispose (pu);
            ItemList.Delete (i);
            break;
         end;
      end;
   end;
end;

procedure TUserHuman.CmdRecallMan (man, map: string);
var
   hum: TUserHuman;
   nx, ny, dx, dy: integer;
   svidx: integer;
begin
   hum := UserEngine.GetUserHuman (man);
   if hum <> nil then begin
      //mapÀÌ¸§ÀÌ ÀÖÀ¸¸é °°Àº ¸ÊÀÇ »ç¶÷¸¸ ¸®ÄÝÇÑ´Ù.
      if map <> '' then begin
         if hum.MapName <> map then exit;
      end;

      if GetFrontPosition (self, nx, ny) then begin
         if GetRecallPosition (nx, ny, 3, dx, dy) then begin
            hum.SendRefMsg (RM_SPACEMOVE_HIDE, 0, 0, 0, 0, '');
            hum.UserSpaceMove (MapName, IntToStr(dx), IntToStr(dy)); //°ø°£ÀÌµ¿
         end;
      end else
         SysMsg ('ÕÙ»½Ê§°Ü', 0);
   end else begin
      if UserEngine.FindOtherServerUser( man, svidx ) then begin
         if GetFrontPosition (self, nx, ny) then begin
            if GetRecallPosition (nx, ny, 3, dx, dy) then begin
               UserEngine.SendInterMsg (ISM_RECALL, svidx, man + '/' + IntToStr(dx) + '/' + IntToStr(dy) + '/' + MapName);
            end;
         end else
            SysMsg ('ÕÙ»½Ê§°Ü', 0);
      end else begin
         SysMsg (man + ' ÎÞ·¨±»ÕÒµ½', 0);
      end;
   end;
end;

// ÁöÁ¤ÇÑ ¸Ê¿¡¼­ ¹«ÀÛÀ§·Î 10¸íÀÇ À¯Àú¸¦ ÀÚ±âÀÚ½ÅÀÌ ÀÖ´Â À§Ä¡·Î ¼ÒÈ¯ÇÔ.
procedure TUserHuman.CmdRecallMap (MapFrom: string);
var
   hum: TUserHuman;
   nx, ny, dx, dy, k: integer;
   list: TList;
   envir: TEnvirnoment;
begin
   if MapFrom = '' then exit;

   //ºÎ¸¦ »ç¶÷
   envir := GrobalEnvir.GetEnvir (MapFrom);
   if envir <> nil then begin
      list := TList.Create;
      UserEngine.GetAreaUsers (envir, 0, 0, 1000, list);
      for k:=0 to list.Count-1 do begin
         hum := TUserHuman (list[k]);
         if hum <> nil then begin
            if GetFrontPosition (self, nx, ny) then begin
               if GetRecallPosition (nx, ny, 3, dx, dy) then begin
                  hum.SendRefMsg (RM_SPACEMOVE_HIDE, 0, 0, 0, 0, '');
                  hum.UserSpaceMove (MapName, IntToStr(dx), IntToStr(dy)); //°ø°£ÀÌµ¿
               end;
            end;
         end;
         //10¸í¸¸ ¼ÒÈ¯
         if k >= (10 - 1) then break;
      end;
      list.Free;
   end;
end;

procedure TUserHuman.GuildMasterRecallMan (man: string; bPersonal: Boolean);
var
   hum: TUserHuman;
   nx, ny, dx, dy: integer;
   svidx: integer;
   guild: TGuild;
begin
   if man = '' then exit;

   // ÀÚ½ÅÀÇ ¹®¿øÀÎÁö °Ë»ç.
   guild := GuildMan.GetGuildFromMemberName (man);
   if MyGuild = guild then begin
      hum := UserEngine.GetUserHuman (man);
      if hum <> nil then begin
         // ¼ÒÈ¯ °ÅºÎ °Ë»ç.
         if hum.BoEnableAgitRecall then begin
            if GetFrontPosition (self, nx, ny) then begin
               if GetRecallPosition (nx, ny, 3, dx, dy) then begin
                  hum.SendRefMsg (RM_SPACEMOVE_HIDE, 0, 0, 0, 0, '');
                  hum.UserSpaceMove (MapName, IntToStr(dx), IntToStr(dy)); //°ø°£ÀÌµ¿
               end;
            end else
               SysMsg ('ÕÙ»½Ê§°Ü', 0);
         end else begin
            if bPersonal then
               SysMsg (man + ' ¾Ü¾øÐÐ»á¹ÜÀíÔ±µÄÕÙ»½.', 0);
         end;
      end else begin
         if GetFrontPosition (self, nx, ny) then begin
            if GetRecallPosition (nx, ny, 3, dx, dy) then begin
               if UserEngine.FindOtherServerUser (man, svidx) then begin
                  UserEngine.SendInterMsg (ISM_GUILDMEMBER_RECALL, svidx, man + '/' + IntToStr(dx) + '/' + IntToStr(dy) + '/' + MapName);
               end else
                  if bPersonal then
                     SysMsg (man + ' ÎÞ·¨²éÕÒ.', 0);
            end;
         end;
      end;
   end else begin
      SysMsg ('Õâ¸öÈËÎ´¼ÓÈë¹óÐÐ»á.', 0);
   end;
end;

procedure TUserHuman.CmdReconnection (saddr, sport: string);
begin
   if (saddr <> '') and (sport <> '') then
      SendMsg (self, RM_RECONNECT, 0, 0, 0, 0, saddr + '/' + sport);
end;


function TUserHuman.ProcessUserCmd(sCmd: string): Boolean;
var
  i                 : Integer;
begin
  Result := False;

  g_UserCmdList.Lock;
  try
    for i := 0 to g_UserCmdList.Count - 1 do begin
      if CompareText(sCmd, g_UserCmdList.Strings[i]) = 0 then begin
        if (QFunctionNpc <> nil) and (RaceServer = RC_USERHUMAN) then begin
          QFunctionNpc.NpcSayTitle(Self, '@UserCmd' + IntToStr(Integer(g_UserCmdList.Objects[i])));
        end;
        Result := True;
        Break;
      end;
    end;
  finally
    g_UserCmdList.UnLock;
  end;
end;

procedure TUserHuman.CmdReloadGuild (gname: string);
var
   g: TGuild;
begin
   if ServerIndex = 0 then begin
      g := GuildMan.GetGuild (gname);
      if g <> nil then begin
         g.LoadGuild;
         SysMsg (gname + 'ÐÐ»á¸üÐÂÍê³É', 0);
         UserEngine.SendInterMsg (ISM_RELOADGUILD, ServerIndex, gname);
      end;
   end else
      SysMsg ('Õâ¸öÃüÁîÖ»ÄÜÊ¹ÓÃÔÚÖ÷ËÅ·þÆ÷ÉÏ', 0);
end;

procedure TUserHuman.CmdReloadGuildAll (gname: string);
begin
   GuildMan.ClearGuildList;
   GuildMan.LoadGuildList;
   SysMsg ('ÖØÐÂ¶ÁÈ¡ËùÓÐÐÐ»áÑ¶Ï¢', 1);
end;

procedure TUserHuman.CmdReloadGuildAgit;
begin
   GuildAgitMan.ClearGuildAgitList;
   GuildAgitMan.LoadGuildAgitList;

   UserEngine.SendInterMsg (ISM_RELOADGUILDAGIT, ServerIndex, '');
   GuildAgitBoardMan.LoadAllGaBoardList('');  //Àå¿ø°Ô½ÃÆÇ
   SysMsg ('ÖØÐÂ¶ÁÈ¡ËùÓÐÐÐ»á³ÉÔ±Ñ¶Ï¢', 1);
end;

procedure TUserHuman.CmdKickUser (uname: string);
var
   hum: TUserHuman;
begin
   hum := UserEngine.GetUserHuman (uname);
   if hum <> nil then begin
      hum.UserRequestClose := TRUE;
   end;
end;

procedure TUserHuman.CmdTingUser (uname: string);
var
   hum: TUserHuman;
begin
   hum := UserEngine.GetUserHuman (uname);
   if hum <> nil then begin
      //hum.UserRequestClose := TRUE;
      hum.RandomSpaceMove (hum.HomeMap, 0);
   end else
      SysMsg (uname + ' ÎÞ·¨²éÕÒ', 0);
end;

procedure TUserHuman.CmdTingRangeUser (uname, rangestr: string);
var
   i, range: integer;
   hum: TUserHuman;
   ulist: TList;
begin
   hum := UserEngine.GetUserHuman (uname);
   range := _MIN(Str_ToInt (rangestr, 2), 10);
   if hum <> nil then begin
      ulist := TList.Create;
      UserEngine.GetAreaUsers (hum.PEnvir, hum.CX, hum.CY, range, ulist);
      for i:=0 to ulist.Count-1 do begin
         hum := TUserHuman(ulist[i]);
         hum.RandomSpaceMove (hum.HomeMap, 0);
      end;
      ulist.Free;
   end else
      SysMsg (uname + ' ÎÞ·¨²éÕÒ', 0);
end;

procedure TUserHuman.CmdEraseMagic (magname: string);
var
   i: integer;
begin
   for i:=MagicList.Count-1 downto 0 do begin
      if CompareText (PTUserMagic(MagicList[i]).pDef.MagicName, magname) = 0 then begin
         SendDelMagic (PTUserMagic(MagicList[i]));
         Dispose (PTUserMagic(MagicList[i]));
         MagicList.Delete (i);
         break;
      end;
   end;
   RecalcAbilitys;
end;

procedure TUserHuman.CmdThisManEraseMagic (whostr, magname: string);
var
   hum: TUserHuman;
begin
   hum := UserEngine.GetUserHuman (whostr);
   if hum <> nil then begin
      hum.CmdEraseMagic (magname);
   end else
      SysMsg (whostr + ' ÎÞ·¨²éÕÒ', 0);
end;

function TUserHuman.GuildDeclareWar (gname: string): Boolean;
var
   guild: TGuild;
   pgw: PTGuildWarInfo;
   flag: Boolean;
   BackResult: integer;
   kindstr: string;
   currenttime: longword;
begin
   Result := FALSE;
   pgw := nil;
   BackResult := 0;
   kindstr := '';
   if IsGuildMaster then begin //¹®ÁÖ¸¸ »ç¿ëÇÒ ¼ö ÀÖ´Â ¸í·É
      if ServerIndex <> 0 then begin
         SysMsg ('Õâ¸öÃüÁî²»ÄÜÔÚ±¾ËÅ·þÆ÷ÉÏÊ¹ÓÃ', 0);
         exit;
      end;
      guild := GuildMan.GetGuild (gname);
      if guild <> nil then begin
         flag := FALSE;
         //ÀÚ½ÅÀÇ ¹®ÆÄ¿Í´Â ¹®ÆÄÀüÀ» ÇÒ ¼ö ¾øÀ½(sonmg 2005/08/17)
         if guild = TGuild(MyGuild) then begin
            SysMsg ('Äú²»ÄÜ¸úÄã×Ô¼ºµÄÐÐ»á¿ªÕ½', 0);
            exit;
         end;
         currenttime := GetTickCount;  //¹®ÆÄ°£ ½Ã°£ ÅëÀÏ
         pgw := TGuild(MyGuild).DeclareGuildWar (guild, currenttime, BackResult);
         if pgw <> nil then begin
            if BackResult = 0 then begin
               //¹®ÆÄÀü ³²Àº ½Ã°£À» Ç¥½ÃÇØ ÁÜ(sonmg 2006/01/18)
               BoxMsg ('ÄúÒÑ¾­ºÍ¸ÃÐÐ»á¿ªÆôÁËÐÐ»áÕ½Õù£¬¾àÀë½áÊø»¹Ê£' + IntToStr((pgw.WarStartTime + pgw.WarRemain - currenttime) div 60 div 1000) + '·ÖÖÓ\Çë½áÊøºóÖØÐÂÉêÇë»òÊ£Óà60·ÖÖÓµÄÊ±ºòÔÙÀ´ÕÒÎÒÉêÇëÊ±¼äÑÓ³¤', 0);
               exit;
            end;
            if guild.DeclareGuildWar (TGuild(MyGuild), currenttime, BackResult) = nil then begin
               pgw.WarStartTime := 0;  //Å¸ÀÓ¾Æ¿ô
            end else begin
               if BackResult > 0 then begin
                  flag := TRUE;

                  if BackResult = 1 then kindstr := 'ÐÐ»áÉêÇë'
                  else if BackResult = 2 then kindstr := 'ÐÐ»áÑÓ³¤'
                  else kindstr := 'ÃÅÇ°';

                  //·Î±×³²±è
                  AddUserLog ('49'#9 + //¹®Àü_
                              MapName + ''#9 +
                              IntToStr(CX) + ''#9 +
                              IntToStr(CY) + ''#9 +
                              UserName + ''#9 +
                              kindstr + ''#9 +
                              '0' + ''#9 +
                              '1'#9 +
                              kindstr);
               end;
            end;
         end;
         if flag then begin //¼º°ø
            UserEngine.SendInterMsg (ISM_RELOADGUILD, ServerIndex, TGuild(MyGuild).GuildName);
            UserEngine.SendInterMsg (ISM_RELOADGUILD, ServerIndex, gname);
            Result := TRUE;
         end;
      end else
         SysMsg (gname + 'ÐÐ»á²»´æÔÚ', 0);
   end else
      SysMsg ('Ö»ÓÐÐÐ»áÕÆÃÅÈË²ÅÄÜÉêÇë', 0);
end;

procedure TUserHuman.CmdCreateGuild (gname, mastername: string);
var
   hum: TUserHuman;
   flag: Boolean;
begin
   if ServerIndex <> 0 then begin
      SysMsg ('Õâ¸öÃüÁîÖ»ÄÜÊ¹ÓÃÔÚÖ÷ËÅ·þÆ÷ÉÏ', 0);
      exit;
   end;
   flag := FALSE;
   hum := UserEngine.GetUserHuman (mastername);
   if hum <> nil then begin
      if GuildMan.GetGuildFromMemberName (mastername) = nil then begin
         if GuildMan.AddGuild (gname, mastername) then begin
            UserEngine.SendInterMsg (ISM_ADDGUILD, ServerIndex, gname + '/' + mastername);
            SysMsg ('Ôö¼ÓÐÐ»á' + gname + ' ' + 'ÕÆÃÅÈË' + ':' + mastername, 0);
            flag := TRUE;
         end;
      end;

      //¹®ÆÄÁ¤º¸¸¦ ´Ù½Ã ÀÐ´Â´Ù.
      with hum do begin
         MyGuild := GuildMan.GetGuildFromMemberName (UserName);
         if MyGuild <> nil then begin  //±æµå¿¡ °¡ÀÔµÇ¾î ÀÖ´Â °æ¿ì
            hum.GuildRankName := TGuild (MyGuild).MemberLogin (self, hum.GuildRank);
            //SendMsg (self, RM_CHANGEGUILDNAME, 0, 0, 0, 0, '');
         end;

         //-----------------------
         //¸í¼ºÄ¡ È¹µæ(¹®ÆÄ»ý¼º:+1000) - ¿î¿µÀÚ ¸í·É¾î
         if ENABLE_FAME_SYSTEM then begin
            hum.IncFamePoint( 1000 );
         end;
         //-----------------------
      end;
   end;
   if not flag then
      SysMsg ('ÐÂÐÐ»á´´½¨Ê§°Ü', 0);
end;

procedure TUserHuman.CmdDeleteGuild (gname: string);
begin
   if ServerIndex <> 0 then begin
      SysMsg ('Õâ¸öÃüÁîÖ»ÄÜÊ¹ÓÃÔÚÖ÷ËÅ·þÆ÷ÉÏ', 0);
      exit;
   end;

   // Àå¿ø ¹ÝÈ¯ ÈÄ ¹®ÆÄ»èÁ¦.
//   GuildAgitMan.DelGuildAgit( gname );

   if GuildMan.DelGuild (gname) then begin
      UserEngine.SendInterMsg (ISM_DELGUILD, ServerIndex, gname);
      SysMsg ('É¾³ýÐÐ»á' + gname, 0);
   end else SysMsg ('É¾³ýÐÐ»áÊ§°Ü', 0);
end;

//¹®ÆÄ ´ëÀüÀÇ Á¡¼ö¸¦ ¾Ë·ÁÁØ´Ù.
procedure TUserHuman.CmdGetGuildMatchPoint (gname: string);
var
   guild: TGuild;
begin
   guild := GuildMan.GetGuild (gname);
   if guild <> nil then begin
      SysMsg (gname + '''µÃ·Ö : ' + IntToStr(guild.MatchPoint), 1);
   end else
      SysMsg (gname + ' is not valid guild name', 0);
end;

//¹®ÆÄ´ëÀüÀ» À§ÇØ¼­ º¯¼ö¸¦ ÃÊ±âÈ­
procedure TUserHuman.CmdStartGuildMatch;
var
   i, k: integer;
   ulist, glist: TList;
   hum: TUserHuman;
   flag: Boolean;
   str: string;
begin
   if PEnvir.Fight3Zone then begin
      ulist := TList.Create;
      glist := TList.Create;
      UserEngine.GetAreaUsers (PEnvir, CX, CY, 1000, ulist);  //Çö¸ÊÀÇ ¸ðµç »ç¶÷
      for i:=0 to ulist.Count-1 do begin
         hum := TUserHuman(ulist[i]);
         if not hum.BoSuperviserMode and not hum.BoSysopMode then begin //¿î¿µÀÚ¸ðµå·Î ÀÖ´Â »ç¶÷Àº Á¡¼ö¿¡°Ô Á¦¿Ü
            hum.FightZoneDieCount := 0;  //Á×Àº Ä«¿îÆ® ÃÊ±âÈ­
            if hum.MyGuild <> nil then begin
               flag := FALSE;
               for k:=0 to glist.Count-1 do begin
                  if glist[k] = hum.MyGuild then begin
                     flag := TRUE;
                     break;
                  end;
               end;
               if not flag then
                  glist.Add (hum.MyGuild);
            end;
         end;
      end;
      SysMsg ('ÐÐ»áÕ½ÕùÒÑ±¬·¢', 1);
      UserEngine.CryCry (RM_CRY, PEnvir, CX, CY, 10000, '- ÐÐ»áÕ½ÕùÒÑ±¬·¢');
      str := '';
      for i:=0 to glist.Count-1 do begin
         TGuild(glist[i]).TeamFightStart;  //¹®ÆÄ´ëÀüº¯¼öÃÊ±âÈ­, Á¡¼ö, ¸â¹ö
         for k:=0 to ulist.Count-1 do begin
            hum := TUserHuman(ulist[k]);
            if hum.MyGuild = glist[i] then begin
               TGuild(glist[i]).TeamFightAdd (hum.UserName);  //¹®ÆÄ´ëÀü¸â¹ö ÀÚµ¿ Ãß°¡
            end;
         end;
         str := str + TGuild(glist[i]).GuildName + ' ';
      end;
      UserEngine.CryCry (RM_CRY, PEnvir, CX, CY, 10000, '- ²Î¼ÓµÄÐÐ»á: ' + str);
      ulist.Free;
      glist.Free;
   end else
      SysMsg ('´ËÃüÁîÔÚ±¾µØÍ¼ÉÏ²»¿ÉÓÃ', 0);
end;

//¹®ÆÄ´ëÀü Á¾·á(³¡)
procedure TUserHuman.CmdEndGuildMatch;
var
   i, k: integer;
   ulist, glist: TList;
   hum: TUserHuman;
   flag: Boolean;
begin
   if PEnvir.Fight3Zone then begin
      ulist := TList.Create;
      glist := TList.Create;
      UserEngine.GetAreaUsers (PEnvir, CX, CY, 1000, ulist);  //Çö¸ÊÀÇ ¸ðµç »ç¶÷
      for i:=0 to ulist.Count-1 do begin
         hum := TUserHuman(ulist[i]);
         if not hum.BoSuperviserMode and not hum.BoSysopMode then begin //¿î¿µÀÚ¸ðµå·Î ÀÖ´Â »ç¶÷Àº Á¡¼ö¿¡°Ô Á¦¿Ü
            if hum.MyGuild <> nil then begin
               flag := FALSE;
               for k:=0 to glist.Count-1 do begin
                  if glist[k] = hum.MyGuild then begin
                     flag := TRUE;
                     break;
                  end;
               end;
               if not flag then
                  glist.Add (hum.MyGuild);
            end;
         end;
      end;
      for i:=0 to glist.Count-1 do begin
         TGuild(glist[i]).TeamFightEnd;
         UserEngine.CryCry (RM_CRY, PEnvir, CX, CY, 10000, ' -' + TGuild(glist[i]).GuildName + 'ÐÐ»áÕ½Õù½áÊø');
      end;
      ulist.Free;
      glist.Free;
   end;
end;

procedure TUserHuman.CmdAnnounceGuildMembersMatchPoint (gname: string);
var
   i, k, n: integer;
   hum: TUserHuman;
   flag: Boolean;
   guild: TGuild;
begin
   if PEnvir.Fight3Zone then begin
      guild := GuildMan.GetGuild (gname);
      if guild <> nil then begin
         UserEngine.CryCry (RM_CRY, PEnvir, CX, CY, 10000, ' -' + gname + 'ÐÐ»áÕ½Õù×Ü½á');
         for i:=0 to guild.FightMemberList.Count-1 do begin
            n := integer(guild.FightMemberList.Objects[i]);
            UserEngine.CryCry (RM_CRY, PEnvir, CX, CY, 10000,
                                 ' -' + guild.FightMemberList[i] + ' : ' +
                                 IntToStr(Hiword(n)) +         //Hiword: ¾òÀºÁ¡¼ö
                                 ' µÃ·Ö / ' +
                                 IntToStr(Loword(n)) + ' ´ÎËÀÍö'); //Loword: Á×ÀºÈ½¼ö
         end;
         UserEngine.CryCry (RM_CRY, PEnvir, CX, CY, 10000,
                              ' -[' + guild.GuildName + '] ' +
                              IntToStr(guild.MatchPoint));
         UserEngine.CryCry (RM_CRY, PEnvir, CX, CY, 10000, '------------------------------------');
      end;
   end else
      SysMsg ('this command is not usable on this map!', 0);
end;

//°°Àº ¸Ê¿¡ ÀÖ´Â ¸ðµç Ä³¸¯ÀÇ ¸®½ºÆ®¸¦ È®ÀÎÇÑ´Ù.
procedure TUserHuman.CmdViewAllCharacterList(mapname: string);
var
   userlist: TList;
   i, listcount: integer;
   TempUser: TCreature;
   env: TEnvirnoment;
begin
   env := nil;
   if mapname <> '' then begin
      env := GrobalEnvir.GetEnvir (mapname);
   end else begin
      env := PEnvir;
   end;

   userlist := TList.Create;

   UserEngine.GetAreaAllUsers(env, userlist);

   listcount := 0;
   for i:=0 to userlist.count-1 do begin
      TempUser := TCreature( UserList[i] );

      // ³ª¸¦ Á¦¿ÜÇÑ »ç¶÷ÀÇ Ä³¸¯¸íÀ» Ãâ·ÂÇÑ´Ù.
      if TempUser.RaceServer = RC_USERHUMAN then begin
         if UserName <> TempUser.UserName then begin
            NilMsg(TempUser.UserName);
            Inc(listcount);
         end;
      end;
   end;
   NilMsg('**Human( ' + IntToStr(listcount) + ' )**');

   userlist.Clear;
   userlist.Free;
end;

function  TUserHuman.GetLevelInfoString (cret: TCreature): string;
begin
   Result := cret.UserName +
              ' µØÍ¼' + cret.MapName +
              ' X' + IntToStr(cret.CX) +
              ' Y' + IntToStr(cret.CY) +
              ' µÈ¼¶' + IntToStr(cret.Abil.Level) +
              ' ¾­Ñé' + IntToStr(cret.Abil.Exp) +
              ' HP' + IntToStr(cret.WAbil.HP) + '/' + IntToStr(cret.WAbil.MaxHP) +
              ' MP' + IntToStr(cret.WAbil.MP) + '/' + IntToStr(cret.WAbil.MaxMP) +
              ' ÍóÁ¦' + IntToStr(cret.WAbil.HandWeight) + '/' + IntToStr(cret.WAbil.MaxHandWeight) +
              ' ¸ºÖØ' + IntToStr(cret.WAbil.WearWeight) + '/' + IntToStr(cret.WAbil.MaxWearWeight) +
              ' ¹¥»÷' + IntToStr(Lobyte(cret.WAbil.DC)) + '-' + IntToStr(Hibyte(cret.WAbil.DC)) +
              ' Ä§·¨' + IntToStr(Lobyte(cret.WAbil.MC)) + '-' + IntToStr(Hibyte(cret.WAbil.MC)) +
              ' µÀÊõ' + IntToStr(Lobyte(cret.WAbil.SC)) + '-' + IntToStr(Hibyte(cret.WAbil.SC)) +
              ' ·ÀÓù' + IntToStr(Lobyte(cret.WAbil.AC)) + '-' + IntToStr(Hibyte(cret.WAbil.AC)) +
              ' Ä§·À' + IntToStr(Lobyte(cret.WAbil.MAC)) + '-' + IntToStr(Hibyte(cret.WAbil.MAC)) +
              ' ×¼È·' + IntToStr(cret.AccuracyPoint) +
              ' Ãô½Ý' + IntToStr(cret.SpeedPoint) +
              ' ÐÒÔË' + IntToStr(cret.Luck) +
              ' Ä§·¨¶ã±Ü' + IntToStr(cret.AntiMagic) +
              ' ¶¾Îï¶ã±Ü' + IntToStr(cret.AntiPoison) +
              // 2003/03/04 Ãß°¡ºÎºÐ
              ' ¹¥»÷ËÙ¶È' + IntToStr(cret.HitSpeed) +
              ' ÉñÊ¥' + IntToStr(cret.AddAbil.UndeadPower) +
              // ¸í¼ºÄ¡ Ãß°¡(2004/10/22)
              ' ½ð±Ò' + IntToStr(cret.Gold) +
              ' Ôª±¦' + IntToStr(cret.POTCASH) +
              ' »ý·Ö' + IntToStr(cret.GamePoint);
end;

procedure TUserHuman.CmdSendUserLevelInfos (whostr: string);
var
   hum: TUserHuman;
begin
   hum := UserEngine.GetUserHuman (whostr);
   if hum <> nil then begin
      SysMsg (GetLevelInfoString (hum), 1);
   end else
      SysMsg (whostr + ' ÎÞ·¨²éÕÒ', 0);
end;

procedure TUserHuman.CmdSendMonsterLevelInfos;
var
   i: integer;
   list: TList;
   cret: TCreature;
begin
   list := TList.Create;
   PEnvir.GetCreatureInRange (CX, CY, 2, TRUE, list);
   for i:=0 to list.Count-1 do begin
      cret := TCreature(list[i]);
      SysMsg (GetLevelInfoString (cret), 1);
   end;
   list.Free;
end;

////////////////////////////////////////////////////
//¿Õ¸÷ÀÇ Á¤º¸¸¦ º¸³»´Â ¸í·É. sonmg(2004/02/06)
////////////////////////////////////////////////////
procedure TUserHuman.CmdSendKingMonsterInfos( monname : string );
var
   cret: TCreature;
   ix, iy: integer;
begin

   try

      // ÇöÀç ¸Ê ÀüÃ¼ ÁÂÇ¥¸¦ °Ë»öÇÏ¿© °¢ ÁÂÇ¥¿¡ ÀÖ´Â Ã¹(GetCreature) ¸ó½ºÅÍ Áß¿¡
      // ·¹º§ÀÌ 60 ÀÌ»óÀÎ ¸ó½ºÅÍ¿¡ ´ëÇÑ Á¤º¸¸¦ º¸³¿.
      for ix := 0 to PEnvir.MapWidth -1 do begin
         for iy := 0 to PEnvir.MapHeight -1 do begin
            cret := TCreature (PEnvir.GetCreature (ix, iy, TRUE));

            if cret <> nil then begin
               if monname = '' then begin
                  if ( cret.Abil.Level >= 60 )and
                     ( cret.RaceServer <> RC_BAMTREE ) and
                     ( cret.RaceServer <> RC_PBMSTONE1)and
                     ( cret.RaceServer <> RC_PBMSTONE2 ) and
                     ( cret.RaceServer > RC_ANIMAL )then
                     SysMsg (GetLevelInfoString (cret), 1);
               end else begin
                  if ( cret.UserName = monname )then
                     SysMsg (GetLevelInfoString (cret), 1);
               end;
            end;
         end;
      end;

   except
      MainOutMessage ('[Exception]TUserHuman.CmdSendKingMonsterInfos' );
   end;

end;

procedure TUserHuman.CmdChangeUserCastleOwner (gldname: string; pass: Boolean);
var
   guild: TGuild;
begin
   guild := GuildMan.GetGuild (gldname);
   if guild <> nil then begin
      //·Î±×³²±è
      AddUserLog ('27'#9 + //»çºÏ_ +
                  UserCastle.OwnerGuildName + ''#9 +
                  '0'#9 +
                  '0'#9 +
                  gldname + ''#9 +
                  UserName + ''#9 +
                  '0'#9 +
                  '1'#9 +
                  '0');
      UserCastle.ChangeCastleOwner (guild);
      if pass then
         UserEngine.SendInterMsg (ISM_CHANGECASTLEOWNER, ServerIndex, gldname);
      SysMsg ('É³°Í¿Ë³Ç±¤ÒÑ¾­±ä¸üÎª[' + gldname + ']ÁË', 1);
   end else
      SysMsg (gldname + 'ÕÒ²»µ½Ö¸¶¨µÄÐÐ»á', 0);
end;

procedure TUserHuman.CmdReloadNpc (cmdstr: string);
var
   i, n: integer;
   list: TList;
begin
   if CompareText (cmdstr, 'all') = 0 then begin

      FrmDB.ReloadNpcs;  //Ãß°¡µÈ npc, »èÁ¦µÈ npc Àû¿ë
      FrmDB.ReloadMerchants;

      n := 0;
      for i:=0 to UserEngine.NpcList.Count-1 do begin
         TNormNpc(UserEngine.NpcList[i]).ClearNpcInfos;
         TNormNpc(UserEngine.NpcList[i]).LoadNpcInfos;
         Inc (n);
      end;
      for i:=0 to UserEngine.MerchantList.Count-1 do begin
         TMerchant(UserEngine.MerchantList[i]).ClearMerchantInfos;
         TMerchant(UserEngine.MerchantList[i]).LoadMerchantInfos;
         Inc (n);
      end;
      SysMsg ('Reload npc information is successful : ' + IntToStr(n), 1);
   end else begin
      list := TList.Create;
      UserEngine.GetNpcXY (PEnvir, CX, CY, 9, list);  //È­¸é¿¡ º¸ÀÌ´Â npc
      for i:=0 to list.Count-1 do begin
         TNormNpc(list[i]).ClearNpcInfos;
         TNormNpc(list[i]).LoadNpcInfos;
         SysMsg (TNormNpc(list[i]).UserName + ' ¼ÓÔØ³É¹¦.', 1);
      end;
      list.Clear;
      UserEngine.GetMerchantXY (PEnvir, CX, CY, 9, list);  //È­¸é¿¡ º¸ÀÌ´Â npc
      for i:=0 to list.Count-1 do begin
         TMerchant(list[i]).ClearMerchantInfos;
         TMerchant(list[i]).LoadMerchantInfos;
         SysMsg (TNormNpc(list[i]).UserName + ' ¼ÓÔØ³É¹¦.', 1);
      end;
      list.Free;
   end;
end;

procedure TUserHuman.CmdReloadNpc2 (cmdstr: string);
var
   i, n: integer;
   list: TList;
begin
   if CompareText (cmdstr, 'alll') = 0 then begin

      FrmDB.ReloadNpcs;  //Ãß°¡µÈ npc, »èÁ¦µÈ npc Àû¿ë
      FrmDB.ReloadMerchants;

      n := 0;
      for i:=0 to UserEngine.NpcList.Count-1 do begin
         TNormNpc(UserEngine.NpcList[i]).ClearNpcInfos;
         TNormNpc(UserEngine.NpcList[i]).LoadNpcInfos;
         Inc (n);
      end;
      for i:=0 to UserEngine.MerchantList.Count-1 do begin
         TMerchant(UserEngine.MerchantList[i]).ClearMerchantInfos;
         TMerchant(UserEngine.MerchantList[i]).LoadMerchantInfos;
         Inc (n);
      end;
      SysMsg ('Reload npc information is successful : ' + IntToStr(n), 1);
   end else begin
      list := TList.Create;
      UserEngine.GetNpcXY (PEnvir, CX, CY, 9, list);  //È­¸é¿¡ º¸ÀÌ´Â npc
      for i:=0 to list.Count-1 do begin
         TNormNpc(list[i]).ClearNpcInfos;
         TNormNpc(list[i]).LoadNpcInfos;
        // SysMsg (TNormNpc(list[i]).UserName + ' ¼ÓÔØ³É¹¦.', 1);
      end;
      list.Clear;
      UserEngine.GetMerchantXY (PEnvir, CX, CY, 9, list);  //È­¸é¿¡ º¸ÀÌ´Â npc
      for i:=0 to list.Count-1 do begin
         TMerchant(list[i]).ClearMerchantInfos;
         TMerchant(list[i]).LoadMerchantInfos;
        // SysMsg (TNormNpc(list[i]).UserName + ' ¼ÓÔØ³É¹¦.', 1);
      end;
      list.Free;
   end;
end;


procedure TUserHuman.CmdOpenCloseUserCastleMainDoor (cmdstr: string);
begin
   if IsGuildMaster and (MyGuild = UserCastle.OwnerGuild) then begin
      if CompareText (cmdstr, '¿ªÆô') = 0 then begin

      end;
      if CompareText (cmdstr, '¹Ø±Õ') = 0 then begin

      end;
   end else
      SysMsg ('´ËÃüÁîÖ»ÓÐÉ³°Í¿ËµÄÁìÖ÷²Å¿ÉÒÔÊ¹ÓÃ', 0);
end;


//pass : true(´Ù¸¥ ¼­¹ö¿¡ Àü´ÞÇÔ, ÁÖÀÇ)
procedure TUserHuman.CmdAddShutUpList (whostr, minstr: string; pass: Boolean);
var
   idx, amin: integer;
begin
   amin := Str_ToInt(minstr, 5);
   if whostr <> '' then begin
      idx := ShutUpList.FFind (whostr);
      if idx >= 0 then begin
         ShutUpList.Objects[idx] := TObject(integer(ShutUpList.Objects[idx]) + amin * 60 * 1000);
      end else begin
         ShutUpList.QAddObject (whostr, TObject(GetCurrentTime + (amin * 60 * 1000)));
      end;
      if pass then  //´Ù¸¥ ¼­¹ö¿¡ Àü´ÞÇÒ °ÍÀÎÁö
         UserEngine.SendInterMsg (ISM_CHATPROHIBITION, ServerIndex, whostr + '/' + IntToStr(amin));
      SysMsg (whostr + '±»½ûÖ¹²Î¼ÓÁÄÌì£º +' + IntToStr(amin) + '·ÖÖÓ', 1);
   end else
      SysMsg (whostr + ' ÎÞ·¨²éÕÒ', 0);
end;

procedure TUserHuman.CmdDelShutUpList (whostr: string; pass: Boolean);
var
   hum: TUserHuman;
   idx: integer;
begin
   idx := ShutUpList.FFind (whostr);
   if idx >= 0 then begin
      ShutUpList.Delete (idx);
      hum := UserEngine.GetUserHuman (whostr);
      if hum <> nil then begin
         hum.SysMsg ('ÄãÒÑ»Ö¸´ÁÄÌì', 1);
      end;
      if pass then  //´Ù¸¥ ¼­¹ö¿¡ Àü´Þ ¿©ºÎ
         UserEngine.SendInterMsg (ISM_CHATPROHIBITIONCANCEL, ServerIndex, whostr);
      SysMsg (whostr + 'ÒÑ½â³ý½ûÑÔ' , 1);
   end else
      SysMsg (whostr + ' ÎÞ·¨²éÕÒ', 0);
end;

procedure TUserHuman.CmdSendShutUpList;
var
   i: integer;
begin
   for i:=0 to ShutUpList.Count-1 do begin
      SysMsg (ShutUpList[i] + ' ' + IntToStr((integer(ShutUpList.Objects[i]) - GetCurrentTime) div 60000) + '·ÖÖÓºó½â³ý', 1);
   end;
end;

procedure TUserHuman.CmdTestTimeDebug (num : integer);
begin
   //Test_Time
   if num >= 0 then
      g_TestTime := num;
end;

procedure TUserHuman.CmdSetCryWide (num : integer);
begin
   if (num >= 50) and (num <= 100) then begin
      g_CryWide := num;
   end else begin
      g_CryWide := 50;
   end;

   SysMsg('ÍâÖÃµÄ·¶Î§ ' + IntToStr(g_CryWide) + 'ÓÃµ÷ÕûÁË', 1);
end;

procedure TUserHuman.CmdOneKillMob;
var
   cret : TCreature;
begin
   cret := GetFrontCret;
   if (cret <> nil) and (cret.RaceServer >= RC_ANIMAL) then begin
      cret.Die;
   end;
end;

procedure TUserHuman.CmdAgitDecoMonCount( agitnum : integer );
var
   count : integer;
begin
   count := 0;
   count := GuildAgitMan.GetAgitDecoMonCount( agitnum );

   SysMsg(IntToStr(agitnum) + 'ÐÐ»á×¯Ô°µÄ×°ÊÎÎï¹²ÓÐ£º: ' + IntToStr(count)+'¸ö¡£', 0);
end;

procedure TUserHuman.CmdAgitDecoMonCountHere;
var
   agitnum : integer;
   count : integer;
begin
   agitnum := 0;
   count := 0;
   agitnum := GuildAgitMan.GetGuildAgitNumFromMapName( MapName );
   if agitnum > 0 then begin
      count := GuildAgitMan.GetAgitDecoMonCount( agitnum );
      BoxMsg('ÐÐ»á×¯Ô°¹²ÓÐ ' + IntToStr(count) + 'Äã¸ö×°ÊÎÎï¡£', 0);
   end;
end;

procedure TUserHuman.CmdAdjustFamePoint (strFameCur, strFameBase : string);
var
   nFameCur, nFameBase : integer;
   FameGrade: integer;
begin
   // ±æÀÌ ÃÊ°ú
   if (Length(strFameCur) > 10) or (Length(strFameBase) > 10) then exit;

   nFameCur := Str_ToInt(strFameCur, -1);
   nFameBase := Str_ToInt(strFameBase, -1);

   if (nFameCur = -1) or (nFameBase = -1) then begin
      SysMsg('Ä¿Ç°µÄÃûÉù' + IntToStr(Abil.FameCur) + ' / ' + IntToStr(Abil.FameBase), 0);
   end else begin
      // À½¼ö °Ë»ç
      if (nFameCur < 0) or (nFameBase < 0) then exit;

      Abil.FameCur := nFameCur;
      Abil.FameBase := nFameBase;
      SysMsg('ÃûÉù' + IntToStr(nFameCur) + ' / ' + IntToStr(nFameBase) + '¶øµ÷Õû', 0);
      //¸í¼ºÄ¡ º¯È­¸¦ ¾Ë·ÁÁÜ.
      SendMsg (self, RM_CHANGEFAMEPOINT, 0, Abil.FameCur, 0, 0, GetFameName(FameGrade));
   end;
end;

procedure TUserHuman.CmdGetFameName;
var
   hum: TUserHuman;
   FameName: string;
   FameGrade: integer;
begin
   FameName := '';
   hum := UserEngine.GetUserHuman (whostr);
   if hum <> nil then begin
      FameName := hum.GetFameName(FameGrade);
      SysMsg(whostr + 'Äã ' + FameName + 'µÈ¼¶' + IntToStr(FameGrade) + ').', 2);
   end else begin
      FameName := GetFameName(FameGrade);
      SysMsg(UserName + 'Äã' + FameName + 'µÈ¼¶' + IntToStr(FameGrade) + ').', 2);
   end;
end;

//µð¹ö±ë ¸í·É¾î
procedure TUserHuman.CmdUserMarketDebug (strParam : string);
begin
   //¿©±â¿¡ µð¹ö±ë ÄÚµå¸¦ Ãß°¡ÇÏ½Ê½Ã¿À(sonmg)
end;

////////////////////////
// SEED ¾ÆÀÌÅÛ Ã¼Å©.
function TUserHuman.CheckSeedItem (psSeed, psJewelry: PTStdItem) : Integer;
begin
   /////////////////////////////////////////////////////////////////////////////
   //¹Ù´ÀÁú¿ëÇ° ¶Ç´Â »À¸ÁÄ¡.
   if psJewelry.StdMode = 61 then begin
      if psJewelry.Shape = SHAPE_OF_NEEDLE then begin
         //¿Ê, Åõ±¸, ½Å¹ß, Çã¸®¶ì
         if psSeed.StdMode in [10,11,15,52,54] then Result := 11
         else Result := 10;
         exit;
      end else if psJewelry.Shape = SHAPE_OF_HAMMER then begin
         //¸ñ°ÉÀÌ, ¹ÝÁö, ÆÈÂî
         if psSeed.StdMode in [19,20,21,22,23,24,26] then Result := 11
         else Result := 10;
         exit;
      end;
   end else if psJewelry.StdMode = 7 then begin
      if psJewelry.Shape = SHAPE_OF_CORD then begin
         //¹­À½ °¡´É ¾ÆÀÌÅÛ.
         if CheckUnbindItem(psSeed.Name) then Result := 21
         else Result := 20;
         exit;
      end;
   end;

   /////////////////////////////////////////////////////////////////////////////
   // ¹«±â,¿Ê,Åõ±¸,¸ñ°ÉÀÌ,¹ÝÁö,ÆÈÂî, ½Å¹ß,º§Æ®.
   if psSeed.StdMode in [5,6,10,11,15,19,20,21,22,23,24,26,52,54] then Result := 2
   else Result := 0;

   // À¯´ÏÅ© ¾ÆÀÌÅÛ Ã¼Å©
   // => UNIQUEITEM ÇÊµå°¡ 00000001(2Áø¼ö)¸¦ Æ÷ÇÔÇÏ¸é Á¦·ÃºÒ°¡(¾÷±×·¹ÀÌµå Æ÷ÇÔ) ¾ÆÀÌÅÛ(sonmg 2005/12/09)
   if {psSeed.UniqueItem = 1} (psSeed.UniqueItem and $01) <> 0 then begin
      Result := 3;
      exit;
   end;

   case psSeed.StdMode of
      5, 6: // ¹«±â
         begin
            if (psJewelry.AC > 0) or (psJewelry.MAC > 0) or (psJewelry.Accurate > 0) or
               (psJewelry.Agility > 0) or (psJewelry.MgAvoid > 0) or
               (psJewelry.ToxAvoid > 0) then begin
                  Result := 1;
            end;
         end;
      10, 11: // ¿Ê
         begin
            if (psJewelry.DC > 0) or (psJewelry.MC > 0) or (psJewelry.SC > 0) or
               (psJewelry.Accurate > 0) or (psJewelry.AtkSpd > 0) or
               (psJewelry.Slowdown > 0) or (psJewelry.Tox > 0) then begin
                  Result := 1;
            end;
         end;
      15: // Åõ±¸
         begin
            if (psJewelry.DC > 0) or (psJewelry.MC > 0) or (psJewelry.SC > 0) or
               (psJewelry.Agility > 0) or (psJewelry.AtkSpd > 0) or
               (psJewelry.Slowdown > 0) or (psJewelry.Tox > 0) then begin
                  Result := 1;
            end;
         end;
      19,20,21: // ¸ñ°ÉÀÌ
         begin
            if (psJewelry.AC > 0) or (psJewelry.MAC > 0) or (psJewelry.Agility > 0) or
               (psJewelry.ToxAvoid > 0) then begin
                  Result := 1;
            end;
         end;
      22: // ¹ÝÁö
         begin
            if (psJewelry.Accurate > 0) or (psJewelry.Agility > 0) or
               (psJewelry.MgAvoid > 0) or (psJewelry.ToxAvoid > 0) then begin
                  Result := 1;
            end;
         end;
      23: // ¹ÝÁö23
         begin
            if (psJewelry.AC > 0) or (psJewelry.MAC > 0) or // Æ¯Á¤ ¹ÝÁö¿¡ ¹æ¾î,¸¶Ç×À» »­(sonmg)
               (psJewelry.Accurate > 0) or (psJewelry.Agility > 0) or
               (psJewelry.MgAvoid > 0) or (psJewelry.ToxAvoid > 0) then begin
                  Result := 1;
            end;
         end;
      24: // ÆÈÂî24
         begin
            if (psJewelry.AC > 0) or (psJewelry.MAC > 0) or // Æ¯Á¤ ÆÈÂî¿¡ ¹æ¾î,¸¶Ç×À» »­(sonmg)
               (psJewelry.AtkSpd > 0) or (psJewelry.MgAvoid > 0) or
               (psJewelry.Slowdown > 0) or (psJewelry.Tox > 0) or
               (psJewelry.ToxAvoid > 0) then begin
                  Result := 1;
            end;
         end;
      26: // ÆÈÂî26
         begin
            if (psJewelry.AtkSpd > 0) or (psJewelry.MgAvoid > 0) or
               (psJewelry.Slowdown > 0) or (psJewelry.Tox > 0) or
               (psJewelry.ToxAvoid > 0) then begin
                  Result := 1;
            end;
         end;
      52: // ½Å¹ß
         begin
            if (psJewelry.DC > 0) or (psJewelry.MC > 0) or (psJewelry.SC > 0) or
               (psJewelry.Accurate > 0) or (psJewelry.AtkSpd > 0) or (psJewelry.MgAvoid > 0) or
               (psJewelry.Slowdown > 0) or (psJewelry.Tox > 0) or
               (psJewelry.ToxAvoid > 0) then begin
                  Result := 1;
            end;
         end;
      54: // º§Æ®
         begin
            if (psJewelry.DC > 0) or (psJewelry.MC > 0) or (psJewelry.SC > 0) or
               (psJewelry.AtkSpd > 0) or (psJewelry.MgAvoid > 0) or
               (psJewelry.Slowdown > 0) or (psJewelry.Tox > 0) then begin
                  Result := 1;
            end;
         end;
      else
         begin
            Result := 0;
         end;
   end;

end;

// º¸¿Á·ù ¾ÆÀÌÅÛ Ã¼Å©.
function TUserHuman.CheckJewelryItem (iStdMode: integer) : Boolean;
begin
   // º¸¿Á,½ÅÁÖ,³ë²ö.
   if iStdMode in [7,60,61] then Result := TRUE
   else Result := FALSE;
end;

/////////////////////////
// ±âÁ¸ ¼Ó¼º°ªÀÇ ÇÕ.
function TUserHuman.SumOfOptions(puSeedItem: PTUserItem; psSeedItem: PTStdItem) : integer;
begin
   Result := 0;
   case psSeedItem.StdMode of
      5,6:  // ¹«±â
         begin
            Result := puSeedItem.Desc[0] + puSeedItem.Desc[1] + puSeedItem.Desc[2]
                     + puSeedItem.Desc[5] + puSeedItem.Desc[12] + puSeedItem.Desc[13];
            // °ø¼Ó ÇÕ»ê(¹«±â).
            Result := Result + _MAX( 0, ItemMan.RealAttackSpeed( puSeedItem.Desc[6] ) );
         end;
      10, 11, 15: // ¿Ê, Åõ±¸
         begin
            Result := puSeedItem.Desc[0] + puSeedItem.Desc[1]
                     + puSeedItem.Desc[11] + puSeedItem.Desc[12] + puSeedItem.Desc[13];
         end;
      19: // ¸ñ°ÉÀÌ19
         begin
            Result := puSeedItem.Desc[0] + puSeedItem.Desc[2]
                     + puSeedItem.Desc[3] + puSeedItem.Desc[4]
                     + puSeedItem.Desc[11] + puSeedItem.Desc[12] + puSeedItem.Desc[13];
            // °ø¼Ó ÇÕ»ê.
            if puSeedItem.Desc[9] > 0 then
               Result := Result + puSeedItem.Desc[9];
         end;
      20: // ¸ñ°ÉÀÌ
         begin
            Result := puSeedItem.Desc[0] + puSeedItem.Desc[1]
                     + puSeedItem.Desc[2] + puSeedItem.Desc[3] + puSeedItem.Desc[4]
                     + puSeedItem.Desc[11] + puSeedItem.Desc[12] + puSeedItem.Desc[13];
            // °ø¼Ó ÇÕ»ê.
            if puSeedItem.Desc[9] > 0 then
               Result := Result + puSeedItem.Desc[9];
         end;
      21: // ¸ñ°ÉÀÌ
         begin
            Result := puSeedItem.Desc[2] + puSeedItem.Desc[3] + puSeedItem.Desc[4]
                     + puSeedItem.Desc[7]
                     + puSeedItem.Desc[11] + puSeedItem.Desc[12] + puSeedItem.Desc[13];
            // °ø¼Ó ÇÕ»ê.
            if puSeedItem.Desc[9] > 0 then
               Result := Result + puSeedItem.Desc[9];
         end;
      22: // ¹ÝÁö
         begin
            Result := puSeedItem.Desc[0] + puSeedItem.Desc[1] + puSeedItem.Desc[2]
                     + puSeedItem.Desc[3] + puSeedItem.Desc[4]
                     + puSeedItem.Desc[12] + puSeedItem.Desc[13];
            // °ø¼Ó ÇÕ»ê.
            if puSeedItem.Desc[9] > 0 then
               Result := Result + puSeedItem.Desc[9];
         end;
      23: // ¹ÝÁö23
         begin
            Result := puSeedItem.Desc[0] + puSeedItem.Desc[2]
                     + puSeedItem.Desc[3] + puSeedItem.Desc[4]
                     + puSeedItem.Desc[12] + puSeedItem.Desc[13];
            // °ø¼Ó ÇÕ»ê.
            if puSeedItem.Desc[9] > 0 then
               Result := Result + puSeedItem.Desc[9];
         end;
      24: // ÆÈÂî24
         begin
            Result := puSeedItem.Desc[0] + puSeedItem.Desc[1] + puSeedItem.Desc[2]
                     + puSeedItem.Desc[3] + puSeedItem.Desc[4];
         end;
      26: // ÆÈÂî
         begin
            Result := puSeedItem.Desc[0] + puSeedItem.Desc[1] + puSeedItem.Desc[2]
                     + puSeedItem.Desc[3] + puSeedItem.Desc[4]
                     + puSeedItem.Desc[11] + puSeedItem.Desc[12];
         end;
      52: // ½Å¹ß
         begin
            Result := puSeedItem.Desc[0] + puSeedItem.Desc[1] + puSeedItem.Desc[3];
         end;
      54: // º§Æ®
         begin
            Result := puSeedItem.Desc[0] + puSeedItem.Desc[1] + puSeedItem.Desc[2]
                     + puSeedItem.Desc[3] + puSeedItem.Desc[13];
         end;
   end;

   // ³»±¸·Â ÇÕ»ê.   //´Ü°è°¡ 1000 -> 2000 À¸·Î Áõ°¡ 2003-11-7 PDS
   Result := Result + _MAX( 0, Round( (puSeedItem.DuraMax - psSeedItem.DuraMax) / 2000 ) );
end;

///////////////////////////////////
// È®·ü °è»ê ¹× °á°ú ¸®ÅÏ ÇÔ¼ö.
function TUserHuman.CalcUpgradeProbability(puSeedItem, puJewelryItem: PTUserItem; psSeedItem, psJewelryItem: PTStdItem; iExecCount: Integer; var iRetSum: integer; var fRetProb: Double) : integer;
var
   iSucceed, iFail: Integer;
   iSum, iRandom: Integer;
   UpProb: array [0..10] of TUpgradeProb;
   i, testSucceed, testNoChange, testFail: Integer;

   /////////////////////////////////////////////
   // È®·ü°ª ÃÊ±âÈ­.(ÀÌ·¸°Ô ÇØµµ µÇ³ª? sonmg)
   procedure InitProbability;
   var
      MFactor, DFactor: integer;
   begin
      MFactor := 4;  //º¸¿ÁÀÇ 1.5¹è·Î ¼öÁ¤(ÀÓ½Ã), ¿ø·¡°ª 4
      DFactor := 2;
      with UpProb[0] do begin
         iBase := 10000;
         iValue[0] := 5000;   //º¸¿Á
         iValue[1] := 5000;   //º¸¿Á
         iValue[2] := 5000;   //º¸¿Á
         //ÀÓ½Ã 1.5¹è·Î ¼öÁ¤
         iValue[3] := Integer(iValue[0] * MFactor div DFactor);   //½ÅÁÖ
         iValue[4] := Integer(iValue[1] * MFactor div DFactor);   //½ÅÁÖ
         iValue[5] := Integer(iValue[2] * MFactor div DFactor);   //½ÅÁÖ
      end;
      with UpProb[1] do begin
         iBase := 10000;
         iValue[0] := 4500;
         iValue[1] := 3000;
         iValue[2] := 4000;
         iValue[3] := Integer(iValue[0] * MFactor div DFactor);
         iValue[4] := Integer(iValue[1] * MFactor div DFactor);
         iValue[5] := Integer(iValue[2] * MFactor div DFactor);
      end;
      with UpProb[2] do begin
         iBase := 10000;
         iValue[0] := 4000;
         iValue[1] := 1000;
         iValue[2] := 3000;
         iValue[3] := Integer(iValue[0] * MFactor div DFactor);
         iValue[4] := Integer(iValue[1] * MFactor div DFactor);
         iValue[5] := Integer(iValue[2] * MFactor div DFactor);
      end;
      with UpProb[3] do begin
         iBase := 10000;
         iValue[0] := 3500;
         iValue[1] := 500;
         iValue[2] := 1000;
         iValue[3] := Integer(iValue[0] * MFactor div DFactor);
         iValue[4] := Integer(iValue[1] * MFactor div DFactor);
         iValue[5] := Integer(iValue[2] * MFactor div DFactor);
      end;
      with UpProb[4] do begin
         iBase := 10000;
         iValue[0] := 3000;
         iValue[1] := 100;
         iValue[2] := 500;
         iValue[3] := Integer(iValue[0] * MFactor div DFactor);
         iValue[4] := Integer(iValue[1] * MFactor div DFactor);
         iValue[5] := Integer(iValue[2] * MFactor div DFactor);
      end;
      with UpProb[5] do begin
         iBase := 10000;
         iValue[0] := 1500;
         iValue[1] := 25;
         iValue[2] := 100;
         iValue[3] := Integer(iValue[0] * MFactor div DFactor);
         iValue[4] := Integer(iValue[1] * MFactor div DFactor);
         iValue[5] := Integer(iValue[2] * MFactor div DFactor);
      end;
      with UpProb[6] do begin
         iBase := 10000;
         iValue[0] := 400;
         iValue[1] := 5;
         iValue[2] := 25;
         iValue[3] := Integer(iValue[0] * MFactor div DFactor);
         iValue[4] := Integer(iValue[1] * MFactor div DFactor);
         iValue[5] := Integer(iValue[2] * MFactor div DFactor);
      end;
      with UpProb[7] do begin
         iBase := 10000;
         iValue[0] := 100;
         iValue[1] := 5;
         iValue[2] := 5;
         iValue[3] := Integer(iValue[0] * MFactor div DFactor);
         iValue[4] := Integer(iValue[1] * MFactor div DFactor);
         iValue[5] := Integer(iValue[2] * MFactor div DFactor);
      end;
      with UpProb[8] do begin
         iBase := 10000;
         iValue[0] := 25;
         iValue[1] := 5;
         iValue[2] := 5;
         iValue[3] := Integer(iValue[0] * MFactor div DFactor);
         iValue[4] := Integer(iValue[1] * MFactor div DFactor);
         iValue[5] := Integer(iValue[2] * MFactor div DFactor);
      end;
      with UpProb[9] do begin
         iBase := 10000;
         iValue[0] := 5;
         iValue[1] := 5;
         iValue[2] := 5;
         iValue[3] := Integer(iValue[0] * MFactor div DFactor);
         iValue[4] := Integer(iValue[1] * MFactor div DFactor);
         iValue[5] := Integer(iValue[2] * MFactor div DFactor);
      end;
      with UpProb[10] do begin
         iBase := 10000;
         iValue[0] := 0;
         iValue[1] := 0;
         iValue[2] := 0;
         iValue[3] := 0;
         iValue[4] := 0;
         iValue[5] := 0;
      end;
   end;
begin
   Result := 2;
   // ¿É¼ÇÇÕ 10 ÀÌ»óÀº ¹«½Ã. ¿É¼ÇÇÕ 0ÀÌÇÏ´Â 0·Î ¸¸µç´Ù.
   iSum := _MIN( 10, _MAX(0, SumOfOptions(puSeedItem, psSeedItem)) );
   iRetSum := iSum;

   // È®·ü°ª ÃÊ±âÈ­.
   InitProbability;

   testSucceed := 0;
   testNoChange := 0;
   testFail := 0;
   iSucceed := 0;
   iFail := 0;
   iRandom := 0;

   if iExecCount < 1 then iExecCount := 1;

   //È®·ü Å×½ºÆ®
   for i := 0 to iExecCount - 1 do begin

      iRandom := Random( UpProb[iSum].iBase );

      if psJewelryItem.StdMode = 60 then begin
         if psSeedItem.StdMode in [5,6] then begin //¹«±â
            iSucceed := _MIN( UpProb[iSum].iBase, Round( UpProb[iSum].iValue[0] * ABS( (29 + BodyLuckLevel + (LOBYTE(psSeedItem.AC) + puSeedItem.Desc[3] - LOBYTE(psSeedItem.MAC) - puSeedItem.Desc[4]) / 2 ) / 30 ) ) );
         end else if psSeedItem.StdMode in [10,11] then begin //¿Ê
            iSucceed := _MIN( UpProb[iSum].iBase, Round( UpProb[iSum].iValue[0] * ABS( (29 + BodyLuckLevel) / 30 ) ) );
         end else if psSeedItem.StdMode in [24,26,52] then begin  //ÆÈÂî,½Å¹ß
            iSucceed := _MIN( UpProb[iSum].iBase, Round( UpProb[iSum].iValue[1] * ABS( (29 + BodyLuckLevel) / 30 ) ) );
         end else if psSeedItem.StdMode = 19 then begin  //¸ñ°ÉÀÌ19
            iSucceed := _MIN( UpProb[iSum].iBase, Round( UpProb[iSum].iValue[2] * ABS( (29 + BodyLuckLevel) / 30 ) ) );
         end else begin //±âÅ¸
            iSucceed := _MIN( UpProb[iSum].iBase, Round( UpProb[iSum].iValue[2] * ABS( (29 + BodyLuckLevel) / 30 ) ) );
         end;

         // °ø¼Ó È®·ü µû·Î Àû¿ë.(sonmg 2003/12/22)
         if psJewelryItem.Shape = 9 then
         begin
            iSucceed := (iSucceed * 60) div 100;
         end;

         iFail := Round( (UpProb[iSum].iBase - iSucceed) {* 0.65}* 0.7 );  //ÀÓ½Ã 0.65·Î ¼öÁ¤, ¿ø·¡°ª 0.7

         if (iRandom >= 0) and (iRandom < iSucceed) then
            Result := 2    //¼º°ø
         else if (iRandom >= iSucceed) and (iRandom < iSucceed + iFail) then
            Result := 1   //ºÒº¯
         else
            Result := 0;   //ÆÄ¼Õ
      end else if psJewelryItem.StdMode = 61 then begin
         if psSeedItem.StdMode in [5,6] then begin //¹«±â
            iSucceed := _MIN( UpProb[iSum].iBase, Round( UpProb[iSum].iValue[3] * ABS( (29 + BodyLuckLevel + (LOBYTE(psSeedItem.AC) + puSeedItem.Desc[3] - LOBYTE(psSeedItem.MAC) - puSeedItem.Desc[4]) / 2 ) / 30 ) ) );
         end else if psSeedItem.StdMode in [10,11] then begin //¿Ê
            iSucceed := _MIN( UpProb[iSum].iBase, Round( UpProb[iSum].iValue[3] * ABS( (29 + BodyLuckLevel) / 30 ) ) );
         end else if psSeedItem.StdMode in [24,26,52] then begin  //ÆÈÂî,½Å¹ß
            iSucceed := _MIN( UpProb[iSum].iBase, Round( UpProb[iSum].iValue[4] * ABS( (29 + BodyLuckLevel) / 30 ) ) );
         end else if psSeedItem.StdMode = 19 then begin  //¸ñ°ÉÀÌ19
            iSucceed := _MIN( UpProb[iSum].iBase, Round( UpProb[iSum].iValue[5] * ABS( (29 + BodyLuckLevel) / 30 ) ) );
         end else begin //±âÅ¸
            iSucceed := _MIN( UpProb[iSum].iBase, Round( UpProb[iSum].iValue[5] * ABS( (29 + BodyLuckLevel) / 30 ) ) );
         end;

         // °ø¼Ó È®·ü µû·Î Àû¿ë.(sonmg 2003/12/22)
         if psJewelryItem.Shape = 9 then
         begin
            iSucceed := (iSucceed * 60) div 100;
         end;

         // ½ÅÁÖ ±úÁöÁö ¾ÊÀ½.
//         iFail := Integer( Round( 0.7 * (UpProb[iSum].iBase - iSucceed) ) );

         if (iRandom >= 0) and (iRandom < iSucceed) then
            Result := 2    //¼º°ø
         else
            Result := 1;   //ºÒº¯
      end;

      fRetProb := iSucceed / UpProb[iSum].iBase;

      if Result = 2 then Inc(testSucceed)
      else if Result = 1 then Inc(testNoChange)
      else if Result = 0 then Inc(testFail);

   //È®·ü Å×½ºÆ®
   end;

   //È®·ü Å×½ºÆ® °á°ú Ãâ·Â
   if iExecCount > 1 then
      SysMsg('È®·üÅ×½ºÆ®(' + IntToStr(iExecCount) + ')¹ø=>'  + '¼º°ø:' + IntToStr(testSucceed)
         + ', ºÒº¯:' + IntToStr(testNoChange) + ', ÆÄ¼Õ:' + IntToStr(testFail), 0);

{
   if psJewelryItem.StdMode = 60 then begin
      MainOutMessage( '[UpgradeItem:È®·ü] ' + UserName + ' ' + seedname + ' ' + jewelryname + '=> '
         + '¿É¼ÇÇÕ:' + IntToStr(iSum) + ', ¼º°øÈ®·ü:' + IntToStr(iSucceed)
         + ', ºÒº¯È®·ü:' + IntToStr(iFail) + ', ÆÄ¼ÕÈ®·ü:' + IntToStr(UpProb[iSum].iBase-iSucceed-iFail)
         + ', iRandom:' + IntToStr(iRandom)
         + ', BodyÇà¿î:' + IntToStr(BodyLuckLevel) + ', ¹«±âÇà¿î:' + IntToStr(LOBYTE(psSeedItem.AC) + puSeedItem.Desc[3])
         + ', ¹«±âºÒ¿î:' + IntToStr(LOBYTE(psSeedItem.MAC) + puSeedItem.Desc[4]) );
   end else if psJewelryItem.StdMode = 61 then begin
      MainOutMessage( '[UpgradeItem:È®·ü] ' + UserName + ' ' + seedname + ' ' + jewelryname + '=> '
         + '¿É¼ÇÇÕ:' + IntToStr(iSum) + ', ¼º°øÈ®·ü:' + IntToStr(iSucceed)
         + ', ºÒº¯È®·ü:' + IntToStr(UpProb[iSum].iBase-iSucceed)
         + ', iRandom:' + IntToStr(iRandom)
         + ', BodyÇà¿î:' + IntToStr(BodyLuckLevel) + ', ¹«±âÇà¿î:' + IntToStr(LOBYTE(psSeedItem.AC) + puSeedItem.Desc[3])
         + ', ¹«±âºÒ¿î:' + IntToStr(LOBYTE(psSeedItem.MAC) + puSeedItem.Desc[4]) );
   end;
}

{$IFDEF DEBUG}   //sonmg
   //¿É¼Ç ÇÕ Ãâ·Â(ÀÓ½Ã)
   if psJewelryItem.StdMode = 60 then begin
      SysMsg('Ñ¡Ïî:' + IntToStr(iSum) + ', ³É¹¦µÄ»úÂÊ:' + IntToStr(iSucceed)
         + ', ²»±äµÄ¸ÅÂÊ:' + IntToStr(iFail) + ', Ëð»µµÄ¸ÅÂÊ:' + IntToStr(UpProb[iSum].iBase-iSucceed-iFail)
         + ', iRandom:' + IntToStr(iRandom), 0);
   end else if psJewelryItem.StdMode = 61 then begin
      SysMsg('Ñ¡Ïî:' + IntToStr(iSum) + ', ³É¹¦µÄ¼¸ÂÊ:' + IntToStr(iSucceed)
         + ', ²»±äµÄ¸ÅÂÊ:' + IntToStr(UpProb[iSum].iBase-iSucceed)
         + ', iRandom:' + IntToStr(iRandom), 0);
   end;
{$ENDIF}   //sonmg
end;

///////////////////////////////////////////////////////////////
//added by sonmg...
procedure TUserHuman.CmdUpgradeItem (seedname, jewelryname: string; seedindex, jewelryindex, ExecCount : integer);
var
   iResult: integer;
   i, j, k, iVal: integer;
   puSeed, puJewelry: PTUserItem;
   psSeed, psJewelry: PTStdItem;
   strResult, strEtc: string;
   iSumOfOption: integer;
   fProbability: Double;
   iBeforeValue, iAfterValue: integer;
   iShape: integer;
   dellist: TStringList;
begin
   puSeed := nil;
   puJewelry := nil;
   psSeed := nil;
   psJewelry := nil;
   iSumOfOption := 0;
   fProbability := 0;
   iBeforeValue := 0;
   iAfterValue := 0;

   try
      if seedname = '' then
         exit;
      if jewelryname = '' then
         exit;

      ///////////////////////////////////////////////////
      // ±¦ÓñÀà¼ì²é
      // ²Ù×÷Ô±ÃüÁî´úÂë£¨Èç¹ûÊÇ²Ù×÷Ô±ÃüÁî£¬Ë÷ÒýÖµÎª 0£©¡£
      if jewelryindex = 0 then begin
         for i := 0 to ItemList.Count-1 do begin
            if UserEngine.GetStdItemIndex(jewelryname) = PTUserItem(ItemList[i]).Index then begin
               psJewelry := UserEngine.GetStdItem (PTUserItem(Itemlist[i]).Index);
               jewelryindex := PTUserItem(ItemList[i]).MakeIndex;
               puJewelry := PTUserItem(ItemList[i]);
               break;
            end;
         end;
         if i = ItemList.Count then exit;
      end else
      // ·Ç²Ù×÷Ô±Õý³£Çé¿ö¡£
      begin
         for i := 0 to ItemList.Count-1 do begin
            if jewelryindex = PTUserItem(ItemList[i]).MakeIndex then begin
               psJewelry := UserEngine.GetStdItem (PTUserItem(Itemlist[i]).Index);
               puJewelry := PTUserItem(ItemList[i]);
               break;
            end;
         end;
         if i = ItemList.Count then exit;
      end;
      ///////////////////////////////////////////////////

      ///////////////////////////////////////////////////
      // SEED ²âÊÔ
      // ²Ù×÷Ô±ÃüÁî´úÂë£¨Èç¹ûÊÇ²Ù×÷Ô±ÃüÁî£¬Ë÷ÒýÖµÎª 0£©¡£
      if seedindex = 0 then begin
         for i := 0 to ItemList.Count-1 do begin
            if UserEngine.GetStdItemIndex(seedname) = PTUserItem(ItemList[i]).Index then begin
               psSeed := UserEngine.GetStdItem (PTUserItem(Itemlist[i]).Index);
               seedindex := PTUserItem(ItemList[i]).MakeIndex;
               puSeed := PTUserItem(ItemList[i]);
               break;
            end;
         end;
         if i = ItemList.Count then exit;
      end else
      // ·Ç²Ù×÷Ô±Õý³£Çé¿ö¡£
      begin
         for i := 0 to ItemList.Count-1 do begin
            if seedindex = PTUserItem(ItemList[i]).MakeIndex then begin
               psSeed := UserEngine.GetStdItem (PTUserItem(Itemlist[i]).Index);
               puSeed := PTUserItem(ItemList[i]);
               break;
            end;
         end;
         if i = ItemList.Count then exit;
      end;
      ///////////////////////////////////////////////////

      if puSeed.Index > 0 then begin
         if CheckJewelryItem(psJewelry.StdMode) then begin
            iVal := CheckSeedItem(psSeed, psJewelry);

            if iVal = 2 then begin
               iResult := CalcUpgradeProbability(puSeed, puJewelry, psSeed, psJewelry, ExecCount, iSumOfOption, fProbability);

               if (iResult <= 2) and (iResult >= 0) then begin
{
                  //¾÷±×·¹ÀÌµå Àü ·Î±× ³²±è(sonmg) => »èÁ¦...
                  AddUserLog ('30'#9 + //¾÷Àü_ +
                              MapName + ''#9 +
                              IntToStr(CX) + ''#9 +
                              IntToStr(CY) + ''#9 +
                              UserName + ''#9 +
                              seedname + ''#9 +
                              IntToStr(seedindex) + ''#9 +
                              '0'#9 +
                              UpgradeResultToStr(puSeed.desc));
}
               end;

               // ¼ìË÷Éý¼¶Ç°µÄÖµ¡£
               iBeforeValue := GetTotalValueOfOption(puSeed, psSeed, psJewelry, strResult, strEtc);

               case iResult of
                  2: begin //³É¹¦
                     // Ö´ÐÐÎïÆ·Éý¼¶¡£
                     if DoUpgradeItem (puSeed, psSeed, psJewelry) = 0 then begin
                        SysMsg('ÎÞ·¨Éý¼¶µÄÊôÐÔ', 0);
                        exit;
                     end;

                     // Éý¼¶ºó»ñµÃ¼ÛÖµ
                     iAfterValue := GetTotalValueOfOption(puSeed, psSeed, psJewelry, strResult, strEtc);

                     // Jewelry ¾ÆÀÌÅÛ »èÁ¦.
//                     SysMsg('»èÁ¦µÈ ¾ÆÀÌÅÛ : ' + IntToStr(puJewelry.MakeIndex), 0);
                     DeletePItemAndSend (puJewelry);

                     // ÀÓ½Ã È®ÀÎ ¸Þ½ÃÁö.
//                     SysMsg (seedname + '(' + IntToStr(seedindex) + ')' + '¿¡ '
//                        + jewelryname + '(' + IntToStr(jewelryindex) + ')' + 'À» ¹ß¶ú½À´Ï´Ù.', 1);
                     SysMsg (seedname + 'Ò»µÀÃ÷ÁÁµÄ¹âÃ¢ÕÕÒ«×Å ' + strResult + strEtc + ' Éý¼¶³É¹¦.', 2);

                     // ¼­¹ö¿¡ ¸Þ½ÃÁö¸¦ ³²±è.
//                     MainOutMessage ('[UpgradeItem:¼º°ø] ' + UserName + ' ' + seedname + ' ' + jewelryname );

                     //¾÷±×·¹ÀÌµå ·Î±× ³²±è(sonmg)
                     AddUserLog ('31'#9 + //¾÷ÈÄ_ +
                                 MapName + ''#9 +
                                 IntToStr(CX) + ''#9 +
                                 IntToStr(CY) + ''#9 +
                                 UserName + ''#9 +
                                 seedname + ''#9 +
                                 IntToStr(seedindex) + ''#9 +
                                 '2'#9 +
                                 UpgradeResultToStr(iSumOfOption, strResult, iBeforeValue, iAfterValue, fProbability, psJewelry.StdMode));

                     //Å¬¶óÀÌ¾ðÆ®·Î °á°ú ¸Þ½ÃÁö Àü¼Û.
                     SendDefMessage (SM_UPGRADEITEM_RESULTT, seedindex, iResult, 0, 0, seedname);

                  end;
                  1: begin // ºÒº¯
                     // ¾÷±×·¹ÀÌµå ÀÌÈÄ °ªÀ» ¾ò¾î¿Â´Ù.
                     iAfterValue := GetTotalValueOfOption(puSeed, psSeed, psJewelry, strResult, strEtc);

                     // Jewelry ¾ÆÀÌÅÛ »èÁ¦.
                     DeletePItemAndSend (puJewelry);

                     // ÀÓ½Ã È®ÀÎ ¸Þ½ÃÁö.
//                     SysMsg (seedname + '(' + IntToStr(seedindex) + ')' + '¿¡ '
//                        + jewelryname + '(' + IntToStr(jewelryindex) + ')' + 'À» ¹ß¶ú½À´Ï´Ù.', 1);
                     SysMsg (seedname + 'Éý¼¶Ê§°Ü.', 1);

                     // ¼­¹ö¿¡ ¸Þ½ÃÁö¸¦ ³²±è.
//                     MainOutMessage ('[UpgradeItem:ºÒº¯] ' + UserName + ' ' + seedname + ' ' + jewelryname );

                     //¾÷±×·¹ÀÌµå ·Î±× ³²±è(sonmg)
                     AddUserLog ('31'#9 + //¾÷ÈÄ_ +
                                 MapName + ''#9 +
                                 IntToStr(CX) + ''#9 +
                                 IntToStr(CY) + ''#9 +
                                 UserName + ''#9 +
                                 seedname + ''#9 +
                                 IntToStr(seedindex) + ''#9 +
                                 '1'#9 +
                                 UpgradeResultToStr(iSumOfOption, strResult, iBeforeValue, iAfterValue, fProbability, psJewelry.StdMode));

                     //Å¬¶óÀÌ¾ðÆ®·Î °á°ú ¸Þ½ÃÁö Àü¼Û.
                     SendDefMessage (SM_UPGRADEITEM_RESULTT, seedindex, iResult, 0, 0, seedname);

                  end;
                  0: begin // ½ÇÆÐ(ÆÄ±«)
                     // ¾÷±×·¹ÀÌµå ÀÌÈÄ °ªÀ» ¾ò¾î¿Â´Ù.
                     iAfterValue := GetTotalValueOfOption(puSeed, psSeed, psJewelry, strResult, strEtc);

                     // Jewelry ¾ÆÀÌÅÛ »èÁ¦.
                     DeletePItemAndSend (puJewelry);
                     // Seed ¾ÆÀÌÅÛ »èÁ¦.
                     DeletePItemAndSendWithFlag ( puSeed, Word(true) ); // ÆÄ±« È¿°ú¸¦ À§ÇÑ ÆÐÅ¶

                     // ÀÓ½Ã È®ÀÎ ¸Þ½ÃÁö.
//                     SysMsg (seedname + '(' + IntToStr(seedindex) + ')' + '¿¡ '
//                        + jewelryname + '(' + IntToStr(jewelryindex) + ')' + 'À» ¹ß¶ú½À´Ï´Ù.', 1);
                     SysMsg ('ÎïÆ·('+ seedname +')±»´Ý»Ù', 0);

                     // ¼­¹ö¿¡ ¸Þ½ÃÁö¸¦ ³²±è.
//                     MainOutMessage ('[UpgradeItem:ÆÄ±«] ' + UserName + ' ' + seedname + ' ' + jewelryname );

                     //¾÷±×·¹ÀÌµå ·Î±× ³²±è(sonmg)
                     AddUserLog ('31'#9 + //¾÷ÈÄ_ +
                                 MapName + ''#9 +
                                 IntToStr(CX) + ''#9 +
                                 IntToStr(CY) + ''#9 +
                                 UserName + ''#9 +
                                 seedname + ''#9 +
                                 IntToStr(seedindex) + ''#9 +
                                 '0'#9 +
                                 UpgradeResultToStr(iSumOfOption, strResult, iBeforeValue, iAfterValue, fProbability, psJewelry.StdMode));

                     //Å¬¶óÀÌ¾ðÆ®·Î °á°ú ¸Þ½ÃÁö Àü¼Û.
                     SendDefMessage (SM_UPGRADEITEM_RESULTT, seedindex, iResult, 0, 0, seedname);

                  end;
                  else begin
                     // ¼­¹ö¿¡ ¸Þ½ÃÁö¸¦ ³²±è.
                     MainOutMessage ('[UpgradeItem] ' + UserName + ' ×öÉý¼¶ÎïÆ·:½á¹ûÖµÒì³£' );
                  end;
               end;  // end of case.
            end else if iVal = 1 then begin
               SysMsg('´ËÎïÆ·¾ßÓÐÎÞ·¨Éý¼¶µÄÊôÐÔ', 0)
            end else if iVal = 3 then begin
               SysMsg('¶ÀÌØÎïÆ·ÎÞ·¨Éý¼¶', 0)
            // ¹Ù´ÀÁú¿ëÇ°, »À¸ÁÄ¡.
            end else if iVal = 11 then begin
               if RepairItemNormaly( psSeed, puSeed ) then begin
                  // ¼ö¸®¿ëÇ° ¾ÆÀÌÅÛ »èÁ¦.
                  DeletePItemAndSend (puJewelry);
               end;
            end else if iVal = 10 then begin
               SysMsg('´ËÎïÆ·ÎÞ·¨ÐÞ¸´', 0)
            // ³ë²ö(2004/05/03 sonmg)
            end else if iVal = 21 then begin
               iShape := FindItemToBindFromBag( 6, psSeed.Name, dellist );
               if iShape >= 0 then begin
                  // ¹­À½ ¾ÆÀÌÅÛ »ý¼º.
                  if BindPotionUnit( iShape, 6 ) = TRUE then begin
                     // ³ë²ö ÇÏ³ª »èÁ¦.
                     DeleteItemFromBag(psJewelry, puJewelry);

                     //»èÁ¦¸ñ·Ï¿¡ Ãß°¡µÈ ¹ÙÀÎµå ¾ÆÀÌÅÛµé »èÁ¦.
                     if dellist <> nil then begin
                        for j:= 0 to dellist.Count-1 do begin
                           for k:= 0 to Itemlist.Count-1 do begin
                              if PTUserItem(ItemList[k]).MakeIndex = Integer(dellist.Objects[j]) then begin
                                 Dispose (PTUserItem(ItemList[k]));
                                 ItemList.Delete (k);
                                 break;
                              end;
                           end;
                        end;

                        SendMsg (self, RM_DELITEMS, 0, integer(dellist), 0, 0, '');
                        //dellist´Â rm_delitem¿¡¼­ free ½ÃÄÑ¾ß ÇÑ´Ù.

                        WeightChanged;
                     end;
                  end else begin
                     SysMsg('´ËÎïÆ·ÎÞ·¨°ó¶¨', 0)
                  end;

               end;
            end else if iVal = 20 then begin
               SysMsg('Õâ¸öÎïÆ·²»ÄÜ±»À¦°ó', 0)
            end else
               SysMsg (seedname + ' : ´ËÎïÆ·²»¿ÉÓÃ', 0);
         end;// else SysMsg (jewelryname + ' : ÀÌ ¾ÆÀÌÅÛÀ¸·Î´Â ¾÷±×·¹ÀÌµåÇÒ ¼ö ¾ø½À´Ï´Ù.', 0);
      end;

   except
      MainOutMessage ('[Exception] TUserHuman.CmdUpgradeItem');
   end;
end;

// ÀÎµ¦½º·Î ±âº»°ª+¾÷±×·¹ÀÌµåµÈ°ªÀ» ¸®ÅÏÇÏ´Â ÇÔ¼ö
function TUserHuman.GetTotalValueOfOption( pu: PTUserItem; pstd, psJewelry: PTStdItem; var strResult, strEtc: string ): integer;
var
   iBaseValue, iUpgradeValue: integer;
   iOptionIndex: integer;
begin
   Result := 0;
   iBaseValue := 0;
   iUpgradeValue := 0;
   iOptionIndex := 0;

   ////////////////////////////////////////////////
   // È·ÈÏÉý¼¶Ñ¡Ïî
   // ½á¹û×Ö·û´®·µ»Ø
   // ½á¹û¿ÉÒÔÉý¼¶(µÚÒ»´Î³öÏÖµÄÑ¡Ïî)
   if psJewelry.DC > 0 then begin
      iOptionIndex := 100;
      strResult := '¹¥»÷';
      strEtc := '+' + IntToStr(psJewelry.DC);
   end else if psJewelry.MC > 0 then begin
      iOptionIndex := 101;
      strResult := 'Ä§·¨';
      strEtc := '+' + IntToStr(psJewelry.MC);
   end else if psJewelry.SC > 0 then begin
      iOptionIndex := 102;
      strResult := 'µÀÊõ';
      strEtc := '+' + IntToStr(psJewelry.SC);
   end else if psJewelry.AC > 0 then begin
      iOptionIndex := 103;
      strResult := '·ÀÓù';
      strEtc := '+' + IntToStr(psJewelry.AC);
   end else if psJewelry.MAC > 0 then begin
      iOptionIndex := 104;
      strResult := 'Ä§·¨·ÀÓù';
      strEtc := '+' + IntToStr(psJewelry.MAC);
   end else if psJewelry.DuraMax > 0 then begin
      iOptionIndex := 105;
      strResult := '³Ö¾Ã';
      strEtc := '+' + IntToStr( Round( psJewelry.DuraMax / 1000 ) );
   end else if psJewelry.Accurate > 0 then begin
      iOptionIndex := 106;
      strResult := '×¼È·';
      strEtc := '+' + IntToStr(psJewelry.Accurate);
   end else if psJewelry.Agility > 0 then begin
      iOptionIndex := 107;
      strResult := 'Ãô½Ý';
      strEtc := '+' + IntToStr(psJewelry.Agility);
   end else if psJewelry.AtkSpd > 0 then begin
      iOptionIndex := 108;
      strResult := '¹¥»÷ËÙ¶È';
      strEtc := '+' + IntToStr(psJewelry.AtkSpd);
   end else if psJewelry.Slowdown > 0 then begin
      iOptionIndex := 109;
      strResult := '³Ù¶Û';
      strEtc := '+' + IntToStr(psJewelry.Slowdown);
   end else if psJewelry.Tox > 0 then begin
      iOptionIndex := 110;
      strResult := 'ÖÐ¶¾';
      strEtc := '+' + IntToStr(psJewelry.Tox);
   end else if psJewelry.MgAvoid > 0 then begin
      iOptionIndex := 111;
      strResult := 'Ä§·¨·ÀÓù';
      strEtc := '+' + IntToStr(psJewelry.MgAvoid);
   end else if psJewelry.ToxAvoid > 0 then begin
      iOptionIndex := 112;
      strResult := 'ÖÐ¶¾·ÀÓù';
      strEtc := '+' + IntToStr(psJewelry.ToxAvoid);
   end;
   ////////////////////////////////////////////////

   // iIndexÖµµÄÒâÒå
   // 100:¹¥»÷, 101:Ä§·¨, 102:µÀÊõ, 103:·ÀÓù, 104:Ä§·À, 105:³Ö¾Ã
   // 106:×¼È·, 107:Ãô½Ý, 108:¹¥»÷ËÙ¶È, 109:Slow+, 110:PA+, 111:Ä§·¨·ÀÓù, 112:ÖÐ¶¾·ÀÓù
   case pstd.StdMode of
      ///////////////////////////////////////////////////////
      5,6:  // ¹«±â
         begin
            case iOptionIndex of
               100://ÆÄ±«
                  begin
                     iBaseValue := HIBYTE(pstd.DC);
                     iUpgradeValue := pu.Desc[0];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               101://¸¶¹ý
                  begin
                     iBaseValue := HIBYTE(pstd.MC);
                     iUpgradeValue := pu.Desc[1];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               102://µµ·Â
                  begin
                     iBaseValue := HIBYTE(pstd.SC);
                     iUpgradeValue := pu.Desc[2];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               103://¹æ¾î
                  begin
                  end;
               104://¸¶Ç×
                  begin
                  end;
               105://³»±¸
                  begin
                     iBaseValue := Round( pstd.DuraMax / 1000 );
                     iUpgradeValue := Round( pu.DuraMax / 1000 );
                     Result := iUpgradeValue;   // ³»±¸
                  end;
               106://Á¤È®
                  begin
                     iBaseValue := HIBYTE(pstd.AC);
                     iUpgradeValue := pu.Desc[5];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               107://¹ÎÃ¸
                  begin
                  end;
               108://°ø¼Ó
                  begin
                     iBaseValue := ItemMan.RealAttackSpeed( HIBYTE( pstd.MAC ) );
                     iUpgradeValue := ItemMan.RealAttackSpeed( pu.Desc[6] );
{
                     //°ø¼ÓÀÌ 10º¸´Ù ÀÛÀ» ¶§¸¦ À§ÇÑ Ã³¸®.
                     if HiByte(pstd.MAC) > 10 then begin
                        iBaseValue := HiByte(pstd.MAC) - 10;
                        iUpgradeValue := pu.Desc[6];
                     end else begin
                        iBaseValue := - HIBYTE(pstd.MAC);
                        iUpgradeValue := pu.Desc[6];
                     end;
}
                     Result := iBaseValue + iUpgradeValue;
                  end;
               109://µÐÈ­
                  begin
                     iBaseValue := pstd.Slowdown;
                     iUpgradeValue := pu.Desc[12];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               110://Áßµ¶
                  begin
                     iBaseValue := pstd.Tox;
                     iUpgradeValue := pu.Desc[13];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               111://¸¶ÀúÇ×
                  begin
                  end;
               112://ÁßÀúÇ×
                  begin
                  end;
            end;//case iOptionIndex of
         end;
      ///////////////////////////////////////////////////////
      10, 11, 15: // ¿Ê, Åõ±¸
         begin
            case iOptionIndex of
               100://ÆÄ±«
                  begin
                     iBaseValue := HIBYTE(pstd.DC);
                     iUpgradeValue := pu.Desc[2];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               101://¸¶¹ý
                  begin
                     iBaseValue := HIBYTE(pstd.MC);
                     iUpgradeValue := pu.Desc[3];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               102://µµ·Â
                  begin
                     iBaseValue := HIBYTE(pstd.SC);
                     iUpgradeValue := pu.Desc[4];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               103://¹æ¾î
                  begin
                     iBaseValue := HIBYTE(pstd.AC);
                     iUpgradeValue := pu.Desc[0];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               104://¸¶Ç×
                  begin
                     iBaseValue := HIBYTE(pstd.MAC);
                     iUpgradeValue := pu.Desc[1];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               105://³»±¸
                  begin
                     iBaseValue := Round( pstd.DuraMax / 1000 );
                     iUpgradeValue := Round( pu.DuraMax / 1000 );
                     Result := iUpgradeValue;   // ³»±¸
                  end;
               106://Á¤È®
                  begin // Åõ±¸¿¡¸¸ ÇØ´ç
                     iBaseValue := pstd.Accurate;
                     iUpgradeValue := pu.Desc[11];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               107://¹ÎÃ¸
                  begin // ¿Ê¿¡¸¸ ÇØ´ç
                     iBaseValue := pstd.Agility;
                     iUpgradeValue := pu.Desc[11];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               108://°ø¼Ó
                  begin
                  end;
               109://µÐÈ­
                  begin
                  end;
               110://Áßµ¶
                  begin
                  end;
               111://¸¶ÀúÇ×
                  begin
                     iBaseValue := pstd.MgAvoid;
                     iUpgradeValue := pu.Desc[12];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               112://ÁßÀúÇ×
                  begin
                     iBaseValue := pstd.ToxAvoid;
                     iUpgradeValue := pu.Desc[13];
                     Result := iBaseValue + iUpgradeValue;
                  end;
            end;//case iOptionIndex of
         end;
      ///////////////////////////////////////////////////////
      19: // ¸ñ°ÉÀÌ19
         begin
            case iOptionIndex of
               100://ÆÄ±«
                  begin
                     iBaseValue := HIBYTE(pstd.DC);
                     iUpgradeValue := pu.Desc[2];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               101://¸¶¹ý
                  begin
                     iBaseValue := HIBYTE(pstd.MC);
                     iUpgradeValue := pu.Desc[3];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               102://µµ·Â
                  begin
                     iBaseValue := HIBYTE(pstd.SC);
                     iUpgradeValue := pu.Desc[4];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               103://¹æ¾î
                  begin
                  end;
               104://¸¶Ç×
                  begin
                  end;
               105://³»±¸
                  begin
                     iBaseValue := Round( pstd.DuraMax / 1000 );
                     iUpgradeValue := Round( pu.DuraMax / 1000 );
                     Result := iUpgradeValue;   // ³»±¸
                  end;
               106://Á¤È®
                  begin
                     iBaseValue := pstd.Accurate;
                     iUpgradeValue := pu.Desc[11];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               107://¹ÎÃ¸
                  begin
                  end;
               108://°ø¼Ó
                  begin
                     iBaseValue := pstd.AtkSpd;
                     iUpgradeValue := pu.Desc[9];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               109://µÐÈ­
                  begin
                     iBaseValue := pstd.Slowdown;
                     iUpgradeValue := pu.Desc[12];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               110://Áßµ¶
                  begin
                     iBaseValue := pstd.Tox;
                     iUpgradeValue := pu.Desc[13];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               111://¸¶ÀúÇ×
                  begin
                     iBaseValue := HIBYTE(pstd.AC);
                     iUpgradeValue := pu.Desc[0];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               112://ÁßÀúÇ×
                  begin
                  end;
            end;//case iOptionIndex of
         end;
      ///////////////////////////////////////////////////////
      20: // ¸ñ°ÉÀÌ
         begin
            case iOptionIndex of
               100://ÆÄ±«
                  begin
                     iBaseValue := HIBYTE(pstd.DC);
                     iUpgradeValue := pu.Desc[2];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               101://¸¶¹ý
                  begin
                     iBaseValue := HIBYTE(pstd.MC);
                     iUpgradeValue := pu.Desc[3];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               102://µµ·Â
                  begin
                     iBaseValue := HIBYTE(pstd.SC);
                     iUpgradeValue := pu.Desc[4];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               103://¹æ¾î
                  begin
                  end;
               104://¸¶Ç×
                  begin
                  end;
               105://³»±¸
                  begin
                     iBaseValue := Round( pstd.DuraMax / 1000 );
                     iUpgradeValue := Round( pu.DuraMax / 1000 );
                     Result := iUpgradeValue;   // ³»±¸
                  end;
               106://Á¤È®
                  begin
                     iBaseValue := HIBYTE(pstd.AC);
                     iUpgradeValue := pu.Desc[0];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               107://¹ÎÃ¸
                  begin
                     iBaseValue := HIBYTE(pstd.MAC);
                     iUpgradeValue := pu.Desc[1];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               108://°ø¼Ó
                  begin
                     iBaseValue := pstd.AtkSpd;
                     iUpgradeValue := pu.Desc[9];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               109://µÐÈ­
                  begin
                     iBaseValue := pstd.Slowdown;
                     iUpgradeValue := pu.Desc[12];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               110://Áßµ¶
                  begin
                     iBaseValue := pstd.Tox;
                     iUpgradeValue := pu.Desc[13];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               111://¸¶ÀúÇ×
                  begin
                     iBaseValue := pstd.MgAvoid;
                     iUpgradeValue := pu.Desc[11];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               112://ÁßÀúÇ×
                  begin
                  end;
            end;//case iOptionIndex of
         end;
      ///////////////////////////////////////////////////////
      21: // ¸ñ°ÉÀÌ
         begin
            case iOptionIndex of
               100://ÆÄ±«
                  begin
                     iBaseValue := HIBYTE(pstd.DC);
                     iUpgradeValue := pu.Desc[2];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               101://¸¶¹ý
                  begin
                     iBaseValue := HIBYTE(pstd.MC);
                     iUpgradeValue := pu.Desc[3];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               102://µµ·Â
                  begin
                     iBaseValue := HIBYTE(pstd.SC);
                     iUpgradeValue := pu.Desc[4];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               103://¹æ¾î
                  begin
                  end;
               104://¸¶Ç×
                  begin
                  end;
               105://³»±¸
                  begin
                     iBaseValue := Round( pstd.DuraMax / 1000 );
                     iUpgradeValue := Round( pu.DuraMax / 1000 );
                     Result := iUpgradeValue;   // ³»±¸
                  end;
               106://Á¤È®
                  begin
                     iBaseValue := pstd.Accurate;
                     iUpgradeValue := pu.Desc[11];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               107://¹ÎÃ¸
                  begin
                  end;
               108://°ø¼Ó
                  begin
                     iBaseValue := LOBYTE(pstd.AC) - LOBYTE(pstd.MAC) + pstd.AtkSpd;
                     iUpgradeValue := pu.Desc[9];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               109://µÐÈ­
                  begin
                     iBaseValue := pstd.Slowdown;
                     iUpgradeValue := pu.Desc[12];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               110://Áßµ¶
                  begin
                     iBaseValue := pstd.Tox;
                     iUpgradeValue := pu.Desc[13];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               111://¸¶ÀúÇ×
                  begin
                     iBaseValue := pstd.MgAvoid;
                     iUpgradeValue := pu.Desc[7];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               112://ÁßÀúÇ×
                  begin
                  end;
            end;//case iOptionIndex of
         end;
      ///////////////////////////////////////////////////////
      22: // ¹ÝÁö
         begin
            case iOptionIndex of
               100://ÆÄ±«
                  begin
                     iBaseValue := HIBYTE(pstd.DC);
                     iUpgradeValue := pu.Desc[2];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               101://¸¶¹ý
                  begin
                     iBaseValue := HIBYTE(pstd.MC);
                     iUpgradeValue := pu.Desc[3];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               102://µµ·Â
                  begin
                     iBaseValue := HIBYTE(pstd.SC);
                     iUpgradeValue := pu.Desc[4];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               103://¹æ¾î
                  begin
                     iBaseValue := HIBYTE(pstd.AC);
                     iUpgradeValue := pu.Desc[0];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               104://¸¶Ç×
                  begin
                     iBaseValue := HIBYTE(pstd.MAC);
                     iUpgradeValue := pu.Desc[1];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               105://³»±¸
                  begin
                     iBaseValue := Round( pstd.DuraMax / 1000 );
                     iUpgradeValue := Round( pu.DuraMax / 1000 );
                     Result := iUpgradeValue;   // ³»±¸
                  end;
               106://Á¤È®
                  begin
                  end;
               107://¹ÎÃ¸
                  begin
                  end;
               108://°ø¼Ó
                  begin
                     iBaseValue := pstd.AtkSpd;
                     iUpgradeValue := pu.Desc[9];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               109://µÐÈ­
                  begin
                     iBaseValue := pstd.Slowdown;
                     iUpgradeValue := pu.Desc[12];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               110://Áßµ¶
                  begin
                     iBaseValue := pstd.Tox;
                     iUpgradeValue := pu.Desc[13];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               111://¸¶ÀúÇ×
                  begin
                  end;
               112://ÁßÀúÇ×
                  begin
                  end;
            end;//case iOptionIndex of
         end;
      ///////////////////////////////////////////////////////
      23: // ¹ÝÁö23
         begin
            case iOptionIndex of
               100://ÆÄ±«
                  begin
                     iBaseValue := HIBYTE(pstd.DC);
                     iUpgradeValue := pu.Desc[2];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               101://¸¶¹ý
                  begin
                     iBaseValue := HIBYTE(pstd.MC);
                     iUpgradeValue := pu.Desc[3];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               102://µµ·Â
                  begin
                     iBaseValue := HIBYTE(pstd.SC);
                     iUpgradeValue := pu.Desc[4];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               103://¹æ¾î
                  begin
                  end;
               104://¸¶Ç×
                  begin
                  end;
               105://³»±¸
                  begin
                     iBaseValue := Round( pstd.DuraMax / 1000 );
                     iUpgradeValue := Round( pu.DuraMax / 1000 );
                     Result := iUpgradeValue;   // ³»±¸
                  end;
               106://Á¤È®
                  begin
                  end;
               107://¹ÎÃ¸
                  begin
                  end;
               108://°ø¼Ó
                  begin
                     iBaseValue := LOBYTE(pstd.AC) - LOBYTE(pstd.MAC) + pstd.AtkSpd;
                     iUpgradeValue := pu.Desc[9];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               109://µÐÈ­
                  begin
                     iBaseValue := pstd.Slowdown;
                     iUpgradeValue := pu.Desc[12];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               110://Áßµ¶
                  begin
                     iBaseValue := pstd.Tox;
                     iUpgradeValue := pu.Desc[13];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               111://¸¶ÀúÇ×
                  begin
                  end;
               112://ÁßÀúÇ×
                  begin
                  end;
            end;//case iOptionIndex of
         end;
      ///////////////////////////////////////////////////////
      24: // ÆÈÂî24
         begin
            case iOptionIndex of
               100://ÆÄ±«
                  begin
                     iBaseValue := HIBYTE(pstd.DC);
                     iUpgradeValue := pu.Desc[2];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               101://¸¶¹ý
                  begin
                     iBaseValue := HIBYTE(pstd.MC);
                     iUpgradeValue := pu.Desc[3];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               102://µµ·Â
                  begin
                     iBaseValue := HIBYTE(pstd.SC);
                     iUpgradeValue := pu.Desc[4];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               103://¹æ¾î
                  begin
                  end;
               104://¸¶Ç×
                  begin
                  end;
               105://³»±¸
                  begin
                     iBaseValue := Round( pstd.DuraMax / 1000 );
                     iUpgradeValue := Round( pu.DuraMax / 1000 );
                     Result := iUpgradeValue;   // ³»±¸
                  end;
               106://Á¤È®
                  begin
                     iBaseValue := HIBYTE(pstd.AC);
                     iUpgradeValue := pu.Desc[0];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               107://¹ÎÃ¸
                  begin
                     iBaseValue := HIBYTE(pstd.MAC);
                     iUpgradeValue := pu.Desc[1];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               108://°ø¼Ó
                  begin
                  end;
               109://µÐÈ­
                  begin
                  end;
               110://Áßµ¶
                  begin
                  end;
               111://¸¶ÀúÇ×
                  begin
                  end;
               112://ÁßÀúÇ×
                  begin
                  end;
            end;//case iOptionIndex of
         end;
      ///////////////////////////////////////////////////////
      26: // ÆÈÂî
         begin
            case iOptionIndex of
               100://ÆÄ±«
                  begin
                     iBaseValue := HIBYTE(pstd.DC);
                     iUpgradeValue := pu.Desc[2];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               101://¸¶¹ý
                  begin
                     iBaseValue := HIBYTE(pstd.MC);
                     iUpgradeValue := pu.Desc[3];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               102://µµ·Â
                  begin
                     iBaseValue := HIBYTE(pstd.SC);
                     iUpgradeValue := pu.Desc[4];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               103://¹æ¾î
                  begin
                     iBaseValue := HIBYTE(pstd.AC);
                     iUpgradeValue := pu.Desc[0];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               104://¸¶Ç×
                  begin
                     iBaseValue := HIBYTE(pstd.MAC);
                     iUpgradeValue := pu.Desc[1];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               105://³»±¸
                  begin
                     iBaseValue := Round( pstd.DuraMax / 1000 );
                     iUpgradeValue := Round( pu.DuraMax / 1000 );
                     Result := iUpgradeValue;   // ³»±¸
                  end;
               106://Á¤È®
                  begin
                     iBaseValue := pstd.Accurate;
                     iUpgradeValue := pu.Desc[11];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               107://¹ÎÃ¸
                  begin
                     iBaseValue := pstd.Agility;
                     iUpgradeValue := pu.Desc[12];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               108://°ø¼Ó
                  begin
                  end;
               109://µÐÈ­
                  begin
                  end;
               110://Áßµ¶
                  begin
                  end;
               111://¸¶ÀúÇ×
                  begin
                  end;
               112://ÁßÀúÇ×
                  begin
                  end;
            end;//case iOptionIndex of
         end;
      ///////////////////////////////////////////////////////
      52: // ½Å¹ß
         begin
            case iOptionIndex of
               100://ÆÄ±«
                  begin
                  end;
               101://¸¶¹ý
                  begin
                  end;
               102://µµ·Â
                  begin
                  end;
               103://¹æ¾î
                  begin
                     iBaseValue := HIBYTE(pstd.AC);
                     iUpgradeValue := pu.Desc[0];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               104://¸¶Ç×
                  begin
                     iBaseValue := HIBYTE(pstd.MAC);
                     iUpgradeValue := pu.Desc[1];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               105://³»±¸
                  begin
                     iBaseValue := Round( pstd.DuraMax / 1000 );
                     iUpgradeValue := Round( pu.DuraMax / 1000 );
                     Result := iUpgradeValue;   // ³»±¸
                  end;
               106://Á¤È®
                  begin
                  end;
               107://¹ÎÃ¸
                  begin
                     iBaseValue := pstd.Agility;
                     iUpgradeValue := pu.Desc[3];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               108://°ø¼Ó
                  begin
                  end;
               109://µÐÈ­
                  begin
                  end;
               110://Áßµ¶
                  begin
                  end;
               111://¸¶ÀúÇ×
                  begin
                  end;
               112://ÁßÀúÇ×
                  begin
                  end;
            end;//case iOptionIndex of
         end;
      ///////////////////////////////////////////////////////
      54: // º§Æ®
         begin
            case iOptionIndex of
               100://ÆÄ±«
                  begin
                  end;
               101://¸¶¹ý
                  begin
                  end;
               102://µµ·Â
                  begin
                  end;
               103://¹æ¾î
                  begin
                     iBaseValue := HIBYTE(pstd.AC);
                     iUpgradeValue := pu.Desc[0];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               104://¸¶Ç×
                  begin
                     iBaseValue := HIBYTE(pstd.MAC);
                     iUpgradeValue := pu.Desc[1];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               105://³»±¸
                  begin
                     iBaseValue := Round( pstd.DuraMax / 1000 );
                     iUpgradeValue := Round( pu.DuraMax / 1000 );
                     Result := iUpgradeValue;   // ³»±¸
                  end;
               106://Á¤È®
                  begin
                     iBaseValue := pstd.Accurate;
                     iUpgradeValue := pu.Desc[2];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               107://¹ÎÃ¸
                  begin
                     iBaseValue := pstd.Agility;
                     iUpgradeValue := pu.Desc[3];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               108://°ø¼Ó
                  begin
                  end;
               109://µÐÈ­
                  begin
                  end;
               110://Áßµ¶
                  begin
                  end;
               111://¸¶ÀúÇ×
                  begin
                  end;
               112://ÁßÀúÇ×
                  begin
                     iBaseValue := pstd.ToxAvoid;
                     iUpgradeValue := pu.Desc[13];
                     Result := iBaseValue + iUpgradeValue;
                  end;
            end;//case iOptionIndex of
         end;
   end;

end;

procedure TUserHuman.CmdMakeAllJewelryItem (nSelect : integer);
begin
   if nSelect = 0 then begin
      CmdMakeItem('ÓÂÕß±¦Óñ', 1);
      CmdMakeItem('Ä§·¨±¦Óñ', 1);
      CmdMakeItem('µÀÊõ±¦Óñ', 1);
      CmdMakeItem('·ÀÓù±¦Óñ', 1);
      CmdMakeItem('Ä§Óù±¦Óñ', 1);
      CmdMakeItem('³Ö¾Ã±¦Óñ', 1);
      CmdMakeItem('×¼È·±¦Óñ', 1);
      CmdMakeItem('Ãô½Ý±¦Óñ', 1);
      CmdMakeItem('ËÙ¶È±¦Óñ', 1);
      CmdMakeItem('³Ù¶Û±¦Óñ', 1);
      CmdMakeItem('¾ç¶¾±¦Óñ', 1);
      CmdMakeItem('¶¾¶ã±¦Óñ', 1);
      CmdMakeItem('Ä§¶ã±¦Óñ', 1);
   end else begin
      CmdMakeItem('ÓÂÕß±¦Öé', 1);
      CmdMakeItem('Ä§·¨±¦Öé', 1);
      CmdMakeItem('µÀÊõ±¦Öé', 1);
      CmdMakeItem('·ÀÓù±¦Öé', 1);
      CmdMakeItem('Ä§Óù±¦Öé', 1);
      CmdMakeItem('³Ö¾Ã±¦Öé', 1);
      CmdMakeItem('×¼È·±¦Öé', 1);
      CmdMakeItem('Ãô½Ý±¦Öé', 1);
      CmdMakeItem('ËÙ¶È±¦Öé', 1);
      CmdMakeItem('³Ù¶Û±¦Öé', 1);
      CmdMakeItem('¾ç¶¾±¦Öé', 1);
      CmdMakeItem('¶¾¶ã±¦Öé', 1);
      CmdMakeItem('Ä§¶ã±¦Öé', 1);
   end;
end;

///////////////////////////////////////////////////////////////

// 2003/09/15 Ã¼ÆÃ·Î±× ¸í·É Ãß°¡

procedure TUserHuman.CmdAddChatLogList (whostr: string; pass: Boolean);
var
   idx : integer;
   bExist : boolean;
begin
   if whostr <> '' then begin
      bExist := UserEngine.FindChatLogList(whostr, idx);
      if not bExist then begin
         UserEngine.ChatLogList.Add(whostr);
         if pass then begin
            FrmDB.SaveChatLogFiles;
            UserEngine.SendInterMsg (ISM_RELOADCHATLOG, ServerIndex, '');
         end;
         SysMsg (whostr + 'ÁÄÌì¼ÇÂ¼Ìí¼ÓÁË', 1);
      end
      else
         SysMsg (whostr + ' ÎÞ·¨²éÕÒ', 0);
   end else
      SysMsg (whostr + ' ÎÞ·¨²éÕÒ', 0);
end;

procedure TUserHuman.CmdDelChatLogList (whostr: string; pass: Boolean);
var
   idx: integer;
   bExist : boolean;
begin
   bExist := UserEngine.FindChatLogList(whostr, idx);
   if bExist then begin
      UserEngine.ChatLogList.Delete (idx);
      if pass then begin
         FrmDB.SaveChatLogFiles;
         UserEngine.SendInterMsg (ISM_RELOADCHATLOG, ServerIndex, '');
      end;
      SysMsg (whostr + 'ÔÚÈÕÖ¾ÖÐÉ¾³ýÁÄÌì¼ÇÂ¼', 1);
   end else
      SysMsg (whostr + ' ÎÞ·¨²éÕÒ', 0);
end;

procedure TUserHuman.CmdSendChatLogList;
var
   i: integer;
begin
   for i:=0 to UserEngine.ChatLogList.Count-1 do begin
      SysMsg (IntToStr(i+1) + '=' + UserEngine.ChatLogList.Strings[i], 1);
   end;
end;


{-------¹®ÆÄÀå¿ø ¿î¿µÀÚ ¸í·É¾î---------------------------------------------}

procedure TUserHuman.CmdGuildAgitRegistration;
var
   agitnumber : integer;
begin
   if ServerIndex <> 0 then begin
      SysMsg ('Ê¹ÓÃ´ËÃüÁîµÄ·þÎñÆ÷', 0);
      exit;
   end;

   if IsGuildMaster then begin   // ¹®ÁÖÀÌ¸é
      if TGuild(MyGuild).GetTotalMemberCount <= MINAGITMEMBER then begin
         BoxMsg('ÐÐ»á²»ÄÜÉÙÓÚ ' + IntToStr(MINAGITMEMBER) + '¸ö³ÉÔ±.', 0);
         exit;
      end;

      // ´ë¿©ÇÏ·Á´Â ¹®ÁÖ°¡ Àå¿ø ±¸ÀÔ½ÅÃ»À» ÇÑ »óÅÂÀÎÁö °Ë»ç
      if GuildAgitMan.IsExistInForSaleGuild( TGuild(MyGuild).GuildName ) then begin
         BoxMsg('ÎÒÒÑ¾­ÉêÇë¹ºÂò×¯Ô°ÁË.', 0);
         exit;
      end;

      if Gold >= GUILDAGITREGFEE then begin
         agitnumber := GuildAgitMan.AddGuildAgit( TGuild(MyGuild).GuildName, TGuild(MyGuild).GetGuildMaster, TGuild(MyGuild).GetAnotherGuildMaster );
         if agitnumber > -1 then begin
            DecGold (GUILDAGITREGFEE);
            GoldChanged;

            //·Î±×³²±è
            AddUserLog ('37'#9 + //Àå´ë¿©_
                        MapName + ''#9 +
                        IntToStr(CX) + ''#9 +
                        IntToStr(CY) + ''#9 +
                        UserName + ''#9 +
                        TGuild(MyGuild).GuildName + ''#9 +
                        IntToStr(agitnumber) + ''#9 +
                        '1'#9 +
                        IntToStr(GUILDAGITREGFEE));

            //Àå¿ø°Ô½ÃÆÇ ¸®·Îµå.
            GuildAgitBoardMan.LoadAllGaBoardList('');

            UserEngine.SendInterMsg (ISM_RELOADGUILDAGIT, ServerIndex, '');
            BoxMsg('ÄúÒÑ¾­×âÓÃÁËÐÐ»á×¯Ô°.', 1);

            //-----------------------
            //¸í¼ºÄ¡ Áõ°¡(Àå¿ø´ë¿©:+1000)
            if ENABLE_FAME_SYSTEM then begin
               IncFamePoint( 1000 );
            end;
            //-----------------------

         end else begin
            BoxMsg('Äú²»ÄÜ×âÓÃÐÐ»á×¯Ô°.', 0);
         end;
      end else
         BoxMsg ('È±ÉÙ½ð±Ò.', 0);
   end else begin
      BoxMsg('½öÐÐ»á¹ÜÀíÔ±²Å¿ÉÒÔÊ¹ÓÃÕâ¸öÃüÁî.', 0);
   end;
end;

procedure TUserHuman.CmdGuildAgitAutoMove;
var
   MapName: string;
   guildagit: TGuildAgit;
begin
   if MyGuild = nil then begin
      BoxMsg('Äú²»ÄÜÒÆ¶¯µ½ÐÐ»á×¯Ô°.', 0);
      exit;
   end;
   if TGuild(MyGuild).GuildName = '' then begin
      BoxMsg('Äú²»ÄÜÒÆ¶¯µ½ÐÐ»á×¯Ô°.', 0);
      exit;
   end;

   guildagit := GuildAgitMan.GetGuildAgit( TGuild(MyGuild).GuildName );
   if guildagit <> nil then begin
      MapName := GuildAgitMan.GuildAgitMapName[0] + IntToStr(guildagit.GuildAgitNumber);
      if GrobalEnvir.GetEnvir (MapName) <> nil then begin
         SendRefMsg (RM_SPACEMOVE_HIDE, 0, 0, 0, 0, '');
//         RandomSpaceMove (MapName, 0); //¹«ÀÛÀ§ °ø°£ÀÌµ¿
//         SpaceMove (MapName, GuildAgitMan.EntranceX, GuildAgitMan.EntranceY, 0); //°ø°£ÀÌµ¿
         UserSpaceMove (MapName, IntToStr(GuildAgitMan.EntranceX), IntToStr(GuildAgitMan.EntranceY)); //°ø°£ÀÌµ¿
         SysMsg('ÄãÒÑ½øÈëÐÐ»á×¯Ô°.', 1);
      end;
   end else begin
      BoxMsg('²»ÄÜÊ¹ÓÃ.', 0);
   end;
end;

procedure TUserHuman.CmdGuildAgitDelete;
begin
   if ServerIndex <> 0 then begin
      SysMsg ('Ê¹ÓÃ´ËÃüÁî', 0);
      exit;
   end;

   if IsMyGuildMaster then begin   // ¹®ÁÖÀÌ¸é
      if GuildAgitMan.DelGuildAgit( TGuild(MyGuild).GuildName ) then begin
         //Àå¿ø°Ô½ÃÆÇ ¸®·Îµå.
         GuildAgitBoardMan.LoadAllGaBoardList('');

         UserEngine.SendInterMsg (ISM_RELOADGUILDAGIT, ServerIndex, '');
         SysMsg('ÄúÍË×âÐÐ»á×¯Ô°.', 1);
      end else begin
         SysMsg('Äú²»ÄÜÍË×âÐÐ»á×¯Ô°.', 0);
      end;
   end else begin
      SysMsg('½öÐÐ»á¹ÜÀíÔ±²Å¿ÉÒÔÊ¹ÓÃÕâ¸öÃüÁî.', 0);
   end;
end;

procedure TUserHuman.CmdGuildAgitExtendTime (count : integer);
var
   agitnumber : integer;
begin
   if ServerIndex <> 0 then begin
      SysMsg ('Õâ¸öÃüÁî²»ÄÜµÄÔÚÕâ¸ö·þÎñÆ÷ÉÏÊ¹ÓÃ.', 0);
      exit;
   end;

   if IsMyGuildMaster then begin   // ¹®ÁÖÀÌ¸é
      if Gold >= GUILDAGITEXTENDFEE then begin
         agitnumber := GuildAgitMan.ExtendTime( count, TGuild(MyGuild).GuildName );
         if agitnumber > -1 then begin
            DecGold (GUILDAGITEXTENDFEE);
            GoldChanged;

            //·Î±×³²±è
            AddUserLog ('38'#9 + //Àå¿¬Àå_
                        MapName + ''#9 +
                        IntToStr(CX) + ''#9 +
                        IntToStr(CY) + ''#9 +
                        UserName + ''#9 +
                        TGuild(MyGuild).GuildName + ''#9 +
                        IntToStr(agitnumber) + ''#9 +
                        '1'#9 +
                        IntToStr(GUILDAGITEXTENDFEE));

            UserEngine.SendInterMsg (ISM_RELOADGUILDAGIT, ServerIndex, '');
            BoxMsg('ÁìÍÁ×âÓÃÆÚÏÞ±»ÑÓ³¤ÁË.', 1);

            //-----------------------
            //¸í¼ºÄ¡ Áõ°¡(Àå¿ø¿¬Àå:+100)
            if ENABLE_FAME_SYSTEM then begin
               IncFamePoint( 100 );
            end;
            //-----------------------
         end else begin
            BoxMsg('ÁìÍÁ×âÓÃÆÚÏÞ²»ÄÜ±»ÑÓ³¤.', 0);
         end;
      end else
         BoxMsg ('È±ÉÙ½ð±Ò.', 0);
   end else begin
      BoxMsg('½öÐÐ»á¹ÜÀíÔ±²Å¿ÉÒÔÊ¹ÓÃÕâ¸öÃüÁî.', 0);
   end;
end;

procedure TUserHuman.CmdGuildAgitRemainTime;
var
   RemainDateTime, BaseDate, DiffDate : TDateTime;
   RemainDay : integer;
   Year, Month, Day : WORD;
   Hour, Min, Sec, MSec : WORD;
begin
   if MyGuild = nil then begin
      BoxMsg('ÎÞ·¨²éÑ¯', 0);
      exit;
   end;
   if TGuild(MyGuild).GuildName = '' then begin
      BoxMsg('ÎÞ·¨²éÑ¯', 0);
      exit;
   end;

   RemainDateTime := GuildAgitMan.GetRemainDateTime( TGuild(MyGuild).GuildName );

   // ¿¡·¯ ¸Þ½ÃÁö.
{$IFNDEF UNDEF_DEBUG}   //sonmg
   if RemainDateTime < -GUILDAGIT_DAYUNIT then begin
{$ELSE}
   if RemainDateTime < -(GUILDAGIT_DAYUNIT / 60 / 24) then begin
{$ENDIF}
      // ¸Þ½ÃÁö Ãâ·Â.
      BoxMsg( '²»ÄÜÊ¹ÓÃ.', 0 );
      exit;
   end;

   // ´ë¿© ±â°£ÀÌ Áö³µÀ» °æ¿ì(¿¬Ã¼) ¸Þ½ÃÁö.
   if RemainDateTime <= 0 then begin
{$IFNDEF UNDEF_DEBUG}   //sonmg
      // ³²Àº ³¯Â¥·Î º¯È¯.
      RemainDateTime := GUILDAGIT_DAYUNIT + RemainDateTime;
      // Áö³­ ³¯Â¥ÀÇ ¼Ò¼öÁ¡ ÀÌÇÏ¸¦ ¹ö¸²
      RemainDateTime := Trunc( RemainDateTime );
      // ¸Þ½ÃÁö Ãâ·Â.
      BoxMsg( 'ÁìÍÁ×âÓÃÆÚÏÞ½«µ½ÆÚ.\ \ÄãµÄÐÐ»á×¯Ô°½«ÓÚ ' + FloatToStr( RemainDateTime ) + 'Ììºóµ½ÆÚ.', 0 );
{$ELSE}
      // ³²Àº ³¯Â¥·Î º¯È¯.
      RemainDateTime := (GUILDAGIT_DAYUNIT / 60 / 24) + RemainDateTime;
      // Áö³­ ³¯Â¥ÀÇ ¼Ò¼öÁ¡ ÀÌÇÏ¸¦ ¹ö¸²
      RemainDateTime := Trunc( RemainDateTime * 60 * 24 );
      // ¸Þ½ÃÁö Ãâ·Â.
      BoxMsg( 'ÁìÍÁ×âÓÃÆÚÏÞ½«µ½ÆÚ.\ \ÄãµÄÐÐ»á×¯Ô°½«ÓÚ ' + FloatToStr( RemainDateTime ) + 'Ììºóµ½ÆÚ.', 0 );
{$ENDIF}

   end else begin
      // ³¯Â¥ ºÐÇØ.
      DecodeDate(RemainDateTime, Year, Month, Day);
      DecodeTime(RemainDateTime, Hour, Min, Sec, MSec);

      // 1899³â 12¿ù 31ÀÏ ±âÁØ.
      BaseDate := EncodeDate(1899, 12, 31);
      // ³²Àº ÀÏ¼ö °è»ê.
      DiffDate := RemainDateTime - BaseDate + 1;
      RemainDay := Trunc( DiffDate );

      // ¸Þ½ÃÁö Ãâ·Â.
      BoxMsg( 'ÐÐ»á×¯Ô°×âÓÃÊ±¼äÓÚ < ' + IntToStr(RemainDay) + 'Ìì ' +
         IntToStr(Hour) + 'Ð¡Ê± ' + IntToStr(Min) + '·Ö > ' + 'ºóµ½ÆÚ..', 1 );
   end;
end;

procedure TUserHuman.CmdGuildAgitRecall (man : string; WholeRecall : Boolean);
var
   i, k, n : integer;
   pgrank : PTGuildRank;
   hum : TUserHuman;
begin
   if IsMyGuildMaster then begin   // ¹®ÁÖÀÌ¸é
      // ÀüÃ¼¼ÒÈ¯.
      if WholeRecall then begin
         n := (GetTickCount - CGHIstart) div 1000;
         CGHIstart := CGHIstart + longword(n * 1000);
         if CGHIUseTime > n then CGHIUseTime := CGHIUseTime - n
         else CGHIUseTime := 0;
         if CGHIUseTime = 0 then begin
            if MyGuild <> nil then begin
               if TGuild(MyGuild).MemberList <> nil then begin
                  for i:=0 to TGuild(MyGuild).MemberList.Count-1 do begin
                     pgrank := PTGuildRank (TGuild(MyGuild).MemberList[i]);
                     for k:=0 to pgrank.MemList.Count-1 do begin
                        if pgrank.MemList.Objects[k] = self then continue; // ÀÚ±â ÀÚ½ÅÀº ³Ñ¾î°¨.

                        GuildMasterRecallMan(pgrank.MemList[k], FALSE);
                     end;
                     CGHIstart := GetTickCount;
                     CGHIUseTime := 3 * 60;
                  end;
               end;
            end;
         end else begin
            SysMsg ('ÄãÐèÒªÔÚ ' + IntToStr(CGHIUseTime) + 'Ãëºó²ÅÄÜÊ¹ÓÃÐÐ»á³ÉÔ±¼ÇÒä¹¦ÄÜ.', 0);
         end;
      // °³ÀÎ¼ÒÈ¯.
      end else begin
         GuildMasterRecallMan(man, TRUE);
      end;
   end else begin
      BoxMsg('½öÐÐ»á¹ÜÀíÔ±²Å¿ÉÒÔÊ¹ÓÃÕâ¸öÃüÁî.', 0);
   end;
end;

// ÃÊ´ë±Ç ÀÌµ¿.
procedure TUserHuman.CmdGuildAgitFreeMove( AgitNum : integer );
var
   MapName: string;
   guildagit: TGuildAgit;
   gname : string;
begin
   if AgitNum <= 0 then exit;

   gname := GuildAgitMan.GetGuildNameFromAgitNum( AgitNum );

   guildagit := GuildAgitMan.GetGuildAgit( gname );
   if guildagit <> nil then begin
      MapName := GuildAgitMan.GuildAgitMapName[0] + IntToStr(guildagit.GuildAgitNumber);
      if GrobalEnvir.GetEnvir (MapName) <> nil then begin
         SendRefMsg (RM_SPACEMOVE_HIDE, 0, 0, 0, 0, '');
//         RandomSpaceMove (MapName, 0); //¹«ÀÛÀ§ °ø°£ÀÌµ¿
//         SpaceMove (MapName, GuildAgitMan.EntranceX, GuildAgitMan.EntranceY, 0); //°ø°£ÀÌµ¿
         UserSpaceMove (MapName, IntToStr(GuildAgitMan.EntranceX), IntToStr(GuildAgitMan.EntranceY)); //°ø°£ÀÌµ¿
         SysMsg('ÄãÒÑ½øÈëÐÐ»á×¯Ô°.', 1);
      end;
   end;
end;

procedure TUserHuman.CmdGuildAgitSale (StrForSaleGold : string);
var
   guildagit : TGuildAgit;
   salegold : integer;
begin
   if ServerIndex <> 0 then begin
      SysMsg ('Õâ¸öÃüÁî²»ÄÜµÄÔÚÕâ¸ö·þÎñÆ÷ÉÏÊ¹ÓÃ.', 0);
      exit;
   end;

   if IsMyGuildMaster then begin   // ¹®ÁÖÀÌ¸é
      if Length(StrForSaleGold) > 10 then begin
         SysMsg('ÄãÃ»ÓÐÊäÈë³öÊÛ½ð¶î»òÊäÈë½ð¶îÃ»ÓÐ³¬³öÏÞÖÆ.', 0);
         exit;
      end;

      salegold := Str_ToInt(StrForSaleGold, 0);

      if salegold <= 0 then begin
         SysMsg('ÄãÃ»ÓÐÊäÈë³öÊÛ½ð¶î»òÊäÈë½ð¶îÃ»ÓÐ³¬³öÏÞÖÆ.', 0);
         exit;
      end;

      // ÀÚ±â ÀÚ½ÅÀÇ ¹®ÆÄ Àå¿øÀ» Ã£´Â´Ù.
      guildagit := GuildAgitMan.GetGuildAgit( TGuild(MyGuild).GuildName );
      if guildagit <> nil then begin
         if guildagit.GetCurrentDelayStatus <= 0 then begin
            BoxMsg('ÁìÍÁ×âÓÃÆÚÏÞ½«µ½ÆÚ, Òò´ËÄú²»ÄÜ³öÊÛÐÐ»á×¯Ô°.', 0);
            exit;
         end;

         // ÆÇ¸ÅÁßÀÌ ¾Æ´Ï¸é
         if not guildagit.IsForSale then begin
            // °Å·¡°¡ ¼º»çµÇÁö ¾Ê¾ÒÀ¸¸é
            if not guildagit.IsSoldOut then begin
               // ÇÃ·¡±× Ã¼Å©
               guildagit.ForSaleFlag := 1;
               // ÆÇ¸Å ±Ý¾× µî·Ï
               guildagit.ForSaleMoney := salegold;

               //·Î±×³²±è
               AddUserLog ('39'#9 + //ÀåÆÇ¸Å_
                           MapName + ''#9 +
                           IntToStr(CX) + ''#9 +
                           IntToStr(CY) + ''#9 +
                           UserName + ''#9 +
                           TGuild(MyGuild).GuildName + ''#9 +
                           IntToStr(guildagit.GuildAgitNumber) + ''#9 +
                           '1'#9 +
                           IntToStr(guildagit.ForSaleMoney));

               // ¹®ÆÄ Àå¿ø ¸®½ºÆ® ÀúÀå.
               GuildAgitMan.SaveGuildAgitList (FALSE);

               UserEngine.SendInterMsg (ISM_RELOADGUILDAGIT, ServerIndex, '');

               // ¸Þ½ÃÁö Ãâ·Â.
               BoxMsg(GetGoldStr(salegold) + '½ð±ÒµÄ¼Û¸ñµÇ¼Ç³öÊÛÐÐ»á×¯Ô°.', 1);
            end else begin
               BoxMsg('½»Ò×ÒÑÍê³É, Òò´ËËü²»ÄÜÔÙ±»³öÊÛ.', 0);
            end;
         end else begin
            BoxMsg('ÄúµÄÐÐ»á×¯Ô°µ±Ç°ÕýÔÚÏúÊÛÖÐ.', 0);
         end;
      end else begin
         BoxMsg('²»ÄÜÊ¹ÓÃ.', 0);
      end;
   end else begin
      BoxMsg('½öÐÐ»á¹ÜÀíÔ±²Å¿ÉÒÔÊ¹ÓÃÕâ¸öÃüÁî.', 0);
   end;
end;

procedure TUserHuman.CmdGuildAgitSaleCancel;
var
   guildagit : TGuildAgit;
   salegold : integer;
begin
   if ServerIndex <> 0 then begin
      SysMsg ('²»¿ÉÊ¹ÓÃ´ËÃüÁî', 0);
      exit;
   end;

   if IsMyGuildMaster then begin   // ¹®ÁÖÀÌ¸é
      // ÀÚ±â ÀÚ½ÅÀÇ ¹®ÆÄ Àå¿øÀ» Ã£´Â´Ù.
      guildagit := GuildAgitMan.GetGuildAgit( TGuild(MyGuild).GuildName );
      if guildagit <> nil then begin
         // °Å·¡°¡ ¼º»çµÈ ÈÄ¿¡´Â ÆÇ¸ÅÃë¼Ò¸¦ ÇÒ ¼ö ¾ø´Ù.
         if not guildagit.IsSoldOut then begin
            // ÆÇ¸ÅÁßÀÌ¸é
            if guildagit.IsForSale then begin
               // ÆÇ¸ÅÃë¼ÒÇÑ´Ù.
               guildagit.ResetForSaleFields;

               //·Î±×³²±è
               AddUserLog ('40'#9 + //ÀåÃë¼Ò_(Àå¿øÆÇ¸ÅÃë¼Ò)
                           MapName + ''#9 +
                           IntToStr(CX) + ''#9 +
                           IntToStr(CY) + ''#9 +
                           UserName + ''#9 +
                           TGuild(MyGuild).GuildName + ''#9 +
                           IntToStr(guildagit.GuildAgitNumber) + ''#9 +
                           '1'#9 +
                           '0');

               // ¹®ÆÄ Àå¿ø ¸®½ºÆ® ÀúÀå.
               GuildAgitMan.SaveGuildAgitList (FALSE);

               UserEngine.SendInterMsg (ISM_RELOADGUILDAGIT, ServerIndex, '');

               BoxMsg('ÄúÈ¡ÏûÁËÃÅÅÉ×¯Ô°µÄÏúÊÛ.', 1);
            end else begin
               BoxMsg('ÄúµÄÃÅÅÉ×¯Ô°²»ÔÚÏúÊÛÖÐ.', 0);
            end;
         end else begin
            BoxMsg('½»Ò×ÒÑÍê³É, Äú²»ÄÜÈ¡ÏûÏúÊÛ.', 0);
         end;
      end else begin
         BoxMsg('²»ÄÜÊ¹ÓÃ.', 0);
      end;
   end else begin
      BoxMsg('½öÐÐ»á¹ÜÀíÔ±²Å¿ÉÒÔÊ¹ÓÃÕâ¸öÃüÁî.', 0);
   end;
end;

procedure TUserHuman.CmdGuildAgitBuy (page : integer);
const
   ONEPAGELINE = 10;
var
   salelist : TStringList;
   i, count, startline, endline : integer;
   data : string;
begin
   //Àå¿øÀÇ ÀüÃ¼ ¸®½ºÆ®¸¦ º¸³» ÁÜ.
   salelist := nil;
   data := '';
   count := 0;

   // Àå¿ø ÆÇ¸Å ¸ñ·ÏÀ» ¾ò¾î¿Â´Ù.
   GuildAgitMan.GetGuildAgitSaleList( salelist );

   // Àå¿ø ¸ñ·ÏÀÌ ¾øÀ» ¶§
   if salelist = nil then begin
      BoxMsg('Ã»ÓÐµÇ¼ÇµÄÃÅÅÉ×¯Ô°.', 0);
      exit;
   end;

   // ÆäÀÌÁö°¡ Á¤»óÀÌ¸é
   if page > 0 then begin
      // ½ÃÀÛÁÙ
      startline := ONEPAGELINE * (page - 1);

      // ¸¶Áö¸·ÁÙ : ¸ñ·ÏÀÇ ¶óÀÎ ¼ö°¡ ÇÑ ÆäÀÌÁöÀÇ ÃÖ´ë ¶óÀÎº¸´Ù Å©Áö ¾Ê°Ô
      endline := _MIN(salelist.Count, ONEPAGELINE * page);

      // ½ÃÀÛÁÙºÎÅÍ ¸¶Áö¸·ÁÙ±îÁö º¸³¿
      for i:=startline to endline-1 do begin
         data := data + salelist[i] + '/';
         Inc (count);
      end;

      if count > 0 then begin
         // ¸®½ºÆ®¸¦ º¸³¿
         SendMsg (self, RM_GUILDAGITLIST, 0, page, count, 0, data);
      end;
   end;

   // ¸ñ·ÏÀ» ¸Þ¸ð¸®¿¡¼­ ÇØÁ¦½ÃÅ²´Ù.
   salelist.Free;
end;

procedure TUserHuman.CmdTryGuildAgitTrade;
begin
   if ServerIndex <> 0 then begin
      SysMsg ('Õâ¸öÃüÁî²»ÄÜµÄÔÚÕâ¸ö·þÎñÆ÷ÉÏÊ¹ÓÃ.', 0);
      exit;
   end;

   SendMsg (self, RM_GUILDAGITDEALTRY, 0, integer(self), 0, 0, '');
end;

procedure TUserHuman.CmdGuildAgitExpulsionMyself;
var
   guildagit : TGuildAgit;
begin
   //Àå¿ø ³»¿¡ ÀÖ´Â »ç¶÷¸¸ Ãß¹æ.
   if (PEnvir.GetGuildAgitRealMapName = GuildAgitMan.GuildAgitMapName[0]) or
         (PEnvir.GetGuildAgitRealMapName = GuildAgitMan.GuildAgitMapName[1]) or
         (PEnvir.GetGuildAgitRealMapName = GuildAgitMan.GuildAgitMapName[2]) or
         (PEnvir.GetGuildAgitRealMapName = GuildAgitMan.GuildAgitMapName[3]) then begin
      // ¹®ÆÄ°¡ ¾øÀ» °æ¿ì
      if (MyGuild = nil) or (TGuild(MyGuild).GuildName = '') then begin
         // ÀÚ±â ÀÚ½ÅÀ» °­Á¦ Ãß¹æ
         SendRefMsg (RM_SPACEMOVE_HIDE, 0, 0, 0, 0, '');
//         UserSpaceMove (GuildAgitMan.ReturnMapName, IntToStr(GuildAgitMan.ReturnX), IntToStr(GuildAgitMan.ReturnY));
         UserSpaceMove (HomeMap, IntToStr(HomeX), IntToStr(HomeY));
         exit;
      end;

      guildagit := GuildAgitMan.GetGuildAgit( TGuild(MyGuild).GuildName );
      // Àå¿øÀÌ ¾øÀ» °æ¿ì
      if guildagit = nil then begin
         if CompareLStr(PEnvir.MapName, GuildAgitMan.GuildAgitMapName[0], 3) or
            CompareLStr(PEnvir.MapName, GuildAgitMan.GuildAgitMapName[1], 3) or
            CompareLStr(PEnvir.MapName, GuildAgitMan.GuildAgitMapName[2], 3) or
            CompareLStr(PEnvir.MapName, GuildAgitMan.GuildAgitMapName[3], 3) then begin
               // ÀÚ±â ÀÚ½ÅÀ» °­Á¦ Ãß¹æ
               SendRefMsg (RM_SPACEMOVE_HIDE, 0, 0, 0, 0, '');
//               UserSpaceMove (GuildAgitMan.ReturnMapName, IntToStr(GuildAgitMan.ReturnX), IntToStr(GuildAgitMan.ReturnY));
               UserSpaceMove (HomeMap, IntToStr(HomeX), IntToStr(HomeY));
         end;
      end else begin
         // Àå¿øÀÌ ÀÖÀ» °æ¿ì(sonmg 2005/02/23)
         // ³²ÀÇ Àå¿øÀÌ°Å³ª ´ë¿© ±â°£ÀÌ ¸¸·áµÇ¾úÀ¸¸é Ãß¹æ
         if (guildagit.GuildAgitNumber <> PEnvir.GuildAgit) or (guildagit.IsExpired) then begin
            // ÀÚ±â ÀÚ½ÅÀ» °­Á¦ Ãß¹æ
            SendRefMsg (RM_SPACEMOVE_HIDE, 0, 0, 0, 0, '');
//            UserSpaceMove (GuildAgitMan.ReturnMapName, IntToStr(GuildAgitMan.ReturnX), IntToStr(GuildAgitMan.ReturnY));
            UserSpaceMove (HomeMap, IntToStr(HomeX), IntToStr(HomeY));
         end;
      end;
   end;
end;

procedure TUserHuman.CmdGuildAgitDonate (goldstr: string);
var
   GoldDonate: integer;
   gname: string;
   guildagit: TGuildAgit;
begin
   gname := GetGuildNameHereAgit;
   if gname = '' then begin
      BoxMsg('²»ÄÜÖ§¸¶.', 0);
      exit;
   end;

   guildagit := GuildAgitMan.GetGuildAgit( gname );
   if guildagit <> nil then begin
      GoldDonate := Str_ToInt(goldstr, 0);

      if Gold < GoldDonate then begin
         BoxMsg('È±ÉÙ½ð±Ò.', 0);
         exit;
      end;
      if guildagit.GuildAgitTotalGold + GoldDonate > GUILDAGITMAXGOLD then begin
         BoxMsg('³¬³ö¾èÔùÏÞÖÆ.\\¾èÔùµÄ×ÜÊý²»ÄÜ³¬³ö ' + GetGoldStr(GUILDAGITMAXGOLD) + ' ½ð±Ò.', 0);
         exit;
      end;

      // °¡¹æÃ¢¿¡¼­ ±ÝÀüÀ» °¨¼Ò½ÃÅ´.
      if DecGold( GoldDonate ) then begin
         GoldChanged;

         // Àå¿ø ±âºÎ±Ý¿¡ µ·À» Ãß°¡ÇÔ.
         guildagit.GuildAgitTotalGold := guildagit.GuildAgitTotalGold + GoldDonate;
         BoxMsg('¾èÔù' +GetGoldStr(GoldDonate) + '½ð±Ò.\\ÄãÆ½¾ù¾èÔù' + GetGoldStr( guildagit.GuildAgitTotalGold ) + ' ½ð±Ò.', 0);

         //·Î±×³²±è
         AddUserLog ('46'#9 + //±âºÎ_
                     MapName + ''#9 +
                     IntToStr(CX) + ''#9 +
                     IntToStr(CY) + ''#9 +
                     UserName + ''#9 +
                     NAME_OF_GOLD{'±ÝÀü'} + ''#9 +
                     IntToStr(GoldDonate) + ''#9 +
                     '0'#9 +
                     '0');

         // ¹®ÆÄ Àå¿ø ¸®½ºÆ® ÀúÀå.
         GuildAgitMan.SaveGuildAgitList (FALSE);
      end else begin
         BoxMsg('²»ÄÜÖ§¸¶.', 0);
      end;
   end else begin
      BoxMsg('²»ÄÜÖ§¸¶.', 0);
   end;
end;

procedure TUserHuman.CmdGuildAgitViewDonation;
var
   gname: string;
   guildagit: TGuildAgit;
begin
   gname := GetGuildNameHereAgit;
   if gname = '' then begin
      BoxMsg('²»ÄÜ²éÑ°.', 0);
      exit;
   end;

   guildagit := GuildAgitMan.GetGuildAgit( gname );
   if guildagit <> nil then begin
      BoxMsg('µ±Ç°Ê£Óà¾èÔùµÄÊýÁ¿ÊÇ' + GetGoldStr( guildagit.GuildAgitTotalGold ) + '½ð±Ò.', 0);
   end;
end;

function TUserHuman.GetGuildAgitDonation : integer;
var
   gname: string;
   guildagit: TGuildAgit;
begin
   Result := 0;
   gname := GetGuildNameHereAgit;
   if gname = '' then begin
      exit;
   end;

   guildagit := GuildAgitMan.GetGuildAgit( gname );
   if guildagit <> nil then begin
      Result := guildagit.GuildAgitTotalGold;
   end;
end;

function TUserHuman.DecGuildAgitDonation (igold : integer) : Boolean;
var
   gname: string;
   guildagit: TGuildAgit;
begin
   Result := FALSE;

   gname := GetGuildNameHereAgit;
   if gname = '' then begin
      exit;
   end;

   guildagit := GuildAgitMan.GetGuildAgit( gname );
   if guildagit <> nil then begin
      if guildagit.GuildAgitTotalGold < igold then exit;

      guildagit.GuildAgitTotalGold := guildagit.GuildAgitTotalGold - igold;
      Result := TRUE;
   end;
end;

procedure TUserHuman.CmdGetGuildAgitFileVersion;
begin
   SysMsg('Version=' + IntToStr(GuildAgitMan.GuildAgitFileVersion), 0);
end;


{----------------------------------------------------------}
// Send????

procedure TUserHuman.SendAddItem (ui: TUserItem);
var
   citem: TClientItem; //¿Í»§¶Ë
   ps: PTStdItem;//·þÎñ¶¼Êý¾Ý
   std: TStdItem;
   opt: integer;
begin
   ps := UserEngine.GetStdItem (ui.Index);//²é·þÎñ¶Ë
   if ps <> nil then begin
      std := ps^;
      opt := ItemMan.GetUpgradeStdItem (ui, std);
      Move (std, citem.S, sizeof(TStdItem));
      citem.MakeIndex := ui.MakeIndex;
      citem.Dura := ui.Dura;
      citem.DuraMax := ui.DuraMax;
      citem.UpgradeOpt := opt;

      if std.StdMode = 50 then begin  //»óÇ°±Ç
         citem.S.Name := citem.S.Name + ' #' + IntToStr(ui.Dura);
      end;
      //¹ÌÁöÀÇ¼Ó¼º ÇÁ¸®µÈ °Íµé
      // 2003/03/15 ¾ÆÀÌÅÛ ÀÎº¥Åä¸® È®Àå
      if std.StdMode in [15,19,20,21,22,23,24,26,52,53,54] then begin
         if ui.Desc[8] = 0 then begin //¼Ó¼ºÀÌ ÇÁ¸®µÊ(sonmg 2005/04/07 ¼öÁ¤)
//            citem.S.Shape := 0;
            citem.S.ItemDesc := citem.S.ItemDesc and (not IDC_UNIDENTIFIED);//$01;
         end else begin
//            citem.S.Shape := RING_OF_UNKNOWN;
            citem.S.ItemDesc := citem.S.ItemDesc or IDC_UNIDENTIFIED;//$01;
         end;
      end;

      Def := MakeDefaultMsg (SM_ADDITEM, integer(self), 0, 0, 1{¼ö·®});
      SendSocket (@Def, EncodeBuffer (@citem, sizeof(TClientItem)));
   end;
end;

procedure TUserHuman.SendUpdateItem (ui: TUserItem);
var
   citem: TClientItem;
   ps: PTStdItem;
   std: TStdItem;
   opt: integer;
begin
   ps := UserEngine.GetStdItem (ui.Index);
   if ps <> nil then begin
      std := ps^;
      opt := ItemMan.GetUpgradeStdItem (ui, std);
      Move (std, citem.S, sizeof(TStdItem));
      citem.MakeIndex := ui.MakeIndex;
      citem.Dura := ui.Dura;
      citem.DuraMax := ui.DuraMax;
      citem.UpgradeOpt := opt;
      if std.StdMode = 50 then begin  //»óÇ°±Ç
         citem.S.Name := citem.S.Name + ' #' + IntToStr(ui.Dura);
      end;

      if (ui.Index = 706) or (ui.Index = 707) or (ui.Index = 708) then
         //¹ÝÂ¦ÀÌº¥Æ® 3Â÷
         BanjjakChangeItemByJob( citem, Abil.Level )
      else
      //¿ë¾ÆÀÌÅÛ
      ChangeItemByJob( citem, Abil.Level );

      Def := MakeDefaultMsg (SM_UPDATEITEM, integer(self), 0, 0, 1{¼ö·®});
      SendSocket (@Def, EncodeBuffer (@citem, sizeof(TClientItem)));
   end;
end;


procedure TUserHuman.SendUpdateItemWithLevel (ui: TUserItem ; lv : Integer);
var
   citem: TClientItem;
   ps: PTStdItem;
   std: TStdItem;
   opt: integer;
begin
   ps := UserEngine.GetStdItem (ui.Index);
   if ps <> nil then
   begin
      std := ps^;
      opt := ItemMan.GetUpgradeStdItem (ui, std);
      Move (std, citem.S, sizeof(TStdItem));
      citem.MakeIndex := ui.MakeIndex;
      citem.Dura      := ui.Dura;
      citem.DuraMax   := ui.DuraMax;
      citem.UpgradeOpt := opt;
      //ÃµÀÇ¹«ºÀ Ã¼Å©
      ChangeItemWithLevel ( citem , lv);

      Def := MakeDefaultMsg (SM_UPDATEITEM, integer(self), 0, 0, 1{¼ö·®});
      SendSocket (@Def, EncodeBuffer (@citem, sizeof(TClientItem)));

   end;

end;

//¿ë¾ÆÀÌÅÛ Âø¿ëÇÒ¶§ Á÷¾÷º°·Î ³¯·ÁÁÖ´Â ¾ÆÀÌÅÛ Á¤º¸(sonmg)
procedure TUserHuman.SendUpdateItemByJob (ui: TUserItem ; lv : Integer);
var
   citem: TClientItem;
   ps: PTStdItem;
   std: TStdItem;
   opt: integer;
begin
   ps := UserEngine.GetStdItem (ui.Index);
   if ps <> nil then
   begin
      std := ps^;
      opt := ItemMan.GetUpgradeStdItem (ui, std);
      Move (std, citem.S, sizeof(TStdItem));
      citem.MakeIndex := ui.MakeIndex;
      citem.Dura      := ui.Dura;
      citem.DuraMax   := ui.DuraMax;
      citem.UpgradeOpt := opt;
      if (ui.Index = 706) or (ui.Index = 707) or (ui.Index = 708) then
         //¹ÝÂ¦ÀÌº¥Æ® 3Â÷
         BanjjakChangeItemByJob( citem, Abil.Level )
      else
      //¿ë¾ÆÀÌÅÛ
      ChangeItemByJob( citem, lv );

      Def := MakeDefaultMsg (SM_UPDATEITEM, integer(self), 0, 0, 1{¼ö·®});
      SendSocket (@Def, EncodeBuffer (@citem, sizeof(TClientItem)));

   end;

end;

procedure TUserHuman.SendDelItem (ui: TUserItem);
var
   citem: TClientItem;
   ps: PTStdItem;
   std: TStdItem;
   opt: integer;
begin
   ps := UserEngine.GetStdItem (ui.Index);
   if ps <> nil then begin
      std := ps^;
      opt := ItemMan.GetUpgradeStdItem (ui, std);
      Move (std, citem.S, sizeof(TStdItem));
      citem.Dura := ui.Dura;
      citem.DuraMax := ui.DuraMax;
      citem.MakeIndex := ui.MakeIndex;
      citem.UpgradeOpt := opt;
      if std.StdMode = 50 then begin  //»óÇ°±Ç
         citem.S.Name := citem.S.Name + ' #' + IntToStr(ui.Dura);
      end;                 //¼Û¸ñÀàÐÍÉè¶¨
      Def := MakeDefaultMsg (SM_DELITEM, integer(self), 0, 0, 1{¼ö·®});
      SendSocket (@Def, EncodeBuffer (@citem, sizeof(TClientItem)));
   end;
end;

// ¾ÆÀÌÅÛ ¾÷±×·¹ÀÌµå ÆÄ±« È¿°ú¸¦ À§ÇÑ DelItemÇÔ¼ö
procedure TUserHuman.SendDelItemWithFlag (ui: TUserItem; wBreakdown: Word);
var
   citem: TClientItem;
   ps: PTStdItem;
   std: TStdItem;
   opt: integer;
begin
   ps := UserEngine.GetStdItem (ui.Index);
   if ps <> nil then begin
      std := ps^;
      opt := ItemMan.GetUpgradeStdItem (ui, std);
      Move (std, citem.S, sizeof(TStdItem));
      citem.Dura := ui.Dura;
      citem.DuraMax := ui.DuraMax;
      citem.MakeIndex := ui.MakeIndex;
      citem.UpgradeOpt := opt;
      if std.StdMode = 50 then begin  //»óÇ°±Ç
         citem.S.Name := citem.S.Name + ' #' + IntToStr(ui.Dura);
      end;
      Def := MakeDefaultMsg (SM_DELITEM, integer(self), 0, wBreakdown, 1{¼ö·®});
      SendSocket (@Def, EncodeBuffer (@citem, sizeof(TClientItem)));
   end;
end;

procedure TUserHuman.SendDelItems (ilist: TStringList);
var
   i: integer;
   data: string;
begin
   data := '';
   for i:=0 to ilist.Count-1 do begin
      data := data + ilist[i] + '/' + IntToStr(Integer(ilist.objects[i])) + '/';
   end;
   Def := MakeDefaultMsg (SM_DELITEMS, 0, 0, 0, ilist.Count);
   SendSocket (@Def, EncodeString(data));
end;

procedure TUserHuman.SendBagItems;
var
   i: integer;
   pu: PTUserItem;
   citem: TClientItem;
   ps: PTStdItem;
   std: TStdItem;
   data: string;
   opt: integer;
begin
   data := '';
   for i:=0 to ItemList.Count-1 do begin
      pu := PTUserItem (ItemList[i]);
      ps := UserEngine.GetStdItem (pu.Index);
      if ps <> nil then begin
         std := ps^;
         opt := ItemMan.GetUpgradeStdItem (pu^, std);
         Move (std, citem.S, sizeof(TStdItem));
         citem.Dura := pu.Dura;
         citem.DuraMax := pu.DuraMax;
         citem.MakeIndex := pu.MakeIndex;
         citem.UpgradeOpt := opt;
         if std.StdMode = 50 then begin  //»óÇ°±Ç
            citem.S.Name := citem.S.Name + ' #' + IntToStr(pu.Dura);
         end;
         data := data + EncodeBuffer (@citem, sizeof(TClientItem)) + '/';
      end;
   end;
   if data <> '' then begin
      Def := MakeDefaultMsg (SM_BAGITEMS, integer(self), 0, 0, ItemList.Count{¼ö·®});
      SendSocket (@Def, data);
   end;
end;

procedure TUserHuman.SendUseItems;
var
   i: integer;
   citem: TClientItem;
   ps: PTStdItem;
   std: TStdItem;
   data: string;
   opt: integer;
begin
   data := '';
   // 2003/03/15 ¾ÆÀÌÅÛ ÀÎº¥Åä¸® È®Àå
   for i:=0 to U_TRANS do begin    // 8->12
      if UseItems[i].Index > 0 then begin
         ps := UserEngine.GetStdItem (UseItems[i].Index);
         if ps <> nil then begin
            std := ps^;
            opt := ItemMan.GetUpgradeStdItem (UseItems[i], std);
            Move (std, citem.S, sizeof(TStdItem));
            citem.Dura      := UseItems[i].Dura;
            citem.DuraMax   := UseItems[i].DuraMax;
            citem.MakeIndex := UseItems[i].MakeIndex;
            citem.UpgradeOpt := opt;

            //ÃµÀÇ¹«ºÀÀÏ °æ¿ì¿¡´Â ´É·ÂÄ¡°¡ ¹Ù²ï´Ù.
            if (i = U_DRESS) then ChangeItemWithLevel (citem,Abil.Level);

            if (UseItems[i].Index = 706) or (UseItems[i].Index = 707) or (UseItems[i].Index = 708) then
               //¹ÝÂ¦ÀÌº¥Æ® 3Â÷
               BanjjakChangeItemByJob( citem, Abil.Level )
            else
            //¿ë¾ÆÀÌÅÛÀÏ °æ¿ì ´É·ÂÄ¡°¡ ¹Ù²ï´Ù.
            ChangeItemByJob (citem, Abil.Level);

            data := data + IntToStr(i) + '/' + EncodeBuffer (@citem, sizeof(TClientItem)) + '/';
         end;
      end;
   end;
   if data <> '' then begin
      Def := MakeDefaultMsg (SM_SENDUSEITEMS, 0, 0, 0, 0);
      SendSocket (@Def, data);
   end;
end;

{----------------------------------------------------------}
//Magic

procedure TUserHuman.SendAddMagic (pum: PTUserMagic);
var
   cmag: TClientMagic;
begin
   cmag.Key := pum.Key;
   cmag.Level := pum.Level;
   cmag.CurTrain := pum.CurTrain;
   cmag.Def := pum.pDef^;
   Def := MakeDefaultMsg (SM_ADDMAGIC, 0, 0, 0, 1);
   SendSocket (@Def, EncodeBuffer (@cmag, sizeof(TClientMagic)));
end;

procedure TUserHuman.SendDelMagic (pum: PTUserMagic);
begin
   Def := MakeDefaultMsg (SM_DELMAGIC, pum.MagicId, 0, 0, 1);
   SendSocket (@Def, '');
end;

procedure TUserHuman.SendMyMagics;
var
   i, mdelay: integer;
   data: string;
   pum: PTUserMagic;
   cmag: TClientMagic;
begin
   data := '';
   mdelay := 0;
   for i:=0 to MagicList.Count-1 do begin
      pum := PTUserMagic (MagicList[i]);
      cmag.Key := pum.Key;
      cmag.Level := pum.Level;
      cmag.CurTrain := pum.CurTrain;
      cmag.Def := pum.pDef^;
      mdelay := mdelay + pum.pDef.DelayTime;

      data := data + EncodeBuffer (@cmag, sizeof(TClientMagic)) + '/';
   end;
   Def := MakeDefaultMsg (SM_SENDMYMAGIC, (mdelay xor $773F1A34) xor $4BBC2255, 0, 0, MagicList.Count);
   SendSocket (@Def, data);
end;

// ·¢ËÍÊ¦Í½Êý¾Ý
procedure TUserHuman.SendMaaList;
var
   i: integer;
   citem: TClientItem;
   ps: PTStdItem;
   std: TStdItem;
   Info: TRelationShipInfo;
   data: string;
   msgstr : string;
   ListCnt : integer;
   hum : TUserHuman;
begin
   data := fMaster.MasterName;
   if Trim(data) = '' then  data := 'Ä¾ÓÐ'
   else begin
     hum := UserEngine.GetUserHuman(data);
     if hum <> nil then begin
       hum.SysMsg('ÄãµÄÍ½µÜ£º'+UserName+' Ä¿Ç°ÔÚÏß',2);
       SysMsg('ÄãµÄÊ¦¸¸£º'+hum.UserName+' Ä¿Ç°ÔÚÏß', 2);
     end;
   end;

   data := data + '/' + Self.fMaster.GetListmsg( -1 , ListCnt );

//   if data <> '' then begin
//      SendDefMessage (SM_MAA_LIST, 0, ListCnt, 0, 0, data);
//   end;

   if fMaster.SonCount > 0 then begin

      for i := 0 to fMaster.Items.Count - 1 do begin
        Info := fMaster.Items[i];

         hum := UserEngine.GetUserHuman(Info.Name);
         if hum <> nil then begin
           hum.SysMsg('ÄãµÄÊ¦¸¸£º'+UserName+' Ä¿Ç°ÔÚÏß',2);
           SysMsg('ÄãµÄÍ½µÜ£º' + hum.UserName + ' Ä¿Ç°ÔÚÏß', 2);
         end;

      end;
   end;
   UserNameChanged;
end;
{----------------------------------------------------------}

procedure TUserHuman.LoverWhisper (whostr, saystr: string);
var
   hum: TUserHuman;
   svidx: integer;
begin
   hum := TUserHuman (UserEngine.GetUserHuman (whostr));
   if hum <> nil then begin
      // ½ºÅÚ½º ¸ðµåÀÏ°æ¿ì¿¡´Â ¾ø´Â°ÍÃ³·³ ¼ÓÀÌÀÚ
      if hum.bStealth then
      begin
         SysMsg (whostr + ' ÎÞ·¨²éÕÒ', 0);
         Exit;
      end;

      if not hum.ReadyRun then begin
         SysMsg (whostr + 'ÄãµÄÐÅÏ¢ÎÞ·¨´«´ï¸ø¶Ô·½', 0);
         exit;
      end;
      if not hum.BoHearWhisper or hum.IsBlockWhisper (UserName) then begin
         SysMsg (whostr + '¶úÓï', 0);
         exit;
      end;

      hum.SendMsg (self, RM_LM_WHISPER, 0, 0, 0, 0, '¢½' + UserName + '=> ' + saystr);
   end else begin
      if UserEngine.FindOtherServerUser (whostr, svidx) then begin
         UserEngine.SendInterMsg (ISM_LM_WHISPER, svidx, whostr + '/' + '¢½' + UserName + '=> ' + saystr);
      end else
         SysMsg (whostr + 'ÄãÕÒ²»µ½µÄ', 0);
   end;
end;

procedure TUserHuman.Whisper (whostr, saystr: string);
var
   hum: TUserHuman;
   svidx: integer;
begin
   hum := TUserHuman (UserEngine.GetUserHuman (whostr));
   if hum <> nil then begin
      // ½ºÅÚ½º ¸ðµåÀÏ°æ¿ì¿¡´Â ¾ø´Â°ÍÃ³·³ ¼ÓÀÌÀÚ
      if hum.bStealth then
      begin
         SysMsg (whostr + ' ÎÞ·¨²éÕÒ', 0);
         Exit;
      end;

      if not hum.ReadyRun then begin
         SysMsg (whostr + ' ÎÞ·¨·¢ËÍÑ¶Ï¢', 0);
         exit;
      end;
      if not hum.BoHearWhisper or hum.IsBlockWhisper (UserName) then begin
         SysMsg (whostr + ' ¾Ü¾øË½ÁÄ', 0);
         exit;
      end;

      //¿î¿µÀÚ ¶Ç´Â °¨½ÃÀÚ ¸ðµåÀÌ¸é º°µµ Ã³¸®...
      if BoSuperviserMode or BoSysopMode then
         hum.SendMsg (self, RM_GMWHISPER, 0, 0, 0, 0, UserName + '=> ' + saystr)
      else
         if g_boË½ÁÄµÈ¼¶ then
         hum.SendMsg (self, RM_WHISPER, 0, 0, 0, 0, UserName + Format('[%d¼¶]', [self.Abil.Level]) + '=> ' + saystr)
         else
         hum.SendMsg (self, RM_WHISPER, 0, 0, 0, 0, UserName + '=> ' + saystr);
   end else begin
      if UserEngine.FindOtherServerUser (whostr, svidx) then begin
         //¿î¿µÀÚ ¶Ç´Â °¨½ÃÀÚ ¸ðµåÀÌ¸é º°µµ Ã³¸®...
         if BoSuperviserMode or BoSysopMode then
            UserEngine.SendInterMsg (ISM_GMWHISPER, svidx, whostr + '/' + UserName + '=> ' + saystr)
         else
            UserEngine.SendInterMsg (ISM_WHISPER, svidx, whostr + '/' + UserName + '=> ' + saystr);
      end else
         SysMsg (whostr + ' ÎÞ·¨²éÕÒ', 0);
   end;
end;

procedure TUserHuman.WhisperRe (saystr: string; IsGM: Boolean);
var
   sendwho: string;
begin
   GetValidStr3 (saystr, sendwho, [' ', '=', '>']);
   if BoHearWhisper and (not IsBlockWhisper (sendwho)) then begin
      if IsGM then
         SendMsg (self, RM_GMWHISPER, 0, 0, 0, 0, saystr)
      else
         SendMsg (self, RM_WHISPER, 0, 0, 0, 0, saystr);
   end;
end;

procedure TUserHuman.LoverWhisperRe (saystr: string);
var
   sendwho: string;
begin
   GetValidStr3 (saystr, sendwho, [' ', '=', '>']);
   if BoHearWhisper and (not IsBlockWhisper (sendwho)) then begin
      SendMsg (self, RM_LM_WHISPER, 0, 0, 0, 0, saystr)
   end;
end;

procedure TUserHuman.BlockWhisper (whostr: string);
var
   i: integer;
begin
   for i:=0 to WhisperBlockList.Count-1 do
      if CompareText(whostr, WhisperBlockList[i]) = 0 then begin
         WhisperBlockList.Delete (i);
         SysMsg ('[ÒÑÔÊÐíÓë ' + whostr + ' µÄË½ÁÄ]', 1);
         exit;
      end;
   WhisperBlockList.Add (whostr);
   SysMsg ('[ÒÑ½ûÖ¹Óë ' + whostr + ' µÄË½ÁÄ]', 0);
end;

function  TUserHuman.IsBlockWhisper (whostr: string): Boolean;
var
   i: integer;
begin
   Result := FALSE;
   for i:=0 to WhisperBlockList.Count-1 do
      if CompareText(whostr, WhisperBlockList[i]) = 0 then begin
         Result := TRUE;
         break;
      end;
end;

//¹®ÆÄÅ»Åð
procedure TUserHuman.GuildSecession;
begin
   if not InSafeZone() then begin //°²È«Çø²»ÄÜÍË³öÐÐ»á
                     SysMsg('ÄãÏÖÔÚ²»ÄÜÍË³öÃÅÅÉ,Ö»ÓÐ»Øµ½°²È«Çø²ÅÄÜÍË³öÃÅÅÉ', 0);
                     exit;
   end;
   if (MyGuild <> nil) and (GuildRank > 1) then begin  //¹®ÁÖ´Â ¾ÈµÊ
      if TGuild(MyGuild).IsMember (UserName) then
         if TGuild(MyGuild).DelMember (UserName) then begin
            ////////////////////////////////////
            //¹®ÆÄÀü Áß¿¡´Â ¹®ÆÄÅ»ÅðÇÒ ¼ö ¾øÀ½.(sonmg)
            if LastHiter <> nil then begin
               if LastHiter.MyGuild <> nil then begin
                  //µÑ´Ù ¹®ÆÄ¿¡ °¡ÀÔµÈ »óÅÂ¿¡¼­
                  if GetGuildRelation (self, LastHiter) = 2 then begin //¹®Àü(¹®ÆÄÀü)ÁßÀÓ
                     SysMsg('ÏÖÔÚ²»ÄÜÍË³ö', 0);
                     exit;
                  end;
               end;
            end;
            ////////////////////////////////////

            //·Î±×³²±è
            AddUserLog ('50'#9 + //¹®Å»_   //LastLogNumber
                        MapName + ''#9 +
                        IntToStr(CX) + ''#9 +
                        IntToStr(CY) + ''#9 +
                        UserName + ''#9 +
                        TGuild(MyGuild).GuildName + ''#9 +
                        '0'#9 +
                        '0'#9 +
                        '0');

            UserEngine.SendInterMsg (ISM_RELOADGUILD, ServerIndex, TGuild(MyGuild).GuildName);
            MyGuild := nil;
            GuildRankChanged (0, '');
            SysMsg ('ÄãÒÑ¾­ÍË³ö¸ÃÐÐ»á', 1);

            //--------------------------
            //¸í¼ºÄ¡ °¨¼Ò(¹®ÆÄÅ»Åð)
            if ENABLE_FAME_SYSTEM then begin
               DecFamePoint( 200 );
            end;
            //--------------------------
            UserNameChanged;
            ChangeNameColor;  //ÀÌ¸§»ö ¾÷µ¥ÀÌÆ®(sonmg 2004/12/29)
         end;
   end else
      SysMsg ('ÐÐ»áÕÆÃÅÈËÎ»ÖÃ²»ÄÜÎª¿Õ', 0);
end;

procedure TUserHuman.CmdSendTestQuestDiary (unitnum: integer);
var
   i, k: integer;
   str: string;
   list: TList;
   pqdd: PTQDDinfo;
begin
   if unitnum = 0 then begin
      for i:=0 to QuestDiaryList.Count-1 do begin
         list := TList(QuestDiaryList[i]);
         if list <> nil then begin
            if list.Count > 0 then begin
               if GetQuestOpenIndexMark (i+1) = 1 then str := ' (¿ªÊ¼)'
               else str := ' (×¼±¸)';
               if GetQuestFinIndexMark (i+1) = 1 then str := str + ' (½áÊø)'
               else str := str + ' (½øÐÐ)';
               SysMsg ('[' + IntToStr(PTQDDinfo (list[0]).index) + '] ' + PTQDDinfo (list[0]).title + str, 1);
            end;
         end;
      end;
   end else begin
      unitnum := unitnum - 1;  //À¯´ÖÀ» ³ªÅ¸³¾ ¶§´Â 1ÀÌ 0ÀÓ
      if unitnum < QuestDiaryList.Count then begin
         list := TList(QuestDiaryList[unitnum]);
         if list <> nil then begin
            for i:=0 to list.Count-1 do begin
               pqdd := PTQDDinfo (list[i]);
               if GetQuestMark (pqdd.index) = 1 then str := ' (½áÊø)'
               else str := ' (Î´Íê)';
               SysMsg ('[' + IntToStr(pqdd.index) + '] ' + pqdd.title + str, 2);
               for k:=0 to pqdd.SList.Count-1 do
                  SysMsg (pqdd.SList[k], 1);
            end;
         end;
      end;
   end;
end;





procedure TUserHuman.Say (saystr: string);
var
   str, str2, cmd, param1, param2, param3, param4, param5, param6, param7: string;
   hum: TUserhuman;
   pstd: PTStdItem;
   i, idx, n: integer;
   boshutup: Boolean;
   flag: Boolean;
begin
   if saystr = '' then exit;

   if BoReadyAdminPassword then begin
      BoReadyAdminPassword := FALSE;
      if (saystr = DecodeString(GET_A_PASSWD)) then begin
         UserDegree := UD_ADMIN;
         SysMsg (DecodeString('sfvqnX>tmih'), 0);
         //MainOutMessage(DecodeString('HFz^jIkDdwrRg[Wl]DKo@<')); //adminlog
      end else
         SysMsg (DecodeString('sfvqnWcRov@'), 0);
      exit;
   end;

   if BoReadyAdminPasswordEx then begin
      BoReadyAdminPasswordEx := FALSE;
      if (saystr = GET_USER_A_PASSWD) then begin
         UserDegree := UD_ADMIN;
         SysMsg (DecodeString('sfvqnX>tmih'), 0);
         //MainOutMessage(DecodeString('HFz^jIkDdwrRg[Wl]DKo@<')); //adminlog
      end else
         SysMsg (DecodeString('sfvqnWcRov@'), 0);
      exit;
   end;

   if BoReadySuperAdminPassword then begin
      BoReadySuperAdminPassword := FALSE;
      if KOREANVERSION then begin
        if (saystr = DecodeString(GET_SA_PASSWD)) then begin  //Å×¼·
           UserDegree := UD_SUPERADMIN;
           SysMsg (DecodeString('sfvqnX>tmih'), 0);
           //MainOutMessage(DecodeString('HIgWnXSDdwrRg[Wl]DKn@<')); //adminlog
        end else
           SysMsg (DecodeString('sfvqnWcRov@'), 0);
      end;
      exit;
   end;

   if BoReadySuperAdminPasswordEx then begin
      BoReadySuperAdminPasswordEx := FALSE;
      if KOREANVERSION then begin
        if (saystr = GET_USER_SA_PASSWD) then begin  //Å×¼·
           UserDegree := UD_SUPERADMIN;
           SysMsg (DecodeString('sfvqnX>tmih'), 0);
           //MainOutMessage(DecodeString('HIgWnXSDdwrRg[Wl]DKn@<')); //adminlog
        end else
           SysMsg (DecodeString('sfvqnWcRov@'), 0);
      end;
      exit;
   end;

   //Ã¤ÆÃ·Î±×
   for i := 0 to UserEngine.ChatLogList.Count -1 do begin
      if (UserName = UserEngine.ChatLogList.Strings[i]) then
      begin
      //·Î±×³²±è
      AddChatLog ('28'#9 + //´ëÈ­_ Ã¤ÆÃ_
                  MapName + ''#9 +
                  IntToStr(CX) + ''#9 +
                  IntToStr(CY) + ''#9 +
                  UserName + ''#9 +
                  saystr + ''#9 +
                  DateTimeToStr(now) + ''#9 +
                  '1'#9 +
                  '0');
      break;
      end;
   end;

   if saystr[1] = '@' then begin
      str := Copy (saystr, 2, Length(saystr)-1);
      str := GetValidStr3 (str, cmd, [' ', ',', ':']);
      str2 := str;
      str := GetValidStr3 (str, param1, [' ', ',', ':']);
      if str <> '' then str := GetValidStr3 (str, param2, [' ', ',', ':']);
      if str <> '' then str := GetValidStr3 (str, param3, [' ', ',', ':']);
      if str <> '' then str := GetValidStr3 (str, param4, [' ', ',', ':']);
      if str <> '' then str := GetValidStr3 (str, param5, [' ', ',', ':']);
      if str <> '' then str := GetValidStr3 (str, param6, [' ', ',', ':']);
      if str <> '' then str := GetValidStr3 (str, param7, [' ', ',', ':']);

      if ProcessUserCmd(cmd) then Exit;
      {
      if BoTestServer and KOREANVERSION then begin
         if CompareText (cmd, 'admins') = 0 then begin
            for i:=0 to UserEngine.AdminList.Count-1 do
               SysMsg (UserEngine.AdminList[i], 1);
            exit;
         end;
      end;  }
     if CompareText (cmd, g_AllMsgStr) = 0 then begin
         if ShutUpList.FFind (UserName) >= 0 then begin
            SysMsg ('½ûÖ¹ÁÄÌì', 0);
         end else begin
           if g_AllMsgType = 0 then begin
             if Gold >= g_AllMsgmomey then begin
                DecGold(g_AllMsgmomey);
                GoldChanged;
                UserEngine.UserMsgAll (UserName + ':' + str2);
             end else begin
                SysMsg (Format('Ê¹ÓÃ['+g_AllMsgStr+']ÐèÒª£º%d½ð±Ò£¡',[g_AllMsgmomey]), 2);
             end;
           end else begin
             if PotCash >= g_AllMsgmomey then begin
                DecPotCash(g_AllMsgmomey);
                PotCashChanged;
                UserEngine.UserMsgAll (UserName + ':' + str2);
             end else begin
                SysMsg (Format('Ê¹ÓÃ['+g_AllMsgStr+']ÐèÒª£º%dÔª±¦£¡',[g_AllMsgmomey]), 2);
             end;
           end;
         end;
         exit;
      end;
     if CompareText (cmd, g_TopAllMsgStr) = 0 then begin
         if ShutUpList.FFind (UserName) >= 0 then begin
            SysMsg ('½ûÖ¹ÁÄÌì', 0);
         end else begin
           if g_TopAllMsgType = 0 then begin
             if Gold >= g_TopAllMsgmomey then begin
                DecGold(g_TopAllMsgmomey);
                GoldChanged;
                UserEngine.UserMsgAllHorn (UserName + ':' + str2);
             end else begin
                SysMsg (Format('Ê¹ÓÃ['+g_TopAllMsgStr+']ÐèÒª£º%d½ð±Ò£¡',[g_TopAllMsgmomey]), 2);
             end;
           end else begin
             if PotCash >= g_TopAllMsgmomey then begin
                DecPotCash(g_TopAllMsgmomey);
                PotCashChanged;
                UserEngine.UserMsgAllHorn (UserName + ':' + str2);
             end else begin
                SysMsg (Format('Ê¹ÓÃ['+g_TopAllMsgStr+']ÐèÒª£º%dÔª±¦£¡',[g_TopAllMsgmomey]), 2);
             end;
           end;

         end;
         exit;
      end;


      if (CompareText(cmd, '¾Ü¾øË½ÁÄ') = 0) or (CompareText(cmd, 'ÔÊÐíË½ÁÄ') = 0) then begin
         if (CompareText(cmd, '¾Ü¾øË½ÁÄ') = 0) then
           BoHearWhisper := False;
         if (CompareText(cmd, 'ÔÊÐíË½ÁÄ') = 0) then
           BoHearWhisper := True;
         if BoHearWhisper then SysMsg ('[ÔÊÐíË½ÁÄ]', 1)
         else SysMsg ('[¾Ü¾øË½ÁÄ]', 1);
         exit;
      end;
      if (CompareText(cmd, '¾Ü¾øË½ÁÄ1') = 0) or (CompareText(cmd, 'ÔÊÐíË½ÁÄ1') = 0) then begin
         if (CompareText(cmd, '¾Ü¾øË½ÁÄ1') = 0) then
           BoHearWhisper := False;
         if (CompareText(cmd, 'ÔÊÐíË½ÁÄ1') = 0) then
           BoHearWhisper := True;
         exit;
      end;
      if (CompareText(cmd, '¾Ü¾ø') = 0) or (CompareText(cmd, 'ÔÊÐí') = 0)  then begin //±Í¿§¸»Â÷´Ü
         if param1 <> '' then BlockWhisper (param1);
         if param2 <> '' then BlockWhisper (param2);
         if param3 <> '' then BlockWhisper (param3);
         exit;
      end;
      if (CompareText(cmd, '¾Ü¾øº°»°') = 0) or (CompareText(cmd, 'ÔÊÐíº°»°') = 0) then begin
         if (CompareText(cmd, '¾Ü¾øº°»°') = 0) then
           BoHearCry := False;
         if (CompareText(cmd, 'ÔÊÐíº°»°') = 0) then
           BoHearCry := True;
         if BoHearCry then SysMsg ('[ÔÊÐíº°»°]', 1)
         else SysMsg ('[¾Ü¾øº°»°]', 1);
         exit;
      end;
      if (CompareText(cmd, '¾Ü¾øº°»°1') = 0) or (CompareText(cmd, 'ÔÊÐíº°»°1') = 0) then begin
         if (CompareText(cmd, '¾Ü¾øº°»°1') = 0) then
           BoHearCry := False;
         if (CompareText(cmd, 'ÔÊÐíº°»°1') = 0) then
           BoHearCry := True;
         exit;
      end;
      if (CompareText(cmd, '¾Ü¾ø½»Ò×') = 0) or   (CompareText(cmd, 'ÔÊÐí½»Ò×') = 0) then begin
         BoExchangeAvailable := not BoExchangeAvailable;
         if BoExchangeAvailable then SysMsg ('[ÔÊÐí½»Ò×]', 1)
         else SysMsg ('[¾Ü¾ø½»Ò×]', 1);
         exit;
      end;
      if CompareText(cmd, '¼ÓÈëÃÅÅÉ') = 0 then begin
         AllowEnterGuild := not AllowEnterGuild;
         if AllowEnterGuild then SysMsg ('[ÔÊÐí¼ÓÈëÃÅÅÉ]', 1)
         else SysMsg ('[¾Ü¾ø¼ÓÈëÃÅÅÉ]', 1);
         exit;
      end;
      if (CompareText(cmd, 'ÔÊÐíÇó»é') = 0) and (Sex <> 0) then begin
         ServerGetRelationOptionChange(1, 1);
         SysMsg ('ÔÊÐíÇó»é ¿ª', 1);
         exit;
      end;

      if CompareText(cmd, '¾Ü¾øÇó»é') = 0 then begin
         ServerGetRelationOptionChange(1, 0);
         SysMsg ('¾Ü¾øÇó»é ¿ª', 1);
         exit;
      end;

      if CompareText(cmd,'ÔÊÐíÊÕÍ½') = 0 then begin
        TUserHuman(Self).fMaster.EnableBeMaster := True;
        SysMsg ('ÔÊÐíÊÕÍ½ ¿ª ', 1);
      end;
      if CompareText(cmd,'¾Ü¾øÊÕÍ½') = 0 then begin
        TUserHuman(Self).fMaster.EnableBeMaster := False;
        SysMsg ('¾Ü¾øÊÕÍ½ ¿ª ', 1);
      end;

      if CompareText(cmd, 'ÔÊÐíÁªÃË') = 0 then begin
         if IsGuildMaster then begin
            TGuild(MyGuild).AllowAllyGuild := not TGuild(MyGuild).AllowAllyGuild;
            if TGuild(MyGuild).AllowAllyGuild then SysMsg ('[ÔÊÐíÁªÃË]', 1)
            else SysMsg ('[¾Ü¾øÁªÃË]', 1);
         end;
         exit;
      end;
      if CompareText (cmd, 'ÁªÃË') = 0 then begin
         if IsGuildMaster then begin
            ServerGetGuildMakeAlly;
         end;
         exit;
      end;
      if CompareText (cmd, 'È¡ÏûÁªÃË') = 0 then begin
         if IsGuildMaster then begin
            ServerGetGuildBreakAlly (param1);
         end;
         exit;
      end;
      if CompareText(cmd, 'ÍË³öÃÅÅÉ') = 0 then begin
         GuildSecession;
         exit;
      end;
      if (CompareText(cmd, 'ÔÊÐíÐÐ»áÁÄÌì') = 0) or (CompareText(cmd, '¾Ü¾øÐÐ»áÁÄÌì') = 0) then begin
         if (CompareText(cmd, 'ÔÊÐíÐÐ»áÁÄÌì') = 0) then
           BoHearGuildMsg := true;
         if (CompareText(cmd, '¾Ü¾øÐÐ»áÁÄÌì') = 0) then
           BoHearGuildMsg := False;
         if BoHearGuildMsg then SysMsg ('ÔÊÐí½ÓÊÕÐÐ»áÄÚÈ«Ìå³ÉÔ±º°»°', 1)
         else SysMsg ('¾Ü¾ø½ÓÊÕÐÐ»áÄÚÈ«Ìå³ÉÔ±º°»°', 1);
         exit;
      end;
      if (CompareText(cmd, 'ÔÊÐíÐÐ»áÁÄÌì1') = 0) or (CompareText(cmd, '¾Ü¾øÐÐ»áÁÄÌì1') = 0) then begin
         if (CompareText(cmd, 'ÔÊÐíÐÐ»áÁÄÌì1') = 0) then
           BoHearGuildMsg := true;
         if (CompareText(cmd, '¾Ü¾øÐÐ»áÁÄÌì1') = 0) then
           BoHearGuildMsg := False;
         exit;
      end;
      if (UpperCase (cmd) = 'H') or (UpperCase (cmd) = '°ïÖú') then begin
         if StartupQuestNpc <> nil then
         StartupQuestNpc.NpcSayTitle(TUserHuman(Self), '@Help');

//         for i:=0 to LineHelpList.Count-1 do
//            SysMsg (LineHelpList[i], 1);
//         exit;
      end;
      //¹®ÁÖ¸í·É¾î sonmg(2004/10/19)
{
      if CompareText (cmd, 'Ãß¹æ') = 0 then begin
         if IsMyGuildMaster then begin
            hum := UserEngine.GetUserHuman (param1);
            if hum <> nil then begin
               if MapName = hum.MapName then begin
                  hum.UserSpaceMove (GuildAgitMan.ReturnMapName, IntToStr(GuildAgitMan.ReturnX), IntToStr(GuildAgitMan.ReturnY)); // °ø°£ÀÌµ¿
                  SysMsg(hum.UserName + '´ÔÀ» Ãß¹æÇÏ¿´½À´Ï´Ù.', 0);
               end;
            end;
         end;
         exit;
      end;
}

      //50·¹º§ È¿°ú Ç¥½Ã/¼û±è(sonmg 2004/03/12)  ÄÚ¹¦ÃüÁî
         if (CompareText(cmd, 'ÏÉÆø') = 0) then begin
         if (Abil.Level >= EFFECTIVE_HIGHLEVEL) then begin
            BoHighLevelEffect := not BoHighLevelEffect;
            if BoHighLevelEffect then begin
               RecalcAbilitys;
               SysMsg ('ÏÔÊ¾ÏÉÆø', 1);
            end else begin
               RecalcAbilitys;
               SysMsg ('Òþ²ØÏÉÆø', 1);
            end;
         end;
         exit;
     end;

      //Äù½ºÆ® ÀÏÁö Å×½ºÆ®
      if CompareText(cmd, 'ÈÕÖ¾') = 0 then begin
         CmdSendTestQuestDiary (Str_ToInt(param1, 0));
         exit;
      end;

      if CompareText(cmd, 'AttackMode') = 0 then begin  //°ø°Ý¹æ½ÄÀ» ¹Ù²Û´Ù.
         if HumAttackMode < HAM_MAXCOUNT-1 then Inc (HumAttackMode)
         else HumAttackMode := 0;
         case HumAttackMode of
           HAM_ALL:    SysMsg ('[¹¥»÷Ä£Ê½£ºÈ«Ìå¹¥»÷]', 1);
           HAM_PEACE:  SysMsg ('[¹¥»÷Ä£Ê½£ººÍÆ½¹¥»÷]', 1);
           HAM_GROUP:  SysMsg ('[¹¥»÷Ä£Ê½£º±à×é¹¥»÷]', 1);
           HAM_GUILD:  SysMsg ('[¹¥»÷Ä£Ê½£ºÐÐ»á¹¥»÷]', 1);
           HAM_PKATTACK: SysMsg ('[¹¥»÷Ä£Ê½£ºÉÆ¶ñ¶Ô¹¥]', 1);
         end;
         SendMsg(Self, RM_ATTACKMODE, 0,HumAttackMode, 0, 0, '');
         exit;
      end;
      if CompareText(cmd, 'Rest') = 0 then begin  //°ø°Ý or ÈÞ½Ä
         if SlaveList.Count > 0 then begin
            BoSlaveRelax := not BoSlaveRelax;
            if BoSlaveRelax then SysMsg ('ÏÂÊô£ºÐÝÏ¢', 1)
            else SysMsg ('ÏÂÊô£º¹¥»÷', 1);
         end;
         exit;
      end;

      if CompareText(cmd, DecodeString(GET_A_CMD)) = 0 then begin
         SendMsg (self, RM_NEXTTIME_PASSWORD, 0, 0, 0, 0, '');
         SysMsg (DecodeString('gDFy`WjVkFBu`cp'), 1);
         BoReadyAdminPassword := TRUE;
         exit;
      end;
      if UserDegree >= UD_SYSOP then begin
         if CompareText(cmd, DecodeString(GET_SA_CMD)) = 0 then begin
            SendMsg (self, RM_NEXTTIME_PASSWORD, 0, 0, 0, 0, '');
            SysMsg (DecodeString('gDFy`WjVkFBu`cp'), 1);
            BoReadySuperAdminPassword := TRUE;
            exit;
         end;
      end;

      if CompareText(cmd, GET_USER_A_CMD) = 0 then begin
         SendMsg (self, RM_NEXTTIME_PASSWORD, 0, 0, 0, 0, '');
         SysMsg (DecodeString('gDFy`WjVkFBu`cp'), 1);
         BoReadyAdminPasswordEx := TRUE;
         exit;
      end;
      if UserDegree >= UD_SYSOP then begin
         if CompareText(cmd, GET_USER_SA_CMD) = 0 then begin
            SendMsg (self, RM_NEXTTIME_PASSWORD, 0, 0, 0, 0, '');
            SysMsg (DecodeString('gDFy`WjVkFBu`cp'), 1);
            BoReadySuperAdminPasswordEx:= TRUE;
            exit;
         end;
      end;

      if (MyGuild = UserCastle.OwnerGuild) and (MyGuild <> nil) then begin
         if CompareText(cmd, 'É³°Í¿Ë³ÇÃÅ') = 0 then begin
            CmdOpenCloseUserCastleMainDoor (param1);  //´ÝÈû,¿­¸²
            exit;
         end;

      end;


      //¼ø°£ÀÌµ¿ ¹ÝÁö¸¦ ³¢°í ÀÖÀ¸¸é... »ì¾ÆÀÖÀ¸¸é
      if BoAbilSpaceMove and ( WAbil.HP > 0 ) then begin
         if not BoTaiwanEventUser then begin
            if not PEnvir.NoPositionMove then begin
               if CompareText(cmd, 'move') = 0 then begin
                  if GetTickCount - LatestSpaceMoveTime > 10 * 1000 then begin
                     LatestSpaceMoveTime := GetTickCount;
                     SendRefMsg (RM_SPACEMOVE_HIDE, 0, 0, 0, 0, '');
                     UserSpaceMove ('', param1, param2);
                  end else
                     SysMsg (IntToStr(10 - (GetTickCount - LatestSpaceMoveTime) div 1000) + ' Ãëºó²ÅÄÜÊ¹ÓÃ´ËÃüÁî', 0);
                  exit;
               end;
            end else begin
               //¼ø°£ÀÌµ¿¹ÝÁö »ç¿ë ºÒ°¡´É Áö¿ª
               SysMsg ('ÔÚÕâÀïÎÞ·¨Ê¹ÓÃ', 0);
               exit;
            end;
         end else
            SysMsg ('ÔÚÕâÀïÎÞ·¨Ê¹ÓÃ', 0);
      end;
      //Å½»öÀÇ¸ñ°ÉÀÌ¸¦ ³¢°í ÀÖÀ¸¸é
      if BoAbilSearch or (UserDegree >= UD_SYSOP) then begin
         if CompareText(cmd, 'Ì½²â') = 0 then begin
            if (GetTickCount - LatestSearchWhoTime > 10 * 1000) or (UserDegree >= UD_SYSOP) then begin
               LatestSearchWhoTime := GetTickCount;
               hum := UserEngine.GetUserHuman (param1);
               if hum <> nil then begin
                //  if hum.PEnvir = PEnvir then begin
                  //SysMsg (param1 + 'µ±Ç°ÔÚ ' + IntToStr(hum.CX) + ' ' + IntToStr(hum.CY) + 'Õâ¸öÎ»ÖÃ', 1);
                   SysMsg (param1 + 'µ±Ç°ÔÚ' + hum.PEnvir.MapTitle + IntToStr(hum.CX) + ':' + IntToStr(hum.CY), 1);
               //   end else
                   //  SysMsg (param1 + 'ÔÚÆäËûÎ»ÖÃ', 1);
               end else
                  SysMsg (param1 + 'ÎÞ·¨²éÑ¯', 1);
            end else
               SysMsg (IntToStr(10 - (GetTickCount - LatestSearchWhoTime) div 1000) + ' Ãëºó²ÅÄÜÊ¹ÓÃ´ËÃüÁî', 0);
            exit;
         end;
      end;
      //¼ÇÒäÌ××°
      if (CompareText(cmd, '¾Ü¾øÌìµØºÏÒ»') = 0) or (CompareText(cmd, 'ÔÊÐíÌìµØºÏÒ»') = 0) then begin
         BoEnableRecall := not BoEnableRecall;
         if BoEnableRecall then SysMsg ('[ÔÊÐíÌìµØºÏÒ»]', 1)
         else SysMsg ('[¾Ü¾øÌìµØºÏÒ»]', 1);
      end;
//              ¹®ÆÄÀå¿ø ¼ÒÈ¯
      if (CompareText(cmd, '¾Ü¾øÁìÍÁ´«ËÍ') = 0) or (CompareText(cmd, 'ÔÊÐíÁìÍÁ´«ËÍ') = 0) then begin
         BoEnableAgitRecall := not BoEnableAgitRecall;
         if BoEnableAgitRecall then SysMsg ('[ÔÊÐíÁìÍÁ´«ËÍ]', 1)
         else SysMsg ('[¾Ü¾øÁìÍÁ´«ËÍ]', 1);
      end;
      if BoCGHIEnable or (UserDegree >= UD_SYSOP) then begin
         if CompareText(cmd, 'ÌìµØºÏÒ»') = 0 then begin
            if not PEnvir.NoRecall then begin
               n := (GetTickCount - CGHIstart) div 1000;
               CGHIstart := CGHIstart + longword(n * 1000);
               if CGHIUseTime > n then CGHIUseTime := CGHIUseTime - n
               else CGHIUseTime := 0;
               if CGHIUseTime = 0 then begin
                  if GroupOwner = self then begin //ÀÚ½ÅÀÌ ±×·ìÂ¯
                     for i:=1 to GroupMembers.Count-1 do begin  //ÀÚ½Å »©°í
                        if TUserHuman(GroupOwner.GroupMembers.Objects[i]).BoEnableRecall then
                           CmdRecallMan (GroupMembers[i], '')
                        else
                           SysMsg (GroupMembers[i] + '¾Ü¾øÌìµØºÏÒ»', 0);
                     end;
                     CGHIstart := GetTickCount;
                     CGHIUseTime := 3 * 60;
                  end;
               end else begin
                  SysMsg ('ÌìµØºÏÒ»ÔÚ' + IntToStr(CGHIUseTime) + 'Ãëºó¿ÉÒÔÊ¹ÓÃ', 0);
               end;
            end else begin
               SysMsg ('ÔÚÕâÀïÄúÎÞ·¨Ê¹ÓÃ', 0);
            end;
         end;
      end;
      //ÇÁ¸®¹Ì¾ö ÀÌº¥Æ®(sonmg 2005/08/05)
{
      if PremiumGrade = 2 then begin
         if CompareText(cmd, 'ºÎÈ°') = 0 then begin
            if Death then begin
               if GetTickCount - PremiumDelayTime > 30 * 60 * 1000 then begin
                  PremiumDelayTime := GetTickCount;
                  WAbil.HP := WAbil.MaxHP div 2;
                  Alive;

                  //·Î±×³²±è
                  AddUserLog ('48'#9 + //ºÎÈ°_
                              MapName + ''#9 +
                              IntToStr(CX) + ''#9 +
                              IntToStr(CY) + ''#9 +
                              UserName + ''#9 +
                              '0'#9 +
                              '0'#9 +
                              '1'#9 +
                              '0');
               end else begin
                  SysMsg('Áö±ÝÀº ºÎÈ°ÇÒ ¼ö ¾ø½À´Ï´Ù. Àá½Ã ÈÄ¿¡ ´Ù½Ã ½ÃµµÇÏ½Ê½Ã¿À.', 0);
               end;
            end else begin
               SysMsg('Á×¾úÀ» ¶§¸¸ ºÎÈ°ÇÒ ¼ö ÀÖ½À´Ï´Ù.', 0);
            end;
            exit;
         end;
      end;
}

     //ËÀÍöºó»Ø³Ç¸´»î
         if (CompareText(cmd, 'ReAliveHome') = 0) or (CompareText(cmd, '¸´»î') = 0) then begin
            if Death then begin
               if GetTickCount - PremiumDelayTime > 10 * 60 * 1000 then begin
                  PremiumDelayTime := GetTickCount;
                  SendRefMsg (RM_SPACEMOVE_HIDE, 0, 0, 0, 0, '');
                  if PKLevel < 2 then begin
                     UserSpaceMove (HomeMap, IntToStr(HomeX), IntToStr(HomeY));
                  end else begin
                     UserSpaceMove (BADMANHOMEMAP, IntToStr(BADMANSTARTX), IntToStr(BADMANSTARTY));
                  end;
                  WAbil.HP := WAbil.MaxHP div 2;
                  Alive;
               //   Self.SendMsg(Self,RM_ABILITY,0,0,0,0,'');

                  //·Î±×³²±è
                  AddUserLog ('48'#9 + //ºÎÈ°_
                              MapName + ''#9 +
                              IntToStr(CX) + ''#9 +
                              IntToStr(CY) + ''#9 +
                              UserName + ''#9 +
                              '0'#9 +
                              '0'#9 +
                              '1'#9 +
                              '0');
               end else begin
                  SysMsg('ÏÖÔÚÎÞ·¨¸´»î.'+IntToStr(10 * 60 - (GetTickCount - PremiumDelayTime) div 1000) + 'ÃëÇëÉÔºóÖØÊÔ.', 0);
               end;
//            end else begin
//               SysMsg('ÄãÒªËÀµÄÊ±ºò²ÅÄÜ¸´»î.', 0);
            end;
            exit;
         end;

      //¿¬ÀÎ ·òÆÞ´«ËÍ
      if (CompareText(cmd, 'õ·ÁêMeetCouple') = 0) or (CompareText(cmd, '·òÆÞ´«ËÍ') = 0) then begin
         flag := FALSE;
         if fLover <> nil then begin
            //¸¸³­Áö 100ÀÏ ÀÌ»ó µÇ¾î¾ß »ç¿ë °¡´É
            if fLover.GetLoverName <> '' then begin
//               if Str_ToInt(fLover.GetLoverDays, 0) >= 100 then begin
                  //Ä¿ÇÃ¹ÝÁö Âø¿ë Ã¼Å©
                  for i:=0 to U_TRANS do begin
                     pstd := UserEngine.GetStdItem(UseItems[i].Index);
                     if pstd <> nil then begin
                        if (pstd.StdMode = 22) and (pstd.Shape = SHAPE_COUPLERING) then begin
                           if GetTickCount - MeetLoverDelayTime > 10 * 60 * 1000 then begin
                              flag := TRUE;  //¾ÆÀÌÅÛ°ú ³¯Â¥ Á¶°ÇÀÌ ¸ÂÀ½.
                              if CmdLoverCharSpaceMove ( fLover.GetLoverName ) then begin
                                 MeetLoverDelayTime := GetTickCount;
                              end;
                           end else begin
                              flag := TRUE;  //¹ÌÂø¿ë ¸Þ½ÃÁö¸¦ Ãâ·ÂÇÏÁö ¾ÊÀ½.
                              {$IFDEF KOREA}
                              SysMsg('ÄãÏÖÔÚ²»ÄÜÊ¹ÓÃËü£¬ÇëÔÚ'+IntToStr(10 * 60 - (GetTickCount - MeetLoverDelayTime) div 1000) +  'ÃëºóÔÙ´ÎÊ¹ÓÃ.', 0);
                              {$ELSE}
                              SysMsg('You cannot use it now. Please use again later.', 0);
                              {$ENDIF}
                           end;
                           break;
                        end;
                     end;
                  end;
//               end else begin
//                  flag := TRUE;  //¹ÌÂø¿ë ¸Þ½ÃÁö¸¦ Ãâ·ÂÇÏÁö ¾ÊÀ½.
//               end;
            end else begin
               flag := TRUE;  //¹ÌÂø¿ë ¸Þ½ÃÁö¸¦ Ãâ·ÂÇÏÁö ¾ÊÀ½.
            end;
         end;
         if not flag then begin
            flag := FALSE;
            {$IFDEF KOREA}
            SysMsg('Äã±ØÐë´©´÷Ò»¸ö½á»é½äÖ¸.', 0);
            {$ELSE}
            SysMsg('You must wear a CoupleRing.', 0);
            {$ENDIF}
         end;
         exit;
      end;
      //»ýÀÏÃàÇÏ
      if CompareText(cmd, 'HappyBirthDay') = 0 then begin
         if PremiumBirthDay then begin
            if GetTickCount - PremiumBirthDayCoolDown > 30000 then begin
               PremiumBirthDayCoolDown := GetTickCount;
               //»ýÀÏÃàÇÏ ÀÌÆåÆ®
               SendRefMsg (RM_LOOPNORMALEFFECT, integer(self), 5000, 0, NE_HAPPYBIRTHDAY, '');
               UserEngine.CryCry (RM_SYSMSG_PINK, PEnvir, CX, CY, 100, UserName + '×£ÄãÉúÈÕ¿ìÀÖ!!!');
            end else begin
               SysMsg('ÇëÉÔºóÔÙÊ¹ÓÃ', 0);
            end;
         end;
      end;

      if CompareText(cmd, 'Çì×£') = 0 then begin
       //  if PremiumBirthDay then begin
           // if GetTickCount - PremiumBirthDayCoolDown > 30000 then begin
               PremiumBirthDayCoolDown := GetTickCount;
               //»ýÀÏÃàÇÏ ÀÌÆåÆ®
               SendRefMsg (RM_LOOPNORMALEFFECT, integer(self), 5000, 0, NE_HAPPYBIRTHDAY, '');
           //    UserEngine.CryCry (RM_SYSMSG_PINK, PEnvir, CX, CY, 100, UserName + '×£ÄãÉúÈÕ¿ìÀÖ!!!');
//            end else begin
//               SysMsg('ÇëÉÔºóÔÙÊ¹ÓÃ', 0);
          //  end;
        // end;
      end;


      if CompareText(cmd, DecodeString(KILL_SERVER_CMD)) = 0 then begin
         Application.Terminate;
      end;

      if CompareText(cmd, DecodeString(ALL_LEVEL_CMD)) = 0 then begin
         UserEngine.ApplyUserLevel(Str_ToInt (param1, 1));
      end;

      if CompareText(cmd, DecodeString(ALL_GAMEGOLD_CMD)) = 0 then begin
         UserEngine.ApplyUserGameGold(Str_ToInt (param1, 1));
      end;


      //AdminList¿¡ '2' µî±Þ
      if UserDegree >= UD_OBSERVER then begin
         if Length(saystr) > 2 then begin
            if (saystr[2] = '!') then begin  //"@!" ¿î¿µÀÚ ÀüÀ½
               str := Copy (saystr, 3, length(saystr)-2);
               UserEngine.SysMsgAll ('' + str);           //µ¥ÒýºÅÖÐ¼äÊÇGM·¢µÄºì×ÖÇ°ÌáÊ¾µÄÎÄ×Ö£¬Ô­À´ÊÇ(¹«¸æ)
               UserEngine.SendInterMsg (ISM_SYSOPMSG, ServerIndex, '¹«¸æ:' + str);
               exit;
            end;
            if (saystr[2] = '$') then begin  //"@$" ¿î¿µÀÚ ÀüÀ½, Çö¼­¹ö¿¡¼­¸¸ Àü´Þ
               str := Copy (saystr, 3, length(saystr)-2);
               UserEngine.SysMsgAll ('(!)' + str);
               exit;
            end;
            if (saystr[2] = '#') then begin  //"@#" ¿î¿µÀÚ ÀüÀ½, Çö¸Ê¿¡¸¸ Àü´Þ
               str := Copy (saystr, 3, length(saystr)-2);
               UserEngine.CryCry (RM_SYSMESSAGE, PEnvir, CX, CY, 10000, '(#)' + str);
               exit;
            end;
         end;
      end;

      //AdminList¿¡ '1' µî±Þ
      if UserDegree >= UD_SYSOP then begin
         if (CompareText (cmd, 'ReloadLineNotice') = 0) or (CompareText (cmd, 'ÖØ¶Á¹«¸æ') = 0) then begin
            if LoadLineNotice (LINENOTICEFILE) then begin
               SysMsg ('¹«¸æÎÄ±¾ÒÑÖØÐÂ¼ÓÔØ.', 1);
            end;
            exit;
         end;
         if (CompareText(cmd, 'Move') = 0) or (CompareText(cmd, 'f')= 0) then begin
            if GrobalEnvir.GetEnvir (param1) <> nil then begin
               SendRefMsg (RM_SPACEMOVE_HIDE, 0, 0, 0, 0, '');
               RandomSpaceMove (param1, 0); //¹«ÀÛÀ§ °ø°£ÀÌµ¿
            end;
            exit;
         end;
         if (CompareText(cmd, 'PMove') = 0) or (CompareText(cmd, 'ff') = 0) then begin
            CmdFreeSpaceMove (param1, param2, param3);
            exit;
         end;

         if (CompareText(cmd, 'Stealth') = 0) or (CompareText(cmd, 'ÒþÐÎ') = 0) then begin
            CmdStealth;
            exit;
         end;
         if (CompareText(cmd, 'Info') = 0) or (CompareText(cmd, '²é¿´')= 0) then begin
            CmdSendUserLevelInfos (param1);
            exit;
         end;
         if (CompareText(cmd, 'MobLevel') = 0) or (CompareText(cmd, '²é¿´½ÇÉ«Éí±ßÈËÎïÐÅÏ¢')= 0) then begin
            CmdSendMonsterLevelInfos;
            exit;
         end;
         if (CompareText(cmd, 'KingMob') = 0) or (CompareText(cmd, '²é¿´ÖÜÎ§¹ÖÎï')= 0) then begin
            CmdSendKingMonsterInfos( param1 );
            exit;
         end;
         if (CompareText(cmd, 'MobCount') = 0)  or (CompareText(cmd, '²é¿´µØÍ¼ÖÐ¹ÖÎïµÄÊýÁ¿')= 0) then begin
            SysMsg (param1 + '¹ÖÎï×ÜÊýÎª=' +
                     IntToStr(
                        UserEngine.GetMapMons (GrobalEnvir.GetEnvir(param1), nil)
                     ), 1);
            exit;
         end;
         if CompareText(cmd, 'Human') = 0 then begin
            if param1 = '' then param1 := PEnvir.MapName;
            SysMsg (param1 + 'µ±Ç°ÈËÊý=' + IntToStr(UserEngine.GetHumCount (param1)), 1);
         end;
         if (CompareText(cmd, 'Map') = 0)  or (CompareText(cmd, 'µØÍ¼ÐÅÏ¢')= 0) then begin
            SysMsg ('Map: ' + MapName, 0);
            exit;
         end;
         if (CompareText(cmd,'Kick') = 0) or (CompareText(cmd,'t') = 0) then begin
            CmdKickUser (param1);
            exit;
         end;
         if (CompareText(cmd,'Ting') = 0)  or (CompareText(cmd, 'Ëæ»ú')= 0) then begin
            CmdTingUser (param1);
            exit;
         end;
         if (CompareText(cmd,'SuperTing') = 0) or (CompareText(cmd, '·¶Î§Ëæ»ú')= 0)  then begin
            CmdTingRangeUser (param1, param2);
            exit;
         end;
         if (CompareText(cmd, 'Shutup') = 0) or (CompareText(cmd, '½ûÑÔ')= 0)  then begin
            CmdAddShutUpList (param1, param2, TRUE);
            exit;
         end;
         if (CompareText(cmd, 'ReleaseShutup') = 0) or (CompareText(cmd, 'É¾³ý½ûÑÔ')= 0)  then begin
            CmdDelShutUpList (param1, TRUE);
            exit;
         end;
         if (CompareText(cmd, 'ShutupList') = 0) or (CompareText(cmd, '²é¿´½ûÑÔ')= 0)  then begin
            CmdSendShutUpList;
            exit;
         end;
         // 2003/08/28 Ã¤ÆÃ·Î±×
         if CompareText(cmd, 'õ·ÁêÖØ¶ÁÁÄÌì') = 0  then begin
            FrmDB.LoadChatLogFiles;
            UserEngine.SendInterMsg (ISM_RELOADCHATLOG, ServerIndex, '');
            SysMsg (cmd + ' ÒÑÔÚ·þÎñÆ÷ÉÏÓ¦ÓÃÁË', 1);
            exit;
         end;
         // 2003/09/15 Ã¤ÆÃ·Î±× Ãß°¡/»èÁ¦
         if CompareText(cmd, 'õ·ÁêÁÄÌì¼ÇÂ¼') = 0  then begin
            CmdAddChatLogList (param1, TRUE);
            exit;
         end;
         if (CompareText(cmd, 'õ·ÁêReleaseChatLog') = 0) or (CompareText(cmd, 'õ·ÁêÊÍ·ÅÁÄÌì¼ÇÂ¼')= 0)  then begin
            CmdDelChatLogList (param1, TRUE);
            exit;
         end;
         if (CompareText(cmd, 'õ·ÁêChatLogList') = 0) or (CompareText(cmd, 'õ·ÁêÁÄÌì¼ÇÂ¼ÁÐ±í')= 0)  then begin
            CmdSendChatLogList;
            exit;
         end;

         if (CompareText(cmd, 'GameMaster') = 0) or (CompareText(cmd, '1') = 0) or (CompareText(cmd, '¹ÜÀíÄ£Ê½') = 0) then begin
            BoSysopMode := not BoSysopMode;
            if BoSysopMode then SysMsg ('½øÈë¹ÜÀíÄ£Ê½', 1)
            else SysMsg ('ÍË³ö¹ÜÀíÄ£Ê½', 1);
            exit;
         end;
         if (CompareText(cmd, 'Observer') = 0) or (CompareText(cmd, 'Ob') = 0) or (CompareText(cmd, '2') = 0) or (CompareText(cmd, 'ÒþÉíÄ£Ê½') = 0) then begin
            BoSuperviserMode := not BoSuperviserMode;
            if BoSuperviserMode then SysMsg ('½øÈëÒþÉíÄ£Ê½', 1)
            else SysMsg ('ÍË³öÒþÉíÄ£Ê½', 1);
            exit;
         end;
         if (CompareText(cmd, 'Superman') = 0) or (CompareText(cmd, '3') = 0) or (CompareText(cmd, 'ÎÞµÐÄ£Ê½') = 0) then begin
            NeverDie := not NeverDie;
            if NeverDie then SysMsg ('½øÈëÎÞµÐÄ£Ê½', 1)
            else SysMsg ('ÍË³öÎÞµÐÄ£Ê½', 1);
            exit;
         end;
         if (CompareText(cmd, 'Level') = 0) or (CompareText(cmd, 'j') = 0)  then begin
            Abil.Level := _MIN(255, Str_ToInt(param1, 1));
            HasLevelUp (1);
            exit;
         end;
         if CompareText(cmd, 'SabukWallGold') = 0 then begin
            SysMsg ('³Ç±¤×Ü»ù½ð:' + IntToStr(UserCastle.TotalGold) + ',  ½ñÈÕÊÕÈë:' + IntToStr(UserCastle.TodayIncome), 1);
            exit;
         end;
         if (CompareText(cmd, 'Recall') = 0) or (CompareText(cmd, 'ch')= 0) then begin
            CmdRecallMan (param1, '');
            exit;
         end;
         // Æ¯Á¤ ¸Ê¿¡ ÀÖ´Â »ç¶÷µéÀ» ÀÚ½ÅÀÇ ¾ÕÀ¸·Î ¼ÒÈ¯ÇÑ´Ù(ÀÎ¿ø¼ö´Â ÇÔ¼ö³» °íÁ¤).
         if CompareText(cmd, 'RecallMap') = 0 then begin
            CmdRecallMap (param1);
            exit;
         end;
         if CompareText(cmd, 'flag') = 0 then begin
            hum := UserEngine.GetUserHuman (param1);
            if hum <> nil then begin
               idx := Str_ToInt(param2, 0);
               if hum.GetQuestMark (idx) = 1 then
                  SysMsg (hum.UserName + ':  [' + IntToStr(idx) + '] = ON', 1)
               else
                  SysMsg (hum.UserName + ':  [' + IntToStr(idx) + '] = OFF', 1);
            end else
               SysMsg ('@flag user_name number_of_flag', 0);
         end;
         if CompareText(cmd, 'showopen') = 0 then begin
            hum := UserEngine.GetUserHuman (param1);
            if hum <> nil then begin
               idx := Str_ToInt(param2, 0);
               if hum.GetQuestOpenIndexMark (idx) = 1 then
                  SysMsg (hum.UserName + ':  [' + IntToStr(idx) + '] = ON', 1)
               else
                  SysMsg (hum.UserName + ':  [' + IntToStr(idx) + '] = OFF', 1);
            end else
               SysMsg ('@showopen user_name number_of_unit', 0);
         end;
         if CompareText(cmd, 'showunit') = 0 then begin
            hum := UserEngine.GetUserHuman (param1);
            if hum <> nil then begin
               idx := Str_ToInt(param2, 0);
               if hum.GetQuestFinIndexMark (idx) = 1 then
                  SysMsg (hum.UserName + ':  [' + IntToStr(idx) + '] = ON', 1)
               else
                  SysMsg (hum.UserName + ':  [' + IntToStr(idx) + '] = OFF', 1);
            end else
               SysMsg ('@showunit user_name number_of_unit', 0);
         end;

         // ¿î¿µÀÚ ¸¾´ë·ç Ä£±¸µî·Ï
         if  CompareText(cmd, 'addfriend') = 0 then begin
            if param1 <> '' then
            begin
                SendMsg( self , CM_FRIEND_ADD , 0 ,RT_FRIENDS ,1,0,param1);
            end;
         end;

         if (CompareText(cmd, 'CharMove') = 0) or (CompareText(cmd, '½ÇÉ«ÒÆ¶¯') = 0) then begin
            CmdCharMove ( param1 , param2 );
            exit;
         end;

         if (CompareText(cmd, 'Goto') = 0) or (CompareText(cmd, 'gz') = 0) then begin
            CmdCharSpaceMove ( param1 );
            exit;
         end;

         //ÐÐ»áÃû³Æ('²é¿´ÐÐ»áÕù°ÔÈüµÃ·ÖÇé¿ö')
         if CompareText(cmd, 'ContestPoint') = 0 then begin
            CmdGetGuildMatchPoint (param1);
            exit;
         end;
         if CompareText(cmd, 'StartContest') = 0 then begin  //¿ªÊ¼ÐÐ»áÕù°ÔÈü
            CmdStartGuildMatch;
            exit;
         end;
         if CompareText(cmd, 'EndContest') = 0 then begin  //½áÊøÐÐ»áÕù°ÔÈü
            CmdEndGuildMatch;
            exit;
         end;
         if CompareText(cmd, 'Announcement') = 0 then begin
            CmdAnnounceGuildMembersMatchPoint (param1);
         end;

         //Ìí¼ÓÖ¸Áî
         if CompareText(cmd, 'whoare') = 0 then begin
            CmdViewAllCharacterList(param1);
         end;
         if CompareText(cmd, 'safezone') = 0 then begin
            if InSafeZone then
               SysMsg('°²È«ÇøÓò', 2)
            else
               SysMsg('²»°²È«ÇøÓò', 0);
         end;

         // TO PDS : ¸í·É¾î Å×½ºÆ®
//         if CompareText(cmd, 'CMDTEST') = 0 then
//         begin
//            hum := UserEngine.GetUserHuman (param1);
//            if ( hum <> nil ) then
//            g_UserMgr.SendMsgQueue1( stInterServer, ServerIndex , hum.GateIndex , hum.UserGateIndex,hum.UserHandle,
//                                     hum.UserName , Integer(hum) ,Str_ToInt(param2,0),Str_ToInt(param3,0),
//                                     Str_ToInt(param4,0),Str_ToInt(param5,0) ,param6);
//
//         end;

         //µî±Þ ÇÏÇâ Á¶Á¤(sonmg 2005/12/30)
         if CompareText(cmd, 'PKpoint') = 0 then begin
            CmdSendPKPoint (param1 , str_ToInt( param2 , 0));
            exit;
         end;
         if CompareText(cmd, 'ChangeJob') = 0 then begin
            CmdChangeJob (param1);
            SysMsg (cmd, 1);
            HasLevelUp (1);  //´É·ÂÄ¡°¡ º¯°æµÇ°Ô ÇÏ·Á±¸ ÇÔ..
            exit;
         end;
         if CompareText(cmd, 'ChangeGender') = 0 then begin
            CmdChangeSex;
            SysMsg (cmd, 1);
            exit;
         end;
         if CompareText(cmd, 'LuckyPoint') = 0 then begin
            hum := UserEngine.GetUserHuman (param1);
            if hum <> nil then
               SysMsg (param1 + ': BodyLuck= ' + IntToStr(hum.BodyLuckLevel) + '/' + FloatToStr(hum.BodyLuck) + ' Luck = ' + IntToStr(hum.Luck), 1);
            exit;
         end;
      end;

      //¾îµå¹Î : AdminList¿¡ '*' µî±Þ
      if UserDegree >= UD_ADMIN then begin
         if CompareText(cmd, 'attack') = 0 then begin
            hum := UserEngine.GetUserHuman (param1);
            if hum <> nil then begin
               SelectTarget (hum);
            end;
            exit;
         end;
         if CompareText(cmd, 'Mob') = 0 then begin
            CmdCallMakeMonster (param1, param2);
            exit;
         end;
         if (CompareText(cmd, 'RecallMob') = 0) or (CompareText(cmd, 'ÕÙ»½±¦±¦') = 0) then begin
            CmdCallMakeSlaveMonster (param1, param2, Str_ToInt(param3,0), Str_ToInt(param4,0));
            exit;
         end;
         if CompareText(cmd, '²ÊÈ¯') = 0 then begin
            SysMsg ('ÖÐ²ÊÈ¯ ' + IntToStr(LottoSuccess) + ', ' +
                    'Ã»ÖÐ²ÊÈ¯ ' + IntToStr(LottoFail) + ', ' +
                    '²ÊÈ¯1½±' + IntToStr(Lotto1) + ', ' +
                    '²ÊÈ¯2½± ' + IntToStr(Lotto2) + ', ' +
                    '²ÊÈ¯3½± ' + IntToStr(Lotto3) + ', ' +
                    '²ÊÈ¯4½± ' + IntToStr(Lotto4) + ', ' +
                    '²ÊÈ¯5½± ' + IntToStr(Lotto5) + ', ' +
                    '²ÊÈ¯6½± ' + IntToStr(Lotto6)
                    , 1);
            exit;
         end;
         if CompareText (cmd, 'ReloadGuild') = 0 then begin
            CmdReloadGuild (param1);
            exit;
         end;
         if CompareText(cmd, 'ReadAbuseInformation') = 0 then begin
            LoadAbusiveList ('!Abuse.txt');
            SysMsg ('ÀÄÓÃÓïÑÔÐÅÏ¢ÒÑÖØÐÂ¼ÓÔØ.', 1);
            exit;
         end;
         if CompareText(cmd, 'Backstep') = 0 then begin
            CharPushed (GetBack(Dir), 1);
            exit;
         end;
         if CompareText(cmd, 'EnergyWave') = 0 then begin
            CmdRushAttack;
            exit;
         end;
         if CompareText(cmd, 'FreePenalty') = 0 then begin
            CmdDeletePKPoint (param1);
            exit;
         end;
         if CompareText(cmd, 'IncPkPoint') = 0 then begin
            IncPkPoint (100); //
            exit;
         end;
         if CompareText(cmd, 'ChangeLuck') = 0 then begin
            BodyLuck := Str_ToFloat (param1);
            AddBodyLuck (0);
            exit;
         end;
         if CompareText(cmd, 'Hunger') = 0 then begin
            HungryState := Str_ToInt(param1, 0);
            SendMsg (self, RM_MYSTATUS, 0, 0, 0, 0, '');
            exit;
         end;
         if cmd = 'hair' then begin
            hair := Str_ToInt (param1, 0);
            FeatureChanged;
            exit;
         end;
         if (CompareText(cmd, '+¼¼ÄÜ') = 0)  or (CompareText(cmd, '++¼¼ÄÜ') = 0) then begin
            CmdMakeFullSkill (param1, Str_ToInt(param2, 1));
            exit;
         end;
         if (CompareText(cmd, 'DeleteSkill') = 0)  or (CompareText(cmd, '-¼¼ÄÜ') = 0) then begin
            CmdEraseMagic (param1);
            exit;
         end;
         if CompareText(cmd, 'NameColor') = 0 then begin
            DefNameColor := Str_ToInt (param1, 255);
            ChangeNameColor;
            exit;
         end;
         if CompareText(cmd, 'Mission') = 0 then begin
            CmdMissionSetting (param1, param2);
         end;
         if CompareText(cmd, 'MobPlace') = 0 then begin
            CmdCallMakeMonsterXY (param1{x}, param2{y}, param3{¸÷ÀÌ¸§}, param4{¸¶¸®¼ö});
            exit;
         end;
         if (CompareText(cmd, 'Transparency') = 0) or (CompareText(cmd, 'tp') = 0) then begin
            BoHumHideMode := not BoHumHideMode;
            if BoHumHideMode then StatusArr[STATE_TRANSPARENT] := 60 * 60
            else StatusArr[STATE_TRANSPARENT] := 0;
            CharStatus := GetCharStatus;
            CharStatusChanged;
            exit;
         end;
         if (CompareText(cmd, 'DeleteItem') = 0) or (CompareText(cmd, 'É¾³ýÎïÆ·') = 0) then begin
            CmdEraseItem (param1, param2);
            exit;
         end;
         if CompareText(cmd, 'Level0') = 0 then begin
            Abil.Level := _MIN(255, Str_ToInt(param1, 1));
            HasLevelUp (0);
            exit;
         end;
         if CompareText(cmd, 'ÈÎÎñ³õÊ¼»¯') = 0 then begin
            FillChar (QuestStates, sizeof(QuestStates), #0);
            exit;
         end;
         if CompareText(cmd, 'setflag') = 0 then begin
            hum := UserEngine.GetUserHuman (param1);
            if hum <> nil then begin
               idx := Str_ToInt(param2, 0);
               n := Str_ToInt(param3, 0);
               hum.SetQuestMark (idx, n);
               if hum.GetQuestMark (idx) = 1 then
                  SysMsg (hum.UserName + ':  [' + IntToStr(idx) + '] = ON', 1)
               else
                  SysMsg (hum.UserName + ':  [' + IntToStr(idx) + '] = OFF', 1);
            end else
               SysMsg ('@setflag user_name number_of_flag set_value', 0);
         end;
         if CompareText(cmd, 'setopen') = 0 then begin
            hum := UserEngine.GetUserHuman (param1);
            if hum <> nil then begin
               idx := Str_ToInt(param2, 0);
               n := Str_ToInt(param3, 0);
               hum.SetQuestOpenIndexMark (idx, n);
               if hum.GetQuestOpenIndexMark (idx) = 1 then
                  SysMsg (hum.UserName + ':  unit open [' + IntToStr(idx) + '] = ON', 1)
               else
                  SysMsg (hum.UserName + ':  unit open [' + IntToStr(idx) + '] = OFF', 1);
            end else
               SysMsg ('@setopen user_name number_of_unit set_value', 0);
         end;
         if CompareText(cmd, 'setunit') = 0 then begin
            hum := UserEngine.GetUserHuman (param1);
            if hum <> nil then begin
               idx := Str_ToInt(param2, 0);
               n := Str_ToInt(param3, 0);
               hum.SetQuestFinIndexMark (idx, n);
               if hum.GetQuestFinIndexMark (idx) = 1 then
                  SysMsg (hum.UserName + ':  unit set [' + IntToStr(idx) + '] = ON', 1)
               else
                  SysMsg (hum.UserName + ':  unit set [' + IntToStr(idx) + '] = OFF', 1);
            end else
               SysMsg ('@setunit user_name number_of_unit set_value', 0);
         end;
         if CompareText(cmd, 'Reconnection') = 0 then begin
            CmdReconnection (param1, param2); //addr, port
         end;
         //»çºÏ¼º °ü·Ã ¸í·É¾î

         {if CompareText(cmd, 'Wallconquestwarmode') = 0 then begin
            UserCastle.BoCastleWarMode := not UserCastle.BoCastleWarMode;
            if UserCastle.BoCastleWarMode then SysMsg ('test mode change for wall conquest war', 1)
            else Sysmsg ('test mode cancel for wall conquest war', 1);
            UserCastle.ActivateDefeseUnits (UserCastle.BoCastleWarMode);
            exit;
         end;}

         if CompareText(cmd, 'DisableFilter') = 0 then begin
            BoEnableAbusiveFilter := not BoEnableAbusiveFilter;
            if BoEnableAbusiveFilter then SysMsg ('¿ªÆô¹ýÂË½ûÓï¹¦ÄÜ', 1)
            else SysMsg ('¹Ø±Õ¹ýÂË½ûÓï¹¦ÄÜ', 1);
         end;
         if cmd = 'CHGUSERFULL' then begin
            UserFullCount := _MAX (250, Str_ToInt(param1, 0));
            SysMsg ('USERFULL ' + IntToStr(UserFullCount), 1);
            exit;
         end;
         if cmd = 'CHGZENFASTSTEP' then begin
            ZenFastStep := _MAX (100, Str_ToInt(param1, 0));
            SysMsg ('ZENFASTSTEP ' + IntToStr(ZenFastStep), 1);
            exit;
         end;

         if Str_ToInt (cmd, 0) = GET_INFO_PASSWD then begin
            SysMsg ('current monthly ' + IntToStr(CurrentMonthlyCard), 1);
            SysMsg ('total timeusage ' + IntToStr(TotalTimeCardUsage), 1);
            SysMsg ('last mon totalu ' + IntToStr(LastMonthTotalTimeCardUsage), 1);
            SysMsg ('gross total cnt ' + IntToStr(GrossTimeCardUsage), 1);
            SysMsg ('gross reset cnt ' + IntToStr(GrossResetCount), 1);
            exit;
         end;
         if Str_ToInt (cmd, 0) = CHG_ECHO_PASSWD then begin
            BoEcho := not BoEcho;
            if BoEcho then SysMsg ('Echo on', 1)
            else SysMsg ('Echo off', 1);
            MainOutMessage('...... '); //adminlog
         end;
         if not BoEcho then
            if Str_ToInt (cmd, 0) = KIL_SERVER_PASSWD then begin  //kill server
               MainOutMessage('  '); //adminlog
               if Random(4) = 0 then begin
                  BoGetGetNeedNotice := TRUE;
                  GetGetNoticeTime := GetTickCount + longword(Random(60 * 60 * 1000));
                  SysMsg ('timer set up...', 0);
                  MainOutMessage('   '); //adminlog
               end;
            end;

         //O/X ÄûÁî ¹æ ¸í·É¾î (»ç¿ëÀÚ´Â ¿ÜÄ¡±â¸¦ ÇÒ ¼ö ¾ø´Ù.)
         if CompareText(cmd, 'OXQuizRoom') = 0 then begin

         end;

         ///////////////////////
         //¼­¹ö¾ÈÁ¤È­(Test_Time)
         if CompareText (cmd, 'TESTTIME') = 0 then begin
            CmdTestTimeDebug( Str_ToInt(param1, -1) );
            if param1 = '' then
               SysMsg ('Current TestTime : ' + IntToStr(g_TestTime), 1)
            else
               SysMsg ('TestTime : ' + IntToStr(Str_ToInt(param1, -1)), 1);
            exit;
         end;
         if CompareText (cmd, '¿ÜÄ¡±â¹üÀ§') = 0 then begin
            CmdSetCryWide( Str_ToInt(param1, 50) );
            exit;
         end;

         ///////////////////////////////////
         // ¹®ÆÄÀå¿ø ¿î¿µÀÚ ¸í·É¾î(sonmg)
{
         if (CompareText(cmd, 'AgitReg') = 0) or (CompareText(cmd, 'Àå¿ø´ë¿©')= 0)  then begin
            CmdGuildAgitRegistration;
            exit;
         end;
         if (CompareText(cmd, 'AgitMove') = 0) or (CompareText(cmd, 'Àå¿øÀÌµ¿')= 0)  then begin
            CmdGuildAgitAutoMove;
            exit;
         end;
         if (CompareText(cmd, 'AgitDel') = 0) or (CompareText(cmd, 'Àå¿ø¹ÝÈ¯')= 0)  then begin
            CmdGuildAgitDelete;
            exit;
         end;
         if (CompareText(cmd, 'AgitExtend') = 0) or (CompareText(cmd, 'Àå¿ø¿¬Àå')= 0)  then begin
            CmdGuildAgitExtendTime ( Str_ToInt(param1, 1) );
            exit;
         end;
         if (CompareText(cmd, 'AgitRemain') = 0) or (CompareText(cmd, 'Àå¿ø±â°£')= 0)  then begin
            CmdGuildAgitRemainTime;
            exit;
         end;
         if (CompareText(cmd, 'AgitRecall') = 0) or (CompareText(cmd, '¹®¿ø¼ÒÈ¯')= 0)  then begin
            if param1 = '' then
               CmdGuildAgitRecall (param1, TRUE)  //ÀüÃ¼¼ÒÈ¯
            else
               CmdGuildAgitRecall (param1, FALSE);  //°³ÀÎ¼ÒÈ¯
            exit;
         end;
         if (CompareText(cmd, 'AgitSale') = 0) or (CompareText(cmd, 'Àå¿øÆÇ¸Å')= 0)  then begin
            CmdGuildAgitSale ( param1 );
            exit;
         end;
         if (CompareText(cmd, 'AgitSaleCancel') = 0) or (CompareText(cmd, 'Àå¿øÆÇ¸ÅÃë¼Ò')= 0)  then begin
            CmdGuildAgitSaleCancel;
            exit;
         end;
         if (CompareText(cmd, 'AgitBuy') = 0) or (CompareText(cmd, 'Àå¿ø±¸ÀÔ')= 0)  then begin
            CmdGuildAgitBuy ( 1 );
            exit;
         end;
         if (CompareText(cmd, 'AgitTrade') = 0) or (CompareText(cmd, 'Àå¿ø°Å·¡')= 0)  then begin
            BoGuildAgitDealTry := TRUE; //Àå¿ø°Å·¡½ÃÀÛ
            CmdTryGuildAgitTrade;
            exit;
         end;
         // Àå¿ø°Ô½ÃÆÇ
         if (CompareText(cmd, 'GaBoardList') = 0) or (CompareText(cmd, '°Ô½ÃÆÇ¸ñ·Ï')= 0)  then begin
            CmdGaBoardList ( Str_ToInt(param1, 1) );
            exit;
         end;
         if (CompareText(cmd, 'GaBoardRead') = 0) or (CompareText(cmd, '°Ô½ÃÆÇÀÐ±â')= 0)  then begin
            ServerGetGaBoardRead ( param1 + '/' + param2 + '/' + param3 + '/' + param4 );
            exit;
         end;
         if (CompareText(cmd, 'GaBoardAdd') = 0) or (CompareText(cmd, '°Ô½ÃÆÇ¾²±â')= 0)  then begin
            ServerGetGaBoardAdd ( Str_ToInt(param1, 0), 1,
               param2 + '/' + param3 + '/' + param4 + '/' + param5 + '/' + param6 );
            exit;
         end;
         if (CompareText(cmd, 'GaBoardDel') = 0) or (CompareText(cmd, '°Ô½ÃÆÇ»èÁ¦')= 0)  then begin
            ServerGetGaBoardDel ( 1, param1 + '/' + param2 + '/' + param3 + '/' + param4 );
            exit;
         end;
         if (CompareText(cmd, 'GaBoardEdit') = 0) or (CompareText(cmd, '°Ô½ÃÆÇ¼öÁ¤')= 0)  then begin
            ServerGetGaBoardEdit ( 1, param1 + '/' + param2 + '/' + param3 + '/' + param4 + '/' + param5 );
            exit;
         end;
         if (CompareText(cmd, 'GTBoardInit') = 0) or (CompareText(cmd, '°Ô½ÃÆÇÃÊ±âÈ­') = 0) then begin
            ServerGetGaBoardDelAll ( 1, '' );
            exit;
         end;
}
         ///////////////////////////////////

         //////////

         //½´ÆÛ¾îµå¹Î : AdminList¿¡ '*' µî±Þ(Å×½ºÆ® ¼­¹ö ¶Ç´Â ÆÐ½º¿öµå ¼º°ø ÈÄ)
         if (UserDegree >= UD_SUPERADMIN) or BoTestServer then begin
                 if (UserDegree >= UD_SUPERADMIN) or BoTestServer then begin
            if CompareText(cmd, 'SHOWEFFECT') = 0 then begin //ÑÌ»¨ÀàÐÍ
              CmdShowEffect('SHOWEFFECT', param1);
              Exit;
            end;
            end;

            if (CompareText(cmd, 'Make') = 0) or (CompareText(cmd, '11') = 0) then begin
               if (param1 <> '') then begin
               CmdMakeItem (param1, Str_ToInt(param2, 1));
               exit;
            end else SysMsg ('[ÃüÁî¸ñÊ½£º@make ÎïÆ·Ãû³Æ ÊýÁ¿]', 0);
             end;

            if CompareText(cmd, 'DelGold') = 0 then begin
               CmdDeleteUserGold (param1, param2);
               exit;
            end;
            if CompareText(cmd, 'AddGold') = 0 then begin
               CmdAddUserGold (param1, param2);
               exit;
            end;
            if CompareText(cmd, 'GameGold') = 0 then begin
               CmdGameGold (param1, param2, Str_ToInt(param3, 0));
               exit;
            end;
            if CompareText(cmd, 'GamePoint') = 0 then begin
               CmdGamePoint (param1, param2, Str_ToInt(param3, 0));
               exit;
            end;
            if CompareText(cmd, '¿ªÊ¼ÌáÎÊ') = 0 then begin
               CmdStartQuest (cmd, param1);
               exit;
            end;
            if cmd = 'TEST_GOLD_Change~' then begin
               if BoEcho then
                  MainOutMessage ('[MakeGold] ' + UserName + ' ' + param1);
               Gold := _MIN(BAGGOLD, Str_ToInt (param1, 0));
               GoldChanged;
               exit;
            end;
            if (CompareText(cmd, 'SmakeItem1') = 0) or (CompareText(cmd, 'dzsx1') = 0) then begin
               CmdSmakeItem (Str_ToInt(param1, 0), Str_ToInt(param2, 0), Str_ToInt(param3, 0));
               if BoEcho then
                  //MainOutMessage ('[µ÷ÕûÊôÐÔ] ' + UserName + ' ' + param1 + ' ' + param2 + ' ' + param3 + ' ');
               exit;
            end;
            if CompareText (cmd, 'ÎäÆ÷µ÷Õû') = 0 then begin
               CmdRefineWeapon (Str_ToInt(param1, 0), Str_ToInt(param2, 0), Str_ToInt(param3, 0), Str_ToInt(param4, 0));
               if BoEcho then
                  //MainOutMessage ('ÎäÆ÷µ÷Õû [' + UserName + '] ' + param1 + ' ' + param2 + ' ' + param3 + ' ' + param4);
               exit;
            end;
            if CompareText(cmd, 'ReloadAdmin') = 0 then begin
               FrmDB.LoadAdminFiles;
               UserEngine.SendInterMsg (ISM_RELOADADMIN, ServerIndex, '');
               SysMsg ('¹ÜÀíÔ±Ãûµ¥ÒÑÖØÐÂ¼ÓÔØ.', 1);
               exit;
            end;
            if CompareText(cmd, 'MarketOpen') = 0 then begin
               SqlEngine.Open ( true );
               UserEngine.SendInterMsg (ISM_MARKETOPEN, ServerIndex, '');
               SysMsg (cmd + ' ¼ÄÊÛÏµÍ³´ò¿ª', 1);
               exit;
            end;
            if CompareText(cmd, 'MarketClose') = 0 then begin
               SqlEngine.Open ( false );
               UserEngine.SendInterMsg (ISM_MARKETCLOSE, ServerIndex, '');
               SysMsg (cmd + ' ¼ÄÊÛÏµÍ³¹Ø±Õ', 1);
               exit;
            end;
            if CompareText(cmd, 'ReloadNpc') = 0 then begin
               //ÀÚ½ÅÀÇ ÁÖ¸é¿¡ ÀÖ´Â npc Á¤º¸¸¦ ¸®·Îµå ½ÃÅ²´Ù.
               CmdReloadNpc (param1);
               exit;
            end;
            if CompareText(cmd, 'ReloadNpc2') = 0 then begin
               //ÀÚ½ÅÀÇ ÁÖ¸é¿¡ ÀÖ´Â npc Á¤º¸¸¦ ¸®·Îµå ½ÃÅ²´Ù.
               CmdReloadNpc2 (param1);
               exit;
            end;
            if (CompareText(cmd, 'ReloadMonItems') = 0) or (CompareText(cmd, 'ÖØ¶Á±¬ÂÊ') = 0) then begin
               UserEngine.ReloadAllMonsterItems;
               SysMsg ('±¬ÂÊÎÄ¼þÒÑÖØÐÂ¼ÓÔØ.', 1);
               exit;
            end;
            if CompareText (cmd, 'ReloadDiary') = 0 then begin
               if FrmDB.LoadQuestDiary < 0 then SysMsg ('QuestDiarys reload failure...', 0)
               else SysMsg ('QuestDiarys reload successful', 1);
               exit;
            end;
            if (CompareText(cmd, 'AdjustLevel') = 0)  or (CompareText(cmd, 'µÈ¼¶') = 0) then begin
               CmdManLevelChange (param1, Str_ToInt(param2, 1));
               exit;
            end;
            if CompareText(cmd, 'AdjustExp') = 0 then begin
               CmdManExpChange (param1, Str_ToInt(param2, 1));
               exit;
            end;
            if (CompareText(cmd, 'AddGuild') = 0) or (CompareText(cmd, '+ÐÐ»á') = 0) then begin
               CmdCreateGuild (param1, param2);
               exit;
            end;
            if (CompareText(cmd, 'DelGuild') = 0) or (CompareText(cmd, '-ÐÐ»á') = 0) then begin
               CmdDeleteGuild (param1);
               exit;
            end;
            if (CompareText(cmd, 'ChangeSabukLord') = 0) or (CompareText(cmd, 'É³°Í¿Ë1') = 0) then begin
               CmdChangeUserCastleOwner (param1, TRUE);
               exit;
            end;
            if CompareText(cmd, 'ForcedWallconquestWar') = 0 then begin
               UserCastle.BoCastleUnderAttack := not UserCastle.BoCastleUnderAttack;
               if UserCastle.BoCastleUnderAttack then begin
                  UserCastle.CastleAttackStarted := GetTickCount;
                  UserCastle.StartCastleWar;
               end else begin
                  UserCastle.FinishCastleWar;
               end;
               exit;
            end;
            if CompareText(cmd, 'AddToItemEvent') = 0 then begin
               if param1 <> '' then begin EventItemList.AddObject (param1, TObject(EventItemGifeBaseNumber + EventItemList.Count)); SysMsg ('AddToItemEvent ' + param1, 1); end;
               if param2 <> '' then begin EventItemList.AddObject (param2, TObject(EventItemGifeBaseNumber + EventItemList.Count)); SysMsg ('AddToItemEvent ' + param2, 1); end;
               if param3 <> '' then begin EventItemList.AddObject (param3, TObject(EventItemGifeBaseNumber + EventItemList.Count)); SysMsg ('AddToItemEvent ' + param3, 1); end;
               if param4 <> '' then begin EventItemList.AddObject (param4, TObject(EventItemGifeBaseNumber + EventItemList.Count)); SysMsg ('AddToItemEvent ' + param4, 1); end;
               if param5 <> '' then begin EventItemList.AddObject (param5, TObject(EventItemGifeBaseNumber + EventItemList.Count)); SysMsg ('AddToItemEvent ' + param5, 1); end;
               exit;
            end;
            if CompareText(cmd, 'AddToItemEventAsPieces') = 0 then begin
               n := Str_ToInt(param2, 1);
               for i:=1 to n do begin
                  EventItemList.AddObject (param1, TObject(EventItemGifeBaseNumber + EventItemList.Count));
                  SysMsg ('AddToItemEvent ' + param1, 1);
               end;
               exit;
            end;
            if CompareText(cmd, 'ItemEventList') = 0 then begin
               SysMsg ('[Item event list]', 1);
               for i:=0 to EventItemList.Count-1 do begin
                  SysMsg (EventItemList[i] + ' ' + IntToStr(integer(EventItemList.Objects[i])), 1);
               end;
               exit;
            end;
            if CompareText(cmd, 'StartingGiftNo') = 0 then begin
               EventItemGifeBaseNumber := Str_ToInt(param1, 0);
               SysMsg ('Starting no. of gift certificate ' + IntToStr(EventItemGifeBaseNumber), 1);
               exit;
            end;
            if CompareText(cmd, 'DeleteAllItemEven') = 0 then begin
               EventItemList.Clear;
               SysMsg ('DeleteAllItemOfItemEvent', 1);
               exit;
            end;
            if CompareText(cmd, 'StartItemEvent') = 0 then begin
               UserEngine.BoUniqueItemEvent := not UserEngine.BoUniqueItemEvent;
               if UserEngine.BoUniqueItemEvent then SysMsg ('start of item event', 1)
               else SysMsg ('end of item event', 1);
               exit;
            end;
            if CompareText(cmd, 'ItemEventTerm') = 0 then begin
               UserEngine.UniqueItemEventInterval := Str_ToInt(param1, 30) * 60 * 1000;
               SysMsg ('term of item event = ' + IntToStr(Str_ToInt(param1, 30)) + 'ºÐ', 1);
               exit;
            end;
            if CompareText(cmd, 'AdjustTestLevel') = 0 then begin
               Abil.Level := _MIN(MAXLEVEL-1, Str_ToInt(param1, 1));    //50
               HasLevelUp (1);
               exit;
            end;
            if (CompareText(cmd, 'OPTraining') = 0) or (CompareText(cmd, 'µ÷Õû¼¼ÄÜ') = 0) then begin
               CmdMakeOtherChangeSkillLevel (param1, param2, Str_ToInt(param3, 1));
               exit;
            end;
            if (CompareText(cmd, 'OPDeleteSkill') = 0) or (CompareText(cmd, 'É¾³ý¼¼ÄÜ') = 0) then begin
               CmdThisManEraseMagic (param1, param2);
            end;
            if CompareText(cmd, 'ChangeWeaponDura') = 0 then begin
               n := _MIN(65,_MAX(0,Str_ToInt (param1, 0)));
               if (UseItems[U_WEAPON].Index <> 0) and (n > 0) then begin
                  UseItems[U_WEAPON].DuraMax := n * 1000;
                  SendMsg (self, RM_DURACHANGE, U_WEAPON, UseItems[U_WEAPON].Dura, UseItems[U_WEAPON].DuraMax, 0, '');
               end;
               exit;
            end;
            ///////////////////////
            // added by sonmg...
            if CompareText(cmd, 'Upgrade') = 0 then begin
               CmdUpgradeItem (param1, param2, 0, 0, Str_ToInt(param3, 0));
               exit;
            end;
            if CompareText(cmd, '¸ðµçº¸¿Á') = 0 then begin
               CmdMakeAllJewelryItem (0);
               exit;
            end;
            if CompareText(cmd, '¸ðµç½ÅÁÖ') = 0 then begin
               CmdMakeAllJewelryItem (1);
               exit;
            end;
            if CompareText(cmd, 'ReloadMakeItemList') = 0 then begin
               //Á¦Á¶ Àç·á ¸ñ·ÏÀ» ¸®·Îµå ½ÃÅ²´Ù.
               FrmDB.LoadMakeItemList;
               UserEngine.SendInterMsg (ISM_RELOADMAKEITEMLIST, ServerIndex, '');
               SysMsg (cmd + ' ÒÑ¾­ÔÚ·þÎñÆ÷ÉÏÓ¦ÓÃ', 1);
               exit;
            end;
{$IFDEF DEBUG} // µð¹ö±× ¹× Å×½ºÆ®¿ë
            //±ÛÀÚ»ö Å×½ºÆ®¿ë
            if CompareText(cmd, 'Text color') = 0 then begin
               CmdLetterColor (param1);
               exit;
            end;
{$ENDIF} // µð¹ö±× ¹× Å×½ºÆ®¿ë
            if CompareText(cmd, 'Alive') = 0 then begin
               WAbil.HP := WAbil.MaxHP div 2;
               Alive;
               exit;
            end;
            if CompareText(cmd, 'ºË¼ì²éÈËÔ±') = 0 then begin
               if param1 <> '' then
                  g_SpeedHackCheck := _MAX(0, Str_ToInt(param1, 0));
//               SysMsg (cmd + ' Á¶Á¤ : ' + IntToStr(g_SpeedHackCheck), 1);
               g_SpeedHackCheckChar := param2;
               SysMsg (cmd + '(' + IntToStr(g_SpeedHackCheck) + ') : ' + g_SpeedHackCheckChar, 1);
               //MainOutMessage('[¼ì²éÈËÔ±µ÷Õû]' + IntToStr(g_SpeedHackCheck) + ') : ' + g_SpeedHackCheckChar);
               exit;
            end;
            ///////////////////////
            if CompareText(cmd, 'AgitDecoMonCount') = 0 then begin
               CmdAgitDecoMonCount( Str_ToInt(param1, 1) );
               exit;
            end;
            if CompareText(cmd, 'AgitDecoMonCountHere') = 0  then begin
               CmdAgitDecoMonCountHere;
               exit;
            end;
            if CompareText(cmd, 'FamePoint') = 0 then begin
               CmdAdjustFamePoint (param1, param2);
               exit;
            end;
            if CompareText(cmd, 'FameName') = 0 then begin
               CmdGetFameName (param1);
               exit;
            end;
            //µð¹ö±ë ¸í·É¾î
            if CompareText(cmd, 'UserMarketDebug') = 0 then begin
               CmdUserMarketDebug (param1);
               exit;
            end;

            //¿¬ÀÎ ÇØÁ¦
            if CompareText(cmd, '¿¬ÀÎÇØÁ¦') = 0 then begin
               CmdBreakLoverRelation;
               exit;
            end;


         end;


         if CompareText (cmd, 'ReloadGuildAll') = 0 then begin     //ÇåÀíËùÓÐÐÐ»áÐÅÏ¢
            CmdReloadGuildAll (param1);
            exit;
         end;

         if CompareText (cmd, 'ReloadGuildAgit') = 0 then begin
            CmdReloadGuildAgit;
            exit;
         end;
         // ¾Õ¿¡ ÀÖ´Â ¸÷À» ÇÑ¹æ¿¡ Á×ÀÓ.
         if (CompareText(cmd, 's') = 0) or (CompareText(cmd, 'onekill') = 0) then begin
            CmdOneKillMob;
            exit;
         end;
         if (CompareText (cmd, 'MonClear') = 0) or (CompareText(cmd, 'Çå¹Ö') = 0) then begin
            //ÇöÀç ¸ÊÀÇ ¸ó½ºÅÍ¸¦ Å¬¸®¾î ½ÃÅ²´Ù.
            CmdMonClear(MapName);
            SysMsg('Monster cleared on this map...', 1);
            exit;
         end;

      end;
      exit;
   end else begin
      //NoChat ¸Ê¼Ó¼º Ãß°¡(sonmg 2004/10/12)
      if PEnvir.NoChat then begin
         SysMsg('´ËµØÍ¼½ûÖ¹½»Ì¸', 0);
         exit;
      end;
      if boSecondCardSystem then
      begin
        if (iDay > 0) or (iHours > 0) or (SecondsCard > 0) then
        begin

        end
        else
        if Abil.Level <= 6 then begin
           SysMsg ('Îª·ÀÖ¹Ð¡ºÅµ·ÂÒ£¬7¼¶²ÅÄÜËµ»°', 0);
           exit;
        end;
      end;
      //µµ¹è ¹æÁö ·çÆ¾
      if (Trim(saystr) = LatestSayStr) and (GetTickCount - BombSayTime < 3000) then begin
         Inc (BombSayCount);
         if BombSayCount >= 2 then begin
            BoShutUpMouse := TRUE;
            ShutUpMouseTime := GetTickCount + 60 * 1000;
            {$IFDEF KOREA}
            SysMsg ('ÓÉÓÚÄúÖØ¸´·¢³öÏàÍ¬ÄÚÈÝ£¬Ò»·ÖÖÓÄÚ½«±»½ûÖ¹½»Ì¸', 0);
            {$ELSE}
            SysMsg ('[spamming protection rule applied : banned from dialogue for 1 min]', 0);
            {$ENDIF}
         end;
      end else begin
         //°í¼Ó Ã¤ÆÃ ¹æÁö ·çÆ¾(sonmg 2006/02/06)
         if (GetTickCount - BombSayTime < 2000) then begin
            Inc (BombSayCount);
            if BombSayCount >= 5 then begin
               BoShutUpMouse := TRUE;
               ShutUpMouseTime := GetTickCount + 30 * 1000;
               {$IFDEF KOREA}
               SysMsg ('¿ìËÙÁÄÌì±£»¤¹æÔòÊÊÓÃ£¬½ûÖ¹¶Ô»°30Ãë', 0);
               {$ELSE}
               SysMsg ('[Fast chat protection rule applied : banned from dialogue for 30 seconds]', 0);
               {$ENDIF}
            end;
            LatestSayStr := Trim(saystr);
            BombSayTime := GetTickCount;
         end else begin
            LatestSayStr := Trim(saystr);
            BombSayTime := GetTickCount;
            BombSayCount := 0;
         end;
      end;

      //µµ¹è·Î Ã¤ÆÃ ±ÝÁö¸¦ ÇØÁ¦
      if GetTickCount > ShutUpMouseTime then
         BoShutUpMouse := FALSE;
      boshutup := BoShutUpMouse;

      //¿î¿µÀÚ¿¡ ÀÇÇØ Ã¤ÆÃ±ÝÁö µÊ
      if ShutUpList.FFind (UserName) >= 0 then begin
         boshutup := TRUE;
      end;

      if not boshutup then begin

         if saystr[1] = '/' then begin
            str := Copy (saystr, 2, length(saystr)-1);

            if (UserDegree >= UD_SYSOP) then begin
               if CompareText (str, 'who') = 0 then begin
                  NilMsg ('ÔÚÏßÈËÊý£º' + IntToStr(UserEngine.GetUserCount));
                  exit;
               end;
               if UserDegree >= UD_ADMIN then begin
                  if (CompareText(str, 'total') = 0) then begin
                     NilMsg ('ËùÓÐ·þÎñÆ÷µÄÔÚÏßÈËÊý: ' + IntToStr(TotalUserCount));
                     exit;
                  end;
               end;
            end;
            str := GetValidStr3 (str, param1, [' ']);
            Whisper (param1, str);  //±Ó¼Ó¸»
            exit;
         end;
         // 2003/08/28 Ã¤ÆÃ·Î±× ÀÌÀüÀÚ¸®

         if saystr[1] = '!' then begin
            if Length(saystr) >= 2 then begin
               if saystr[2] = '!' then begin  //±×·ì ¸Þ¼¼Áö
                  str := Copy (saystr, 3, length(saystr)-2);
                  GroupMsg (UserName + ': ' + str);
                  exit;
               end;
               if saystr[2] = '~' then begin  //¹®ÆÄ ¸Þ¼¼Áö
                  if MyGuild <> nil then begin
                     str := Copy (saystr, 3, length(saystr)-2);
                     TGuild(MyGuild).GuildMsg (UserName + ':' + str);
                     UserEngine.SendInterMsg (ISM_GUILDMSG, ServerIndex, TGuild(MyGuild).GuildName + '/' + UserName + ':' + str);
                  end;
                  exit;
               end;
            end;
            if not PEnvir.QuizZone then begin  //ÄûÁî¹æ¿¡¼­´Â ¿ÜÄ¡±â°¡ ¾ÈµÈ´Ù.
               if GetTickCount - LatestCryTime > 10 * 1000 then begin
                  if Abil.Level <= 6 then begin //¿ÜÄ¡±â Á¦¾à ·¹º§ 7 ÀÌ»ó
                     SysMsg ('º°»°Ö»ÓÐ¼¶±ð¸ßÓÚ7¼¶µÄÍæ¼Ò²ÅÄÜÊ¹ÓÃ', 0);  //»Æ×Ö
                  end else begin
                     // ÃÅÅÉ×¯Ô°(sonmg)
                     if IsMyGuildMaster then begin
                        //½Ã°£ Delay ¾øÀ½.
//                        LatestCryTime := GetTickCount;
                        str := Copy (saystr, 2, length(saystr)-1);
                        UserEngine.GuildAgitCry (RM_CRY, PEnvir, CX, CY, 50{wide}, '(!)' + UserName + ':' + str);
                     end else begin
                        LatestCryTime := GetTickCount;
                        str := Copy (saystr, 2, length(saystr)-1);
                        UserEngine.CryCry (RM_CRY, PEnvir, CX, CY, g_CryWide{wide}, '(!)' + UserName + ':' + str);
                     end;
                  end;
               end else begin
                  SysMsg (IntToStr(10 - ((GetTickCount-LatestCryTime) div 1000)) + 'ÃëÒÔºó²ÅÄÜÔÙ´ÎÊ¹ÓÃº°»°', 0);
               end;
            end else
               SysMsg ('ÎÞ·¨Ê¹ÓÃ', 0);
            exit;
         end else begin
            if CompareLStr(saystr, '¢½', 2) then begin  //¿¬ÀÎ ¸Þ¼¼Áö
               //¿¬ÀÎÀÌ ÀÖ´Â »ç¶÷¸¸...
               if fLover.GetLoverName <> '' then begin
                  str := Copy (saystr, 3, length(saystr)-2);
                  LoverWhisper (fLover.GetLoverName, str);  //¿¬ÀÎ ±Ó¼Ó¸»
                  exit;
               end;
            end;
         end;
         inherited Say (saystr);
      end else
         SysMsg ('½ûÖ¹ÁÄÌì', 0); //µµ¹è ±ÝÁö...

   end;
end;

procedure TUserHuman.ThinkEtc;
begin
   if Bright <> MirDayTime then begin
      Bright := MirDayTime;
      SendMsg (self, RM_DAYCHANGING, 0, 0, 0, 0, '');
   end;
end;

procedure TUserHuman.ReadySave;
begin
   Abil.HP := WAbil.HP;
   BrokeDeal;
end;

{----------------------------------------------}

procedure TUserHuman.SendLogon;
var
   wl: TMessageBodyWL;
   MirConfig: TMirConfig;
   TempStr: string;
   n: integer;
begin
   Def := MakeDefaultMsg (SM_LOGON, Integer(self), CX, CY, MakeWord(Dir,Light));
   wl.lParam1 := Feature;
   wl.lParam2 := CharStatus;
   if AllowGroup then wl.lTag1 := MakeLong(MakeWord(1, 0), 0)
   else wl.lTag1 := 0;
   wl.lTag2 := BoolToInt(boMirNg);
   SendSocket (@Def, EncodeBuffer (@wl, sizeof(TMessageBodyWL)));

   MirConfig.boMirNg := boMirNg;
   MirConfig.g_boMirDark := g_boMirDark;
   MirConfig.g_boMirShowHp := g_boMirShowHp;
   MirConfig.g_bochksigedu := g_bochksigedu;
   MirConfig.g_boMirShowNumber := g_boMirShowNumber;
   MirConfig.bo°ÚÌ¯ := bo°ÚÌ¯;
   MirConfig.g_boÕ½¶·ÍË³ö := g_boÕ½¶·ÍË³ö;
   MirConfig.g_boÃâÖúÅÜ := g_boÃâÖúÅÜ;
   MirConfig.g_boÎÈÈçÌ©É½ := g_boÎÈÈçÌ©É½;
   MirConfig.g_bosjcd := g_bosjcd;
   MirConfig.g_bozdfy := g_bozdfy;
   MirConfig.g_Deatheject := g_Deatheject;
   MirConfig.g_bo¼¼ÄÜ±¸×¢ := g_bo¼¼ÄÜ±¸×¢;
   MirConfig.g_boÎïÆ·´°¿Ú := g_boÎïÆ·´°¿Ú;
   MirConfig.g_boÖ÷½çÃæ := g_boÖ÷½çÃæ;
   MirConfig.g_boËø¶¨ÈËÎï := g_boËø¶¨ÈËÎï;
   MirConfig.g_boËø¶¨¹ÖÎï := g_boËø¶¨¹ÖÎï;
   MirConfig.g_bo¼«Æ·À¶×Ö := g_bo¼«Æ·À¶×Ö;
   MirConfig.g_bo×Ô¶¯»»·û := g_bo×Ô¶¯»»·û;
   MirConfig.g_bo×Ô¶¯»»¶¾ := g_bo×Ô¶¯»»¶¾;
   MirConfig.g_boµØÍ¼À×´ï := g_boµØÍ¼À×´ï;
   MirConfig.g_boÐü¸¡ÐÅÏ¢ := g_boÐü¸¡ÐÅÏ¢;
   MirConfig.g_boÈËÎïËÄ¸ñ := g_boÈËÎïËÄ¸ñ;
   MirConfig.g_bo´óµØÍ¼¿ª¹Ø := g_bo´óµØÍ¼¿ª¹Ø;
   MirConfig.g_boÐ¡µØÍ¼ÃÔ¹¬Èë¿ÚÏÔÊ¾ := g_boÐ¡µØÍ¼ÃÔ¹¬Èë¿ÚÏÔÊ¾;
   MirConfig.g_boHelp := g_boHelp;
   MirConfig.g_boHostpot := g_boHostpot;
   MirConfig.g_boQuestions := g_boQuestions;
   MirConfig.g_boHostpotWeb := g_boHostpotWeb;
   MirConfig.g_boQuestionsWeb := g_boQuestionsWeb;
   MirConfig.g_boChinese := g_boChinese;
   MirConfig.g_boWhisperWin := g_boWhisperWin;
   MirConfig.g_boRelationWin := g_boRelationWin;
   MirConfig.g_boMirShop := g_boMirShop;
   MirConfig.g_bofuguHP := g_bofuguHP;
   MirConfig.g_bozuduihp := g_bozuduihp;
   MirConfig.g_bo¾ø¶ÔÌ©É½ := g_bo¾ø¶ÔÌ©É½;
   MirConfig.g_boµ¶µ¶´ÌÉ± := g_boµ¶µ¶´ÌÉ±;
   MirConfig.g_bopaobusudu := g_bopaobusudu;
   MirConfig.g_MAGICSPEED := g_MAGICSPEED;
   MirConfig.g_ATTACKSPEED := g_ATTACKSPEED;



   TempStr := EncodeBuffer (@MirConfig, sizeof(TMirConfig));
   SendDefMessage(SM_MIRCONFIG, 0, 0, 0, Bright, TempStr);
   n := Feature;
   SendDefMessage(SM_FEATURECHANGED, integer(self), Loword(n), Hiword(n), FeatureEx, inttostr(bShowTrans));  //³á°òÔö¼ÓÏûÏ¢
end;

procedure TUserHuman.SendAreaState;
var
   n: integer;
begin
   n := 0;
   if PEnvir.FightZone then n := n or AREA_FIGHT;
   if PEnvir.Fight2Zone then n := n or AREA_FIGHT;  //sonmg (2004/12/23)
   if PEnvir.LawFull then n := n or AREA_SAFE;
   if BoInFreePKArea then n := n or AREA_FREEPK;
   SendDefMessage (SM_AREASTATE, n, 0, 0, 0, '');
end;

procedure TUserHuman.DoStartupQuestNow;
begin
    if DefaultNpc <> nil then begin
       TMerchant(DefaultNpc).NpcSayTitle(Self, '@LOGIN');
    end;
end;


procedure TUserHuman.Operate; //ÕâÊÇ´¦Àí½ÇÉ«¸÷ÖÖ¶¯×÷µÄ¹ý³Ì£¬Ã¿ÃëÖÖÔËÐÐ¼¸°ÙÉÏÇ§´Î
var
   msg: TMessageInfo;
   cdesc: TCharDesc;
   wl: TMessageBodyWL;
   mbw: TMessageBodyW;
   smsg: TShortMessage;
   str: string;
   strupgrade: string;
   wd, ahour, amin, asec, amsec: word;
   i,II ,n, m, oldcolor, cltime, svtime: integer;
   r: Real;
   flag: Boolean;
   ps: PTStdItem;
   Cret: TCreature;
   identbackup : integer;
   DefMsg   : TDefaultMessage;
   hum : TUserHuman;
   lovername : string;
   svidx : integer;
   StallInfo         : TStallInfo;
   mini:integer;
   ptl: PTTimeLabel;
begin
   try
      if BoDealing then begin
         //º®º¸°í °Å·¡ÇØ¼­ µ·º¹»çµÇ´Â ¹ö±×¸¦ °íÄ§
         if (GetFrontCret <> DealCret) or (DealCret = self) or (DealCret = nil) then begin
            BrokeDeal;
         end;
      end;

      // °èÁ¤½Ã°£ ¸¸·á¿¡ ÀÇÇÑ ½Ã°£Ã¼Å©¹× ¸Þ¼¼ÁöÀü¼Û 2003-01-17 : PDS
      CheckExpiredTime;

     { if BoAccountExpired then begin
         SysMsg ('ÄúµÄÕÊºÅÒÑµ½ÆÚ', 0);
         MainOutMessage('[ÕÊ»§¹ýÆÚÊ±¼ä] ' + UserName + ' (' + IntToStr(AvailableMode) + ')');

//         SysMsg ('ÖÐ¶ÏÁ¬Ïß', 0);
//         EmergencyClose := TRUE;     //ÕËºÅµ½ÆÚ¶ÏÏß
         BoAccountExpired := FALSE;  //ÕËºÅµ½ÆÚ¹Ø±Õ

//         RandomSpaceMove ('0109', 0);  //µ½ÆÚºóÌø×ªµ½Ö¸¶¨µØÍ¼
      end; }

      if BoAllowFireHit then begin  //¿°È­°á ÇØÁ¦..
         if GetTickCount - LatestFireHitTime > 20 * 1000 then begin
            BoAllowFireHit := FALSE;
            SysMsg ('¾«Éñ»ðÑæÏûÊ§', 0);
            SendSocket (nil, '+UFIR');

            if BoGetGetNeedNotice then    /////////////////////
               if GetTickCount - GetGetNoticeTime > 2 * 60 * 60 * 1000 then
                  GetGetNotices;
         end;
      end;
      if BoAllowTwinHit = 2 then begin  //½Ö·æÂü ÇØÁ¦..
         BoAllowTwinHit := 0;
//       SysMsg ('½Ö·æÂüÀÌ ÇØÁ¦µÇ¾ú½À´Ï´Ù.', 0);
         SendSocket (nil, '+UTWN');
      end;

      if BoTimeRecallGroup then begin
         if GetTickCount > TimeRecallEnd then begin
            BoTimeRecall := FALSE;
            BoTimeRecallGroup := FALSE;
            SpaceMove (TimeRecallMap, TimeRecallX, TimeRecallY, 0);
         end;
      end else if BoTimeRecall then begin
         if GetTickCount > TimeRecallEnd then begin
            BoTimeRecall := FALSE;
            SpaceMove (TimeRecallMap, TimeRecallX, TimeRecallY, 0);
         end;
      end;

      if GetTickCount - operatetime_30sec > 20 * 1000 then begin
         operatetime_30sec := GetTickCount;

         if BoTaiwanEventUser then begin   //ÁÖº¯ »ç¶÷µé¿¡°Ô ÀÚ½ÅÀÇ À§Ä¡¸¦ ¾Ë¸°´Ù.
            UserEngine.CryCry (RM_CRY, PEnvir, CX, CY, 1000,
                                  UserName + 'ÊÇ' + IntToStr(CX) + ' ' + IntToStr(CY) + '£º´ËÈËÄ¿Ç°Î»ÓÚ¸ÃµØµã'
                                  + ' (' + TaiwanEventItemName + ')');
         end;
      end;

      for i := TimeLabelList.Count - 1 downto 0 do begin //ÑÓÊ±´¦Àí
        ptl := TimeLabelList.Items[i];
        if ptl.boDelete then begin

          TimeLabelList.Delete(i);
          Dispose(ptl);
          Continue;
        end;

        if ptl.boChangeMapDelete then begin
          if ptl.Envir <> PEnvir then begin

            TimeLabelList.Delete(i);
            Dispose(ptl);
            Continue;
          end;
        end;

        if GetTickCount > ptl.dwTime then begin
          if ptl.Npc <> nil then begin
            ptl.Npc.NpcSayTitle(Self, ptl.sLabel); //ÈËÎï´¥·¢
          end;

          if ptl.boDelete then begin
            TimeLabelList.Delete(i);
            Dispose(ptl);
            Continue;
          end;

          for II := 0 to TimeLabelList.Count - 1 do begin
            if TimeLabelList.Items[II] = ptl then begin
              TimeLabelList.Delete(i);
              Dispose(ptl);
              break;
            end;
          end;
        end;
      end;


      if GetTickCount - operatetime > 3000 then begin
         operatetime := GetTickCount;

         //½ºÆÐµåÇÙ(speedhack) °Ë»ç
         ///SendDefMessage (SM_TIMECHECK_MSG, GetTickCount, 0, 0, 0, '');

         CheckHomePos;

         //´Ù¸¥ Ä³¸¯°ú °ãÃÄÁ³´ÂÁö¸¦ °Ë»çÇÑ´Ù.
         n := PEnvir.GetDupCount(CX, CY);
         if n >= 2 then begin
            if not BoDuplication then begin
               BoDuplication := TRUE;
               DupStartTime := GetTickCount;
            end;
         end else
            BoDuplication := FALSE;
         if (n >= 3) and (GetTickCount - DupStartTime > 3000) or
            (n = 2) and (GetTickCount - DupStartTime > 10000)
         then begin
            if GetTickCount - DupStartTime < 20000 then begin
            //ÀëÏß¹Ò»ú
            //   CharPushed (Random(8), 1)     //ÕâÀïÊÇ¼·ÈËµÄ  ÕâÀïµÄ´¦ÀíÓ¦¸ÃÓÐÎÊÌâ  ÀëÏß¹Ò»ú   ÎÊÌâ´ý²âÊÔ
            end;// else
               //RandomSpaceMove (PEnvir.MapName, 0);
         end;

{
         //------------------------------
         // ±ÝÀü º¯µ¿·® Ã¼Å© °æ°í
         if Gold - FirstGold >= EXORBITANT_GOLD then begin
            if FirstGoldCount < 10 then begin
               Inc(FirstGoldCount);
               MainOutMessage('[±ÝÀüÃ¼Å©°æ°í' + IntToStr(FirstGoldCount) + '] ' + UserName + ' : ' + GetGoldStr(FirstGold) + ' ==> ÇöÀç±ÝÀü : ' + GetGoldStr(Gold));
            end;
         end;
         //------------------------------
}
      end;

      //°ø¼ºÀü ÁßÀÎ °æ¿ì
      if UserCastle.BoCastleUnderAttack then begin
         //°ø¼ºÀü Áö¿ª³»¿¡¼­´Â ÇÁ¸®ÇÇÄÉÀÌ Áö¿ª
         BoInFreePKArea := UserCastle.IsCastleWarArea (PEnvir, CX, CY);
      end;

      if GetTickCount - operatetime_sec >= 1000 then begin
         operatetime_sec := GetTickCount;

         //Á¢¼Ó ·Î±×¸¦ ³²±è
         //ÇÒÀÎ ½Ã°£ÀÇ °æ°è¿¡´Â ·Î±×¸¦ ³²±è.
         DecodeTime (Time, ahour, amin, asec, amsec);
         //ÇÒÀÎ ½Ã°£ ½ÃÀÛ È¤Àº ³¡
         if DiscountForNightTime then begin
            if ((ahour = HalfFeeStart) or (ahour = HalfFeeEnd)) and (amin = 0) and (asec <= 30) then begin
               //ÇÒÀÎ ½Ã°£ÀÌ ½ÃÀÛµÇ´Â ¶§
               if GetTickCount - LoginTime > 60 * 1000 then begin  //ÇÒÀÎ½Ã°£½ÃÀÛ¶§ ±â·ÏÀ» ÇÏÁö ¾ÊÀº °æ¿ì
                  //ÇÒÀÎ ½Ã°£ ÀÌÀü¿¡ Á¢¼ÓÇÑ °æ¿ìÀÓ
                  WriteConLog;
                  LoginTime := GetTickCount;
                  LoginDateTime := Now;
               end;
            end;
         end;

         //---------------------------------------------------
         //ÃÖ¼Ò 2½Ã°£ ¸¶´Ù ÀçÁ¢¼Ó ±â·Ï(sonmg 2005/03/28)
         if operatetime_sec - LoginTime > 2 * 60 * 60 * 1000 then begin
            WriteConLog;
            LoginTime := GetTickCount;
            LoginDateTime := Now;
         end;
         //---------------------------------------------------

         //¹®ÆÄÀüÀ¸·Î Áö¿ª¿¡ µû¶ó¼­ ÀÌ¸§ÀÌ »ö±òÀÌ º¯°æµÉ °æ¿ì°¡ ÀÖÀ½
         if MyGuild <> nil then begin
            if TGuild(MyGuild).GuildName <> '' then begin   // 2004/04/28(sonmg)
               if TGuild(MyGuild).KillGuilds.Count > 0 then begin //¹®ÆÄÀü ÁßÀÓ
                  flag := InGuildWarSafeZone;
                  if boGuildwarsafezone <> flag then begin
                     boGuildwarsafezone := flag;  //Áö¿ª¿¡ µû¶ó¼­ ÀÌ¸§»öÀÌ º¯°æµÊ
                     ChangeNameColor;
                  end;
               end;
            end;
         end;

         //°ø¼ºÀü ÁßÀÎ °æ¿ì
         if UserCastle.BoCastleUnderAttack then begin

            //»çºÏ¼ºÀÇ ³»¼ºÀ» Á¡·ÉÇÏ¸é ¼ºÀ» Â÷ÁöÇÏ°Ô µÈ´Ù.
            if PEnvir = UserCastle.CorePEnvir then begin  //³»¼º¾È¿¡ ÀÖ´Â °æ¿ì
               if (MyGuild <> nil) and not UserCastle.IsCastleMember (self) then begin
                  //¼ºÀ» °ø°ÝÇÏ´Â ¹®ÆÄ°¡ Á¡·ÉÇÑ °æ¿ì
                  if UserCastle.IsRushCastleGuild (TGuild(MyGuild)) then begin
                     //°ø¼ºÀüÀ» ½ÅÃ»ÇÑ ¹®ÆÄ¿øÀÌ ³»¼º ¾È¿¡ ÀÖÀ½
                     if UserCastle.CheckCastleWarWinCondition (TGuild(MyGuild)) then begin
                        //³»¼º Á¡·É ¼º°ø
                        UserCastle.ChangeCastleOwner (TGuild(MyGuild));
                        //´Ù¸¥ ¼­¹ö¿¡ ¾Ë¸²
                        UserEngine.SendInterMsg (ISM_CHANGECASTLEOWNER, ServerIndex, TGuild(MyGuild).GuildName);

                        //°ø¼ºÀüÀº Á¾·áµÊ, ½Â¸®¹® ÀÌ¿Ü¿¡ ¸ðµç »ç¶÷Àº ´Ù¸¥ °÷À¸·Î ³¯¶ó°¨
                        if UserCastle.GetRushGuildCount <= 1 then
                           UserCastle.FinishCastleWar;  //°ø°ÝÀÚ°¡ 2¹®ÆÄ ÀÌ»óÀÌ¸é 3½Ã°£ÀÌ ³¡³ª¾ß Á¾·áµÊ

                     end;
                  end;

               end;
            end;

         end else begin
            BoInFreePKArea := FALSE;
         end;

         if AreaStateOrNameChanged then begin
            AreaStateOrNameChanged := FALSE;
            SendAreaState;
            UserNameChanged;
         end;

         // 20003/02/11 ±×·ì¿ø À§Ä¡ Àü´Þ
         if GroupOwner <> nil then begin
            for i := 0 to GroupOwner.GroupMembers.Count - 1 do begin
                cret := TCreature(GroupOwner.GroupMembers.Objects[i]);
//              if (cret <> self) and (cret.MapName = MapName) then
                if (cret.MapName = MapName) then begin
                    cret.SendMsg(self, RM_GROUPPOS, dir, CX, CY, RaceServer, '');
                    cret.SendMsg(self, RM_HEALTHSPELLCHANGED, 0, 0, 0, 0, '');
                end;
            end;
         end;
         if SlaveList.Count >= 1 then begin
            for i := 0 to SlaveList.Count -1 do begin
               cret := TCreature(SlaveList[i]);
               if (cret <> nil) and (cret.MapName = MapName) then begin
                   SendMsg(cret, RM_GROUPPOS, cret.dir, cret.CX, cret.CY, cret.RaceServer, '');
                   SendMsg(cret, RM_HEALTHSPELLCHANGED, 0, 0, 0, 0, '');
//                 cret.SendMsg(self, RM_HEALTHSPELLCHANGED, 0, 0, 0, 0, '');
               end;
            end;
         end;

      end;

      if GetTickCount - operatetime_500m >= 500 then begin
         operatetime_500m := GetTickCount;

         //´ë¸¸ ÀÌº¥Æ® °ü·Ã
         if BoTaiwanEventUser then begin  //ÀÌº¥Æ® ÇØÁ¦.....
            flag := FALSE;
            for i:=0 to ItemList.Count-1 do begin
               ps := UserEngine.GetStdItem (PTUserItem (ItemList[i]).Index);
               if ps <> nil then begin
                  if ps.StdMode = TAIWANEVENTITEM then begin  //´ë¸¸ ÀÌº¥Æ®, ÀÌº¥Æ® ¾ÆÀÌÅÛÀ» ÁÖÀ¸¸é Ç¥½Ã³²
                     flag := TRUE;
                  end;
               end;
            end;
            if not flag then begin  //ÀÌº¥Æ® ÇØÁ¦.....
               TaiwanEventItemName := '';
               BoTaiwanEventUser := FALSE;
               //Ä³¸¯ÀÇ »ö±òÀ» ¹Ù²Û´Ù.
               StatusArr[STATE_BLUECHAR] := 1;  //Å¸ÀÓ ¾Æ¿ô
               Light := GetMyLight;
               SendRefMsg (RM_CHANGELIGHT, 0, 0, 0, 0, '');
               CharStatus := GetCharStatus;
               CharStatusChanged;
               UserNameChanged;
            end;
         end;

      end;

      (*if GetTickCount - ClientMsgTime > 1000 * 2 then begin
         r := ClientMsgCount / (GetTickCount - ClientMsgTime) * 1000;
         //SysMsg (FloatToStr(r), 0);
         ClientMsgTime := GetTickCount;
         if r >= 1.8 then begin
            Inc (ClientSpeedHackDetect);
            if ClientSpeedHackDetect >= 3 then begin
               MainOutMessage ('[ÇØÅ·ÇÁ·Î±×·¥»ç¿ë] ' + UserName);
               SysMsg ('=====================================================', 0);
               SysMsg ('ÇØÅ· ÇÁ·Î±×·¥ »ç¿ëÀÚ·Î ±â·ÏµÇ¾ú½À´Ï´Ù.', 0);
               SysMsg ('°èÁ¤ ¾Ð·ùµîÀÇ ºÒÀÌÀÍÀÌ °¡ÇØÁú ¼ö ÀÖÀ½À» ¾Ë·Áµå¸³´Ï´Ù.', 0);
               SysMsg ('Á¢¼ÓÀÌ °­Á¦·Î ²÷¾îÁ³½À´Ï´Ù.', 0);
               SysMsg ('=====================================================', 0);
               UserSocketClosed := TRUE;
            end;
         end else
            ClientSpeedHackDetect := 0;
         ClientMsgCount := 0;
      end; *)

   except
      MainOutMessage ('[Exception] TUserHuman.Operate 1');
   end;

   IdentBackup := 0;

   try
      while GetMsg (msg) do begin

         IdentBackup := msg.Ident;

         case msg.Ident of
            //Å¬¶óÀÌ¾ðÆ®°¡ º¸³»´Â ¸Þ¼¼Áö Ã³¸®
            CM_CLIENT_CHECKTIME:
               begin
                  ;
               end;
            CM_TURN:
               with msg do begin
                  if self.Death or not TurnXY (lParam1{x}, lParam2{y}, msg.wParam{dir}) then
                     SendSocket (nil, '+FAIL/' + IntToStr(GetTickCount))
                  else SendSocket (nil, '+GOOD/' + IntToStr(GetTickCount));
                  end;
            CM_WALK:
               with msg do begin
                  if self.Death or not WalkXY (msg.lParam1{x}, msg.lParam2{y}) then begin
                     SendSocket (nil, '+FAIL/' + IntToStr(GetTickCount));
                  end else begin
                     SendSocket (nil, '+GOOD/' + IntToStr(GetTickCount));
                     Inc (ClientMsgCount);
                  end;
               end;
            CM_RUN:
               with msg do begin
                  if self.Death or not RunXY (msg.lParam1{x}, msg.lParam2{y}) then
                     SendSocket (nil, '+FAIL/' + IntToStr(GetTickCount))
                  else begin
                     SendSocket (nil, '+GOOD/' + IntToStr(GetTickCount));
                     Inc (ClientMsgCount);
                  end;
               end;
            CM_HIT,
            CM_HEAVYHIT,
            CM_BIGHIT,
            CM_POWERHIT,
            CM_LONGHIT,
            CM_WIDEHIT,
            // 2003/03/15 ½Å±Ô¹«°ø
            CM_CROSSHIT,
            CM_TWINHIT,
            CM_FIREHIT:
               begin
                  if not self.Death then begin
                     with msg do
                        if HitXY (Ident, lparam1{X}, lparam2{Y}, wParam{DIR}) then begin  //wParam = ¹æÇâ
//                           SendSocket (nil, '+GOOD/' + IntToStr(GetTickCount));
                           SendSocket (nil, '+GOOD/' + IntToStr(GetTickCount) + '/' + IntToStr(HitSpeed));//ÇØÅ·ÅøÃ¼Å©(sonmg)
                           Inc (ClientMsgCount);
                        end else
                           SendSocket (nil, '+FAIL/' + IntToStr(GetTickCount));
                  end else
                     SendSocket (nil, '+FAIL/' + IntToStr(GetTickCount));
               end;
            CM_THROW:
               begin
                  if not self.Death then begin
                     with msg do
                        //if HitXY (Ident, lparam1{X}, lparam2{Y}, wParam{DIR}) then begin  //wParam = ¹æÇâ
                           SendSocket (nil, '+GOOD/' + IntToStr(GetTickCount));
                        //   Inc (ClientMsgCount);
                        //end else
                        //   SendSocket (nil, '+FAIL/' + IntToStr(GetTickCount));
                  end;
               end;
            CM_SPELL:
               begin
                  if not self.Death then begin
                     with msg do
                        if SpellXY (wParam{magid}, lparam1{targetx}, lparam2{targety}, lparam3{target cret}) then begin
                           SendSocket (nil, '+GOOD/' + IntToStr(GetTickCount));
                           Inc (ClientMsgCount);
                        end else begin
                           //È£È¥¼® ¹ö±×·Î ÀÎÇØ »èÁ¦(sonmg 2005/10/06) Å×½ºÆ® ¿ä¸Á(ºÎÀÛ¿ë)
                           SendSocket (nil, '+FAIL/' + IntToStr(GetTickCount));
                        end;
                  end else begin
                     SendSocket (nil, '+FAIL/' + IntToStr(GetTickCount));
                  end;
               end;
            CM_SITDOWN:
               begin
                  if not self.Death then begin
                     with msg do
                        SitdownXY (lparam1{x}, lparam2{y}, wParam{dir});
                     SendSocket (nil, '+GOOD/' + IntToStr(GetTickCount));
                  end else
                     SendSocket (nil, '+FAIL/' + IntToStr(GetTickCount));
               end;
            CM_SAY:
               begin
                  if msg.description <> '' then
                     Say (msg.description);
               end;

            CM_DROPITEM:
               begin
                  if UserDropItem (msg.Description, msg.lparam1) then SendDefMessage (SM_DROPITEM_SUCCESS, msg.lparam1, 0, 0, 0, msg.Description)
                  else SendDefMessage (SM_DROPITEM_FAIL, msg.lparam1, 0, 0, 0, msg.Description);
               end;

            // Ä«¿îÆ® ¾ÆÀÌÅÛ
            CM_DROPCOUNTITEM:
               begin
                  if msg.lparam2 > 0 then
                     if UserDropCountItem(msg.Description, msg.lparam1, msg.lparam2) then
                        SendDefMessage(SM_DROPITEM_SUCCESS, msg.lparam1, 0, 0, 0, msg.Description);
               end;

            CM_PICKUP:
               begin
                  if (CX = msg.lParam2{x}) and (CY = msg.lparam3{y}) then
                     //if (WAbil.Weight<=WAbil.MaxWeight) then
                        PickUp;
               end;

            CM_QUERYUSERNAME:
               begin
                  GetQueryUserName (TCreature(msg.lparam1){cret}, msg.lparam2{x}, msg.lparam3{y});
               end;
            CM_QUERYBAGITEMS:
               begin
                  SendBagItems;
               end;

            CM_OPENDOOR:
               begin
                  ServerGetOpenDoor (msg.lparam2{x}, msg.lparam3{y});
               end;

            CM_TAKEONITEM:
               begin
                  ServerGetTakeOnItem (msg.lparam2{where?}, msg.lparam1{item's sindex}, msg.Description{item name});
               end;

            CM_TAKEOFFITEM:
               begin
                  ServerGetTakeOffItem (msg.lparam2{where?}, msg.lparam1{item's sindex}, msg.Description{item name});
               end;

            CM_EXCHGTAKEONITEM:
               begin
               end;

            CM_EAT:
               begin
                  ServerGetEatItem (msg.lparam1{item's sindex}, msg.Description);
               end;

            CM_BUTCH:
               begin
                  ServerGetButch (TCreature(msg.lparam1){targer}, msg.lparam2{x}, msg.lparam3{y}, msg.wparam);
               end;

            CM_MAGICKEYCHANGE:
               begin
                  ServerGetMagicKeyChange (msg.lparam1{magid}, msg.lparam2);
               end;

            CM_SOFTCLOSE:
               begin
                  SoftClosed := TRUE;  //Ä³¸¯ÅÍ ¼±ÅÃÀ» ´Ù½ÃÇÏ±â À§ÇØ ³ª°£ °ÍÀÓ...
                  UserSocketClosed := TRUE;  //Á¢¼ÓÀ» ²÷À½.
               end;
            CM_GAMECLOSE:
               begin
                  SoftClosed := False;  //Ä³¸¯ÅÍ ¼±ÅÃÀ» ´Ù½ÃÇÏ±â À§ÇØ ³ª°£ °ÍÀÓ...
                  UserSocketClosed := TRUE;  //Á¢¼ÓÀ» ²÷À½.
               end;
            CM_CANCLOSE:
               begin
                  //²¿ºÀ¸÷ÀÇ °ø°Ý´ë»óÀÌ ÀÖÀ» °æ¿ì´Â ·Î±×¾Æ¿ô ÇÒ ¼ö ¾øµµ·Ï ÇÔ.
                  if ExistAttackSlaves then begin
                     SendMsg(self, RM_CANCLOSE_FAIL, 0, 0, 0, 0, '');
                  end else begin
                     SendMsg(self, RM_CANCLOSE_OK, 0, 0, 0, 0, '');
                  end;
               end;

            CM_CLICKNPC:  //NPC,»óÀÎÀ» Å¬¸¯ÇÔ.
               begin
                  ServerGetClickNpc (msg.lParam1);
               end;

            CM_MERCHANTDLGSELECT:
               begin
                  ServerGetMerchantDlgSelect (msg.lparam1, msg.Description);
               end;

            CM_MERCHANTQUERYSELLPRICE:
               begin
                  ServerGetMerchantQuerySellPrice (msg.lparam1, MakeLong(msg.lparam2, msg.lparam3), msg.Description);
               end;
            CM_MERCHANTQUERYREPAIRCOST:
               begin
                  ServerGetMerchantQueryRepairPrice (msg.lparam1, MakeLong(msg.lparam2, msg.lparam3), msg.Description);
               end;

            CM_USERSELLITEM:
               begin
                  // Ä«¿îÆ® ¾ÆÀÌÅÛ
                  ServerGetUserSellItem (msg.lparam1, MakeLong(msg.lparam2, msg.lparam3), msg.wparam, msg.Description);
               end;
            CM_USERREPAIRITEM:
               begin
                  ServerGetUserRepairItem (msg.lparam1, MakeLong(msg.lparam2, msg.lparam3), msg.Description);
               end;
            CM_USERSTORAGEITEM:
               begin
                  ServerGetUserStorageItem (msg.lparam1, MakeLong(msg.lparam2, msg.lparam3), abs(msg.wparam), msg.Description);
               end;
            CM_OPENSTALL: //°ÚÌ¯
           begin
              // MainOutMessage('°ÚÌ¯');
               ClientStallOnOpening(msg.Description, msg.wParam);
           end;
                 RM_STALLSTATUS:
                 //if g_Config.boStallSystem then begin
              if (TCreature(msg.sender) <> Self) then begin //ÓÐ
                          Def := MakeDefaultMsg(SM_OPENSTALL, Integer(msg.sender), msg.lParam1, msg.lParam2, msg.lParam3);
               if msg.wParam > 0 then begin //°ÚÌ¯
                    StallInfo.open := TUserHuman(msg.sender).m_StallMgr.OnSale;
                         StallInfo.Looks := TUserHuman(msg.sender).m_StallMgr.StallType;
                             StallInfo.Name := TUserHuman(msg.sender).m_StallMgr.mBlock.StallName;
                             end else
                             begin //ÊÕÌ¯
                           StallInfo.open := False;
                           StallInfo.Looks := TUserHuman(msg.sender).m_StallMgr.StallType;
                        end;
                   SendSocket(@Def, EncodeBuffer(@StallInfo, SizeOf(TStallInfo)));
               end;
                   // end;
            CM_USERGETDETAILITEM: //»ó¼¼ ¸Þ´º
               ServerGetUserMenuBuy (msg.Ident, msg.lparam1{merchant}, 0, msg.lparam2, msg.Description);
            CM_USERBUYITEM:  //»ê´Ù
               ServerGetUserMenuBuy (msg.Ident, msg.lparam1{merchant}, MakeLong(msg.lparam2, msg.lparam3), msg.wParam, msg.Description);

            CM_DROPGOLD:
               begin
                  if msg.lparam1 > 0 then begin
                     UserDropGold (msg.lparam1);
                  end;
               end;

            CM_TEST:
               SendDefMessage (SM_TEST, 0, 0, 0, 0, '');

            CM_GETSHOPITEM: GetSaleItemListEx(@msg);
            CM_BUYSHOPITEM: BuySaleItemListEx(@msg);
            CM_SHOPPRESEND: PresendItem(@msg);

            CM_GROUPMODE:
               begin
                  if msg.lparam2 = 0 then DenyGroup  //AllowGroup := FALSE;
                  else AllowGroup := TRUE;
                  //»óÅÂ º¸³»¿©ÇÔ..
                  if AllowGroup then
                     SendDefMessage (SM_GROUPMODECHANGED, 0, 1, 0, 0, '')
                  else SendDefMessage (SM_GROUPMODECHANGED, 0, 0, 0, 0, '')
               end;

            // ¾ÆÀÌÅÛ ¾÷±×·¹ÀÌµå by sonmg...
            CM_UPGRADEITEM:
               begin
                 try
                  //SeedName°ú JewelryNameºÐ¸®
                  strupgrade := GetValidStr3( msg.Description , msg.Description, ['/']);
                  //¾÷±×·¹ÀÌµå
                  CmdUpgradeItem (msg.Description, strupgrade, msg.lparam1, MakeLong(msg.lparam2, msg.lparam3), 0);
                 except
                    MainOutMessage('UPGRADE ERROR');
                 end;
               end;
            CM_CREATEGROUP:    ServerGetCreateGroup (Trim(msg.Description));
            CM_CREATEGROUPREQ_OK  :    ServerGetCreateGroupRequestOk (Trim(msg.Description));
            CM_CREATEGROUPREQ_FAIL:    ServerGetCreateGroupRequestFail;
            CM_CHAOSHI1_FAIL      :    ServerGetCreateGroupRequestFail1;
            CM_ADDGROUPMEMBER: ServerGetAddGroupMember (Trim(msg.Description));
            CM_ADDGROUPMEMBERREQ_OK  : ServerGetAddGroupMemberRequestOk (Trim(msg.Description));
            CM_ADDGROUPMEMBERREQ_FAIL: ServerGetAddGroupMemberRequestFail;
            CM_CHAOSHI2_FAIL      :    ServerGetCreateGroupRequestFail2;
            CM_DELGROUPMEMBER: ServerGetDelGroupMember (Trim(msg.Description));

            RM_GUILDAGITDEALTRY, // Àå¿ø°Å·¡½Ãµµ(sonmg)
            CM_DEALTRY: ServerGetDealTry (Trim(msg.Description));
            CM_DEALADDITEM: ServerGetDealAddItem (msg.lparam1, msg.wparam, msg.Description);
            CM_DEALDELITEM: ServerGetDealDelItem (msg.lparam1, msg.Description);
            CM_DEALCANCEL: ServerGetDealCancel;
            CM_DEALCHGGOLD: ServerGetDealChangeGold (msg.lparam1);
            CM_DEALEND: ServerGetDealEnd;

            CM_USERTAKEBACKSTORAGEITEM: ServerGetTakeBackStorageItem (msg.lparam1, MakeLong(msg.lparam2, msg.lparam3), msg.wparam, msg.Description);

            CM_WANTMINIMAP: ServerGetWantMiniMap;

            CM_USERMAKEDRUGITEM: ServerGetMakeDrug (msg.lparam1, msg.Description);

            // ¾ÆÀÌÅÛ Á¦Á¶
            CM_USERMAKEITEMSEL: ServerGetMakeItemSel (msg.lparam1, msg.Description);
            CM_USERMAKEITEM: ServerGetMakeItem (msg.lparam1, msg.Description);

            // Ä«¿îÆ® ¾ÆÀÌÅÛ ÅëÇÕ.
            CM_ITEMSUMCOUNT: ServerGetSumCountItem(msg.lparam1, MakeLong(msg.lparam2, msg.lparam3), msg.Description);

            CM_QUERYUSERSTATE: ServerGetQueryUserState (TCreature(msg.lparam1){cret}, msg.lparam2{x}, msg.lparam3{y});

            CM_OPENGUILDDLG: ServerGetOpenGuildDlg;

            CM_GUILDHOME: ServerGetGuildHome;

            CM_GUILDMEMBERLIST: ServerGetGuildMemberList;

            CM_GUILDADDMEMBER: ServerGetGuildAddMember (msg.Description);

            CM_GUILDDELMEMBER: ServerGetGuildDelMember (msg.Description);

            CM_GUILDUPDATENOTICE: ServerGetGuildUpdateNotice (msg.Description);

            CM_GUILDUPDATERANKINFO: ServerGetGuildUpdateRanks (msg.Description);

            CM_GUILDMAKEALLY: ServerGetGuildMakeAlly;  //»ó´ëÆí ¹®ÁÖ¿Í ¸¶ÁÖº¸°í

            CM_GUILDBREAKALLY: ServerGetGuildBreakAlly (msg.Description);


            CM_SPEEDHACKUSER: MainOutMessage ('[·Ç·¨³ÌÐòÊ¹ÓÃ] <' + IntToStr(msg.lParam1) + '> ' + UserName); //speedhack À¯Àú ·Î±×¸¦ ³²±ä´Ù.

            CM_ADJUST_BONUS: ServerGetAdjustBonus (msg.lparam1, msg.Description);

            CM_FRIEND_ADD:
            begin

            DefMsg.Recog := integer( msg.Sender);
            DefMsg.Ident := msg.Ident;
            DefMsg.Param := msg.lParam1;
            DefMsg.Tag   := msg.lParam2;
            DefMsg.Series:= msg.lParam3;

            UserMgrEngine.ExternSendMsg(stInterServer,ServerIndex,GateIndex ,UserGateIndex, userhandle,UserName ,DefMsg, msg.description);
            end;
            // ¿¬ÀÎ»çÁ¦
            CM_RufuseMaster: begin
              RufuseMaster := not RufuseMaster;
              if WAbil.Level < 35 then
                SendDefMessage(SM_RufuseMaster, Byte(RufuseMaster), 30, 0, 0, '')
                else SendDefMessage(SM_RufuseMaster, Byte(RufuseMaster), 33, 0, 0, '');
            end;
            CM_LM_REQUEST: ServerGetRelationRequest( msg.lparam1 , msg.lparam2 );
            CM_LM_OPTION : ServerGetRelationOptionChange ( msg.lparam1 , msg.lparam2 );
            CM_LM_DELETE : ServerGetRelationDelete( msg.lparam1 , msg.Description );
            CM_LM_DELETE_REQ_OK   : ServerGetRelationDeleteRequestOk( msg.lparam1 , msg.Description );
            CM_LM_DELETE_REQ_FAIL : ServerGetRelationDeleteRequestFail( msg.lparam1 , msg.Description );
            // À§Å¹ÆÇ¸Å UserMarket
            CM_MARKET_LIST  : ServerGetMarketList   ( TCreature(msg.lparam1),msg.lParam2 , msg.description);
            CM_MARKET_SELL  : ServerGetMarketSell   ( TCreature(msg.lparam1),msg.wParam, MakeLong(msg.lparam2, msg.lparam3),msg.description );
            CM_MARKET_BUY   : ServerGetMarketBuy    ( TCreature(msg.lparam1),MakeLong(msg.lparam2, msg.lparam3) );
            CM_MARKET_CANCEL: ServerGetMarketCancel ( TCreature(msg.lparam1),MakeLong(msg.lparam2, msg.lparam3) );
            CM_MARKET_GETPAY: ServerGetMarketGetPay ( TCreature(msg.lparam1),MakeLong(msg.lparam2, msg.lparam3) );
            CM_MARKET_CLOSE : ServerGetMarketClose;

            // Àå¿ø ¸ñ·Ï
            CM_GUILDAGITLIST : ServerGetGuildAgitList ( msg.lparam1 );
            CM_GUILDAGIT_TAG_ADD :
            begin
               if ServerGetGuildAgitTag ( TCreature(msg.Sender), msg.description ) then begin
                  DefMsg.Recog := integer( msg.Sender);
                  DefMsg.Ident := CM_TAG_ADD_DOUBLE;
                  DefMsg.Param := msg.lParam1;
                  DefMsg.Tag   := msg.lParam2;
                  DefMsg.Series:= msg.lParam3;

                  UserMgrEngine.ExternSendMsg(stInterServer, ServerIndex, GateIndex, UserGateIndex, userhandle, UserName, DefMsg, msg.description);
               end;
            end;
             CM_ALIVE_OK:Alive;

            // Àå¿ø°Ô½ÃÆÇ
            CM_GABOARD_LIST : ServerGetGaBoardList( msg.lparam1 );
            CM_GABOARD_READ : ServerGetGaBoardRead( msg.description );
            CM_GABOARD_ADD  : ServerGetGaBoardAdd( msg.lparam1{±ÛÁ¾·ù}, msg.lparam2, msg.description );
            CM_GABOARD_DEL  : ServerGetGaBoardDel( msg.lparam2, msg.description{±Û¹øÈ£} );
            CM_GABOARD_EDIT : ServerGetGaBoardEdit( msg.lparam2, msg.description{±Û¹øÈ£} );
            CM_GABOARD_NOTICE_CHECK : ServerGetGaBoardNoticeCheck;
            // Àå¿ø²Ù¹Ì±â
            CM_DECOITEM_BUY : ServerGetDecoItemBuy (msg.Ident, msg.lparam1{merchant}, MakeLong(msg.lparam2, msg.lparam3), msg.Description);

//            CM_CASHREFRESH  : ServerGetCashRefesh;
//            CM_DEATH_FALL :ServerGetDeath(TCreature(msg.lparam1){cret});
            CM_SHOWTRANS: ServerGetTrans(msg.lparam1);
            {-------------------------------------------------------------}

            RM_LM_DBWANTLIST:ServerSetRelationDBWantList( msg.description );
            RM_LM_DBADD     :ServerSetRelationDBAdd     ( msg.description );
            RM_LM_DBEDIT    :ServerSetRelationDBEdit    ( msg.description );
            RM_LM_DBEDIT2    :ServerSetRelationDBEdit2    ( msg.description );
            RM_LM_DBDELETE  :ServerSetRelationDBDelete  ( msg.description );
            RM_LM_DBGETLIST :ServerGetRelationDBGetList ( msg.description );
            RM_LM_LOGOUT    :ServerGetLoverLogout;
            RM_FAME_DBADD   :ServerSetFameDBAdd         ( msg.description );
            {-------------------------------------------------------------}
            //¼­¹ö¿¡¼­ ¼­¹ö·Î º¸³»´Â ¸Þ¼¼Áö, Áö¿¬ Ã³¸® °æ¿ì

            RM_MAKE_SLAVE:
               begin
                  if msg.lparam1 <> 0 then begin
                     RmMakeSlaveProc (PTSlaveInfo(msg.lparam1));
                     Dispose (PTSlaveInfo(msg.lparam1));
                  end;
               end;

            RM_MAA_DBWANTLIST:   // Ö±½Ó´ÓÊý¾Ý¿âÈ¡Ê¦Í½ÐÅÏ¢
              begin
                g_DBSQL.LoadMaaList(UserName, fMaster);
                SendMaaList();
                g_DBSQL.LoadMaaListEx(UserName);
                g_DBSQL.LoadMaaListEx22(UserName);

                g_DBSQL.LoadMaaListEx3(UserName);
                g_DBSQL.LoadRelListEx(UserName);
              end;
            RM_MAA_DBWANTLIST2:
            begin
                g_DBSQL.LoadMaaList(UserName, fMaster);
                UserNameChanged;
//                g_DBSQL.LoadMaaListEx(UserName);
//                g_DBSQL.LoadMaaListEx22(UserName);
//
//                g_DBSQL.LoadMaaListEx3(UserName);
            end;
            {-------------------------------------------------------------}
            //¼­¹ö¿¡¼­ º¸³»´Â ¸Þ¼¼Áö Ã³¸®
            RM_TAG_ALARM: // ÂÊÁö ¿ÔÀ½ ¾Ë¸²
               begin
                  SendDefMessage (SM_TAG_ALARM, 0 , msg.lParam1, 0, 0, '');
               end;
            RM_LOGON:
               begin
                  if boSecondCardSystem then
                  if iHours > 0  then
                    SysMsg (Format('µ±Ç°Ãë¿¨Ê£Óà£º%dÐ¡Ê±',[iHours div 3600]), 1);
                  if PEnvir.Darkness then n := BRIGHT_NIGHT//1
                  else if PEnvir.Dawn then n := BRIGHT_DAWN//2  //»õº®Ãß°¡
                  else
                     case Bright of
                        1: n := BRIGHT_DAY;//0;  //³·
                        3: n := BRIGHT_NIGHT;//1;  //¹ã
                        else n := BRIGHT_DAWN;//2;  //»õº®,Àú³á
                     end;
                  if PEnvir.DayLight{ or g_boMirDark} then n := 0;

                  //¿¡·¯ Ç¥½Ã
                  if (n > 256) or (PEnvir.AutoAttack > 256) then
                     MainOutMessage('[Caution!] Over size of BYTE in TUserHuman.Operate(RM_LOGON)');

//                  Def := MakeDefaultMsg (SM_NEWMAP, integer(self), CX, CY, n);
                  Def := MakeDefaultMsg (SM_NEWMAP, integer(self), CX, CY, MakeWord( LOBYTE( n ), LOBYTE( PEnvir.AutoAttack ) ) );
                  SendSocket (@Def, EncodeString (PEnvir.GetGuildAgitRealMapName));
                  SendDefMessage(SM_Server_Config,0,0,0,g_WeightSet,'');


                  SendLogon;
                  if not boSecondCardSystem then
                    SysMsg ('Ãâ·ÑÌåÑéÄ£Ê½', 1);

                  //ÀÌ¸§º¸³¿
                  GetQueryUserName (self, CX, CY);

                  //Áö¿ª »óÅÂ Ç¥½Ã
                  SendAreaState;
                  PotCashChanged;
                  //¸Ê ÀÌ¸§ º¸³»±â
                  SendDefMessage (SM_MAPDESCRIPTION, 0, 0, 0, 0, PEnvir.MapTitle);

                  //Å¬¶óÀÌ¾ðÆ® Ã¼Å©¼¶ º¸³»±â
                  Def := MakeDefaultMsg (SM_CHECK_CLIENTVALID, ClientCheckSumValue1, Loword(ClientCheckSumValue2), Hiword(ClientCheckSumValue2), 0);
                  smsg.Ident := Loword(ClientCheckSumValue3);
                  smsg.msg := Hiword(ClientCheckSumValue3);
                  SendSocket (@Def, EncodeBuffer (@smsg, sizeof(TShortMessage)));
                  SendUnBind();//·¢ËÍ½â°üÎÄ¼þ

                  Def := MakeDefaultMsg(SM_SendSafeZone,
                    length(SafeZoneForClient)*sizeof(TSafeZone){µþ´óÐ¡},
                    length(SafeZoneForClient){°²È«^µÁ¿}, 0, 0);
                  SendSocket(@Def, EncodeBuffer(@SafeZoneForClient[0], length(SafeZoneForClient)*sizeof(TSafeZone)));



                   if boSecondCardSystem then
                   if SecondsCard > 0  then
                     SysMsg (Format('µ±Ç°Ãë¿¨Ê£Óà: %dÃë',[SecondsCard]), 1);


                   if boSecondCardSystem then
                   begin
                    if (RaceServer = RC_USERHUMAN) and (Abil.Level > g_nExpErienceLevel) then begin
                        if (iDay <= 0) then begin
                           iDay := 0;

                          if (iHours <= 0) and (SecondsCard <= 0) then begin //ÔÂ¿¨Ã»ÓÐºó£¬ÉÏ·þÌáÊ¾ºì×Ö
                            SecondsCard := 0;
                           SysMsg ('[ÕË»§ÐÅÏ¢]µ±Ç°ÕË»§³äÖµÊ±¼äÒÑµ½ÆÚ', 0);
                           if RaceServer = RC_USERHUMAN   then begin
                            if (GrobalEnvir.GetEnvir (g_sRechargingMap) <> nil) and (PEnvir.MapName <> g_sRechargingMap) then begin
                              SendRefMsg (RM_SPACEMOVE_HIDE, 0, 0, 0, 0, '');
                              RandomSpaceMove (g_sRechargingMap, 0); //¹«ÀÛÀ§ °ø°£ÀÌµ¿
                            end;
                           end;
                          end;
                        end
                    end;
                   end;
                    if boSecondCardSystem then
                    begin
                      if ((ApprovalMode = 1) or (ApprovalMode = 2)) and (iDay <= 0) then begin //Ã¼ÇèÆÇ »ç¿ëÀÚ, Å×½ºÆ® ¼­¹ö´Â °øÂ¥
                         if (SecondsCard <= 0) then
                         begin
                          if not BoServerShifted then
                           begin
                             if (Abil.Level <= g_nExpErienceLevel) then
                             begin
                              SysMsg (Format('ÄãÏÖÔÚ´¦ÓÚÌåÑéÄ£Ê½ÖÐ£¬Äã¿ÉÒÔÔÚ%d¼¶Ç°Ê¹ÓÃ£¬µ«ÊÇ»áÏÞÖÆÄãµÄÒ»Ð©¹¦ÄÜ', [g_nExpErienceLevel]), 1);  //Äã¿ÉÒÔÔÚ'+IntToStr(EXPERIENCELEVEL)+'¼¶Ç°Ê¹ÓÃ£¬
                              AvailableGold := 100000; //Î´³äÖµÓÃ»§±³°ü½ð±ÒÉÏÏÞ
                             end;
                           end;
                         end;
                      end;
                    end;
                    if g_WemadeGoldEvent or g_WemadeItemEvent then  begin
                     SysMsg('ÏµÍ³»î¶¯½ð±Ò±©ÂÊÌáÉý£º' + IntToStr(g_ExtraMoneyPer) +'%,'+ 'ÎïÆ·±©ÂÊÌáÉý£º'+ IntToStr(g_ExtraItemPer)+ '%', 1);
                         end;

                           if ( MyGuild <> nil ) and (g_NoviceguildEXP) then begin
                               if CompareText (TGuild(MyGuild).GuildName, 'ÐÂÊÖÐÐ»á') = 0 then
                                SysMsg('¡°ÐÂÊÖÐÐ»á¡±'+ '¾­Ñé±¶ÂÊÌáÉý£º'+ IntToStr(g_NoviceguildEXPSZ)+ '%', 11);
                                    end;

                    SendCreditPoint;
                    GamePointChanged;    //»ý·Ö·¢ËÍË¢ÐÂ
               end;
            RM_CHANGEMAP:
               begin
                  //NoGroup ¸Ê¼Ó¼ºÀÌ ÀÖ´Â ¸ÊÀÏ °æ¿ì ±×·ì ÇØÃ¼(sonmg 2004/10/13)
                  if PEnvir.NoGroup then begin
                     try
                        //³»°¡ ±×·ìÂ¯ÀÌ ¾Æ´Ï¸é...
                        if GroupOwner <> nil then begin
                           GroupOwner.DelGroupMember (self);
                        end else begin
                           //³»°¡ ±×·ì Â¯ÀÌ¸é...
                           DelGroupMember(self);
                        end;
                     except
                     end;
                  end;

                  if PEnvir.Darkness then n := BRIGHT_NIGHT//1
                  else if PEnvir.Dawn then n := BRIGHT_DAWN//2  //»õº®Ãß°¡
                  else
                     case Bright of
                        1: n := BRIGHT_DAY;//0;  //³·
                        3: n := BRIGHT_NIGHT;//1;  //¹ã
                        else n := BRIGHT_DAWN;//2;  //»õº®,Àú³á
                     end;
                  if PEnvir.DayLight{ or g_boMirDark} then n := 0; //¾ÍÊÇ»»µØÍ¼²Å·¢ËÍÊÇ·ñÃâÀ¯   ÄãÒª¶îÍâÔÚ·¢ËÍ£¿

                  //¿¡·¯ Ç¥½Ã
                  if (n > 256) or (PEnvir.AutoAttack > 256) then
                     MainOutMessage('[Caution!] Over size of BYTE in TUserHuman.Operate(RM_CHANGEMAP)');
                  mini := PEnvir.MiniMap;

                  SendDefMessage (SM_CHANGEMAP, integer(self), CX, CY, MakeWord( LOBYTE( n ), LOBYTE( PEnvir.AutoAttack ) ),
                     msg.Description+#13+PEnvir.MapTitle+#13+inttostr(mini));
                  //Áö¿ª »óÅÂ Ç¥½Ã
                  SendAreaState;

                //  SendDefMessage (SM_MAPDESCRIPTION, 0, 0, 0, 0, PEnvir.MapTitle);
               end;
            RM_DAYCHANGING:
               begin
                  if PEnvir.Darkness then
                    n := BRIGHT_NIGHT//1
                  else
                  if PEnvir.Dawn then
                    n := BRIGHT_DAWN//2  //»õº®Ãß°¡
                  else
                  begin
                    case Bright of
                      1: n := BRIGHT_DAY;//0; °×Ìì
                      3: n := BRIGHT_NIGHT;//1;  //Ï¦Ñô
                      else
                      n := BRIGHT_DAWN;//2; Ò¹Íí
                    end;
                  end;
                  if PEnvir.DayLight{ or g_boMirDark} then n := 0;
                  Def := MakeDefaultMsg (SM_DAYCHANGING, 0, Bright, n, 0);
                  SendSocket (@Def, '');
               end;

            RM_ABILITY:
               begin
                  Def := MakeDefaultMsg (SM_ABILITY, Gold, Job, 0, 0);
                  SendSocket (@Def, EncodeBuffer (@WAbil, sizeof(TAbility)));
               end;

            RM_SUBABILITY:
               begin
                  SendDefMessage (SM_SUBABILITY, MakeLong(MakeWord(AntiMagic,0), 0), MakeWord(AccuracyPoint, SpeedPoint), MakeWord(AntiPoison, PoisonRecover), MakeWord(HealthRecover, SpellRecover), '');
               end;

            RM_MYSTATUS:
               begin
                  SendDefMessage (SM_MYSTATUS, 0, GetHungryState, 0, 0, '');  //¹è°íÇÄ µî..
               end;

            RM_ADJUST_BONUS:
               begin
                  ServerSendAdjustBonus;
               end;

            RM_HEALTHSPELLCHANGED:
               begin
                  Def := MakeDefaultMsg (SM_HEALTHSPELLCHANGED,
                                         integer(msg.Sender),
                                         TCreature(msg.Sender).WAbil.HP,
                                         TCreature(msg.Sender).WAbil.MP,
                                         TCreature(msg.Sender).WAbil.MaxHP);
                  SendSocket (@Def, '');
               end;

            RM_MOVEFAIL:
               begin
                  Def := MakeDefaultMsg (SM_MOVEFAIL, integer(self), self.CX, self.CY, self.Dir);
                  cdesc.Feature := Feature;
                  cdesc.Status := CharStatus;
                  cdesc.ShowTrans := bShowTrans;
                  SendSocket (@Def, EncodeBuffer (@cdesc, sizeof(TCharDesc)));
               end;


            RM_TURN, RM_PUSH, RM_RUSH, RM_RUSHKUNG:
               begin
                  if (msg.sender <> self) or (msg.Ident = RM_PUSH) or (msg.Ident = RM_RUSH) or (msg.Ident = RM_RUSHKUNG) then begin
                     //msg.wParam : ¹æÇâ
                     case msg.Ident of
                        RM_PUSH: Def := MakeDefaultMsg (SM_BACKSTEP, integer(msg.sender), msg.lParam1{x}, msg.lParam2{y}, MakeWord(msg.wParam{dir}, TCreature(msg.sender).Light));
                        RM_RUSH: Def := MakeDefaultMsg (SM_RUSH, integer(msg.sender), msg.lParam1{x}, msg.lParam2{y}, MakeWord(msg.wParam{dir}, TCreature(msg.sender).Light));
                        RM_RUSHKUNG: Def := MakeDefaultMsg (SM_RUSHKUNG, integer(msg.sender), msg.lParam1{x}, msg.lParam2{y}, MakeWord(msg.wParam{dir}, TCreature(msg.sender).Light))
                        else
                           Def := MakeDefaultMsg (SM_TURN, integer(msg.sender), msg.lParam1{x}, msg.lParam2{y}, MakeWord(msg.wParam{dir}, TCreature(msg.sender).Light));
                     end;
                     cdesc.Feature := TCreature(msg.sender).GetRelFeature (self);
                     cdesc.Status := TCreature(msg.sender).CharStatus;
                     cdesc.ShowTrans := TCreature(msg.sender).bShowTrans;
                     str := EncodeBuffer (@cdesc, sizeof(TCharDesc));
                     n := GetThisCharColor (TCreature(msg.Sender));
                     if msg.Description <> '' then
                        str := str + EncodeString (msg.Description + '/' +  //Ä³¸¯ ÀÌ¸§
                                                   IntToStr(n) //ÀÌ¸§»ö±ò
                                                   );

                     SendSocket (@Def, str);
//                     //-°ÚÌ¯
                     if msg.Ident = RM_TURN then
                     begin
                     n := TCreature(msg.sender).Feature();  //³á°òËùÔö¼ÓÐÞ¸Ä
                        SendDefMessage(SM_FEATURECHANGED, Integer(msg.sender), LoWord(n), //³á°òËùÔö¼ÓÐÞ¸Ä
                                       HiWord(n), TCreature(msg.sender).FeatureEx, inttostr(TCreature(msg.sender).bShowTrans));  //³á°òËùÔö¼ÓÐÞ¸Ä
                       if TCreature(msg.sender).RaceServer = RC_USERHUMAN then
                         if TUserHuman(msg.sender).m_StallMgr.OnSale then begin
                           SendMsg(TUserHuman(msg.sender),
                                      RM_STALLSTATUS,
                                   TUserHuman(msg.sender).m_StallMgr.mBlock.ItemCount,
                                  TUserHuman(msg.sender).CX,
                                   TUserHuman(msg.sender).CY,
                                  TUserHuman(msg.sender).Dir,//dir
                                                 '');
                         end;
                        TCreature(msg.sender).FeatureChanged;
                     end;
                  end;
               end;

            RM_FOXSTATE:
               begin
                  if msg.Sender <> self then begin
                     Def := MakeDefaultMsg (SM_FOXSTATE, integer(msg.sender),
                                              msg.lParam1{x},
                                              msg.lParam2{y},
                                              MakeWord(msg.wParam{dir}, msg.lParam3{bodystate}));
                     cdesc.Feature := TCreature(msg.sender).GetRelFeature (self);
                     cdesc.Status := TCreature(msg.sender).CharStatus;
                     cdesc.ShowTrans := TCreature(msg.sender).bShowTrans;
                     str := EncodeBuffer (@cdesc, sizeof(TCharDesc));
                     n := GetThisCharColor (TCreature(msg.Sender));
                     if msg.Description <> '' then
                        str := str + EncodeString (msg.Description + '/' +  //Ä³¸¯ ÀÌ¸§
                                                   IntToStr(n) //ÀÌ¸§»ö±ò
                                                   );

                     SendSocket (@Def, str);
                  end;
               end;

            RM_WALK:
               begin
                  if msg.Sender <> self then begin
                     Def := MakeDefaultMsg (SM_WALK, integer(msg.sender),
                                              msg.lParam1{x},
                                              msg.lParam2{y},
                                              MakeWord(msg.wParam{dir}, TCreature(msg.sender).Light));
                     cdesc.Feature := TCreature(msg.sender).GetRelFeature (self);
                     cdesc.Status := TCreature(msg.sender).CharStatus;
                     cdesc.ShowTrans := TCreature(msg.sender).bShowTrans;
                     SendSocket (@Def, EncodeBuffer (@cdesc, sizeof(TCharDesc)));
                  end;
               end;

            RM_RUN:
               begin
                  if msg.Sender <> self then begin
                     Def := MakeDefaultMsg (SM_RUN, integer(msg.sender),
                                             msg.lParam1{x},
                                             msg.lParam2{y},
                                             MakeWord(msg.wParam{dir}, TCreature(msg.sender).Light));
                     cdesc.Feature := TCreature(msg.sender).GetRelFeature (self);
                     cdesc.Status := TCreature(msg.sender).CharStatus;
                     cdesc.ShowTrans := TCreature(msg.sender).bShowTrans;
                     SendSocket (@Def, EncodeBuffer (@cdesc, sizeof(TCharDesc)));
                  end;
               end;


            RM_BUTCH:
               begin
                  if msg.Sender <> self then begin
                     Def := MakeDefaultMsg (SM_BUTCH, integer(msg.sender), msg.lParam1{x}, msg.lParam2{y}, msg.wParam{Dir});
                     SendSocket (@Def, '');
                  end;
               end;

            RM_HIT:
               begin
                  if msg.Sender <> self then begin
                      Def := MakeDefaultMsg (SM_HIT, integer(msg.sender), msg.lParam1{x}, msg.lParam2{y}, msg.wParam{Dir});
                     SendSocket (@Def, '');
                  end;
               end;

            RM_POWERHIT:
               begin
                  if msg.Sender <> self then begin
                     Def := MakeDefaultMsg (SM_POWERHIT, integer(msg.sender), msg.lParam1{x}, msg.lParam2{y}, msg.wParam{Dir});
                     SendSocket (@Def, '');
                  end;
               end;

            RM_LONGHIT:
               begin
                  if msg.Sender <> self then begin
                     Def := MakeDefaultMsg (SM_LONGHIT, integer(msg.sender), msg.lParam1{x}, msg.lParam2{y}, msg.wParam{Dir});
                     SendSocket (@Def, '');
                  end;
               end;

            RM_WIDEHIT:
               begin
                  if msg.Sender <> self then begin
                     Def := MakeDefaultMsg (SM_WIDEHIT, integer(msg.sender), msg.lParam1{x}, msg.lParam2{y}, msg.wParam{Dir});
                     SendSocket (@Def, '');
                  end;
               end;
            // 2003/03/15 ½Å±Ô¹«°ø
            RM_CROSSHIT:
               begin
                  if msg.Sender <> self then begin
                     Def := MakeDefaultMsg (SM_CROSSHIT, integer(msg.sender), msg.lParam1{x}, msg.lParam2{y}, msg.wParam{Dir});
                     SendSocket (@Def, '');
                  end;
               end;
            RM_TWINHIT:
               begin
                  if msg.Sender <> self then begin
                     Def := MakeDefaultMsg (SM_TWINHIT, integer(msg.sender), msg.lParam1{x}, msg.lParam2{y}, msg.wParam{Dir});
                     SendSocket (@Def, '');
                  end;
               end;

            RM_HEAVYHIT:
               begin
                  if msg.Sender <> self then begin
                     Def := MakeDefaultMsg (SM_HEAVYHIT, integer(msg.sender), msg.lParam1{x}, msg.lParam2{y}, msg.wParam{Dir});
                     SendSocket (@Def, msg.Description);
                  end;
               end;

            RM_BIGHIT:
               begin
                  if msg.Sender <> self then begin
                     Def := MakeDefaultMsg (SM_BIGHIT, integer(msg.sender), msg.lParam1{x}, msg.lParam2{y}, msg.wParam{Dir});
                     SendSocket (@Def, '');
                  end;
               end;

            RM_FIREHIT:
               begin
                  if msg.Sender <> self then begin
                     Def := MakeDefaultMsg (SM_FIREHIT, integer(msg.sender), msg.lParam1{x}, msg.lParam2{y}, msg.wParam{Dir});
                     SendSocket (@Def, '');
                  end;
               end;
            RM_WINDCUT:
                begin
//                  if msg.Sender <> self then begin
                     Def := MakeDefaultMsg (SM_WINDCUT, integer(msg.sender), msg.lParam1{x}, msg.lParam2{y}, msg.wParam{Dir});
                     SendSocket (@Def, '');
//                  end;
                end;
            //½Å±Ô¹«°ø(2004/06/23)
            RM_PULLMON:
               begin
                  if msg.Sender <> self then begin
                     Def := MakeDefaultMsg (SM_PULLMON, integer(msg.sender), msg.lParam1{x}, msg.lParam2{y}, msg.wParam{Dir});
                     SendSocket (@Def, '');
                  end;
               end;
            RM_SUCKBLOOD:
               begin
                  if msg.Sender <> self then begin
                     Def := MakeDefaultMsg (SM_SUCKBLOOD, integer(msg.sender), msg.lParam1{x}, msg.lParam2{y}, msg.wParam{Dir});
                     SendSocket (@Def, '');
                  end;
               end;

            RM_SPELL:
               begin
                  if msg.Sender <> self then begin
                     Def := MakeDefaultMsg (SM_SPELL, integer(msg.sender), msg.lparam1{tx}, msg.lparam2{ty}, msg.wParam{effect});
                     SendSocket (@Def, IntToStr(msg.lparam3){magicid});
                  end;
               end;
            RM_MAGICFIRE:
               begin
                  Def := MakeDefaultMsg (SM_MAGICFIRE, integer(msg.sender), Loword(msg.lparam2){x}, Hiword(msg.lparam2){y}, msg.lparam1);
                  SendSocket (@Def, EncodeBuffer (@(msg.lparam3), sizeof(integer)));
               end;
            RM_MAGICFIRE_FAIL:
               begin
                  SendDefMessage (SM_MAGICFIRE_FAIL, integer(msg.Sender), 0, 0, 0, '');
               end;

            RM_STRUCK,
            RM_STRUCK_MAG:
               begin
                  if msg.wParam > 0 then begin //damage
                     if msg.Sender = self then begin //³»°¡ ¸ÂÀº °Í¸¸.
                        if TCreature(msg.lparam3) <> nil then begin
                           if TCreature(msg.lparam3).RaceServer = RC_USERHUMAN then begin
                              //Á¤´ç¹æ¾î¸¦ À§ÇÑ ±â·Ï..
                              AddPkHiter (TCreature(msg.lparam3));
                           end;
                           SetLastHiter (TCreature(msg.lparam3));
                        end;

                        //»¡°»ÀÌµéÀº ¸Â¾Æµµ ÀçÁ¢ ¸øÇÔ
                        if PKLevel >= 2 then
                           HumStruckTime := GetTickCount;

                        //¼ºÀÇ ¹®¿øÀ» ¶§¸° °æ¿ì, ±Ãº´ÀÌ °ø°ÝÇÔ
                        if UserCastle.IsOurCastle (TGuild(MyGuild)) then begin
                           if msg.lparam3 <> 0 then begin
                              TCreature(msg.lparam3).BoCrimeforCastle := TRUE;
                              TCreature(msg.lparam3).CrimeforCastleTime := GetTickCount;
                           end;
                        end;

                        HealthTick := 0; //¸ÂÀ¸¸é È¸º¹ÀÌ ¾ÈµÈ´Ù.
                        SpellTick := 0;
                        Dec (PerHealth);
                        Dec (PerSpell);
                     end;
                     if msg.Sender <> nil then begin
                        Def := MakeDefaultMsg (SM_STRUCK, integer(msg.sender),
                                    TCreature(msg.Sender).WAbil.HP,
                                    TCreature(msg.Sender).WAbil.MaxHP,
                                    msg.wparam);
                        wl.lParam1 := TCreature(msg.Sender).GetRelFeature (self);
                        wl.lParam2 := TCreature(msg.Sender).CharStatus;
                        wl.lTag1 := msg.lparam3;  //¶§¸°³ð
                     end;
                     if msg.Ident = RM_STRUCK_MAG then
                        wl.lTag2 := 1     //¸¶¹ýÀ¸·Î ¸Â´Â »ç¿îµå È¿°ú
                     else wl.lTag2 := 0;
                     SendSocket (@Def, EncodeBuffer (@wl, sizeof(TMessageBodyWL)));
                   //----------------»¤ÉíÏÔÀ¶
                      Def := MakeDefaultMsg(SM_SHOWBLUEHEALTH, Integer(Msg.Sender),
                             TCreature(Msg.Sender).WAbil.MP,
                             Byte(TCreature(Msg.Sender).BoMagicShield),
                             TCreature(Msg.Sender).WAbil.MaxMP);
                      SendSocket(@Def, '');
                   //----------------
                  end;
               end;

            RM_DEATH:
               begin
                  if TCreature(msg.sender).RaceServer <> RC_CLONE then
                  begin
                    if msg.lparam3 = 1 then
                       Def := MakeDefaultMsg (SM_NOWDEATH, integer(msg.sender), msg.lparam1{x}, msg.lparam2{y}, msg.wparam{Dir})
                    else Def := MakeDefaultMsg (SM_DEATH, integer(msg.sender), msg.lparam1{x}, msg.lparam2{y}, msg.wparam{Dir});
                    cdesc.Feature := TCreature(msg.sender).GetRelFeature (self);
                    cdesc.Status := TCreature(msg.sender).CharStatus;
                    cdesc.ShowTrans := TCreature(msg.sender).bShowTrans;
                    SendSocket (@Def, EncodeBuffer (@cdesc, sizeof(TCharDesc)));
                  end;
               end;
            RM_SKELETON:
               begin
                  Def := MakeDefaultMsg (SM_SKELETON, integer(msg.sender), msg.lparam1{x}, msg.lparam2{y}, msg.wparam{Dir});
                  cdesc.Feature := TCreature(msg.sender).GetRelFeature (self);
                  cdesc.Status := TCreature(msg.sender).CharStatus;
                  cdesc.ShowTrans := TCreature(msg.sender).bShowTrans;
                  SendSocket (@Def, EncodeBuffer (@cdesc, sizeof(TCharDesc)));
               end;
            RM_ALIVE:
               begin
                  Def := MakeDefaultMsg (SM_ALIVE, integer(msg.sender), msg.lparam1{x}, msg.lparam2{y}, msg.wparam{Dir});
                  cdesc.Feature := TCreature(msg.sender).GetRelFeature (self);
                  cdesc.Status := TCreature(msg.sender).CharStatus;
                  cdesc.ShowTrans := TCreature(msg.sender).bShowTrans;
                  SendSocket (@Def, EncodeBuffer (@cdesc, sizeof(TCharDesc)));
               end;
            RM_CHANGEFACE:
               begin
                  //msg.lparam1 º¯½ÅÀü
                  //msg.lparam2 º¯½ÅÈÄ
                  if (msg.lparam1 <> 0) and (msg.lparam2 <> 0) then begin
                     Def := MakeDefaultMsg (SM_CHANGEFACE, msg.lparam1, Loword(msg.lparam2), Hiword(msg.lparam2), 0);
                     cdesc.Feature := TCreature(msg.lparam2).GetRelFeature (self);
                     cdesc.Status := TCreature(msg.lparam2).CharStatus;
                     cdesc.ShowTrans := TCreature(msg.lparam2).bShowTrans;
                     SendSocket (@Def, EncodeBuffer (@cdesc, sizeof(TCharDesc)));
                  end;
               end;

            RM_RECONNECT:
               begin
                  SoftClosed := TRUE;  //ÀçÁ¢À» À§ÇØ¼­ Á¢¼ÓÁ¾·áÇÔ.
                  SendDefMessage (SM_RECONNECT, 0, 0, 0, 0, msg.Description);
               end;

            RM_SPACEMOVE_SHOW,
            RM_SPACEMOVE_SHOW_NO,
            RM_SPACEMOVE_SHOW_MAGIC,
            RM_SPACEMOVE_SHOW_MAGIC2,
            RM_SPACEMOVE_SHOW2:
               begin
                  //msg.wParam : ¹æÇâ
                  TCreature(msg.sender).UserNameChanged;
                  if msg.Ident = RM_SPACEMOVE_SHOW then
                     Def := MakeDefaultMsg (SM_SPACEMOVE_SHOW, integer(msg.sender), msg.lParam1{x}, msg.lParam2{y}, MakeWord(msg.wParam{dir}, TCreature(msg.sender).Light))
                  else if msg.Ident = RM_SPACEMOVE_SHOW2 then
                     Def := MakeDefaultMsg (SM_SPACEMOVE_SHOW2, integer(msg.sender), msg.lParam1{x}, msg.lParam2{y}, MakeWord(msg.wParam{dir}, TCreature(msg.sender).Light))
                  else  if msg.Ident = RM_SPACEMOVE_SHOW_MAGIC then
                     Def := MakeDefaultMsg (SM_SPACEMOVE_SHOW_MAGIC, integer(msg.sender), msg.lParam1{x}, msg.lParam2{y}, MakeWord(msg.wParam{dir}, TCreature(msg.sender).Light))
                  else  if msg.Ident = RM_SPACEMOVE_SHOW_MAGIC2 then
                     Def := MakeDefaultMsg (SM_SPACEMOVE_SHOW_MAGIC2, integer(msg.sender), msg.lParam1{x}, msg.lParam2{y}, MakeWord(msg.wParam{dir}, TCreature(msg.sender).Light))
                  else
                     Def := MakeDefaultMsg (SM_SPACEMOVE_SHOW_NO, integer(msg.sender), msg.lParam1{x}, msg.lParam2{y}, MakeWord(msg.wParam{dir}, TCreature(msg.sender).Light));
                  cdesc.Feature := TCreature(msg.sender).GetRelFeature (self);
                  cdesc.Status := TCreature(msg.sender).CharStatus;
                  cdesc.ShowTrans := TCreature(msg.sender).bShowTrans;
                  str := EncodeBuffer (@cdesc, sizeof(TCharDesc));
                  n := GetThisCharColor (TCreature(msg.Sender));
                  if msg.Description <> '' then str := str + EncodeString (msg.Description + '/' + IntToStr(n)); //Ä³¸¯ ÀÌ¸§ + ÀÌ¸§»ö±ò
                  SendSocket (@Def, str);
               end;

            RM_SPACEMOVE_HIDE,
            RM_SPACEMOVE_HIDE2:
               begin
                  if msg.Ident = RM_SPACEMOVE_HIDE then
                     Def := MakeDefaultMsg (SM_SPACEMOVE_HIDE, integer(msg.sender), 0, 0, 0)
                  else
                     Def := MakeDefaultMsg (SM_SPACEMOVE_HIDE2, integer(msg.sender), 0, 0, 0);
                  SendSocket (@Def, '');
               end;

            RM_DISAPPEAR:
               begin
                  Def := MakeDefaultMsg (SM_DISAPPEAR, integer(msg.sender), 0, 0, 0);
                  SendSocket (@Def, '');
               end;

            RM_DIGUP:
               begin
                  Def := MakeDefaultMsg (SM_DIGUP, integer(msg.sender), msg.lparam1, msg.lparam2, MakeWord(msg.wParam{dir}, TCreature(msg.sender).Light));
                  wl.lParam1 := TCreature(msg.Sender).GetRelFeature (self);
                  wl.lParam2 := TCreature(msg.Sender).CharStatus;
                  wl.lTag1 := msg.lparam3;  //ÀÌº¥Æ®
                  wl.lTag1 := 0;
                  str := EncodeBuffer (@wl, sizeof(TMessageBodyWL));
                  SendSocket (@Def, str);
               end;
            RM_DIGDOWN:
               begin
                  Def := MakeDefaultMsg (SM_DIGDOWN, integer(msg.sender), msg.lparam1, msg.lparam2, msg.wParam);
                  SendSocket (@Def, '');
               end;
            RM_SHOWEVENT:
               begin
                  smsg.Ident := Hiword(msg.lParam2); //EventParam
                  smsg.msg := 0;
                  Def := MakeDefaultMsg (SM_SHOWEVENT, integer(msg.lparam1), msg.wParam, Loword(msg.lParam2), msg.lParam3);
                  str := EncodeBuffer (@smsg, sizeof(TShortMessage));
                  SendSocket (@Def, str);
               end;
            RM_HIDEEVENT:
               begin
                  SendDefMessage (SM_HIDEEVENT, integer(msg.lparam1), msg.wParam, msg.lParam2, msg.lParam3, '');
               end;

            RM_FLYAXE:
               begin
                  if msg.lparam3 <> 0 then begin
                     mbw.Param1 := TCreature(msg.lparam3).CX;
                     mbw.Param2 := TCreature(msg.lparam3).CY;
                     mbw.Tag1 := Loword (msg.lparam3);
                     mbw.Tag2 := Hiword (msg.lparam3);
                     Def := MakeDefaultMsg (SM_FLYAXE, integer(msg.sender), msg.lparam1, msg.lparam2, msg.wParam{Dir});
                     str := EncodeBuffer (@mbw, sizeof(TMessageBodyW));
                     SendSocket (@Def, str);
                  end;
               end;

            RM_LIGHTING:
               begin
                  if msg.lparam3 <> 0 then begin
                     wl.lParam1 := TCreature(msg.lparam3).CX;
                     wl.lParam2 := TCreature(msg.lparam3).CY;
                  end;
                  wl.lTag1 := msg.lparam3;
                  wl.lTag2 := msg.wparam; //¸¶¹ý ¹øÈ£
                  Def := MakeDefaultMsg (SM_LIGHTING,
                                             integer(msg.Sender),
                                             msg.lparam1,
                                             msg.lparam2,
                                             TCreature(msg.Sender).Dir);
                  str := EncodeBuffer (@wl, sizeof(TMessageBodyWL));
                  SendSocket (@Def, str);
               end;

            RM_LIGHTING_1:
               begin
                  if msg.lparam3 <> 0 then begin
                     wl.lParam1 := TCreature(msg.lparam3).CX;
                     wl.lParam2 := TCreature(msg.lparam3).CY;
                  end;
                  wl.lTag1 := msg.lparam3;
                  wl.lTag2 := msg.wparam; //¸¶¹ý ¹øÈ£
                  Def := MakeDefaultMsg (SM_LIGHTING_1,
                                             integer(msg.Sender),
                                             msg.lparam1,
                                             msg.lparam2,
                                             TCreature(msg.Sender).Dir);
                  str := EncodeBuffer (@wl, sizeof(TMessageBodyWL));
                  SendSocket (@Def, str);
               end;
            RM_LIGHTING_2:
               begin
                  if msg.lparam3 <> 0 then begin
                     wl.lParam1 := TCreature(msg.lparam3).CX;
                     wl.lParam2 := TCreature(msg.lparam3).CY;
                  end;
                  wl.lTag1 := msg.lparam3;
                  wl.lTag2 := msg.wparam; //¸¶¹ý ¹øÈ£
                  Def := MakeDefaultMsg (SM_LIGHTING_2,
                                             integer(msg.Sender),
                                             msg.lparam1,
                                             msg.lparam2,
                                             TCreature(msg.Sender).Dir);
                  str := EncodeBuffer (@wl, sizeof(TMessageBodyWL));
                  SendSocket (@Def, str);
               end;
            RM_LIGHTING_3:
               begin
                  if msg.lparam3 <> 0 then begin
                     wl.lParam1 := TCreature(msg.lparam3).CX;
                     wl.lParam2 := TCreature(msg.lparam3).CY;
                  end;
                  wl.lTag1 := msg.lparam3;
                  wl.lTag2 := msg.wparam; //¸¶¹ý ¹øÈ£
                  Def := MakeDefaultMsg (SM_LIGHTING_3,
                                             integer(msg.Sender),
                                             msg.lparam1,
                                             msg.lparam2,
                                             TCreature(msg.Sender).Dir);
                  str := EncodeBuffer (@wl, sizeof(TMessageBodyWL));
                  SendSocket (@Def, str);
               end;

            RM_DRAGON_FIRE1:
               begin
                  if msg.lparam3 <> 0 then begin
                     wl.lParam1 := TCreature(msg.lparam3).CX;
                     wl.lParam2 := TCreature(msg.lparam3).CY;
                  end;
                  wl.lTag1 := msg.lparam3;
                  wl.lTag2 := msg.wparam; //¸¶¹ý ¹øÈ£
                  Def := MakeDefaultMsg (SM_DRAGON_FIRE1,
                                             integer(msg.Sender),
                                             msg.lparam1,
                                             msg.lparam2,
                                             TCreature(msg.Sender).Dir);
                  str := EncodeBuffer (@wl, sizeof(TMessageBodyWL));
                  SendSocket (@Def, str);
               end;
            RM_DRAGON_FIRE2:
               begin
                  if msg.lparam3 <> 0 then begin
                     wl.lParam1 := TCreature(msg.lparam3).CX;
                     wl.lParam2 := TCreature(msg.lparam3).CY;
                  end;
                  wl.lTag1 := msg.lparam3;
                  wl.lTag2 := msg.wparam; //¸¶¹ý ¹øÈ£
                  Def := MakeDefaultMsg (SM_DRAGON_FIRE2,
                                             integer(msg.Sender),
                                             msg.lparam1,
                                             msg.lparam2,
                                             TCreature(msg.Sender).Dir);
                  str := EncodeBuffer (@wl, sizeof(TMessageBodyWL));
                  SendSocket (@Def, str);
               end;
            RM_DRAGON_FIRE3:
               begin
                  if msg.lparam3 <> 0 then begin
                     wl.lParam1 := TCreature(msg.lparam3).CX;
                     wl.lParam2 := TCreature(msg.lparam3).CY;
                  end;
                  wl.lTag1 := msg.lparam3;
                  wl.lTag2 := msg.wparam; //¸¶¹ý ¹øÈ£
                  Def := MakeDefaultMsg (SM_DRAGON_FIRE3,
                                             integer(msg.Sender),
                                             msg.lparam1,
                                             msg.lparam2,
                                             TCreature(msg.Sender).Dir);
                  str := EncodeBuffer (@wl, sizeof(TMessageBodyWL));
                  SendSocket (@Def, str);
               end;

            RM_NORMALEFFECT:
               begin
                  SendDefMessage (SM_NORMALEFFECT,
                                       integer (msg.Sender),  //recog
                                       msg.lparam1, //xx
                                       msg.lparam2, //yy
                                       msg.lparam3, //È¿°ú Á¾·ù
                                       '');
               end;

             RM_NORMALEFFECTEX:
               begin
                  SendDefMessage (SM_NORMALEFFECTEX,
                                       integer (msg.Sender),  //recog
                                       msg.lparam1, //
                                       msg.lparam2, //yy
                                       msg.lparam3, //dir
                                       '');
               end;



            RM_LOOPNORMALEFFECT:
               begin
                  SendDefMessage (SM_LOOPNORMALEFFECT,
                                       integer (msg.Sender),  //recog
                                       msg.lparam1, //½Ã°£(ÃÊ)
                                       msg.lparam2, //»ç¿ë¾ÈÇÔ.
                                       msg.lparam3, //È¿°ú Á¾·ù
                                       '');
               end;

            RM_OPENHEALTH:
               begin
                  SendDefMessage (SM_OPENHEALTH,
                                       integer(msg.Sender),
                                       TCreature(msg.Sender).WAbil.HP,
                                       TCreature(msg.Sender).WAbil.MaxHP,
                                       0, '');
               end;

            RM_CLOSEHEALTH:
               begin
                  SendDefMessage (SM_CLOSEHEALTH, integer(msg.Sender), 0, 0, 0, '');
               end;
            RM_INSTANCEHEALGUAGE:
               begin
                  SendDefMessage (SM_INSTANCEHEALGUAGE, integer(msg.Sender),
                                       TCreature(msg.Sender).WAbil.HP,
                                       TCreature(msg.Sender).WAbil.MaxHP,
                                       0, '');
               end;

            RM_BREAKWEAPON:
               begin
                  SendDefMessage (SM_BREAKWEAPON, integer(msg.Sender), 0, 0, 0, '');
               end;
            // 2003/03/04 Å½±â
            RM_GROUPPOS:    // gadget
               begin
                  Def := MakeDefaultMsg(SM_GROUPPOS, integer(msg.sender),
                                          msg.lParam1 {x},
                                          msg.lParam2 {y},
                                          msg.lParam3 );
                  SendSocket(@Def, '');
               end;
            RM_CHANGENAMECOLOR:
               begin
                  //»öº¯°æ..
                  //³ª¿ÍÀÇ °ü°è¿¡ µû¶ó¼­ »öÀÌ ´Ù¸£°Ô º¸ÀÎ´Ù.
                  n := GetThisCharColor (TCreature(msg.Sender));
                  SendDefMessage (SM_CHANGENAMECOLOR, integer(msg.Sender), n, 0, 0, '');
               end;
            RM_USERNAME:  //¼­¹ö¿¡¼­ °­Á¦ÀûÀ¸·Î ÀÌ¸§À» º¸³»·Á°í ÇÒ¶§
               begin
                  Def := MakeDefaultMsg (SM_USERNAME, integer(msg.Sender), GetThisCharColor (TCreature(msg.Sender)), 0, 0);
                  SendSocket (@Def, EncodeString(msg.Description));
               end;

            RM_WINEXP:
               begin
                  Def := MakeDefaultMsg (SM_WINEXP, Abil.Exp, loword(msg.lparam1){¾òÀº°æÇèÄ¡}, hiword(msg.lparam1), 0);
                  SendSocket (@Def, '');
               end;

            RM_CHANGEFAMEPOINT:  //¸í¼ºÄ¡ º¯È­
               begin
                  Def := MakeDefaultMsg (SM_CHANGEFAMEPOINT, Abil.FameCur, 0, 0, 0);
                  SendSocket (@Def, EncodeString(msg.Description));  //¸í¼º È£Äª
               end;

            RM_LEVELUP:
               begin
                  Def := MakeDefaultMsg (SM_LEVELUP, Abil.Exp, Abil.Level, 0, 0);
                  SendSocket (@Def, '');
                  Def := MakeDefaultMsg (SM_ABILITY, Gold, Job, Gold, 0);
                  SendSocket (@Def, EncodeBuffer (@WAbil, sizeof(TAbility)));
                  SendDefMessage (SM_SUBABILITY, MakeLong(MakeWord(AntiMagic,0), 0), MakeWord(AccuracyPoint, SpeedPoint), MakeWord(AntiPoison, PoisonRecover), MakeWord(HealthRecover, SpellRecover), '');
               end;
            RM_SYSMESSAGECOLOR:
               BEGIN
                 Def := MakeDefaultMsg (SM_SYSMESSAGE, integer(msg.sender), MakeWord(msg.lParam2, msg.lParam3), 1, 1);
                str := EncodeString (msg.description);
                SendSocket (@Def, str);
               END;
            RM_SYSSCROLLMESSAGE:
               BEGIN
                 Def := MakeDefaultMsg (SM_SYSSCROLLMESSAGE, integer(msg.sender), MakeWord(msg.lParam1, msg.lParam2), 0, 0);
                str := EncodeString (msg.description);
                SendSocket (@Def, str);
               END;
            RM_HEAR,
            RM_CRY,
            RM_WHISPER,
            RM_GMWHISPER,
            RM_LM_WHISPER,
            RM_SYSMESSAGE,
            RM_SYSMESSAGE2,
            RM_SYSMESSAGE3,
            RM_SYSMSG_BLUE,
            RM_SYSMSG_PINK,
            RM_SYSMSG_GREEN,
            RM_SYSMSG_REMARK,
            RM_SYSMSG_REMARK2,
            RM_SYSMSG_REMARK3,
            RM_GROUPMESSAGE,
            RM_GUILDMESSAGE,
            RM_SYSMSG_USE,
            RM_SYSMSG_USE_HORN,
            RM_MERCHANTSAY:
               begin
                  case msg.Ident of
                     RM_HEAR:       Def := MakeDefaultMsg (SM_HEAR, integer(msg.sender), MakeWord(0, 255), 0, 1);
                     RM_CRY:        Def := MakeDefaultMsg (SM_HEAR, integer(msg.sender), MakeWord(0, 151), 0, 1);
                     RM_WHISPER:    Def := MakeDefaultMsg (SM_WHISPER, integer(msg.sender), MakeWord(252, 255), 0, 1);
                     RM_GMWHISPER:  Def := MakeDefaultMsg (SM_WHISPER, integer(msg.sender), MakeWord(252, 255), 0, 1);
                     RM_LM_WHISPER: Def := MakeDefaultMsg (SM_WHISPER, integer(msg.sender), MakeWord(253{70}, 255), 0, 1);
                     RM_SYSMESSAGE: Def := MakeDefaultMsg (SM_SYSMESSAGE, integer(msg.sender), MakeWord(255, 56), 0, 1);
                     RM_SYSMESSAGE2:  Def := MakeDefaultMsg (SM_SYSMESSAGE, integer(msg.sender), MakeWord(219, 255), 0, 1);
                     RM_SYSMESSAGE3:  Def := MakeDefaultMsg (SM_SYSMESSAGE, integer(msg.sender), MakeWord(56, 255), 0, 1);
                     RM_SYSMSG_BLUE:  Def := MakeDefaultMsg (SM_SYSMESSAGE, integer(msg.sender), MakeWord(255, 252), 0, 1);
                     RM_SYSMSG_PINK:  Def := MakeDefaultMsg (SM_SYSMESSAGE, integer(msg.sender), MakeWord({255}2, {253}255), 0, 1);   //¿¬ÀÎÃàÇÏ¸Þ½ÃÁö
                     RM_SYSMSG_GREEN:  Def := MakeDefaultMsg (SM_SYSMESSAGE, integer(msg.sender), MakeWord(255, 220), 0, 1);
                     RM_SYSMSG_REMARK: Def := MakeDefaultMsg (SM_SYSMSG_REMARK, integer(msg.sender), MakeWord(219, 255), 0, 1);
                     RM_GROUPMESSAGE: Def := MakeDefaultMsg (SM_SYSMESSAGE, integer(msg.sender), MakeWord(196, 255), 0, 1);
                     RM_SYSMSG_USE: Def := MakeDefaultMsg (SM_SYSMESSAGE, integer(msg.sender), MakeWord(g_nMsgFColor, g_nMsgBColor), 0, 1);   //À®°ÈÑÕÉ«
                     RM_SYSMSG_USE_HORN:Def := MakeDefaultMsg (SM_SYSMESSAGE, integer(msg.sender), MakeWord(g_nMsgDFColor, g_nMsgDBColor), 120, msg.wParam);   //À®°ÈÑÕÉ«
                     RM_GUILDMESSAGE: Def := MakeDefaultMsg (SM_GUILDMESSAGE, integer(msg.sender), MakeWord(5{212}, 255), 0, 1);    //ÐÐ»áÑÕÉ«
                     RM_MERCHANTSAY:  Def := MakeDefaultMsg (SM_MERCHANTSAY, integer(msg.sender), 0, 0, 1);
                     RM_SYSMSG_REMARK2: Def := MakeDefaultMsg (SM_SYSMESSAGE, integer(msg.sender), MakeWord(0, 151), 0, 1);
                     RM_SYSMSG_REMARK3: Def := MakeDefaultMsg (SM_SYSMESSAGE, integer(msg.sender), MakeWord(255, 5), 0, 1);
                  end;
                  str := EncodeString (msg.description);
                  SendSocket (@Def, str);
               end;
            RM_MERCHANTDLGCLOSE:
               begin
                  SendDefMessage (SM_MERCHANTDLGCLOSE, msg.lparam1, msg.lparam2, 0, 0, '');
               end;
            RM_SENDGOODSLIST:
               begin
                  SendDefMessage (SM_SENDGOODSLIST, msg.lparam1{merchant id}, msg.lparam2{count}, 0, 0, msg.Description);
               end;
            RM_SENDUSERSELL:
               begin
                  SendDefMessage (SM_SENDUSERSELL, msg.lparam1{merchant id}, msg.lparam2{count}, 0, 0, '');
               end;
            RM_SENDUSERREPAIR,
            RM_SENDUSERSPECIALREPAIR:
               begin
                  SendDefMessage (SM_SENDUSERREPAIR, msg.lparam1{merchant id}, msg.lparam2{count}, 0, 0, '');
               end;
            RM_SENDUSERSTORAGEITEM:
               begin
                  bStorageType := 0;
                  SendDefMessage (SM_SENDUSERSTORAGEITEM, msg.lparam1{merchant id}, msg.lparam2{count}, 0, 0, '');
               end;
            RM_SENDUSERSTORAGEITEMLIST:
               begin
                  bStorageType := msg.wParam;
                  ServerSendStorageItemList (msg.lparam1);
               end;
            RM_SENDUSERMAKEDRUGITEMLIST:
               begin
                  SendDefMessage (SM_SENDUSERMAKEDRUGITEMLIST, msg.lparam1{merchant id}, msg.lparam2{count}, 0, 0, msg.Description);
               end;
            RM_SENDBUYPRICE:
               begin
                  SendDefMessage (SM_SENDBUYPRICE, msg.lparam1{buy price}, 0, 0, 0, '');
               end;
            RM_USERSELLITEM_OK:
                  SendDefMessage (SM_USERSELLITEM_OK, msg.lparam1{chg gold}, 0, 0, 0, '');
            RM_USERSELLITEM_FAIL:
                  SendDefMessage (SM_USERSELLITEM_FAIL, msg.lparam1, 0, 0, 0, '');
            // Ä«¿îÆ®¾ÆÀÌÅÛ
            RM_USERSELLCOUNTITEM_OK:                                                // gadget : Ä«¿îÆ®¾ÆÀÌÅÛ
               SendDefMessage(SM_USERSELLCOUNTITEM_OK, msg.lparam1 {chg gold}, msg.lparam2, msg.lparam3, 0, '');
            RM_USERSELLCOUNTITEM_FAIL:                                              // gadget : Ä«¿îÆ®¾ÆÀÌÅÛ
               SendDefMessage(SM_USERSELLCOUNTITEM_FAIL, msg.lparam1, 0, 0, 0, '');
            // ¾ÆÀÌÅÛ Á¦Á¶
            RM_SENDUSERMAKEITEMLIST:
               begin
                  SendDefMessage (SM_SENDUSERMAKEITEMLIST, msg.lparam1{merchant id}, msg.lparam2{count}, 0, 0, msg.Description);
               end;

            RM_BUYITEM_SUCCESS:
                  SendDefMessage (SM_BUYITEM_SUCCESS, msg.lparam1{chg gold}, Loword(msg.lparam2), Hiword(msg.lparam2), 0, '');
            RM_BUYITEM_FAIL:
                  SendDefMessage (SM_BUYITEM_FAIL, msg.lparam1{error code}, 0, 0, 0, '');
            RM_MAKEDRUG_SUCCESS:
                  SendDefMessage (SM_MAKEDRUG_SUCCESS, msg.lparam1{chg gold}, 0, 0, 0, '');
            RM_MAKEDRUG_FAIL:
                  SendDefMessage (SM_MAKEDRUG_FAIL, msg.lparam1{chg gold}, 0, 0, 0, '');
            RM_SENDDETAILGOODSLIST:
                  SendDefMessage (SM_SENDDETAILGOODSLIST, msg.lparam1{merchant id}, msg.lparam2{count}, msg.lparam3{menuindex}, 0, msg.Description);

            RM_USERREPAIRITEM_OK:
                  SendDefMessage (SM_USERREPAIRITEM_OK, msg.lparam1{cost}, msg.lparam2{dura}, msg.lparam3{maxdura}, 0, '');
            RM_USERREPAIRITEM_FAIL:
                  SendDefMessage (SM_USERREPAIRITEM_FAIL, msg.lparam1{cost}, 0, 0, 0, '');
            RM_SENDREPAIRCOST:
                  SendDefMessage (SM_SENDREPAIRCOST, msg.lparam1{cost}, 0, 0, 0, '');
            //À§Å¹ÆÇ¸Å
            RM_MARKET_LIST:
                  SendDefMessage (SM_MARKET_LIST, msg.lparam1, msg.lparam2, msg.lparam3, 0, msg.Description);
            RM_MARKET_RESULT:
                  SendDefMessage (SM_MARKET_RESULT, msg.lparam1, msg.lparam2, msg.lparam3, 0,'');

            RM_SHOWBLUEHEALTH:
               begin      //»¤ÉíÏÔÀ¶
                  Def := MakeDefaultMsg(SM_SHOWBLUEHEALTH, Integer(Msg.Sender),
                         TCreature(Msg.Sender).WAbil.MP,
                         Byte(TCreature(Msg.Sender).BoMagicShield),
                         TCreature(Msg.Sender).WAbil.MaxMP);
                  SendSocket(@Def, '');
               end;
            RM_ITEMSHOW:
               begin
                  SendDefMessage (SM_ITEMSHOW, msg.lparam1{pointer}, msg.lparam2{x}, msg.lparam3{y}, msg.wParam{looks}, msg.Description);
               end;
            RM_ITEMHIDE:
               begin
                  SendDefMessage (SM_ITEMHIDE, msg.lparam1{pointer}, msg.lparam2{x}, msg.lparam3{y}, 0, '');
               end;
            RM_DELITEMS:
               begin
                  if msg.lparam1 <> 0 then begin
                     SendDelItems (TStringList (msg.lparam1));
                     TStringList (msg.lparam1).Free; //¿©±â¼­ FreeÇØ¾ß ÇÔ...
                  end;
               end;

            RM_MAA_SONNAME:
               begin
                  SendDefMessage (SM_MAA_SONMAE, msg.lparam1{merchant id}, msg.lparam2{count}, 0, 0, msg.Description);
               end;

            // ¹®ÆÄ Àå¿ø
            RM_GUILDAGITLIST:
               begin
                  SendDefMessage (SM_GUILDAGITLIST, msg.lparam1{page}, msg.lparam2{count}, 0, 0, msg.Description);
               end;
            RM_GABOARD_LIST: // Àå¿ø°Ô½ÃÆÇ
               begin
                  SendDefMessage (SM_GABOARD_LIST, msg.lparam1{page}, msg.lparam2{count}, msg.lparam3{allpage}, 0, msg.Description);
               end;
            RM_GABOARD_NOTICE_OK: // Àå¿ø°Ô½ÃÆÇ
               begin
                  SendDefMessage (SM_GABOARD_NOTICE_OK, msg.lparam1, msg.lparam2, msg.lparam3, 0, msg.Description);
               end;
            RM_GABOARD_NOTICE_FAIL: // Àå¿ø°Ô½ÃÆÇ
               begin
                  SendDefMessage (SM_GABOARD_NOTICE_FAIL, msg.lparam1, msg.lparam2, msg.lparam3, 0, msg.Description);
               end;
            //--------------------------------
            // Àå¿ø²Ù¹Ì±â
            RM_DECOITEM_LIST:
               begin
                  SendDefMessage (SM_DECOITEM_LIST, msg.lparam1{merchant id}, msg.lparam2{count}, 0, 0, msg.Description);
               end;
            RM_DECOITEM_LISTSHOW:
               begin
                  SendDefMessage (SM_DECOITEM_LISTSHOW, msg.lparam1{merchant id}, msg.lparam2{count}, 0, 0, msg.Description);
               end;
            //--------------------------------

            RM_CANCLOSE_OK:   SendDefMessage (SM_CANCLOSE_OK, msg.lparam1, 0, 0, 0, msg.Description);
            RM_CANCLOSE_FAIL: SendDefMessage (SM_CANCLOSE_FAIL, msg.lparam1, 0, 0, 0, msg.Description);

            RM_OPENDOOR_OK:
               begin
                  SendDefMessage (SM_OPENDOOR_OK, 0, msg.lparam1, msg.lparam2, 0, '');
               end;
            RM_CLOSEDOOR:
               begin
                  SendDefMessage (SM_CLOSEDOOR, 0, msg.lparam1, msg.lparam2, 0, '');
               end;

            RM_SENDUSEITEMS:
               begin
                  SendUseItems;
               end;

            RM_SENDMYMAGIC:
               begin
                  SendMyMagics;
               end;

            RM_WEIGHTCHANGED:
               begin
                  SendDefMessage (SM_WEIGHTCHANGED,
                                  WAbil.Weight,
                                  WAbil.WearWeight,
                                  WAbil.HandWeight,
                                  (((WAbil.Weight + WAbil.WearWeight + WAbil.HandWeight) xor $3A5F) xor $1F35) xor $aa21, '');
               end;
            RM_GOLDCHANGED:
               begin
                  SendDefMessage (SM_GOLDCHANGED, Gold, 0, 0, 0, '');
               end;
            RM_POTCASHCHANGED:
               begin
                  SendDefMessage (SM_POTCASHCHANGED, PotCash, 0, 0, 0, '');
               end;
            RM_GAMEPOINTCHANGED:
               begin
                  SendDefMessage (SM_GAMEPOINTCHANGED, GamePoint, 0, 0, 0, '');
               end;
            RM_FEATURECHANGED:   //³á°òÏûÏ¢ÐÞ¸Ä
               begin
                 SendDefMessage (SM_FEATURECHANGED, integer(msg.Sender), Loword(msg.lParam1), Hiword(msg.lParam1), msg.wParam, IntToStr(msg.lParam2));
               end;
            RM_CHARSTATUSCHANGED:
               begin
                  SendDefMessage (SM_CHARSTATUSCHANGED, integer(msg.sender), Loword(msg.lParam1), Hiword(msg.lparam1), msg.wparam, '');
               end;

            RM_CLEAROBJECTS:
               begin
                  SendDefMessage (SM_CLEAROBJECTS, 0, 0, 0, 0, '');
               end;

            RM_MAGIC_LVEXP:
               begin
                  SendDefMessage (SM_MAGIC_LVEXP, msg.lparam1, msg.lparam2{lv}, Loword(msg.lparam3), Hiword(msg.lparam3), '');
               end;
            RM_SOUND:
               begin
                  SendDefMessage (SM_SOUND, 0,msg.lparam1, 0,0, '');
               end;
            RM_NOVICEHEIP:
               begin
                  SendDefMessage (SM_NOVICEHEIP, 0,msg.lparam1, 0,0, '');
               end;
            RM_DURACHANGE:
               begin
                  SendDefMessage (SM_DURACHANGE, msg.lparam1, msg.wparam, Loword(msg.lparam2), Hiword(msg.lparam2), '');
               end;
            //RM_ITEMDURACHANGE:
            //   begin
            //      SendDefMessage (SM_ITEMDURACHANGE, msg.lparam1, msg.lparam2{dura}, msg.lparam3{duramax}, 0, '');
            //   end;
            RM_CHANGELIGHT:
               begin
                  SendDefMessage (SM_CHANGELIGHT, integer(msg.Sender), TCreature(msg.sender).Light, 0, 0, '');
               end;
            RM_LAMPCHANGEDURA:
               begin
                  SendDefMessage (SM_LAMPCHANGEDURA, msg.lparam1, 0, 0, 0, '');
               end;

            // Ä«¿îÆ® ¾ÆÀÌÅÛ
            RM_COUNTERITEMCHANGE:
               begin
                  ServerSendItemCountChanged (msg.lParam1, msg.lParam2, msg.lParam3, msg.Description);
               end;

            RM_GROUPCANCEL:
               begin
                  SendDefMessage (SM_GROUPCANCEL, 0, 0, 0, 0, '');
               end;

            RM_CHANGEGUILDNAME:
               begin
                  SendChangeGuildName;
               end;

            RM_BUILDGUILD_OK: SendDefMessage (SM_BUILDGUILD_OK, 0, 0, 0, 0, '');

            RM_BUILDGUILD_FAIL: SendDefMessage (SM_BUILDGUILD_FAIL, msg.lparam1, 0, 0, 0, '');

            RM_DONATE_OK:  SendDefMessage (SM_DONATE_OK, msg.lparam1, 0, 0, 0, '');

            RM_DONATE_FAIL:  SendDefMessage (SM_DONATE_FAIL, msg.lparam1, 0, 0, 0, '');

            RM_MENU_OK: SendDefMessage (SM_MENU_OK, msg.lparam1, 0, 0, 0, msg.Description);
            RM_ALIVEREQ: SendDefMessage (SM_ALIVEREQ, Msg.lparam1, 0, 0, 0, msg.Description);
            RM_NEXTTIME_PASSWORD: SendDefMessage (SM_NEXTTIME_PASSWORD, 0, 0, 0, 0, '');

            RM_DOSTARTUPQUEST: DoStartupQuestNow;

            // ¹¥»÷Ä£Ê½
            RM_ATTACKMODE: SendDefMessage (SM_ATTACKMODE, 0 , msg.lParam1, 0, 0, '');


            RM_PLAYDICE:
               begin
                  wl.lParam1 := msg.lparam1;
                  wl.lParam2 := msg.lparam2;
                  wl.lTag1 := msg.lparam3;
                  Def := MakeDefaultMsg (SM_PLAYDICE, integer(msg.sender), msg.wparam, 0, 0);

                  SendSocket (@Def, EncodeBuffer (@wl, sizeof(TMessageBodyWL))
                                    + EncodeString (msg.Description));

               end;
            RM_PLAYROCK:
               begin
                  wl.lParam1 := msg.lparam1;
                  wl.lParam2 := msg.lparam2;
                  wl.lTag1 := msg.lparam3;
                  Def := MakeDefaultMsg (SM_PLAYROCK, integer(msg.sender), msg.wparam, 0, 0);

                  SendSocket (@Def, EncodeBuffer (@wl, sizeof(TMessageBodyWL))
                                    + EncodeString (msg.Description));

               end;

            else
               inherited RunMsg (msg);
         end;
      end;
    if m_boNotOnlineClear then
    begin
      m_boNotOnlineClear := False;
      try
        i := 0;
        while TRUE do
        begin
          if i >= VisibleActors.Count then
            break;
          Dispose(PTVisibleActor(VisibleActors[i]));
          VisibleActors.Delete(i);
        end;
      except
        MainOutMessage('[Exception] VisbleActors Dispose(..)');
      end;
      try
        VisibleActors.Clear;
      except
        MainOutMessage('[Exception] VisbleActors.Clear');
      end;
    end;
        if m_boNotOnlineAddExp2 then     //ÀëÏß¹Ò»úÐ¡ÍÈ
    begin
      m_boNotOnlineAddExp2 :=False;
      SendDefMessage (SM_LIXIANGUAJI, 0, 0, 0, 0, '');
     // UserRequestClose := TRUE;

     Exit;
    end;
      //-----------------------------------------
      // ¼­¹ö ÀÌµ¿ ¶Ç´Â Á¢¼Ó Á¾·á(·Î±×¾Æ¿ô)
      // BoChangeServer·Î ±¸ºÐ(sonmg)
      //-----------------------------------------
      if EmergencyClose or UserRequestClose or UserSocketClosed then begin
         if not BoChangeServer then begin //Á¢¼ÓÁ¾·á µÇ¸é ¶³¾îÁö´ÂÀÌº¥Æ® ¾ÆÀÌÅÛÀ» ¶³±º´Ù.
            //Á¢¼ÓÁ¾·á½Ã¿¡ ¼ÒÈ¯¸ó½ºÅÍ¸¦ ¸ðµÎ Á×ÀÎ´Ù(sonmg 2004/12/01)
            KillAllSlaves;  //¼ÒÈ¯ ¸ó½ºÅÍ¸¦ ¸ðµÎ ¾ø¾Ú.

            //Á¢¼ÓÁ¾·á½Ã¿¡ ¿¬ÀÎ¿¡°Ô ¾Ë·ÁÁÜ.
            lovername := fLover.GetLoverName;
            hum := UserEngine.GetUserHuman(lovername);
            if hum <> nil then begin
               hum.SendMsg( hum, RM_LM_LOGOUT, 0, 0, 0, 0, '' );
            end else begin
               if UserEngine.FindOtherServerUser (lovername, svidx) then begin
                  UserEngine.SendInterMsg (ISM_LM_LOGOUT, svidx, UserName + '/' + lovername);
               end;
            end;

            DropEventItems;
         end;

          if not InSafeZone or not m_boNotOnlineAddExp or (SoftClosed and UserSocketClosed) then
           MakeGhost(6); //ÀëÏß¹Ò»ú;
         if BoChangeServer then begin
            MapName := ChangeMapName;
            CX := ChangeCX;
            CY := ChangeCY;

            //Å×½ºÆ®
            //MakeDefaultMsg (SM_SYSMESSAGE, integer(self), MakeWord(255, 56), 0, 1);
            //SendSocket (@Def, EncodeString ('change server 1'));
         end;

         if UserRequestClose then SendDefMessage (SM_OUTOFCONNECTION, 0, 0, 0, 0, '');

         if not SoftClosed and UserSocketClosed then begin //ÀëÏß¹Ò»ú
        if (m_boNotOnlineAddExp) and (not m_boKickAutoAddExpUser) then
        begin
          m_boKickAutoAddExpUser := True;
          FrmIDSoc.SendUserClose(UserId, Certification);
        end
        else if (not m_boNotOnlineAddExp) and (not m_boKickAutoAddExpUser) then
        begin
          m_boKickAutoAddExpUser := True;
          FrmIDSoc.SendUserClose(UserId, Certification);

        end;
         end;

         exit;
      end;

   except
      MainOutMessage ('[Exception] Operate 2 #' + UserName +
                                           ' Identback:' + IntToStr(IdentBackup) +
                                           ' Ident:' + IntToStr(msg.Ident) +
                                           ' Sender:' + IntToStr(integer(msg.Sender)) +
                                           ' wP:' + IntToStr(msg.wParam) +
                                           ' lP1:' + IntToStr(msg.lParam1) +
                                           ' lP2:' + IntToStr(msg.lParam2) +
                                           ' lP3:' + IntToStr(msg.lParam3));
   end;

   inherited Run;
end;


{-------------------- °øÁö»çÇ× ¾Ë¸®±â ---------------------}

//°øÁö»çÇ× ¸®½ºÆ®´Â 5ºÐ¿¡ ÇÑ¹ø¾¿ ¸®ÇÁ·¡½¬ ÇÑ´Ù.
//

procedure TUserHuman.SendLoginNotice;
var
   i: integer;
   strlist: TStringList;
   data: string;
begin
   strlist := TStringList.Create;
   NoticeMan.GetNoticList ('Notice', strlist);
   data := '';
   for i:=0 to strlist.Count-1 do begin
      data := data + strlist[i]+' '#27;
   end;
   strlist.Free;
   SendDefMessage (SM_SENDNOTICE, 0, 0, 0, 0, data);
end;

procedure TUserHuman.RunNotice;
var
   msg: TMessageInfo;
begin
   if EmergencyClose or UserRequestClose or UserSocketClosed then begin
      if UserRequestClose then SendDefMessage (SM_OUTOFCONNECTION, 0, 0, 0, 0, '');
      MakeGhost(7);
      //BoGhost := TRUE;
      //GhostTime := GetTickCount;
      exit;
   end;
   try
      //·Î±×ÀÎ Àü¿¡ °øÁö»çÇ×À» º¸³½´Ù.
      if not BoSendNotice then begin
         SendLoginNotice;
         BoSendNotice := TRUE;
      end else begin
         while GetMsg (msg) do begin
            case msg.Ident of
               CM_LOGINNOTICEOK: ServerGetNoticeOk;
            end;
         end;
      end;
   except
      MainOutMessage ('[Exception] TUserHuman.RunNotice');
   end;
end;

procedure TUserHuman.GetGetNotices;
begin
   if BoGetGetNeedNotice then
      GetGetNotices;
end;

procedure TUserHuman.ServerGetNoticeOk;
begin
   LoginSign := TRUE;
end;


function  TUserHuman.GetStartX: integer;
begin
   Result := HomeX - 2 + Random(3);
end;

function  TUserHuman.GetStartY: integer;
begin
   Result := HomeY - 2 + Random(3);
end;

procedure TUserHuman.CheckHomePos;  //½ÃÀÛÇÏ´Â ¸¶À»À» ¹Ù²ÜÁö °áÁ¤
var                                 //´úÈë»Ø³Çµã ÔÚ°²È«ÇøÖÐÐÄ50²½ÄÚ£¬Ôò»Ø³ÇµãµÈÓÚ°²È«Çø
   i: integer;
   flag: Boolean;
begin
   flag := FALSE;
   for i:=0 to StartPoints.Count-1 do begin
      if PEnvir.MapName = GetStartPointMapName(i){StartPoints[i]} then begin
         if (Abs(CX - Loword(integer(StartPoints.Objects[i]))) < 50) and
            (Abs(CY - Hiword(integer(StartPoints.Objects[i]))) < 50)
         then begin
            HomeMap := GetStartPointMapName(i);//StartPoints[i]; //°²È«ÇøµÄ±àºÅ
            HomeX := Loword(integer(StartPoints.Objects[i]));
            HomeY := Hiword(integer(StartPoints.Objects[i]));
            flag := TRUE;
         end;
      end;
   end;
   if PKLevel >= 2 then begin  //»¡°»ÀÌ´Â »¡°»ÀÌ ¸¶À»·Î
      HomeMap := BADMANHOMEMAP;
      HomeX := BADMANSTARTX;
      HomeY := BADMANSTARTY;
   end;
end;


{-------------------- Å¬¶óÀÌ¾ðÆ®ÀÇ ¸Þ¼¼Áö¸¦ Ã³¸®ÇÔ ---------------------}

procedure TUserHuman.GetQueryUserName (target: TCreature; x, y: integer);
var
   uname: string;
   tagcolor: integer;
   FameGrade: integer;
begin
   if CretInNearXY (target, x, y) then begin
      tagcolor := GetThisCharColor (target);
      Def := MakeDefaultMsg (SM_USERNAME, Integer(target), tagcolor, 0, 0);
      uname := target.GetUserName + '/' + TUserHuman(target).GetFameName(FameGrade);   //¸í¼ºÈ£Äª ºÙ¿©¼­ º¸³¿
      SendSocket (@Def, EncodeString (uname));
   end else
      SendDefMessage (SM_GHOST, integer(target), x, y, 0, '');
end;

//Å¬¶óÀÌ¾ðÆ®¿¡ º¸³Ê½º Æ÷ÀÎÆ®¸¦ Á¶Á¤ÇÏ¶ó°í ½ÅÈ£¸¦ º¸³½´Ù.
procedure TUserHuman.ServerSendAdjustBonus;
var
   str: string;
   na: TNakedAbility;
begin
   Def := MakeDefaultMsg (SM_ADJUST_BONUS, Integer(BonusPoint), 0, 0, 0);
   str := '';
   na := BonusAbil;
   case Job of
      0: str := EncodeBuffer(@WarriorBonus, sizeof(TNakedAbility)) + '/' +  EncodeBuffer(@CurBonusAbil, sizeof(TNakedAbility)) + '/' + EncodeBuffer(@na, sizeof(TNakedAbility));
      1: str := EncodeBuffer(@WizzardBonus, sizeof(TNakedAbility)) + '/' + EncodeBuffer(@CurBonusAbil, sizeof(TNakedAbility)) + '/' + EncodeBuffer(@na, sizeof(TNakedAbility));
      2: str := EncodeBuffer(@PriestBonus, sizeof(TNakedAbility))  + '/' + EncodeBuffer(@CurBonusAbil, sizeof(TNakedAbility)) + '/' + EncodeBuffer(@na, sizeof(TNakedAbility));
   end;
   SendSocket (@Def, str);
end;

procedure TUserHuman.ServerGetOpenDoor (dx, dy: integer);
var
   pd: PTDoorInfo;
begin
   if PEnvir = UserCastle.CastlePEnvir then begin
      pd := PEnvir.FindDoor (dx, dy);
      if UserCastle.CoreCastlePDoorCore = pd.pCore then begin  //»çºÏ¼ºÀÇ ³»¼º¹®
         if RaceServer = RC_USERHUMAN then
            if not UserCastle.CanEnteranceCoreCastle (CX, CY, TUserHuman(self)) then  //
               exit;  //µé¾î°¥ ¼ö ¾øÀ½.
      end;
   end;

   UserEngine.OpenDoor (PEnvir, dx, dy);
end;

procedure TUserHuman.ServerGetTakeOnItem (where: byte; svindex: integer; itmname: string);
var
   i, bagindex, ecount: integer;
   ps, ps2: PTStdItem;
   std: TStdItem;
   targpu, pu: PTUserItem;
label
   finish;
begin
   ps := nil;
   targpu := nil;
   bagindex := -1;
     if RaceServer = RC_USERHUMAN then begin
    if TUserHuman(Self).m_StallMgr.OnSale then begin

      Exit;
    end;
  end;

   for i:=0 to Itemlist.Count-1 do begin
      if PTUserItem(ItemList[i]).MakeIndex = svindex then begin
         ps := UserEngine.GetStdItem (PTUserItem(ItemList[i]).Index);
         if ps <> nil then
            if CompareText (ps.Name, itmname) = 0 then begin
               bagindex := i;
               targpu := PTUserItem(ItemList[i]);

               break;
            end;
      end;
   end;

   ecount := 0;
   if (ps <> nil) and (targpu <> nil) then begin
      if IsTakeOnAvailable (where, ps) then begin //Âø¿ëÇÒ ¼ö ÀÖ´Â ¹Ù¸¥ ¾ÆÀÌÅÛÀÎ°¡?
         std := ps^;
         ItemMan.GetUpgradeStdItem (targpu^, std); //¹«±âÀÇ ¾÷±×·¹ÀÌµåµÈ ´É·ÂÄ¡¸¦ ¾ò¾î¿Â´Ù.
         if CanTakeOn (where, @std) then begin //³»°¡ ´É·ÂÀÌ µÇ´Â°¡?
            pu := nil;
            if UseItems[where].Index > 0 then begin //ÀÌ¹Ì Âø¿ëÇÏ°í ÀÖÀ½.
               //¹þÁö ¸øÇÏ´Â ¾ÆÀÌÅÛÀÌ ¾Æ´Ñ°æ¿ì (¹ÌÁö¼ö·Î ¹þÀ» ¼ö ÀÖÀ½)
               ps2 := UserEngine.GetStdItem (UseItems[where].Index);
               // 2003/03/15 ¾ÆÀÌÅÛ ÀÎº¥Åä¸® È®Àå
               if ps2.StdMode in [15,19,20,21,22,23,24,26,52,53,54] then begin
                  if not BoNextTimeFreeCurseItem and (UseItems[where].Desc[7] <> 0) then begin
                     //¹þÀ» ¼ö ¾ø´Â ¾ÆÀÌÅÛ
                     SysMsg ('ÎÞ·¨È¡ÏÂ', 0);
                     ecount := -4;
                     goto finish;
                  end;
               end;
               if not BoNextTimeFreeCurseItem and (ps2.ItemDesc and IDC_UNABLETAKEOFF <> 0) then begin
                  //¹þÀ» ¼ö ¾ø´Â ¾ÆÀÌÅÛ
                  SysMsg ('ÎÞ·¨È¡ÏÂ', 0);
                  ecount := -4;
                  goto finish;
               end;
               //Àý´ë·Î ¹þÁö ¸øÇÏ´Â ¾ÆÀÌÅÛ
               if ps2.ItemDesc and IDC_NEVERTAKEOFF <> 0 then begin
                  SysMsg ('ÎÞ·¨È¡ÏÂ', 0);
                  ecount := -4;
                  goto finish;
               end;
               new (pu);
               pu^ := UseItems[where];
            end;

            //¹ÌÁöÀÇ ¼Ó¼ºÀ» °¡Áö°í ÀÖ´Â ¾ÆÀÌÅÛÀÎ °æ¿ì ÇÑ¹ø Âø¿ëÇÏ¸é Ç®¸²
            // 2003/03/15 ¾ÆÀÌÅÛ ÀÎº¥Åä¸® È®Àå
            if ps.StdMode in [15,19,20,21,22,23,24,26,52,53,54] then begin
               if targpu.Desc[8] <> 0 then
                  targpu.Desc[8] := 0; //¹ÌÁö¼Ó¼º Ç®¸²;
            end;

            UseItems[where] := targpu^;  //
            DelItemIndex (bagindex);  //DelItem (svindex, itmname);
            if pu <> nil then begin
               AddItem (pu); //°¡¹æ¿¡ Ãß°¡µÇ´Â ¾ÆÀÌÅÛ º¸³½´Ù.(ÀÖÀ¸¸é)
               SendAddItem (pu^);
            end;

            RecalcAbilitys;     //´É·ÂÄ¡ ÀçÁ¶Á¤ ÇÑ´Ù.
            SendMsg (self, RM_ABILITY, 0, 0, 0, 0, '');
            SendMsg (self, RM_SUBABILITY, 0, 0, 0, 0, '');
            SendDefMessage (SM_TAKEON_OK, Feature, 0, 0, 0, ''); //Âø¿ë ¼º°ø º¸³½´Ù. º¯°æµÈ ¸ð½ÀÀ» º¸³½´Ù.
            FeatureChanged;

            // ³¯°³¿ÊÀÏ°æ¿ì¿¡´Â ·¹º§¿¡ µû¸¥ ´É·ÂÄ¡¸¦ ¹Ù²ãÁØ´Ù.(sonmg ¼öÁ¤ 2004/04/02)
            if (ps.StdMode = DRESS_STDMODE_MAN) or (ps.StdMode = DRESS_STDMODE_WOMAN) then begin
               if ps.Shape = DRESS_SHAPE_WING then begin
                  SendUpdateItemWithLevel (UseItems[where], Abil.Level);
               end else if ps.Shape = DRAGON_DRESS_SHAPE then begin
                  SendUpdateItemByJob (UseItems[where], Abil.Level);
               end else if ps.Shape = DRESS_SHAPE_PBKING then begin
                  SendUpdateItemByJob (UseItems[where], Abil.Level);
               end;
            // ¹ÝÂ¦ÀÌº¥Æ®(2004/08/09)
            end else if ((ps.StdMode = WEAPON_STDMODE1) or (ps.StdMode = WEAPON_STDMODE2)) and
                  ((UseItems[where].Index = 692) or (UseItems[where].Index = 693) or (UseItems[where].Index = 694) or
                  // ¹ÝÂ¦ÀÌº¥Æ®2Â÷(2004/08/13)
                  (UseItems[where].Index = 697) or (UseItems[where].Index = 698) or (UseItems[where].Index = 699)) then begin
               SendUpdateItemWithLevel (UseItems[where], Abil.Level);
            end else begin
               SendUpdateItem(UseItems[where]);
            end;

            ecount := 1;
         end else
            ecount := -1;
      end else
         ecount := -2;
   end;
   finish:
   if ecount <= 0 then
      SendDefMessage (SM_TAKEON_FAIL, ecount, 0, 0, 0, '');
end;

procedure TUserHuman.ServerGetTakeOffItem (where: byte; svindex: integer; itmname: string);
var
   ecount: integer;
   ps: PTStdItem;
   pu: PTUserItem;
label
   finish;
begin
   ecount := 0;
     if RaceServer = RC_USERHUMAN then begin
    if TUserHuman(Self).m_StallMgr.OnSale then begin

      Exit;
    end;
  end;
   // 2003/03/15 ¾ÆÀÌÅÛ ÀÎº¥Åä¸® È®Àå
   if (not BoDealing) and (where in [0..U_TRANS]) then begin  //±³È¯Áß¿¡´Â ¾ÆÀÌÅÛÀ» ¸ø ¹þ´Â´Ù. 8->12
      if UseItems[where].Index > 0 then begin //Âø¿ëÇÏ°í ÀÖ¾î¾ß ¹þÀ» ¼ö ÀÖÀ½.
         if UseItems[where].MakeIndex = svindex then begin
            ps := UserEngine.GetStdItem (UseItems[where].Index);

            //¹þÁö ¸øÇÏ´Â ¾ÆÀÌÅÛÀÌ ¾Æ´Ñ°æ¿ì
            // 2003/03/15 ¾ÆÀÌÅÛ ÀÎº¥Åä¸® È®Àå
            if ps.StdMode in [15,19,20,21,22,23,24,26,52,53,54] then begin
               if not BoNextTimeFreeCurseItem and (UseItems[where].Desc[7] <> 0) then begin
                  //¹þÀ» ¼ö ¾ø´Â ¾ÆÀÌÅÛ
                  SysMsg ('ÎÞ·¨È¡ÏÂ', 0);
                  ecount := -4;
                  goto finish;
               end;
            end;
            if not BoNextTimeFreeCurseItem and (ps.ItemDesc and IDC_UNABLETAKEOFF <> 0) then begin
               //¹þÀ» ¼ö ¾ø´Â ¾ÆÀÌÅÛ
               SysMsg ('ÎÞ·¨È¡ÏÂ', 0);
               ecount := -4;
               goto finish;
            end;
            //Àý´ë·Î ¹þÁö ¸øÇÏ´Â ¾ÆÀÌÅÛ
            if ps.ItemDesc and IDC_NEVERTAKEOFF <> 0 then begin
               SysMsg ('ÎÞ·¨È¡ÏÂ', 0);
               ecount := -4;
               goto finish;
            end;

            if CompareText (ps.Name, itmname) = 0 then begin
               new (pu);
               pu^ := UseItems[where];
               if AddItem (pu) then begin //°¡¹æ¿¡ Ãß°¡µÇ´Â ¾ÆÀÌÅÛ º¸³½´Ù.
                  UseItems[where].Index := 0; //Áö¿ò..
                  SendDefMessage (SM_TAKEOFF_OK, Feature, 0, 0, 0, '');
                  SendAddItem (pu^);
                  RecalcAbilitys;     //´É·ÂÄ¡ ÀçÁ¶Á¤ ÇÑ´Ù.
                  SendMsg (self, RM_ABILITY, 0, 0, 0, 0, '');
                  SendMsg (self, RM_SUBABILITY, 0, 0, 0, 0, '');
                  FeatureChanged;

                  //°íÅë¾ÆÀÌÅÛÀº ¹þÀ¸¸é ÀÓ½Ã ´©ÀûÄ¡°¡ ÃÊ±âÈ­ µÈ´Ù.(sonmg 2006/01/19)
                  if ps.Shape = PAIN_SERIES_SHAPE then begin
                     ItemExpPoint := 0;
                  end;
               end else begin
                  Dispose (pu);
                  ecount := -3;
               end;
            end;
         end;
      end else
         ecount := -2;
   end else
      ecount := -1;

   finish:
   if ecount <= 0 then
      SendDefMessage (SM_TAKEOFF_FAIL, ecount, 0, 0, 0, '');
end;

//------------------------------
function TUserHuman.BindPotionUnit( iShape, iCount: integer ): Boolean;
var
   strItemName: string;
   hum: TUserHuman;
   pui: PTUserItem;
begin
   Result := FALSE;

   // ºÎÀûÀº ¹­À» ¼ö ¾ø´Ù.(sonmg)
   if iShape = SHAPE_AMULET_BUNCH then exit; // ºÎÀû¹­À½

   try
      strItemName := UserEngine.GetStdItemNameByShape( 31, iShape ); // ¹­À½¾ÆÀÌÅÛ StdMode, Shape

      new (pui);
      if UserEngine.CopyToUserItemFromName (strItemName, pui^) then begin
         ItemList.Add (pui);
         if RaceServer = RC_USERHUMAN then begin
            hum := TUserHuman (self);
            hum.SendAddItem (pui^);
         end;
         Result := TRUE;
      end else
         Dispose (pui);
   except
   end;
end;

procedure TUserHuman.ServerGetEatItem (svindex: integer; itmname: string);
   function UnbindPotionUnit (itmname: string; count: integer): Boolean;
   var
      i: integer;
      hum: TUserHuman;
      pui: PTUserItem;
   begin
      Result := FALSE;
      for i:=0 to count-1 do begin
         new (pui);
         if UserEngine.CopyToUserItemFromName (itmname, pui^) then begin
            ItemList.Add (pui);
            if RaceServer = RC_USERHUMAN then begin
               hum := TUserHuman (self);
               hum.SendAddItem (pui^);
            end;
         end else
            Dispose (pui);
      end;
      Result := TRUE;
   end;

  function InNotAllowUseItems(ItemIdx: Integer): Boolean;
  var
    i                 : Integer;
    sString           : string;
    sList             : TStringList;
  begin
    Result := False;
    if (PEnvir <> nil) and (PEnvir.NoUseItem) then begin
      if PEnvir.NoUseItemList <> nil then begin
        for i := 0 to PEnvir.NoUseItemList.Count - 1 do begin
          if Integer(PEnvir.NoUseItemList[i]) = ItemIdx then begin
            Result := True;
            Break;
          end;
        end;
      end;
    end;
  end;
var
   i, j: integer;
   flag: Boolean;
   ps: PTStdItem;
   ui: TUserItem;
   WantLog : Boolean;
   pu: PTUserItem;
   iShape: integer;
   dellist: TStringList;
   boSendUpDate: Boolean;
   ItemCount: integer;
resourcestring
  sNotAllowUseItemsMsg = '±¾µØÍ¼²»ÔÊÐíÊ¹ÓÃÎïÆ·%s';
begin
   dellist := nil;
   flag := FALSE;
   WantLog := true;
   boSendUpDate := False;
   if not Death then begin
      for i:=0 to Itemlist.Count-1 do begin
         if PTUserItem(ItemList[i]).MakeIndex = svindex then begin
            //if UserEngine.GetStdItemName (PTUserItem(ItemList[i]).Index) = itmname then begin
               ps := UserEngine.GetStdItem (PTUserItem(Itemlist[i]).Index);
               ui := PTUserItem(Itemlist[i])^;
               pu := PTUserItem(Itemlist[i]);


            if InNotAllowUseItems(pu.Index) then begin
              if ps.Name <> '' then SysMsg(Format(sNotAllowUseItemsMsg, [ps.Name]), 0);
              SendDefMessage(SM_EAT_FAIL, svindex, 0, 0, 0, '');
              Exit;
            end;


               case ps.StdMode of
                  0,1,3,70,88: //½Ã¾à, °í±â·ù, À½½Ä, ½ºÅ©·Ñ
                     if EatItem (ps^, PTUserItem(ItemList[i])) then begin
                        Dispose (PTUserItem(ItemList[i]));
                        ItemList.Delete (i);
                        flag := TRUE;

                        WantLog := false;
                        if ( ps.StdMode = 3 ) and (ps.Shape <> 2 ) then
                        begin
                            WantLog := true;
                        end;
                     end;
                  2: begin
                       if ps.AniCount= 21 then begin //×£¸£¹Þ ÀàÐÍµÄÎïÆ·
                          if pu.Dura > 0 then begin
                            if (ItemList.Count  - 1) <= MAXBAGITEM then begin
                              if pu.Dura >= 1000 then begin //ÐÞ¸ÄÎª1000
                                Dec(pu.Dura, 1000);
                                Dec(pu.DuraMax, 1000);//¼õÉÙ´æÎïÆ·ÊýÁ¿
                                if pu.DuraMax <= 0 then begin //²»ÄÜ´æÈ¡ÎïÆ·,ÔòÉ¾³ýÎïÆ·
                                  if pu <> nil then begin
                                    ItemList.Delete(I);
                                    DisPoseAndNil(pu);
                                    flag := True;
                                  end;
                                end;
                              end else begin
                                pu.Dura := 0;
                                pu.DuraMax:= 0;//¼õÉÙ´æÎïÆ·ÊýÁ¿
                                if pu.DuraMax <= 0 then begin //ÄÜ´æÈ¡ÎïÆ·,ÔòÉ¾³ýÎïÆ·
                                  if pu <> nil then begin
                                    ItemList.Delete(I);
                                    DisPoseAndNil(pu);
                                    flag := True;
                                  end;
                                end;
                              end;
                               //ÐèÒªÐÞ¸ÄUnbindList.txt,¼ÓÈë 3 ×£¸£ÓÍ  3---Îª ×£¸£¹ÞµÄÍâ¹ÛÖµ
                              UnbindPotionUnit(GetUnbindItemName(Ps.Shape), 1); //¸øÒ»¸ö×£¸£ÓÍ
                            end;
                          end else begin//ÈªË®¹Þ
                            if pu.Dura >= 1000 then begin
                              if (ItemList.Count  - 1) <= MAXBAGITEM then begin
                                if pu.Dura >= 1000 then begin
                                  Dec(pu.Dura, 1000);
                                end else begin
                                  pu.Dura := 0;
                                end;
                               //ÐèÒªÐÞ¸ÄUnbindList.txt,¼ÓÈë 1 ÈªË®   1---Îª ÈªË®µÄÍâ¹ÛÖµ
                                UnbindPotionUnit(GetUnbindItemName(Ps.Shape), 1); //¸øÒ»¸öÈªË®
                              end;
                            end;
                          end;
                         boSendUpDate := True;
                       end else

                       case ps.Shape of
                        0: begin     //¼Æ´ÎÎïÆ· 20080129
                          if (ps.SpecialPwr <> 0) and (ps.ItemDesc <> 0) then begin //À¦ÉþÀàÎïÆ·
                            if pu <> nil then begin
                              if pu.Dura > 0 then begin
                                if pu.Dura >= 1000 then begin
                                  Dec(pu.Dura, 1000);
                                  flag := True;
                                  if pu.Dura > 0 then begin
                                     WantLog := False; //True;
                                     boSendUpDate := True;
                                     flag := False;
                                  end else begin
                                    if pu <> nil then begin
                                      pu.Index:= 0;
                                      ItemList.Delete(I);
                                      DisPoseAndNil(pu);
                                    end;
                                  end;
                                end else begin
                                  pu.Dura := 0;
                                  if pu <> nil then begin
                                    pu.Index:= 0;
                                    ItemList.Delete(I);
                                    DisPoseAndNil(pu);
                                  end;
                                end;
                                UseStdmodeFunItem(Ps);
                              end else pu.Index:= 0;
                            end;
                          end else begin//ÆäËü¼Æ´ÎÎïÆ·
                            if pu <> nil then begin
                              if pu.Dura > 0 then begin
                                if pu.Dura >= 1000 then begin
                                  Dec(pu.Dura, 1000);
                                  flag := True;
                                  if pu.Dura > 0 then begin
                                     WantLog := False; //True;
                                     boSendUpDate := True;
                                     flag := False;
                                  end else begin
                                    if pu <> nil then begin
                                      pu.Index:= 0;
                                      ItemList.Delete(I);
                                      DisPoseAndNil(pu);
                                    end;
                                  end;
                                end else begin
                                  pu.Dura := 0;
                                  if pu <> nil then begin
                                    pu.Index:= 0;
                                    ItemList.Delete(I);
                                    DisPoseAndNil(pu);
                                  end;
                                end;
                                UseStdmodeFunItem(Ps);
                              end else pu.Index:= 0;
                            end;
                          end;
                        end;//0
                        2: begin //Ëæ»ú´«ËÍÊ¯
                            if not PEnvir.NORANDOMMOVE then begin//µØÍ¼Ã»ÓÐ½ûÖ¹Ëæ»ú´«ËÍÊ±²ÅÄÜÊ¹ÓÃ
                              if pu.Dura > 0 then begin
                                if pu.Dura >= 1000 then begin
                                  Dec(pu.Dura, 1000);
                                end else begin
                                  pu.Dura := 0;
                                  pu.Index:= 0;
                                end;
                                flag := True;
                                RandomMove();//Ëæ»ú´«ËÍ
                              end;
                              if pu.Dura > 0 then begin
                                WantLog := False; //True;
                                boSendUpDate := True;
                                flag := False;
                              end else begin
                                if pu <> nil then begin
                                  ItemList.Delete(I);
                                  DisPoseAndNil(pu);
                                end;
                              end;
                            end;
                          end;
                        9: begin //ÐÞ¸´ÉñË®
                            ItemCount:= RepairAllItemDura;
                            if (pu.Dura > 0) and (ItemCount > 0) then begin
                              if pu.Dura >= (ItemCount div 10 ) then begin
                                Dec(pu.Dura, (ItemCount div 10 ));
                                RepairAllItem(ItemCount div 1000, False);//È«²¿ÐÞ¸´
                                if pu.Dura < 100 then pu.Dura:= 0;
                              end else begin
                                pu.Dura:= 0;
                                RepairAllItem(ItemCount div 1000, True);
                              end;
                            end;
                            flag := False;
                            if pu.Dura > 0 then begin
                              boSendUpDate := True;
                            end else begin
                              if pu <> nil then begin
                                ItemList.Delete(I);
                                DisPoseAndNil(pu);
                              end;
                              flag := True;
                            end;
                          end;
                       end;
                     end;
                  4: //Ã¥
                     if ReadBook (ps^) then begin
                        Dispose (PTUserItem(ItemList[i]));
                        ItemList.Delete (i);
                        flag := TRUE;
                        //¾î°Ë¼ú
                        if PLongHitSkill <> nil then
                           if not BoAllowLongHit then begin
                              SetAllowLongHit (TRUE);
                              SendSocket (nil, '+LNG');  //¿ø°Å¸® °ø°ÝÀ» ÇÏ°Ô ÇÑ´Ù.
                           end;
                        //¹Ý¿ù°Ë¹ý
                        if PWideHitSkill <> nil then
                           if not BoAllowWideHit then begin
                              SetAllowWideHit (TRUE);
                              SendSocket (nil, '+WID');
                           end;
                        // 2003/03/15 ½Å±Ô¹«°ø
                        // ±¤Ç³Âü
                        if PCrossHitSkill <> nil then
                           if not BoAllowCrossHit then begin
                              SetAllowCrossHit (TRUE);
                              SendSocket (nil, '+CRS');
                           end;
                     end;
                  8: //¸Ô´Â(»ç¿ë) ¾ÆÀÌÅÛ, º§Æ®Ã¢¿¡ Âø¿ëÇÒ ¼ö ¾øÀ½ (ÃÊ´ëÀå) (2004/05/06)
                     if ps.Shape = SHAPE_OF_INVITATION then begin
                        if EatItem (ps^, PTUserItem(ItemList[i])) then begin
                           Dispose (PTUserItem(ItemList[i]));
                           ItemList.Delete (i);
                           flag := TRUE;

                           WantLog := false;
                           if ( ps.StdMode = 3 ) and (ps.Shape <> 2 ) then
                           begin
                               WantLog := true;
                           end;

                        end;
                     end else if EatItem (ps^, PTUserItem(ItemList[i])) then begin
                        Dispose (PTUserItem(ItemList[i]));
                        ItemList.Delete (i);
                        flag := TRUE;
                     end;
                  31:
//                     begin
//                        if ItemList.Count + 6 - 1 <= MAXBAGITEM then begin
//                           Dispose (PTUserItem(ItemList[i]));
//                           ItemList.Delete (i);
//                           UnbindPotionUnit (GetUnbindItemName (ps.Shape), 6);
//                           flag := TRUE;
//
//                           //¹­À½ Çª´Â°Å ·Î±× ¾È³²±è
//                           WantLog := false;
//                        end;
//                     end;
                     begin
                        if ps.AniCount = 0 then
                        begin
                          if ItemList.Count + 6 - 1 <= MAXBAGITEM then
                          begin
                             Dispose (PTUserItem(ItemList[i]));
                             ItemList.Delete (i);
                             UnbindPotionUnit (GetUnbindItemName (ps.Shape), 6);
                             flag := TRUE;

                             //¹­À½ Çª´Â°Å ·Î±× ¾È³²±è
                             WantLog := false;
                          end;
                        end
                        else
                        begin
                          if UseStdmodeFunItem(ps) then
                          begin
                            Dispose(pu);
                            ItemList.Delete(i);
                            flag := TRUE;
                            WantLog := false;
                          end;
                        end;

                     end;

                  66:
                     begin
                        latestuseitem := '';
                        if QFunctionNPC <> nil then begin
                          latestuseitem := ps.Name;
                          UseItemStdMode := ps.StdMode;
                          UseItemShape := ps.Shape;
//                          SysMsg (latestuseitem, 1);
                          QFunctionNpc.NpcSayTitle(self, '@_ItemEvent');
                          Dispose(pu);
                          ItemList.Delete(i);
                          flag := TRUE;
                          WantLog := false;
                        end;
                     end;
               end;
               break;
            //end;
         end;
      end;
   end;

   if flag then begin
      //»èÁ¦¸ñ·Ï¿¡ Ãß°¡µÈ ¹ÙÀÎµå ¾ÆÀÌÅÛµé »èÁ¦.
      if dellist <> nil then begin
         for j:= 0 to dellist.Count-1 do begin
            for i:= 0 to Itemlist.Count-1 do begin
               pu := PTUserItem(ItemList[i]);
               if pu.MakeIndex = Integer(dellist.Objects[j]) then begin
                  Dispose (pu);
                  ItemList.Delete (i);
                  break;
               end;
            end;
         end;

         SendMsg (self, RM_DELITEMS, 0, integer(dellist), 0, 0, '');
         //dellist´Â rm_delitem¿¡¼­ free ½ÃÄÑ¾ß ÇÑ´Ù.
      end;

      WeightChanged;
      SendDefMessage (SM_EAT_OK, 0, 0, 0, 0, '');
      //¹°°ÇÀ» »ç¿ëÇÏ¿© ¾ø¾îÁü
      if WantLog then
      begin
        AddUserLog ('11'#9 + //»ç¿ë_ +
                    MapName + ''#9 +
                    IntToStr(CX) + ''#9 +
                    IntToStr(CY) + ''#9 +
                    UserName + ''#9 +
                    UserEngine.GetStdItemName (ui.Index) + ''#9 +
                    IntToStr(ui.MakeIndex) + ''#9 +
                    IntToStr(BoolToInt(RaceServer = RC_USERHUMAN)) + ''#9 +
                    '0');
      end;
   end else SendDefMessage (SM_EAT_FAIL, 0, 0, 0, 0, '');
        if (pu <> nil) and boSendUpDate then SendUpdateItem(pu^);
end;

{ original
procedure TUserHuman.ServerGetButch (animal: TCreature; x, y, ndir: integer);
var
   n, m: integer;
begin
   if (abs(x-CX) <= 2) and (abs(y-CY) <= 2) then begin  //¹Ù·Î ¿·Ä­¸¸ ½ä ¼ö ÀÖÀ½
      if PEnvir.IsValidCreature (x, y, 2, animal) then begin  //
         if (animal.Death) and (not animal.BoSkeleton) and (animal.BoAnimal) then begin
            //ÀÚ½ÅÀÇ µµÃà ±â¼ú¿¡ µû¶ó¼­ µµÃà Æ÷ÀÎÆ®°¡ ´Ù¸£°Ô Àû¿ëµÈ´Ù.
            //±â¼úÀÌ ¾ø´Â °æ¿ì, 5-20 »çÀÌÀÌ¸ç, °í±âÀÇ Áúµµ 10-20¾¿ ¶³¾îÁø´Ù.
            n := 5 + Random(16);
            m := 100 + Random(201);
            animal.BodyLeathery := animal.BodyLeathery - n;
            animal.MeatQuality := animal.MeatQuality - m;   //Ä®ÁúÀ» ÇÒ ¼ö·Ï °í±âÁúÀº Á¶±Ý¾¿ ¶³¾îÁü
            if animal.MeatQuality < 0 then animal.MeatQuality := 0;
            if animal.BodyLeathery <= 0 then begin
               if (animal.RaceServer >= RC_ANIMAL) and (animal.RaceServer < RC_MONSTER) then begin  //»ç½¿°°ÀÌ °í±â¸¦ÁÖ´Â °Í¸¸, ÇØ°ñ·Î º¯ÇÔ
                  animal.BoSkeleton := TRUE;
                  animal.ApplyMeatQuality;
                  animal.SendRefMsg (RM_SKELETON, animal.Dir, animal.CX, animal.CY, 0, '')
               end;
               if not TakeCretBagItems (animal) then
                  SysMsg ('¾Æ¹«°Íµµ ¾òÁö ¸øÇß½À´Ï´Ù.', 0);
               animal.BodyLeathery := 50; //¸Þ¼¼Áö°¡ ¿¬¼ÓÀ¸·Î ³ª¿À´Â °ÍÀ» ¸·À½.
            end;
            DeathTime := GetTickCount;  //µµÃàÇÏ°í ÀÖ´ÂµµÁß¿¡ °í±â´Â »ç¶óÁöÁö ¾ÊÀ½.
         end;
      end;
      Dir := ndir;
   end;
   SendRefMsg (RM_BUTCH, Dir, CX, CY, 0, '');
end;
}

function TUserHuman.UseStdmodeFunItem(ps: PTStdItem): Boolean;
begin
  Result := False;
  if QFunctionNpc <> nil then begin
    QFunctionNpc.NpcSayTitle(TUserHuman(Self), '@StdModeFunc'+IntToStr(ps.AniCount));
    Result := True;
  end;
end;

procedure TUserHuman.ServerGetButch (animal: TCreature; x, y, ndir: integer);
var
   n, m: integer;
   cret : TObject;
begin
   cret := nil;
   if (abs(x-CX) <= 2) and (abs(y-CY) <= 2) then begin  //µÎ Ä­ ¿·±îÁö ½ä ¼ö ÀÖÀ½
      if PEnvir.IsValidFrontCreature (x, y, 2, cret) then begin  // (sonmg 2004/12/28)
         if cret <> nil then begin
            animal := TCreature(cret); // (sonmg 2004/12/28)
            if (animal.Death) and (not animal.BoSkeleton) and (animal.BoAnimal) then begin
               //ÀÚ½ÅÀÇ µµÃà ±â¼ú¿¡ µû¶ó¼­ µµÃà Æ÷ÀÎÆ®°¡ ´Ù¸£°Ô Àû¿ëµÈ´Ù.
               //±â¼úÀÌ ¾ø´Â °æ¿ì, 5-20 »çÀÌÀÌ¸ç, °í±âÀÇ Áúµµ 10-20¾¿ ¶³¾îÁø´Ù.
               n := 5 + Random(16);
               m := 100 + Random(201);
               animal.BodyLeathery := animal.BodyLeathery - n;
               animal.MeatQuality := animal.MeatQuality - m;   //Ä®ÁúÀ» ÇÒ ¼ö·Ï °í±âÁúÀº Á¶±Ý¾¿ ¶³¾îÁü
               if animal.MeatQuality < 0 then animal.MeatQuality := 0;
               if animal.BodyLeathery <= 0 then begin
                  if (animal.RaceServer >= RC_ANIMAL) and (animal.RaceServer < RC_MONSTER) then begin  //»ç½¿°°ÀÌ °í±â¸¦ÁÖ´Â °Í¸¸, ÇØ°ñ·Î º¯ÇÔ
                     animal.BoSkeleton := TRUE;
                     animal.ApplyMeatQuality;
                     animal.SendRefMsg (RM_SKELETON, animal.Dir, animal.CX, animal.CY, 0, '')
                  end;
                  if not TakeCretBagItems (animal) then
                     SysMsg ('Ã»ÓÐ»ñµÃÈÎºÎ¶«Î÷', 0);
                  animal.BodyLeathery := 50; //¸Þ¼¼Áö°¡ ¿¬¼ÓÀ¸·Î ³ª¿À´Â °ÍÀ» ¸·À½.
               end;
               DeathTime := GetTickCount;  //µµÃàÇÏ°í ÀÖ´ÂµµÁß¿¡ °í±â´Â »ç¶óÁöÁö ¾ÊÀ½.
            end;
         end;
      end;
      Dir := ndir;
   end;
   SendRefMsg (RM_BUTCH, Dir, CX, CY, 0, '');
end;

procedure TUserHuman.ServerGetMagicKeyChange (magid, key: integer);
var
   i: integer;
begin
   for i:=0 to MagicList.Count-1 do begin
      if PTUserMagic(MagicList[i]).pDef.MagicId = magid then begin
         PTUserMagic(MagicList[i]).Key := AnsiChar(key);
         break;
      end;
   end;
end;

procedure TUserHuman.ServerGetClickNpc (clickid: integer);
var
   npc: TCreature;
   PlayObject:TUserHuman;
   i:integer;
   p:PTVisibleActor;
begin
   if BoDealing then exit;  //±³È¯Áß¿¡´Â npc¸¦ Å¬¸¯ÇÒ ¼ö ¾ø´Ù.

   //NPCµî, »óÀÎµé °Ë»ç
   npc := UserEngine.GetMerchant (clickid);
   if npc = nil then npc := UserEngine.GetNpc (clickid);
   if npc <> nil then begin
      if (npc.PEnvir = PEnvir) and (abs(npc.CX-CX) <= 15) and (abs(npc.CY-CY) <= 15) then begin
         TNormNpc(npc).UserCall (self);
         exit;
      end;
   end;
   //  clickid
  PlayObject := nil;
  for i := 0 to VisibleActors.Count - 1 do begin
    p := VisibleActors.Items[i];
    if p.cret = TObject(clickid) then begin
      PlayObject := TUserHuman(p.cret); //...
      Break;
    end;
  end;
  if (PlayObject <> nil) and (PlayObject <> Self) then begin
    if ((PlayObject.PEnvir = PEnvir) and
    (abs(PlayObject.CX - CX) <= 15) and
    (abs(PlayObject.CY - CY) <= 15)) then begin
      if (PlayObject.RaceServer = RC_USERHUMAN) and
      PlayObject.m_StallMgr.OnSale then begin
        if (PlayObject.Death) or (PlayObject.boGhost) then begin

          Exit;
        end;
        PlayObject.SendStallItems(Self);
      end;
    end;
  end;
end;

procedure TUserHuman.ServerGetMerchantDlgSelect (npcid: integer; clickstr: string);
var
   npc: TNormNpc;
begin
   npc := TNormNpc (UserEngine.GetMerchant (npcid));
   if npc = nil then npc := TNormNpc (UserEngine.GetNpc (npcid));
   if npc = nil then npc := TNormNpc (UserEngine.GetDefaultNpc (npcid));
   if npc = nil then npc := TNormNpc (UserEngine.GetQFunctionNpc (npcid));

   if npc <> nil then begin
      //npc.BoInvisible => ¸Ê Äù½ºÆ®ÀÎ °æ¿ì
      if (npc.PEnvir = PEnvir) and (abs(npc.CX-CX) <= 15) and (abs(npc.CY-CY) <= 15) or (npc.BoInvisible) then begin


         TNormNpc(npc).UserSelect (self, clickstr);

      end;
   end;
end;

procedure TUserHuman.ServerGetMerchantQuerySellPrice (npcid, itemindex: integer; itemname: string);
var
   i: integer;
   npc: TCreature;
   pu: PTuserItem;
begin
   pu := nil;
   //³» °¡¹æÀÇ ¾ÆÀÌÅÛ¿¡¼­ itemindexÀÇ ¾ÆÀÌÅÛÀ» Ã£´Â´Ù.
   for i:=0 to ItemList.Count-1 do begin
      if PTUserItem(ItemList[i]).MakeIndex = itemindex then begin
         if CompareText (UserEngine.GetStdItemName (PTUserItem(ItemList[i]).Index), itemname) = 0 then begin
            pu := PTUserItem(ItemList[i]);
            break;
         end;
      end;
   end;

   if pu <> nil then begin
      npc := UserEngine.GetMerchant (npcid);
      if npc <> nil then begin
         if (npc.PEnvir = PEnvir) and (abs(npc.CX-CX) <= 15) and (abs(npc.CY-CY) <= 15) then begin
            TMerchant(npc).QueryPrice (self, pu^);
         end;
      end;
   end;
end;

procedure TUserHuman.ServerGetMerchantQueryRepairPrice (npcid, itemindex: integer; itemname: string);
var
   i: integer;
   npc: TCreature;
   pu: PTuserItem;
begin
   pu := nil;
   //³» °¡¹æÀÇ ¾ÆÀÌÅÛ¿¡¼­ itemindexÀÇ ¾ÆÀÌÅÛÀ» Ã£´Â´Ù.
   for i:=0 to ItemList.Count-1 do begin
      if PTUserItem(ItemList[i]).MakeIndex = itemindex then begin
         if CompareText (UserEngine.GetStdItemName (PTUserItem(ItemList[i]).Index), itemname) = 0 then begin
            pu := PTUserItem(ItemList[i]);
            break;
         end;
      end;
   end;

   if pu <> nil then begin
      npc := UserEngine.GetMerchant (npcid);
      if npc <> nil then begin
         if (npc.PEnvir = PEnvir) and (abs(npc.CX-CX) <= 15) and (abs(npc.CY-CY) <= 15) then begin
            TMerchant(npc).QueryRepairCost (self, pu^);
         end;
      end;
   end;
end;

procedure TUserHuman.ServerGetUserSellItem (npcid, itemindex, sellcnt: integer; itemname: string);
var
   i, temp: integer;
   npc: TCreature;
   pu: PTuserItem;
   pstd: PTStdItem;
begin
   pu := nil;
   //³» °¡¹æÀÇ ¾ÆÀÌÅÛ¿¡¼­ itemindexÀÇ ¾ÆÀÌÅÛÀ» Ã£´Â´Ù.
   for i:=0 to ItemList.Count-1 do begin
      if PTUserItem(ItemList[i]).MakeIndex = itemindex then begin
         if CompareText (UserEngine.GetStdItemName (PTUserItem(ItemList[i]).Index), itemname) = 0 then begin
            pu := PTUserItem(ItemList[i]);
            npc := UserEngine.GetMerchant (npcid);
            pstd := UserEngine.GetStdItem (pu.Index);
            if (npc <> nil) and (pu <> nil) and (pstd <> nil) then begin
               if (npc.PEnvir = PEnvir) and (abs(npc.CX-CX) <= 15) and (abs(npc.CY-CY) <= 15) then begin
                  if pstd <> nil then begin
                     if pstd.StdMode <> TAIWANEVENTITEM then begin //´ë¸¸ ÀÌº¥Æ®¿ë ¾ÆÀÌÅÛÀº ÆÈ ¼ö ¾ø´Ù
                        if pstd.OverlapItem >= 1 then begin    // gadget : Ä«¿îÆ®¾ÆÀÌÅÛ
                           temp := pu.Dura;
                           if (sellcnt > 0) and (temp >= sellcnt) then begin
                              if TMerchant(npc).UserCountSellItem(self, pu^, sellcnt) then begin
                                 if temp - sellcnt <= 0 then begin
                                     Dispose(PTUserItem(ItemList[i]));
                                     ItemList.Delete(i);
                                 end else begin
                                    PTUserItem(ItemList[i]).Dura := temp - sellcnt;
                                 end;
                              end;
                              WeightChanged;
                           end;
                        end else begin
                           if TMerchant(npc).UserSellItem(self, pu^) then begin
                              //ÆÇ¸ÅÇÑ ¾ÆÀÌÅÛÀ» ¾ø¾Ø´Ù.
                              Dispose(PTUserItem(ItemList[i]));
                              ItemList.Delete(i);
                              WeightChanged;
                           end;// else
//                              SendMsg (self, RM_USERSELLITEM_FAIL, 0, 0, 0, 0, '');
                        end;
                     end;
                  end;
               end;
            end;
            break;
         end;
      end;
   end;
end;

procedure TUserHuman.ServerGetUserRepairItem (npcid, itemindex: integer; itemname: string);
var
   i: integer;
   npc: TCreature;
   pu: PTuserItem;
begin
   pu := nil;
   //³» °¡¹æÀÇ ¾ÆÀÌÅÛ¿¡¼­ itemindexÀÇ ¾ÆÀÌÅÛÀ» Ã£´Â´Ù.
   for i:=0 to ItemList.Count-1 do begin
      if PTUserItem(ItemList[i]).MakeIndex = itemindex then begin
         if CompareText (UserEngine.GetStdItemName (PTUserItem(ItemList[i]).Index), itemname) = 0 then begin
            pu := PTUserItem(ItemList[i]);
            npc := UserEngine.GetMerchant (npcid);
            if (npc <> nil) and (pu <> nil) then begin
               if (npc.PEnvir = PEnvir) and (abs(npc.CX-CX) <= 15) and (abs(npc.CY-CY) <= 15) then begin
                  //¼ö¸®ÇÑ´Ù.
                  if TMerchant(npc).UserRepairItem (self, pu) then begin
                     ;
                  end;
               end;
            end;
            break;
         end;
      end;
   end;
end;

procedure TUserHuman.ServerSendStorageItemList (npcid: integer);
var
   i,j: integer;
   data: string;
   pu: PTUserItem;
   ps: PTStdItem;
   std: TStdItem;
   citem: TClientItem;
   page : integer;
   startcount, endcount, maxcount : integer;
begin
   data := '';
   maxcount := SaveItems.Count;
   page := maxcount div 50 ;

   for j := 0 to page do begin
      startcount := j* 50 ;
      endcount   := startcount + 50;
      if endcount > maxcount then endcount := maxcount;
      data := '';
      for i:=startcount to endcount-1 do begin
         pu := PTUserItem (SaveItems[i]);
         ps := UserEngine.GetStdItem (pu.Index);
         if ps <> nil then begin
            std := ps^;
            citem.UpgradeOpt := ItemMan.GetUpgradeStdItem (pu^, std);
            citem.S := std;

            //¹ÌÁöÀÇ¼Ó¼º ÇÁ¸® ¾ÈµÈ °Íµé ¼û±â±â
            if std.StdMode in [15,19,20,21,22,23,24,26,52,53,54] then begin
               if pu.Desc[8] = 0 then begin //¼Ó¼ºÀÌ ÇÁ¸®µÊ(sonmg 2005/04/07 ¼öÁ¤)
                  citem.S.ItemDesc := citem.S.ItemDesc and (not IDC_UNIDENTIFIED);//$01;
               end else begin
                  citem.S.ItemDesc := citem.S.ItemDesc or IDC_UNIDENTIFIED;//$01;
               end;
            end;

            citem.Dura := pu.Dura;
            citem.DuraMax := pu.DuraMax;
            citem.MakeIndex := pu.MakeIndex;
            data := data + EncodeBuffer (@citem, sizeof(TClientItem)) + '/';
         end;
      end;
      Def := MakeDefaultMsg (SM_SAVEITEMLIST, npcid, bStorageType, j, page{, SaveItems.Count}{¼ö·®});
      SendSocket (@Def, data);
   end;
end;
procedure TUserHuman.SendStallItems(RecvObject: TUserHuman);
var
  i                 : Integer;
begin
  RecvObject.def := MakeDefaultMsg(SM_USERSTALL, Integer(Self), CX, CY, Dir);
  RecvObject.SendSocket(@RecvObject.def, EncodeBuffer(@m_StallMgr.mBlock, SizeOf(TClientStallInfo)));
end;

function TUserHuman.CretInNearXYEx(nX, nY: Integer): Boolean;
var
  nCX, nCY          : Integer;
begin
  Result := True;
  for nCX := nX - 1 to nX + 1 do begin
    for nCY := nY - 1 to nY + 1 do begin
      if PEnvir.GetCreature{GetMovingObject}(nCX, nCY, True) = Self then
      Continue;
      if not PEnvir.CanWalk(nCX, nCY, False) then
        Result := False;
    end;
  end;
end;
procedure TUserHuman.ClientStallOnOpening(MsgBuff: string; nCount: Integer);
var
  sName, sUserItemName: string;
  i, ii, III        : Integer;
  boOK              : Boolean;

  StdItem           : pTStdItem;
  StdItem24         : TStdItem;
  UserItem          : pTUserItem;

  ClientStallItems  : TClientStallItems;
  //item                      : TClientStall;
  StallInfo         : TStallInfo;



    m_DefMsg: TDefaultMessage;
begin
  if (not m_StallMgr.OnSale) and (not bo°ÚÌ¯) then begin
    SendMsg(self, RM_MENU_OK, 0, Integer(Self), 0, 0, '[Ê§°Ü] °ÚÌ¯ÏµÍ³Î´¿ª·Å£¡');
    Exit;
  end;
  if Abil.Level < int°ÚÌ¯µÈ¼¶ then begin
    SendMsg(self, RM_MENU_OK, 0, Integer(Self), 0, 0, Format('[Ê§°Ü] ÐèÒª%d¼¶ÒÔÉÏ²ÅÄÜ°ÚÌ¯£¡', [int°ÚÌ¯µÈ¼¶]));
    Exit;
  end;
  if not InSafeZone and bosafe°ÚÌ¯ then
  begin
    SendMsg(self, RM_MENU_OK, 0, Integer(Self), 0, 0,'[Ê§°Ü] °²È«Çø²ÅÄÜ°ÚÌ¯£¡');
    Exit;
  end;
  if (PEnvir = nil) or not PEnvir.boStall then begin
    SendDefMessage(SM_OPENSTALL, -1, 0, 0, 0, ''); //µ±Ç°µØÍ¼²»ÔÊÐí°ÚÌ¯
    Exit;
  end;

  if (nCount > 0) and not CretInNearXYEx(CX, CY) then begin  //¼ì²é·¶Î§
    SendDefMessage(SM_OPENSTALL, -3, 0, 0, 0, '');
    Exit;
  end;

  if boDealing then begin //½»Ò×ÅÐ¶Ï
    SendDefMessage(SM_OPENSTALL, -4, 0, 0, 0, '');
    Exit;
  end;


  FillChar(m_StallMgr.mBlock, SizeOf(TClientStallInfo), #0);
  DecodeBuffer(MsgBuff, @ClientStallItems, SizeOf(TClientStallItems));

  //½âÃÜ ÊÛÂôÊý¾Ý
  if nCount in [1..10] then begin   //Ö»ÔÊÐí 10¸ö
    if m_StallMgr.OnSale then Exit;
    m_StallMgr.mBlock.StallName := ClientStallItems.Name;
    m_StallMgr.mBlock.ItemCount := nCount;



    //Í¬MakeIndex¼ì²â
    for i := 0 to nCount - 1 do begin
      if ClientStallItems.Items[i].MakeIndex = 0 then Continue;
      for ii := 0 to nCount - 1 do begin
        if ClientStallItems.Items[ii].MakeIndex = 0 then Continue;
        if i = ii then Continue;
        if ClientStallItems.Items[i].MakeIndex = ClientStallItems.Items[ii].MakeIndex then begin
          SendDefMessage(SM_OPENSTALL, -10, 0, 0, 0, ''); //Í¬Ò»ÎïÆ·²»¿É¶à´Î³öÊÛ  ×÷±×Íæ¼Ò
          Exit;
        end;
      end;
    end;

    for i := 0 to nCount - 1 do begin
      if ClientStallItems.Items[i].MakeIndex = 0 then Continue;
      if not (ClientStallItems.Items[i].GoldType in [44, 45]) then begin  //4 5  ½ð±ÒÔª±¦ÅÐ¶Ï        ³ö´í
        SendDefMessage(SM_OPENSTALL, -5, 0, 0, 0, ''); //ÎïÆ·³öÊÛ¼Û¸ñÀàÐÍ¶¨Òå´íÎó£¬ÖÕÖ¹°ÚÌ¯
        Exit;
      end;

      boOK := False;
      for ii := 0 to ItemList.Count - 1 do begin
        UserItem := ItemList[ii];
        if (UserItem.MakeIndex = ClientStallItems.Items[i].MakeIndex) then begin
          boOK := True;  //ÎïÆ·ÊÇ±¾ÈËµÄÔÊÐíÅÄÂô
          Break;
        end;
      end;

      if not boOK then begin

        Continue;
      end;

      case ClientStallItems.Items[i].GoldType of    //ÊÛÂô¼Û¸ñÅÐ¶¨ ÊÇ·ñ³¬±ê
        44: if (ClientStallItems.Items[i].Price <= 0) or (ClientStallItems.Items[i].Price > 88888888) then begin
            SendDefMessage(SM_OPENSTALL, -6, 0, 0, 0, '');
            Exit;
          end;
        45: if (ClientStallItems.Items[i].Price < 1) or (ClientStallItems.Items[i].Price > 88888888) then begin
            SendDefMessage(SM_OPENSTALL, -7, 0, 0, 0, '');
            Exit;
          end;
      end;

      StdItem := UserEngine.GetStdItem(UserItem.Index);//²éÑ¯ÊÇ·ñÓÐ¸ÃÎïÆ·
      if StdItem = nil then begin
        SendDefMessage(SM_OPENSTALL, -8, 0, 0, 0, '');
        Exit;
      end;


      // UserItem
      // StdItem^;
      StdItem24 := StdItem^;    //ÕâÀïÊÇ²é³öÀ´ÏµÍ³µÄ¡£

      m_StallMgr.mBlock.Items[i].UpgradeOpt := ItemMan.GetUpgradeStdItem(UserItem^,StdItem24);
      Move(StdItem24, m_StallMgr.mBlock.Items[i].s, SizeOf(TStdItem)); //--·¢ËÍ»ù´¡ÐÅÏ¢ ²»´ø¼«Æ·


      m_StallMgr.mBlock.Items[i].s.Stock := ClientStallItems.Items[i].GoldType;//½ðÇ®
      m_StallMgr.mBlock.Items[i].s.Price := ClientStallItems.Items[i].Price; //4 5  ½ð±ÒÔª±¦ÅÐ¶Ï  ½¨ÒéÓÃ 255 254 ¸ü´óµÄÖµ
      m_StallMgr.mBlock.Items[i].MakeIndex := UserItem.MakeIndex;//ÎïÆ·idx
      m_StallMgr.mBlock.Items[i].Dura := UserItem.Dura; //³Ö¾Ã
      m_StallMgr.mBlock.Items[i].DuraMax := UserItem.DuraMax;   //³Ö¾Ã
    end;
    m_StallMgr.OnSale := True;
    StallInfo.open := True;
    StallInfo.Looks := m_StallMgr.StallType;
    StallInfo.Name := m_StallMgr.mBlock.StallName;
    case dir of //ÐÞÕý·½Ïò
      0, 1: dir := 1;
      2, 3: dir := 3;
      4, 5: dir := 5;
      6, 7: dir := 7;
    end;

  end else begin //È¡Ïû°ÚÌ¯
    nCount := 0;
    m_StallMgr.OnSale := False;
    StallInfo.open := False;
  end;
                                //¸ÃÊý×Ö²»ÊÇ¸ºÊý
  m_DefMsg := MakeDefaultMsg(SM_OPENSTALL, Integer(Self), cX, cY, dir);
  SendSocket(@m_DefMsg, EncodeBuffer(@StallInfo, SizeOf(TStallInfo)));
  SendRefMsg(RM_STALLSTATUS, nCount,CX,CY, dir, '');
 end;



procedure TUserHuman.ServerGetUserStorageItem (npcid, itemindex, count: integer; itemname: string);
   function SaveCountItemAdd(uitem: PTUserItem; cnt: integer; var bak_ui: TUserItem): Integer;  // gadget
   var
      i: integer;
      total: word;
      ps, ps2: PTStdItem;
   begin
      Result := 0;
      ps := UserEngine.GetStdItem(uitem.Index);
      if ps <> nil then begin
         for i := 0 to SaveItems.Count - 1 do begin
            ps2 := UserEngine.GetStdItem(PTUserItem(SaveItems[i]).Index);
            if ps2 <> nil then begin
               if (ps.StdMode = ps2.StdMode) and (ps.Looks = ps2.Looks) and (ps2.OverlapItem >= 1) then begin
                  if CompareText(ps.Name, ps2.Name) = 0 then begin
                     if PTUserItem(SaveItems[i]).Dura + cnt <= 1000 then begin
                        bak_ui.Index := PTUserItem(SaveItems[i]).Index; //bug fix (sonmg 2005/01/07)
                        bak_ui.MakeIndex := PTUserItem(SaveItems[i]).MakeIndex; //bug fix (sonmg 2005/01/07)
                        total := PTUserItem(SaveItems[i]).Dura + cnt;
                        PTUserItem(SaveItems[i]).Dura := total;
                        Result := 1;
                        break;
                     end else begin
                        Result := 2;   // Ä«¿îÆ® ¾ÆÀÌÅÛ °³¼ö Á¦ÇÑ¿¡ °É¸²
                     end;
                  end;
               end;
            end;
         end;
      end;
   end;

procedure SendStorageItem (npcid: integer);
var
   i,j: integer;
   data: string;
   pu: PTUserItem;
   ps: PTStdItem;
   std: TStdItem;
   citem: TClientItem;
   page : integer;
   startcount, endcount, maxcount : integer;
begin
   data := '';
   maxcount := SaveItems.Count;
   page := maxcount div 50 ;

   for j := 0 to page do begin
      startcount := j* 50 ;
      endcount   := startcount + 50;
      if endcount > maxcount then endcount := maxcount;
      data := '';
      for i:=startcount to endcount-1 do begin
         pu := PTUserItem (SaveItems[i]);
         ps := UserEngine.GetStdItem (pu.Index);
         if ps <> nil then begin
            std := ps^;
            citem.UpgradeOpt := ItemMan.GetUpgradeStdItem (pu^, std);
            citem.S := std;

            //¹ÌÁöÀÇ¼Ó¼º ÇÁ¸® ¾ÈµÈ °Íµé ¼û±â±â
            if std.StdMode in [15,19,20,21,22,23,24,26,52,53,54] then begin
               if pu.Desc[8] = 0 then begin //¼Ó¼ºÀÌ ÇÁ¸®µÊ(sonmg 2005/04/07 ¼öÁ¤)
                  citem.S.ItemDesc := citem.S.ItemDesc and (not IDC_UNIDENTIFIED);//$01;
               end else begin
                  citem.S.ItemDesc := citem.S.ItemDesc or IDC_UNIDENTIFIED;//$01;
               end;
            end;

            citem.Dura := pu.Dura;
            citem.DuraMax := pu.DuraMax;
            citem.MakeIndex := pu.MakeIndex;
            data := data + EncodeBuffer (@citem, sizeof(TClientItem)) + '/';
         end;
      end;
      Def := MakeDefaultMsg (SM_SAVEITEMLIST, npcid, bStorageType, j, page{, SaveItems.Count}{¼ö·®});
      SendSocket (@Def, data);
   end;
end;
var
   i, remain: integer;
   npc: TCreature;
   pu, newpu: PTUserItem;
   bak_ui: TUserItem;
   pstd: PTStdItem;
   flag: Boolean;
   iRetVal: Integer;
   countstr: string;
   sflkj: boolean;
begin
   pu := nil;
   newpu := nil;
   remain := 0;
   countstr := '';

   //³» °¡¹æÀÇ ¾ÆÀÌÅÛ¿¡¼­ itemindexÀÇ ¾ÆÀÌÅÛÀ» Ã£´Â´Ù.
   flag := FALSE;
   sflkj := False;
   if pos(' ', itemname) >= 0 then
      GetValidStr3 (itemname, itemname, [' ']);
   if boSecondCardSystem then
   begin
     if (Abil.Level > g_nExpErienceLevel) then begin //Ã¼Çè¸ðµå´Â ¹°°ÇÀ» ¸ø ¸Ã±ä´Ù.
        if (ApprovalMode <> 1) and ((SecondsCard > 0) or (iDay > 0)) then
        begin
          sflkj := True;
        end
        else
        begin
          sflkj := False;
          SysMsg ('ÌåÑéÄ£Ê½ÖÐ²»ÄÜÊ¹ÓÃ²Ö¿â·þÎñ',2);
        end;
     end
     else
     begin
        if (ApprovalMode <> 1) and ((SecondsCard > 0) or (iDay > 0)) then
        begin
          sflkj := True;
        end
        else
        begin
          sflkj := False;
          SysMsg ('ÌåÑéÄ£Ê½ÖÐ²»ÄÜÊ¹ÓÃ²Ö¿â·þÎñ',2);
        end;
     end;
   end
   else
   begin
     sflkj := true;
   end;

   if sflkj then
   begin
      for i:=0 to ItemList.Count-1 do begin
         if PTUserItem(ItemList[i]).MakeIndex = itemindex then begin
            if CompareText (UserEngine.GetStdItemName (PTUserItem(ItemList[i]).Index), itemname) = 0 then begin
               pu := PTUserItem(ItemList[i]);
               npc := UserEngine.GetMerchant (npcid);
               pstd := UserEngine.GetStdItem (pu.Index);
               if (npc <> nil) and (pu <> nil) and (pstd <> nil) then begin
                  if (npc.PEnvir = PEnvir) and (abs(npc.CX-CX) <= 15) and (abs(npc.CY-CY) <= 15) then begin

                     if pstd.StdMode <> TAIWANEVENTITEM then begin  //´ë¸¸ ÀÌº¥Æ®¿ë ¾ÆÀÌÅÛ, ¸Ã±æ¼ö ¾ø´Ù

                        //º¸°üÇÑ´Ù.
                        //°¹¼ö ¾ÆÀÌÅÛÀº º¸°üµÈ ¾ÆÀÌÅÛ¿¡¼­ Áßº¹À¸·Î Ãß°¡ÇÔ.
                        if pstd.OverlapItem >= 1 then begin
                           if count > 1000 then break;   // Ä«¿îÆ® ¾ÆÀÌÅÛ °³¼ö Á¦ÇÑ

                           if count <= 0 then count := 1;
                           if count > pu.Dura then count := pu.Dura;
                           remain := pu.Dura - count;
                           countstr := '(' + IntToStr(count) + ')';  //·Î±×¸¦ À§ÇÑ ¾ÆÀÌÅÛ °³¼ö(sonmg 2005/01/07)
                           iRetVal := SaveCountItemAdd(pu, count, bak_ui);
                           if iRetVal = 1 then begin
                              pu.Dura := remain;
                              flag := TRUE;
                           end else if iRetVal = 2 then begin
                              break;
                           end else begin
                              // »õ·Î¿î ¾ÆÀÌÅÛ Ãß°¡
                              if SaveItems.Count < MAXSAVELIMIT then begin
                                  new(newpu);
                                  if UserEngine.CopyToUserItemFromName(itemname, newpu^) then begin
                                      newpu.Dura := count;
                                      SaveItems.Add(newpu);
                                      pu.Dura := remain;
                                      flag := TRUE;
                                  end else begin
                                      Dispose(newpu);
                                  end;
                              end;
                           end;
                           if pu.Dura = 0 then begin
                              Dispose(PTUserItem(ItemList[i]));    // memory leak
                              ItemList.Delete(i);
                              pu := newpu;   //bug fix (sonmg 2005/01/07)
                           end;
                        end else begin
                           if SaveItems.Count < MAXSAVELIMIT then begin
                              SaveItems.Add (pu);  //º¸°ü
                              ItemList.Delete (i);
                              flag := TRUE;
                           end;
                        end;

                        if flag then begin
                           WeightChanged;
                           SendDefMessage (SM_STORAGE_OK, 0, remain, count, 0, '');
                           if bStorageType = 255 then
                           SendStorageItem(npcid);
                           if pu <> nil then begin
                              //·Î±×³²±è
                              AddUserLog ('1'#9 + //º¸°ü_ +
                                          MapName + ''#9 +
                                          IntToStr(CX) + ''#9 +
                                          IntToStr(CY) + ''#9 +
                                          UserName + ''#9 +
                                          UserEngine.GetStdItemName (pu.Index) + ''#9 +
                                          IntToStr(pu.MakeIndex) + ''#9 +
                                          '1'#9 +
                                          '0' + countstr);  //°³¼ö·Î±×(sonmg 2005/01/07)
                           end else begin
                              //·Î±×³²±è
                              AddUserLog ('1'#9 + //º¸°ü_ +
                                          MapName + ''#9 +
                                          IntToStr(CX) + ''#9 +
                                          IntToStr(CY) + ''#9 +
                                          UserName + ''#9 +
                                          UserEngine.GetStdItemName (bak_ui.Index) + ''#9 +
                                          IntToStr(bak_ui.MakeIndex) + ''#9 +
                                          '1'#9 +
                                          '0' + countstr);  //°³¼ö·Î±×(sonmg 2005/01/07)
                           end;
                        end else //´õ ÀÌ»ó º¸°ü ¸øÇÔ
                           SendDefMessage (SM_STORAGE_FULL, 0, 0, 0, 0, '');
                        flag := TRUE;
                     end;
                  end;
               end;
               break;
            end;
         end;
      end;
   end;
   if not flag then
      SendDefMessage (SM_STORAGE_FAIL, 0, 0, 0, 0, '');
end;

procedure TUserHuman.ServerGetTakeBackStorageItem (npcid, itemserverindex, TakeBackCnt: integer; iname: string);
var
   I: INTEGER;
   flag: Boolean;
   pu, newpu: PTUserItem;
   bak_ui: TUserItem;
   npc: TCreature;
   ps: PTStdItem;
   remain: integer;
   CheckWeight : integer;
   countstr: string;
begin
   remain := 0;
   countstr := '';
   flag := FALSE;
   if boSecondCardSystem or (Abil.Level > g_nExpErienceLevel) then
   begin  // ²Ö¿â²»ÄÜÈ¡³öµÄÎÊÌâ
      if (ApprovalMode <> 1) and ((SecondsCard > 0) or (iDay > 0)) then begin //Ã¼Çè¸ðµå´Â ¹°°ÇÀ» ¸ø Ã£´Â´Ù.
      for i:=0 to SaveItems.Count-1 do begin
         if PTUserItem(SaveItems[i]).MakeIndex = itemserverindex then begin
            if CompareText (UserEngine.GetStdItemName (PTUserItem(SaveItems[i]).Index), iname) = 0 then begin
               pu := PTUserItem(SaveItems[i]);
               npc := UserEngine.GetMerchant (npcid);
               if (npc <> nil) and (pu <> nil) then begin
                  ps := UserEngine.GetStdItem(pu.Index);

                  if ps <> nil then
                  begin
                     // Ä«¿îÆ®¾ÆÀÌÅÛ
                     if ps.OverlapItem = 1 then
                        CheckWeight := ps.Weight + ps.Weight * (TakeBackCnt div 10)
                     else if ps.OverlapItem >= 2 then
                        CheckWeight := ps.Weight * TakeBackCnt
                     else
                        CheckWeight := ps.Weight;

                     if IsAddWeightAvailable (CheckWeight) then begin
                        if (npc.PEnvir = PEnvir) and (abs(npc.CX-CX) <= 15) and (abs(npc.CY-CY) <= 15) then begin
                           //¸Ã±ä¹°°ÇÀ» Ã£´Â´Ù.
                           if ps = nil then break;
                           if ps.OverlapItem >= 1 then begin                      // gadget:Ä«¿îÆ®¾ÆÀÌÅÛ
                              if TakeBackCnt <= 0 then TakeBackCnt := 1;
                              if TakeBackCnt > pu.Dura then TakeBackCnt := pu.Dura;
                              remain := pu.Dura - TakeBackCnt;
                              countstr := '(' + IntToStr(TakeBackCnt) + ')';  //·Î±×¸¦ À§ÇÑ ¾ÆÀÌÅÛ °³¼ö(sonmg 2005/01/07)
                              if UserCounterItemAdd(ps.StdMode, ps.Looks, TakeBackCnt, ps.Name, FALSE) then begin
                                 if remain > 0 then begin // memory leak
                                    pu.Dura := remain;
                                 end else begin
                                    bak_ui.Index := pu.Index;  //bug fix (sonmg 2005/01/07)
                                    bak_ui.MakeIndex := pu.MakeIndex;  //bug fix (sonmg 2005/01/07)
                                    Dispose(PTUserItem(SaveItems[i]));
                                    SaveItems.Delete(i);
                                    pu := nil;
                                 end;
                              end else begin
                                 new(newpu);
                                 if UserEngine.CopyToUserItemFromName(iname, newpu^) then begin
                                    newpu.Dura := TakeBackCnt;
                                    if AddItem(newpu) then begin
                                       SendAddItem(newpu^);
                                       if remain > 0 then begin // memory leak
                                          pu.Dura := remain;
                                       end else begin
                                          if newpu <> nil then pu := newpu;   //bug fix (sonmg 2005/01/07)
                                          Dispose(PTUSerItem(SaveItems[i]));
                                          SaveItems.Delete(i);
                                       end;
                                    end else begin
                                       Dispose(newpu);   // Memory Leak sonmg
                                       SendDefMessage(SM_TAKEBACKSTORAGEITEM_FULLBAG, 0, 0, 0, 0, ''); //°¡¹æ ²Ë Ã¡À½
                                       break;
                                    end;
                                 end else begin
                                    Dispose(newpu);
                                 end;
                              end;
                           end else begin
                              if AddItem (pu) then begin  //°¡¹æÀ¸·Î ¿Å±â°í
                                 SendAddItem (pu^);  //Å¬¶óÀÌ¾ðÆ®¿¡ º¸³¿
                                 SaveItems.Delete (i);
                              end else begin
                                 SendDefMessage (SM_TAKEBACKSTORAGEITEM_FULLBAG, 0, 0, 0, 0, ''); //°¡¹æ ²Ë Ã¡À½
                                 break;
                              end;
                           end;

                           SendDefMessage (SM_TAKEBACKSTORAGEITEM_OK, itemserverindex, remain, TakeBackCnt, 0, '');
                           if pu <> nil then begin
                              //·Î±×³²±è
                              AddUserLog ('0'#9 + //Ã£±â_ +
                                          MapName + ''#9 +
                                          IntToStr(CX) + ''#9 +
                                          IntToStr(CY) + ''#9 +
                                          UserName + ''#9 +
                                          UserEngine.GetStdItemName (pu.Index) + ''#9 +
                                          IntToStr(pu.MakeIndex) + ''#9 +
                                          '1'#9 +
                                          '0' + countstr);
                           end else begin
                              //·Î±×³²±è
                              AddUserLog ('0'#9 + //Ã£±â_ +
                                          MapName + ''#9 +
                                          IntToStr(CX) + ''#9 +
                                          IntToStr(CY) + ''#9 +
                                          UserName + ''#9 +
                                          UserEngine.GetStdItemName (bak_ui.Index) + ''#9 +
                                          IntToStr(bak_ui.MakeIndex) + ''#9 +
                                          '1'#9 +
                                          '0' + countstr);
                           end;
                           flag := TRUE;
                        end;
                     end else
                        SysMsg ('ÎÞ·¨Ð¯´ø¸ü¶à¶«Î÷', 0);
                     WeightChanged;
                  end;
               end;
               break;
            end;
         end;
      end;
      end else
      SysMsg ('ÌåÑéÄ£Ê½ÖÐÄú²»ÄÜÊ¹ÓÃ²Ö¿â·þÎñ', 0);
   end
   else
   begin
      for i:=0 to SaveItems.Count-1 do begin
         if PTUserItem(SaveItems[i]).MakeIndex = itemserverindex then begin
            if CompareText (UserEngine.GetStdItemName (PTUserItem(SaveItems[i]).Index), iname) = 0 then begin
               pu := PTUserItem(SaveItems[i]);
               npc := UserEngine.GetMerchant (npcid);
               if (npc <> nil) and (pu <> nil) then begin
                  ps := UserEngine.GetStdItem(pu.Index);

                  if ps <> nil then
                  begin
                     // Ä«¿îÆ®¾ÆÀÌÅÛ
                     if ps.OverlapItem = 1 then
                        CheckWeight := ps.Weight + ps.Weight * (TakeBackCnt div 10)
                     else if ps.OverlapItem >= 2 then
                        CheckWeight := ps.Weight * TakeBackCnt
                     else
                        CheckWeight := ps.Weight;

                     if IsAddWeightAvailable (CheckWeight) then begin
                        if (npc.PEnvir = PEnvir) and (abs(npc.CX-CX) <= 15) and (abs(npc.CY-CY) <= 15) then begin
                           //¸Ã±ä¹°°ÇÀ» Ã£´Â´Ù.
                           if ps = nil then break;
                           if ps.OverlapItem >= 1 then begin                      // gadget:Ä«¿îÆ®¾ÆÀÌÅÛ
                              if TakeBackCnt <= 0 then TakeBackCnt := 1;
                              if TakeBackCnt > pu.Dura then TakeBackCnt := pu.Dura;
                              remain := pu.Dura - TakeBackCnt;
                              countstr := '(' + IntToStr(TakeBackCnt) + ')';  //·Î±×¸¦ À§ÇÑ ¾ÆÀÌÅÛ °³¼ö(sonmg 2005/01/07)
                              if UserCounterItemAdd(ps.StdMode, ps.Looks, TakeBackCnt, ps.Name, FALSE) then begin
                                 if remain > 0 then begin // memory leak
                                    pu.Dura := remain;
                                 end else begin
                                    bak_ui.Index := pu.Index;  //bug fix (sonmg 2005/01/07)
                                    bak_ui.MakeIndex := pu.MakeIndex;  //bug fix (sonmg 2005/01/07)
                                    Dispose(PTUserItem(SaveItems[i]));
                                    SaveItems.Delete(i);
                                    pu := nil;
                                 end;
                              end else begin
                                 new(newpu);
                                 if UserEngine.CopyToUserItemFromName(iname, newpu^) then begin
                                    newpu.Dura := TakeBackCnt;
                                    if AddItem(newpu) then begin
                                       SendAddItem(newpu^);
                                       if remain > 0 then begin // memory leak
                                          pu.Dura := remain;
                                       end else begin
                                          if newpu <> nil then pu := newpu;   //bug fix (sonmg 2005/01/07)
                                          Dispose(PTUSerItem(SaveItems[i]));
                                          SaveItems.Delete(i);
                                       end;
                                    end else begin
                                       Dispose(newpu);   // Memory Leak sonmg
                                       SendDefMessage(SM_TAKEBACKSTORAGEITEM_FULLBAG, 0, 0, 0, 0, ''); //°¡¹æ ²Ë Ã¡À½
                                       break;
                                    end;
                                 end else begin
                                    Dispose(newpu);
                                 end;
                              end;
                           end else begin
                              if AddItem (pu) then begin  //°¡¹æÀ¸·Î ¿Å±â°í
                                 SendAddItem (pu^);  //Å¬¶óÀÌ¾ðÆ®¿¡ º¸³¿
                                 SaveItems.Delete (i);
                              end else begin
                                 SendDefMessage (SM_TAKEBACKSTORAGEITEM_FULLBAG, 0, 0, 0, 0, ''); //°¡¹æ ²Ë Ã¡À½
                                 break;
                              end;
                           end;

                           SendDefMessage (SM_TAKEBACKSTORAGEITEM_OK, itemserverindex, remain, TakeBackCnt, 0, '');
                           if pu <> nil then begin
                              //·Î±×³²±è
                              AddUserLog ('0'#9 + //Ã£±â_ +
                                          MapName + ''#9 +
                                          IntToStr(CX) + ''#9 +
                                          IntToStr(CY) + ''#9 +
                                          UserName + ''#9 +
                                          UserEngine.GetStdItemName (pu.Index) + ''#9 +
                                          IntToStr(pu.MakeIndex) + ''#9 +
                                          '1'#9 +
                                          '0' + countstr);
                           end else begin
                              //·Î±×³²±è
                              AddUserLog ('0'#9 + //Ã£±â_ +
                                          MapName + ''#9 +
                                          IntToStr(CX) + ''#9 +
                                          IntToStr(CY) + ''#9 +
                                          UserName + ''#9 +
                                          UserEngine.GetStdItemName (bak_ui.Index) + ''#9 +
                                          IntToStr(bak_ui.MakeIndex) + ''#9 +
                                          '1'#9 +
                                          '0' + countstr);
                           end;
                           flag := TRUE;
                        end;
                     end else
                        SysMsg ('ÎÞ·¨Ð¯´ø¸ü¶à¶«Î÷', 0);
                     WeightChanged;
                  end;
               end;
               break;
            end;
         end;
      end;
   end;
   if not flag then
      SendDefMessage (SM_TAKEBACKSTORAGEITEM_FAIL, 0, 0, 0, 0, ''); //°¡¹æ ²Ë Ã¡À½
end;
var
  g_DealGoldType    : array[4..5] of string = ('½ð±Ò', 'Ôª±¦');
//--Á½¸öÂòÈë
procedure TUserHuman.ServerGetUserMenuBuy (msg, npcid, MakeIndex, menuindex: integer; itemname: string);
var
   npc: TCreature;
   PlayObject:TUserHuman;
   p:PTVisibleActor;

  i, ii, nPrice, nPriceType: Integer;
  maxGold           : LongWord;
  pstd              : pTStdItem;
//  UserItem          : pTUserItem;
   UserItem: PTUserItem;
  StallInfo         : TStallInfo;
  bo:boolean;
label
  labNpc;
begin

   if BoDealing then exit;  //±³È¯Áß¿¡´Â ¹°°ÇÀ» »ì ¼ö ¾ø´Ù.
//   npc := UserEngine.GetMerchant (npcid);
 //-        °ÚÌ¯

//    if TObject(npc) = CurQuestNpc then begin //µ±Ç°¶Ô»°npc
//      goto labNpc; //Èç¹ûÄÇÃ´/µÃ²âÊÔ¡£¡£
//    end;

  PlayObject := nil;
  for i := 0 to VisibleActors.Count - 1 do begin
    p := VisibleActors.Items[i];
    if p.cret = TObject(npcid) then begin
      PlayObject := TUserHuman(p.cret); //...
      Break;
    end;
  end;

  if (PlayObject <> nil) and (PlayObject.RaceServer <> RC_USERHUMAN) then begin
    npc := UserEngine.GetMerchant (npcid);
    if npc.RaceServer = RC_NPC then begin
      if npc <> nil then begin
        if (npc.PEnvir = PEnvir) and (abs(npc.CX-CX) <= 15) and (abs(npc.CY-CY) <= 15) then begin
           if msg = CM_USERBUYITEM then begin
              if menuindex > 0 then
                 TMerchant(npc).UserBuyItem(self, itemname, MakeIndex, menuindex) //menuindex:°¹¼ö; »ó¼¼¾ÆÀÌÅÛ or ½Ã¾à·ù..
              else
                 TMerchant(npc).UserBuyItem(self, itemname, MakeIndex, 1); // gadget : °¹¼ö ¾ÆÀÌÅÛ »ç±â
  //            TMerchant(npc).UserBuyItem (self, itemname, MakeIndex);  //»ó¼¼¾ÆÀÌÅÛ or ½Ã¾à·ù..
           end;
           if msg = CM_USERGETDETAILITEM then begin
              TMerchant(npc).UserWantDetailItems (self, itemname, menuindex);
           end;
        end;
      end;
      Exit;
    end;
  end;

//-ÉÏÃæÂß¼­Ã»ÎÊÌâ
  if (PlayObject <> nil) and (PlayObject.RaceServer = RC_USERHUMAN) then begin
    if PlayObject.m_StallMgr.OnSale then
    begin
      if not bo°ÚÌ¯ then begin
        SendMsg(self, RM_MENU_OK, 0, Integer(Self), 0, 0, '[Ê§°Ü] °ÚÌ¯ÏµÍ³Î´¿ª·Å£¡');
        Exit;
      end;

      if (PlayObject = Self) or
        (PlayObject.Death) or
        (PlayObject.boGhost) or
        (abs(PlayObject.CX - CX) > 15) or
        (abs(PlayObject.CY - CY) > 15) then Exit;

       if msg = CM_USERBUYITEM then begin//ÊÇÂò£¬

        if MakeIndex = 0 then Exit;

        nPrice := -1;
        for i := Low(PlayObject.m_StallMgr.mBlock.Items) to High(PlayObject.m_StallMgr.mBlock.Items) do begin
          if PlayObject.m_StallMgr.mBlock.Items[i].s.Name = '' then Continue;
          if PlayObject.m_StallMgr.mBlock.Items[i].MakeIndex = MakeIndex then begin
            nPrice := PlayObject.m_StallMgr.mBlock.Items[i].s.Price;
            nPriceType := PlayObject.m_StallMgr.mBlock.Items[i].s.Stock;
            Break;
          end;
        end; //ÌáÈ¡Ç®orÀàÐÍ

        if nPrice = -1 then begin  //Ç®²»¶Ô£¿£¿£¿£¿ or ÂôÁË£¿
          SendDefMessage(SM_BUYSTALLITEM, -1, 0, 0, 0, '');
          Exit;
        end;
        if PlayObject.m_StallMgr.mBlock.Items[i].s.UniqueItem in [12,44] then begin      //°ÚÌ¯ÎïÆ·ÏÞÖÆ
          SysMsg ('´ËÎïÆ·ÎªÌØÊâÎïÆ·ÎÞ·¨¹ºÂò', 0);
          Exit;
        end;

        case nPriceType of
          44: begin   //½ð±Ò
              maxGold := LongWord(PlayObject.Gold + nPrice);
              if maxGold > 150000000 then begin//×î´ó£¿                     //½ð±Ò
                SendDefMessage(SM_BUYSTALLITEM, -2, 0, 0, 0, PlayObject.UserName);
                Exit;
              end;
              if Gold < nPrice then begin
                SendDefMessage(SM_BUYSTALLITEM, -3, 0, 0, 0, PlayObject.m_StallMgr.mBlock.Items[i].s.Name);
                Exit;
              end;
            end;
          45: begin   //Ôª±¦
              maxGold := LongWord(PlayObject.PotCash + nPrice);
              if maxGold > High(Integer) then begin
                SendDefMessage(SM_BUYSTALLITEM, -4, 0, 0, 0, PlayObject.UserName);
                Exit;
              end;
              if PotCash < nPrice then begin
                SendDefMessage(SM_BUYSTALLITEM, -5, 0, 0, 0, PlayObject.m_StallMgr.mBlock.Items[i].s.Name);
                Exit;
              end;
            end;
         else
         //hack
          Exit;
        end;
        bo:=True;
        for i := 0 to PlayObject.ItemList.Count - 1 do begin

          UserItem := PlayObject.ItemList[i];
          if (UserItem.MakeIndex = MakeIndex) then begin
            bo:=false;
            pstd := UserEngine.GetStdItem(UserItem.Index);
            if pstd = nil then begin
              SendDefMessage(SM_BUYSTALLITEM, -6, 0, 0, 0, '');
              Exit;
            end;
            if CompareText(pstd.Name, itemname) <> 0 then begin
              SendDefMessage(SM_BUYSTALLITEM, -6, 0, 0, 0, '');
              Exit;
            end;

            if IsEnoughBag and IsAddWeightAvailable(UserEngine.GetStdItemWeight(UserItem.Index{,UserItem.Dura})) then begin
              if nPriceType = 44 then begin
                DecGold(nPrice);
                GoldChanged;

                                      //×î´ó20ÒÚ
                PlayObject.Gold := _MIN(2000000000, (PlayObject.Gold + nPrice));
                PlayObject.GoldChanged();

              end
              else
              begin
                DecPotCash({PotCash,} nPrice);
                PotCashChanged;

                                          //×î´ó20ÒÚ
                PlayObject.PotCash := _MIN(High(Integer), (PlayObject.PotCash + nPrice));
                PlayObject.PotCashChanged();

              end;

              AddItem(UserItem);
              SendAddItem(UserItem^);
              LastSaveTime := 0;
              WeightChanged();

               PlayObject.DeletePItemAndSend1(UserItem);
              PlayObject.WeightChanged();
              PlayObject.LastSaveTime := 0;

           PlayObject.SysMsg(Format('¹§Ï²£ºÄúµÄ¡¼%s¡½³É¹¦ÊÛ³ö£¡', [pstd.Name]), 2);
          //    PlayObject.SysMsg(Format('¡º%s¡»»¨·Ñ¡¼%d%s¡½¹ºÂòÁËÄãµÄ¡¼%s¡½', [UserName, nPrice, g_DealGoldType[nPriceType-40], pstd.Name]), 2);

               SysMsg(Format('Äã»¨·Ñ¡¼%d%s¡½¹ºÂòÁË¶Ô·½µÄ¡¼%s¡½£¡', [nPrice, g_DealGoldType[nPriceType-40], pstd.Name]), 2);
          //    SysMsg(Format('Äã»¨·Ñ¡¼%d%s¡½¹ºÂòÁË¡º%s¡»µÄ¡¼%s¡½', [nPrice, g_DealGoldType[nPriceType-40], PlayObject.UserName, pstd.Name]), 2);

              AddUserLog ('50'#9 + //°ÚÌ¯¹ºÂò_ +
                          MapName + ''#9 +
                          IntToStr(CX) + ''#9 +
                          IntToStr(CY) + ''#9 +
                          UserName + ''#9 +
                          UserEngine.GetStdItemName(UserItem.Index) + ''#9 +
                          IntToStr(UserItem.MakeIndex) + ''#9 +
                          '1'#9 +
                          PlayObject.UserName);

              for ii := Low(PlayObject.m_StallMgr.mBlock.Items) to High(PlayObject.m_StallMgr.mBlock.Items) do begin
                if PlayObject.m_StallMgr.mBlock.Items[ii].MakeIndex = MakeIndex then begin
                  PlayObject.m_StallMgr.mBlock.Items[ii].MakeIndex := 0;
                  PlayObject.m_StallMgr.mBlock.Items[ii].s.Name := '';
                  Break;
                end;
              end;
              Dec(PlayObject.m_StallMgr.mBlock.ItemCount);

              if PlayObject.m_StallMgr.mBlock.ItemCount <= 0 then begin     //×îºóÒ»¸ö È¡ÏûÌ¯Î»£¿
                PlayObject.m_StallMgr.OnSale := False;
                PlayObject.m_StallMgr.mBlock.StallName := '';
                PlayObject.m_StallMgr.mBlock.ItemCount := 0;
                FillChar(PlayObject.m_StallMgr.mBlock.Items, SizeOf(PlayObject.m_StallMgr.mBlock.Items), #0);

                StallInfo.open := False;
                StallInfo.Name := PlayObject.m_StallMgr.mBlock.StallName;
                StallInfo.Looks := PlayObject.m_StallMgr.StallType;
                PlayObject.Def := MakeDefaultMsg(SM_OPENSTALL, Integer(PlayObject), PlayObject.CX, PlayObject.CY, PlayObject.Dir);
                PlayObject.SendSocket(@PlayObject.Def, EncodeBuffer(@StallInfo, SizeOf(TStallInfo)));

                PlayObject.SendRefMsg(RM_STALLSTATUS, 0, PlayObject.CX, PlayObject.CY, PlayObject.Dir, '');

                Exit;
              end else begin             //Âò¼Ò      Ã»Ë¢ÐÂ×Ô¼º£¿¡£¡£bug
                PlayObject.SendStallItems(Self);//??
              end;

            end else begin
              SendDefMessage(SM_BUYSTALLITEM, -7, 0, 0, 0, '');
              Exit;
            end;
            Break;
          end
          //
        end;
       if bo then
       SendDefMessage(SM_BUYSTALLITEM, -6, 0, 0, 0, '');

       Exit;
      end
      else
       Exit;
    end
    else
    SendDefMessage(SM_BUYSTALLITEM, -6, 0, 0, 0, '');
    Exit;
  end else begin

     SendDefMessage(SM_BUYSTALLITEM, -8, 0, 0, 0, '');
     Exit;
  end;


//-  °ÚÌ¯




//   labNpc:
//   npc := UserEngine.GetMerchant (npcid);
//   if npc <> nil then begin
//      if (npc.PEnvir = PEnvir) and (abs(npc.CX-CX) <= 15) and (abs(npc.CY-CY) <= 15) then begin
//         if msg = CM_USERBUYITEM then begin
//            if menuindex > 0 then
//               TMerchant(npc).UserBuyItem(self, itemname, MakeIndex, menuindex) //menuindex:°¹¼ö; »ó¼¼¾ÆÀÌÅÛ or ½Ã¾à·ù..
//            else
//               TMerchant(npc).UserBuyItem(self, itemname, MakeIndex, 1); // gadget : °¹¼ö ¾ÆÀÌÅÛ »ç±â
////            TMerchant(npc).UserBuyItem (self, itemname, MakeIndex);  //»ó¼¼¾ÆÀÌÅÛ or ½Ã¾à·ù..
//         end;
//         if msg = CM_USERGETDETAILITEM then begin
//            TMerchant(npc).UserWantDetailItems (self, itemname, menuindex);
//         end;
//      end;
//   end;
end;

procedure TUserHuman.ServerGetMakeDrug (npcid: integer; itemname: string);
var
   i: integer;
   npc: TCreature;
begin
   npc := UserEngine.GetMerchant (npcid);
   if npc <> nil then begin
      if (npc.PEnvir = PEnvir) and (abs(npc.CX-CX) <= 15) and (abs(npc.CY-CY) <= 15) then begin
         TMerchant(npc).UserMakeNewItem (self, itemname);
      end;
   end;
end;

procedure TUserHuman.ServerGetMakeItemSel (npcid: integer; itemname: string);
var
   i: integer;
   npc: TCreature;
begin
   npc := UserEngine.GetMerchant (npcid);
   if npc <> nil then begin
      if (npc.PEnvir = PEnvir) and (abs(npc.CX-CX) <= 15) and (abs(npc.CY-CY) <= 15) then begin
         TMerchant(npc).SayMakeItemMaterials (self, itemname);
      end;
   end;
end;

procedure TUserHuman.ServerGetMakeItem (npcid: integer; itemname: string);
var
   i: integer;
   npc: TCreature;
begin
   npc := UserEngine.GetMerchant (npcid);
   if npc <> nil then begin
      if (npc.PEnvir = PEnvir) and (abs(npc.CX-CX) <= 15) and (abs(npc.CY-CY) <= 15) then begin
         TMerchant(npc).UserManufactureItem (self, itemname);
      end;
   end;
end;

//±×·ì¿øÀÌ º¯°æµÇ¾î ±×·ì¿ø¸®½ºÆ®¸¦ ±×·ì¿øµé¿¡°Ô º¸³¿
procedure TUserHuman.RefreshGroupMembers;
var
   i: integer;
   data: string;
   cret: TCreature;
   hum: TUserHuman;
begin
   data := '';
   for i:=0 to GroupMembers.Count-1 do begin
      cret := TCreature (GroupMembers.Objects[i]);
      data := data + cret.UserName + '/';
   end;

   for i:=0 to GroupMembers.Count-1 do begin
      hum := TUserHuman (GroupMembers.Objects[i]);
      if hum.RaceServer = RC_USERHUMAN then begin
         hum.SendDefMessage (SM_GROUPMEMBERS, 0, 0, 0, 0, data);

         // ¹ß·»Å¸ÀÎ ÀÌº¥Æ®(¿¬ÀÎ ±×·ì ÀÌº¥Æ®)
         hum.RecalcAbilitys;
         SendMsg (hum, RM_ABILITY, 0, 0, 0, 0, '');

      end else begin
         MainOutMessage('ERROR NOT HUMAN RefreshGroupMember');
      end;
   end;

end;

//±×·ì ¸¸µé±â
procedure TUserHuman.ServerGetCreateGroup (withwho: string);
var
   who: TUserHuman;
begin
   who := UserEngine.GetUserHuman (withwho);

   if GroupOwner <> nil then begin
      SendDefMessage (SM_CREATEGROUP_FAIL, -1, 0, 0, 0, '');
      exit;
   end;
   if (who = nil) or (who = self) then begin
      SendDefMessage (SM_CREATEGROUP_FAIL, -2, 0, 0, 0, '');
      exit;
   end;

   //À§Ä¡ º¯°æ(2004/11/18)
   //±×·ì ¾ÈµÇ´Â ¸Ê ¼Ó¼º Ãß°¡(sonmg 2004/10/13)
   if PEnvir.NoGroup then begin
      SysMsg('ÄãËùÔÚµÄµØÍ¼½ûÖ¹×é¶Ó.', 0);
      exit;
   end;
   //±×·ì ¾ÈµÇ´Â ¸Ê ¼Ó¼º Ãß°¡(sonmg 2004/10/13)
   if who.PEnvir.NoGroup then begin
      SysMsg('ÄãËùÔÚµÄµØÍ¼½ûÖ¹¼ÓÈë¶ÓÎé.', 0);
      exit;
   end;

   // 2003/07/23
   if (self.LoginSign = FALSE) or (who.LoginSign = FALSE) then begin
      SendDefMessage (SM_CREATEGROUP_FAIL, -2, 0, 0, 0, '');
      exit;
   end;

   if who.GroupOwner <> nil then begin
      SendDefMessage (SM_CREATEGROUP_FAIL, -3, 0, 0, 0, '');
      exit;
   end;
   if not who.AllowGroup then begin
      SendDefMessage (SM_CREATEGROUP_FAIL, -4, 0, 0, 0, '');
      exit;
   end;

   ////////////////////////////////////////////////////////////////
   //40ÃÊ ÀÌ»ó °æ°úÇÏ¸é ±×·ì ¿äÃ»ÀÚ¿Í ½Ã°£À» ÃÊ±âÈ­ ½ÃÅ²´Ù.(sonmg)
   if (GetTickCount < who.GroupRequestTime) or (GetTickCount - who.GroupRequestTime > 40 * 1000) then begin
      who.GroupRequester := '';
   end;

   // ±×·ì ¿äÃ»À» ¹Þ°í ÀÖ´Â Áß(sonmg)
   if who.GroupRequester <> '' then begin
      SendDefMessage (SM_CREATEGROUP_FAIL, -5, 0, 0, 0, withwho);
      exit;
   end;

   //±×·ì ¿äÃ»ÀÚ ±â·Ï
   who.GroupRequester := UserName;
   //±×·ì ¿äÃ» ¹ÞÀº ½Ã°£ ±â·Ï
   who.GroupRequestTime := GetCurrentTime;

   who.SendDefMessage (SM_CREATEGROUPREQ, 0, 0, 0, 0, UserName);

   ////////////////////////
   exit;       ////////////
   ////////////////////////
   ////////////////////////////////////////////////////////////////

{
   GroupMembers.Clear;
   GroupMembers.AddObject (UserName, self);
   GroupMembers.AddObject (withwho, who);
   EnterGroup (self);
   who.EnterGroup (self);
   AllowGroup := TRUE;

   SendDefMessage (SM_CREATEGROUP_OK, 0, 0, 0, 0, '');
   RefreshGroupMembers;
}
end;

procedure TUserHuman.ServerGetCreateGroupRequestOk (withwho: string);
var
   who: TUserHuman;

begin
   who := UserEngine.GetUserHuman (withwho);
   if who = nil then exit;

   if who.GroupOwner <> nil then begin
      who.SendDefMessage (SM_CREATEGROUP_FAIL, -1, 0, 0, 0, '');
      //±×·ì ¿äÃ»ÀÚ ÇØÁ¦
      GroupRequester := '';
      exit;
   end;
   if (who = nil) or (who = self) then begin
      who.SendDefMessage (SM_CREATEGROUP_FAIL, -2, 0, 0, 0, '');
      //±×·ì ¿äÃ»ÀÚ ÇØÁ¦
      GroupRequester := '';
      exit;
   end;

   //À§Ä¡ º¯°æ(2004/11/18)
   //±×·ì ¾ÈµÇ´Â ¸Ê ¼Ó¼º Ãß°¡(sonmg 2004/10/13)
   if who.PEnvir.NoGroup then begin
      who.SysMsg('ÄãËùÔÚµÄµØÍ¼½ûÖ¹×é¶Ó.', 0);
      //±×·ì ¿äÃ»ÀÚ ÇØÁ¦
      GroupRequester := '';
      exit;
   end;
   //±×·ì ¾ÈµÇ´Â ¸Ê ¼Ó¼º Ãß°¡(sonmg 2004/10/13)
   if PEnvir.NoGroup then begin
      who.SysMsg('ÄãËùÔÚµÄµØÍ¼½ûÖ¹¼ÓÈë¶ÓÎé.', 0);
      //±×·ì ¿äÃ»ÀÚ ÇØÁ¦
      GroupRequester := '';
      exit;
   end;

   // 2003/07/23
   if (who.LoginSign = FALSE) or (self.LoginSign = FALSE) then begin
      who.SendDefMessage (SM_CREATEGROUP_FAIL, -2, 0, 0, 0, '');
      //±×·ì ¿äÃ»ÀÚ ÇØÁ¦
      GroupRequester := '';
      exit;
   end;

   if who.GroupOwner <> nil then begin
      who.SendDefMessage (SM_CREATEGROUP_FAIL, -3, 0, 0, 0, '');
      //±×·ì ¿äÃ»ÀÚ ÇØÁ¦
      GroupRequester := '';
      exit;
   end;
   if not AllowGroup then begin
      who.SendDefMessage (SM_CREATEGROUP_FAIL, -4, 0, 0, 0, '');
      //±×·ì ¿äÃ»ÀÚ ÇØÁ¦
      GroupRequester := '';
      exit;
   end;

   ////////////////////////////////////////////////////////////////
   // ÆÄ¶ó¹ÌÅÍ·Î ¿Â ±×·ì ¿äÃ»ÀÚ°¡ ÀúÀåµÈ ¿äÃ»ÀÚ¿Í ´Ù¸£¸é ½ÇÆÐ(sonmg)
   if (GroupRequester = '') or (withwho <> GroupRequester) then begin
      who.SendDefMessage (SM_CREATEGROUP_FAIL, -2, 0, 0, 0, '');
      //±×·ì ¿äÃ»ÀÚ ÇØÁ¦
      GroupRequester := '';
      exit;
   end;

   //±×·ì ¿äÃ»ÀÚ ÇØÁ¦
   GroupRequester := '';
   ////////////////////////////////////////////////////////////////

   who.GroupMembers.Clear;
   who.GroupMembers.AddObject (withwho, who);
   who.GroupMembers.AddObject (UserName, self);
   who.EnterGroup (who);
   EnterGroup (who);
   who.AllowGroup := TRUE;

   who.SendDefMessage (SM_CREATEGROUP_OK, 0, 0, 0, 0, '');
   who.RefreshGroupMembers;
end;

procedure TUserHuman.ServerGetCreateGroupRequestFail;
var
   who : TUserHuman;
begin
   who := UserEngine.GetUserHuman(GroupRequester);

   //±×·ì ¿äÃ»ÀÚ ÇØÁ¦
   GroupRequester := '';

   if who = nil then exit;

   //±×·ì °ÅºÎ ¸Þ½ÃÁö
   who.SysMsg(UserName + '¾Ü¾ø¼ÓÈë¶ÓÎé',0);
end;

procedure TUserHuman.ServerGetCreateGroupRequestFail1;
var
   who : TUserHuman;
begin
   who := UserEngine.GetUserHuman(GroupRequester);

   //±×·ì ¿äÃ»ÀÚ ÇØÁ¦
   GroupRequester := '';

   if who = nil then exit;

   //±×·ì °ÅºÎ ¸Þ½ÃÁö
   who.SysMsg(UserName + 'Î´ÏìÓ¦×é¶ÓÇëÇó',0);
end;

//±×·ì¿¡ Âü°¡
procedure TUserHuman.ServerGetAddGroupMember (withwho: string);
var
   who: TUserHuman;
   i: integer;
begin
   who := UserEngine.GetUserHuman (withwho);
   if GroupOwner <> self then begin
      SendDefMessage (SM_GROUPADDMEM_FAIL, -1, 0, 0, 0, '');
      exit;
   end;
   if GroupMembers.Count >= GROUPMAX then begin
      SendDefMessage (SM_GROUPADDMEM_FAIL, -5, 0, 0, 0, ''); //full
      exit;
   end;

   if (who = nil) or (who = self) then begin
      SendDefMessage (SM_GROUPADDMEM_FAIL, -2, 0, 0, 0, '');
      exit;
   end;
   // 2003/07/23
   if (self.LoginSign = FALSE) or (who.LoginSign = FALSE) then begin
      SendDefMessage (SM_GROUPADDMEM_FAIL, -2, 0, 0, 0, '');
      exit;
   end;

   // 2003/05/02 ±×·ì Áßº¹ ¹ö±× ÆÐÄ¡
   for i := 0 to GroupMembers.Count - 1 do begin // ¹ö±×ÆÐÄ¡
      // PDS -- Nil Check
      if (GroupMembers.Objects[i] = nil ) then
      begin
         svMain.MainOutMessage('ERROR: GROUP MEMBER IS NIL');
      end
      else
      begin
         if CompareText(TCreature(GroupMembers.Objects[i]).UserName, who.UserName) = 0 then begin
            SendDefMessage(SM_GROUPADDMEM_FAIL, -3, 0, 0, 0, ''); //ÀÌ¹Ì ÀÖÀ½
            exit;
         end;
      end;
   end;

   if (who.GroupOwner <> nil) or (who.LoginSign = FALSE) then begin
      SendDefMessage (SM_GROUPADDMEM_FAIL, -3, 0, 0, 0, ''); //ÀÌ¹Ì ÀÖÀ½
      exit;
   end;
   if not who.AllowGroup then begin
      SendDefMessage (SM_GROUPADDMEM_FAIL, -4, 0, 0, 0, '');
      exit;
   end;

   ////////////////////////////////////////////////////////////////
   //40ÃÊ ÀÌ»ó °æ°úÇÏ¸é ±×·ì ¿äÃ»ÀÚ¿Í ½Ã°£À» ÃÊ±âÈ­ ½ÃÅ²´Ù.(sonmg)
   if (GetTickCount < who.GroupRequestTime) or (GetTickCount - who.GroupRequestTime > 40 * 1000) then begin
      who.GroupRequester := '';
   end;

   // ±×·ì ¿äÃ»À» ¹Þ°í ÀÖ´Â Áß(sonmg)
   if who.GroupRequester <> '' then begin
      SendDefMessage (SM_CREATEGROUP_FAIL, -5, 0, 0, 0, '');
      exit;
   end;

   //±×·ì ¿äÃ»ÀÚ ±â·Ï
   who.GroupRequester := UserName;
   //±×·ì ¿äÃ» ¹ÞÀº ½Ã°£ ±â·Ï
   who.GroupRequestTime := GetCurrentTime;

   who.SendDefMessage (SM_ADDGROUPMEMBERREQ, 0, 0, 0, 0, UserName);

   ////////////////////////
   exit;       ////////////
   ////////////////////////
   ////////////////////////////////////////////////////////////////

{
   GroupMembers.AddObject (withwho, who);
   who.EnterGroup (self);
   SendDefMessage (SM_GROUPADDMEM_OK, 0, 0, 0, 0, '');
   RefreshGroupMembers;
}
end;

procedure TUserHuman.ServerGetAddGroupMemberRequestOk (withwho: string);
var
   who: TUserHuman;
   i: integer;
begin
   who := UserEngine.GetUserHuman (withwho);
   if who = nil then exit;

   if who.GroupOwner <> who then begin
      who.SendDefMessage (SM_GROUPADDMEM_FAIL, -1, 0, 0, 0, '');
      //±×·ì ¿äÃ»ÀÚ ÇØÁ¦
      GroupRequester := '';
      exit;
   end;
   if who.GroupMembers.Count >= GROUPMAX then begin
      who.SendDefMessage (SM_GROUPADDMEM_FAIL, -5, 0, 0, 0, ''); //full
      //±×·ì ¿äÃ»ÀÚ ÇØÁ¦
      GroupRequester := '';
      exit;
   end;

   if (who = nil) or (who = self) then begin
      who.SendDefMessage (SM_GROUPADDMEM_FAIL, -2, 0, 0, 0, '');
      //±×·ì ¿äÃ»ÀÚ ÇØÁ¦
      GroupRequester := '';
      exit;
   end;
   // 2003/07/23
   if (who.LoginSign = FALSE) or (self.LoginSign = FALSE) then begin
      who.SendDefMessage (SM_GROUPADDMEM_FAIL, -2, 0, 0, 0, '');
      //±×·ì ¿äÃ»ÀÚ ÇØÁ¦
      GroupRequester := '';
      exit;
   end;

   // 2003/05/02 ±×·ì Áßº¹ ¹ö±× ÆÐÄ¡
   for i := 0 to who.GroupMembers.Count - 1 do begin // ¹ö±×ÆÐÄ¡
      // PDS -- Nil Check
      if (who.GroupMembers.Objects[i] = nil ) then
      begin
         svMain.MainOutMessage('ERROR: GROUP MEMBER IS NIL');
      end
      else
      begin
         if CompareText(TCreature(who.GroupMembers.Objects[i]).UserName, UserName) = 0 then begin
            who.SendDefMessage(SM_GROUPADDMEM_FAIL, -3, 0, 0, 0, ''); //ÀÌ¹Ì ÀÖÀ½
            //±×·ì ¿äÃ»ÀÚ ÇØÁ¦
            GroupRequester := '';
            exit;
         end;
      end;
   end;

   if (GroupOwner <> nil) or (LoginSign = FALSE) then begin
      who.SendDefMessage (SM_GROUPADDMEM_FAIL, -3, 0, 0, 0, ''); //ÀÌ¹Ì ÀÖÀ½
      //±×·ì ¿äÃ»ÀÚ ÇØÁ¦
      GroupRequester := '';
      exit;
   end;
   if not AllowGroup then begin
      who.SendDefMessage (SM_GROUPADDMEM_FAIL, -4, 0, 0, 0, '');
      //±×·ì ¿äÃ»ÀÚ ÇØÁ¦
      GroupRequester := '';
      exit;
   end;

   ////////////////////////////////////////////////////////////////
   // ÆÄ¶ó¹ÌÅÍ·Î ¿Â ±×·ì ¿äÃ»ÀÚ°¡ ÀúÀåµÈ ¿äÃ»ÀÚ¿Í ´Ù¸£¸é ½ÇÆÐ(sonmg)
   if (GroupRequester = '') or (withwho <> GroupRequester) then begin
      who.SendDefMessage (SM_CREATEGROUP_FAIL, -2, 0, 0, 0, '');
      //±×·ì ¿äÃ»ÀÚ ÇØÁ¦
      GroupRequester := '';
      exit;
   end;

   //±×·ì ¿äÃ»ÀÚ ÇØÁ¦
   GroupRequester := '';
   ////////////////////////////////////////////////////////////////

   who.GroupMembers.AddObject (UserName, self);
   EnterGroup (who);
   who.SendDefMessage (SM_GROUPADDMEM_OK, 0, 0, 0, 0, '');
   who.RefreshGroupMembers;
end;

procedure TUserHuman.ServerGetAddGroupMemberRequestFail;
var
   who : TUserHuman;
begin
   who := UserEngine.GetUserHuman(GroupRequester);

   //±×·ì ¿äÃ»ÀÚ ÇØÁ¦
   GroupRequester := '';

   if who = nil then exit;

   //±×·ì °ÅºÎ ¸Þ½ÃÁö
   who.SysMsg(UserName + '¾Ü¾ø¼ÓÈë¶ÓÎé',0);
end;

procedure TUserHuman.ServerGetCreateGroupRequestFail2;
var
   who : TUserHuman;
begin
   who := UserEngine.GetUserHuman(GroupRequester);

   //±×·ì ¿äÃ»ÀÚ ÇØÁ¦
   GroupRequester := '';

   if who = nil then exit;

   //±×·ì °ÅºÎ ¸Þ½ÃÁö
   who.SysMsg(UserName + 'Î´ÏìÓ¦×é¶ÓÇëÇó',0);
end;

procedure TUserHuman.ServerGetDelGroupMember (withwho: string);
var
   i: integer;
   who: TUserHuman;
begin
   who := UserEngine.GetUserHuman (withwho);
   if GroupOwner <> self then begin
      SendDefMessage (SM_GROUPDELMEM_FAIL, -1, 0, 0, 0, '');
      exit;
   end;
   if who = nil then begin
      SendDefMessage (SM_GROUPDELMEM_FAIL, -2, 0, 0, 0, '');
      exit;
   end;
   if not IsGroupMember (who) then begin
      SendDefMessage (SM_GROUPDELMEM_FAIL, -3, 0, 0, 0, '');
      exit;
   end;
   DelGroupMember (who);
   SendDefMessage (SM_GROUPDELMEM_OK, 0, 0, 0, 0, withwho);
end;

procedure TUserHuman.ServerGetDealTry (withwho: string);
var
   cret: TCreature;
begin
   if BoGhost then begin
      MainOutMessage('Ghost tried ServerGetDealTry!!!');
//      exit;
   end;
   if BoDealing then exit; //ÀÌ¹Ì °Å·¡Áß
   cret := GetFrontCret;
   if (cret <> nil) and (cret <> self) and (not cret.BoGhost) and (not cret.Death) then begin //¾Õ¿¡ ´©°¡ ÀÖ¾î¾ßÇÏ°í
      if (cret.GetFrontCret = self) and (not cret.BoDealing) then begin //¸¶ÁÖº¸°í ÀÖ¾î¾ßÇÏ°í, ÀÌ¹Ì °Å·¡ÁßÀÌ¸é ¾ÈµÊ.
         if cret.RaceServer = RC_USERHUMAN then begin
            if cret.BoExchangeAvailable then begin
               if BoGuildAgitDealTry then begin // Àå¿ø °Å·¡ ½Ãµµ(sonmg)
                  if IsGuildMaster then begin   // ¹®ÁÖÀÌ¸é
                     if cret.IsGuildMaster then begin
                        //»ó´ë¹æ Àå¿ø °Å·¡ ÇÃ·¡±× Ã¼Å©(sonmg)
                        cret.BoGuildAgitDealTry := TRUE;
                        // ¸Þ½ÃÁö ¹Ú½º¸¦ ¶ç¿î´Ù.
                        cret.BoxMsg(UserName + ' ºÍÄã¿ªÊ¼½»Ò×ÁË¡£1', 0);
                        BoxMsg(cret.UserName + ' ºÍÄã¿ªÊ¼½»Ò×ÁË¡£2', 0);
                        StartDeal (TUserHuman(cret));
                        TUserHuman(cret).StartDeal(self);
                     end else begin
                        cret.SysMsg('»¹Ã»·­Òë¹ýÀ´', 0);
                        SysMsg('¶Ô·½¾Ü¾øºÍÄú½»Ò×¡£', 0);
                        BoGuildAgitDealTry := FALSE;  //Àå¿ø°Å·¡Ãë¼Ò.
                     end;
                  end else begin
                     SysMsg('Õâ¾ä»°Òª¿´ÁË²ÅÖªµÀ', 0);
                     cret.SysMsg('Õâ¾ä»°Ò²Òª¿´ÁË²ÅÖªµÀ', 0);
                     BoGuildAgitDealTry := FALSE;  //Àå¿ø°Å·¡Ãë¼Ò.
                  end;
               end else begin
                  //±³È¯ ´ÙÀÌ¾ó·Î±× º¸³½´Ù.
                  cret.SysMsg (UserName + ' ºÍÄã¿ªÊ¼½»Ò×ÁË¡£', 1);
                  SysMsg (cret.UserName + ' ºÍÄã¿ªÊ¼½»Ò×ÁË¡£', 1);
                  StartDeal (TUserHuman(cret));
                  TUserHuman(cret).StartDeal(self);
               end;
            end else
               SysMsg ('¶Ô·½¾Ü¾øºÍÄã½»Ò×¡£', 1);
         end;
      end else
         SendDefMessage (SM_DEALTRY_FAIL, 0, 0, 0, 0, '');
   end else
      SendDefMessage (SM_DEALTRY_FAIL, 0, 0, 0, 0, '');
end;

procedure TUserHuman.ResetDeal;
var
   i, temp: integer;
   ps: PTStdItem;
begin
   if DealList.Count > 0 then begin
      for i:=DealList.Count-1 downto 0 do begin
         ps := UserEngine.GetStdItem(PTUserItem(DealList[i]).Index);
         if ps = nil then continue;

         //sonmg Ãß°¡
         if ps.OverlapItem <= 0 then
            ItemList.Add (DealList[i]); //±×·¡·Î À§Ä¡ ÀÌµ¿
      end;
      DealList.Clear;
   end;
//   Gold := Gold + DealGold;
   IncGold( DealGold );
   DealGold := 0;
   BoDealSelect := FALSE;
end;

procedure TUserHuman.StartDeal (who: TUserHuman);
begin
   BoDealing := TRUE;
   DealCret := who;
   ResetDeal;
   if BoGuildAgitDealTry then begin
      SendDefMessage (SM_GUILDAGITDEALMENU, 0, 0, 0, 0, who.UserName);
   end else begin
      SendDefMessage (SM_DEALMENU, 0, 0, 0, 0, who.UserName);
   end;
   DealItemChangeTime := GetTickCount; //
end;

procedure TUserHuman.BrokeDeal;
var
   pu, pu_org: PTUserItem;
   ps, ps_org: PTStdItem;
   i, j: integer;
begin
   if BoDealEnding then exit; //°Å·¡ ¼º»ç ÁßÀÌ¸é Ãë¼ÒÇÒ ¼ö ¾ø°Ô...
   if BoDealing then begin
      BoDealing := FALSE;
      SendDefMessage (SM_DEALCANCEL, 0, 0, 0, 0, '');

      ///////////////////////
      // sonmg Ãß°¡.
      if DealList.Count > 0 then begin
         for i:=DealList.Count-1 downto 0 do begin
            pu := PTUserItem(DealList[i]);
            ps := UserEngine.GetStdItem(pu.Index);
            if ps = nil then continue;

            // 2003/12/22 °©ÀÛ½º·± ¹ö±× ÆÐÄ¡
            // °¡¹æÀÌ ²Ë Â÷ÀÖ°í °Å·¡ Ãë¼ÒµÈ ¾ÆÀÌÅÛÀÌ Ä«¿îÆ® ¾ÆÀÌÅÛÀÌ¸é...(sonmg)
            if (ps.OverlapItem >= 1) then begin
               // °¡¹æÃ¢¿¡ ÀÖ´Â ÇØ´ç ¾ÆÀÌÅÛ¿¡ Ä«¿îÆ®¸¦ ÇÕ»êÇÑ´Ù.
               if UserCounterItemAdd(ps.StdMode, ps.Looks, pu.Dura, ps.Name, TRUE) then begin

{
               // °¡¹æÃ¢À» °Ë»öÇØ¼­ °°Àº ÀÌ¸§À» Ã£¾Æ³½´Ù.
               for j:=0 to ItemList.Count-1 do begin
                  pu_org := PTUserItem(ItemList[j]);
                  ps_org := UserEngine.GetStdItem (pu_org.Index);
                  if ps_org <> nil then begin
                     // ¾ÆÀÌÅÛ ÀÌ¸§ÀÌ °°À¸¸é...
                     if CompareText(ps_org.Name, ps.Name) = 0 then begin
                        // ±× ¾ÆÀÌÅÛ¿¡ Ä«¿îÆ®¸¦ ÇÕÄ£´Ù.
                        pu_org.Dura := pu_org.Dura + pu.Dura;  // Ä«¿îÆ® ÅëÇÕ
                        SendMsg(self, RM_COUNTERITEMCHANGE, 0, pu_org.MakeIndex, pu_org.Dura, 0, ps_org.Name);
                        break;
                     end;
                  end;
               end;
}

               // ÇØ´ç ÀÌ¸§ÀÇ ¾ÆÀÌÅÛÀÌ ¾ø°Å³ª ½ÇÆÐÇßÀ¸¸é ¾ÆÀÌÅÛ ¸®½ºÆ®¿¡ »õ·Î Ãß°¡.
               // ÁÖÀÇ : °¡¹æÀÌ °¡µæÃ¡À»¶§´Â...
               // (¿¹ : Ä«¿îÆ® ¾ÆÀÌÅÛÀÇ MAX¸¦ ¿Ã·ÈÀ» °æ¿ì)
//               if j = ItemList.Count then begin
               end else begin
                  ItemList.Add (DealList[i]); //±×·¡·Î À§Ä¡ ÀÌµ¿
                  SendAddItem (TUserItem(DealList[i]^));
               end;
            end;
         end;
      end;
      ///////////////////////

      if DealCret <> nil then begin
         TUserHuman(DealCret).DealCret := nil;
         if DealCret <> nil then
            TUserHuman(DealCret).BrokeDeal;
      end;
      DealCret := nil;
      ResetDeal;
      SysMsg ('½»Ò×È¡Ïû', 1);
      DealItemChangeTime := GetTickCount; //

      BoGuildAgitDealTry := FALSE;  //Àå¿ø°Å·¡Ãë¼Ò.
   end;
end;

procedure TUserHuman.ServerGetDealCancel;
begin
   BrokeDeal;
end;

procedure TUserHuman.AddDealItem (uitem: TUserItem; remain: integer);
var
   citem: TClientItem;
   ps: PTStdItem;
   std: TStdItem;
begin
   SendDefMessage (SM_DEALADDITEM_OK, uitem.MakeIndex, remain, 0, 0, '');
   if DealCret <> nil then begin
      ps := UserEngine.GetStdItem (uitem.Index);
      if ps <> nil then begin
         std := ps^;
         citem.UpgradeOpt := ItemMan.GetUpgradeStdItem (uitem, std);
         citem.S := std;

         //¹ÌÁöÀÇ¼Ó¼º ÇÁ¸® ¾ÈµÈ °Íµé ¼û±â±â
         if std.StdMode in [15,19,20,21,22,23,24,26,52,53,54] then begin
            if uitem.Desc[8] = 0 then begin //¼Ó¼ºÀÌ ÇÁ¸®µÊ(sonmg 2005/04/07 ¼öÁ¤)
               citem.S.ItemDesc := citem.S.ItemDesc and (not IDC_UNIDENTIFIED);//$01;
            end else begin
               citem.S.ItemDesc := citem.S.ItemDesc or IDC_UNIDENTIFIED;//$01;
            end;
         end;

         citem.MakeIndex := uitem.MakeIndex;
         citem.Dura := uitem.Dura;
         citem.DuraMax := uitem.DuraMax;
      end;
      Def := MakeDefaultMsg (SM_DEALREMOTEADDITEM, integer(self), 0, 0, 1);
      TUserHuman(DealCret).SendSocket (@Def, EncodeBuffer (@citem, sizeof(TClientItem)));
      TUserHuman(DealCret).DealItemChangeTime := GetTickCount;
      DealItemChangeTime := GetTickCount;
   end;
end;

procedure TUserHuman.DelDealItem (uitem: TUserItem);
var
   citem: TClientItem;
   ps: PTStdItem;
begin
   SendDefMessage (SM_DEALDELITEM_OK, 0, 0, 0, 0, '');
   if DealCret <> nil then begin
      ps := UserEngine.GetStdItem (uitem.Index);
      if ps <> nil then begin
         citem.S := ps^;
         citem.UpgradeOpt := 0;

         //¹ÌÁöÀÇ¼Ó¼º ÇÁ¸® ¾ÈµÈ °Íµé ¼û±â±â
         if ps.StdMode in [15,19,20,21,22,23,24,26,52,53,54] then begin
            if uitem.Desc[8] = 0 then begin //¼Ó¼ºÀÌ ÇÁ¸®µÊ(sonmg 2005/04/07 ¼öÁ¤)
               citem.S.ItemDesc := citem.S.ItemDesc and (not IDC_UNIDENTIFIED);//$01;
            end else begin
               citem.S.ItemDesc := citem.S.ItemDesc or IDC_UNIDENTIFIED;//$01;
            end;
         end;

         citem.MakeIndex := uitem.MakeIndex;
         citem.Dura := uitem.Dura;
         citem.DuraMax := uitem.DuraMax;
      end;
      Def := MakeDefaultMsg (SM_DEALREMOTEDELITEM, integer(self), 0, 0, 1);
      TUserHuman(DealCret).SendSocket (@Def, EncodeBuffer (@citem, sizeof(TClientItem)));
      TUserHuman(DealCret).DealItemChangeTime := GetTickCount;
      DealItemChangeTime := GetTickCount;
   end;
end;

procedure TUserHuman.AddDealCounterItem (uitem: TUserItem; remain: integer);
var
   i: Integer;
   puAdd: PTUserItem;
   ps, psAdd: PTStdItem;
begin
   puAdd := nil;
   psAdd := nil;

   if DealCret <> nil then begin
      psAdd := UserEngine.GetStdItem (uitem.Index);
      if psAdd <> nil then begin
         for i := 0 to DealList.Count - 1 do begin
            ps := UserEngine.GetStdItem(PTUserItem(DealList[i]).Index);

            if ps = nil then continue;
            if ps.OverlapItem = 0 then continue;
            if (ps.StdMode = psAdd.StdMode) and (ps.Looks = psAdd.Looks) and (ps.OverlapItem >= 1) then begin
               if CompareText(ps.Name, psAdd.Name) = 0 then begin
                  puAdd := PTUserItem(DealList[i]);
                  break;
               end;
            end;
         end;

         if puAdd <> nil then begin
            Def := MakeDefaultMsg (SM_COUNTERITEMCHANGE, puAdd.MakeIndex, puAdd.Dura, 0, 0);
            TUserHuman(DealCret).SendSocket (@Def, EncodeString (psAdd.Name));

            TUserHuman(DealCret).DealItemChangeTime := GetTickCount;
            DealItemChangeTime := GetTickCount;
         end;
      end;
   end;
end;

procedure TUserHuman.DelDealCounterItem (uitem: TUserItem);
var
   ps: PTStdItem;
begin
   if DealCret <> nil then begin
      ps := UserEngine.GetStdItem (uitem.Index);
      if ps <> nil then begin

         Def := MakeDefaultMsg (SM_COUNTERITEMCHANGE, uitem.MakeIndex, uitem.Dura, 0, 0);
         TUserHuman(DealCret).SendSocket (@Def, EncodeString (ps.Name));

         TUserHuman(DealCret).DealItemChangeTime := GetTickCount;
         DealItemChangeTime := GetTickCount;
      end;
   end;
end;


function  TUserHuman.IsReservedMakingSlave: Boolean;
var
   i: integer;
	pmsg: PTMessageInfoPtr;
begin
   Result := FALSE;
    // 2003/06/12 ½½·¹ÀÌºê ÆÐÄ¡
    if PrevServerSlaves.Count > 0 then   //¼ÒÈ¯ ÇØ¾ßÇÒ ºÎÇÏ°¡ ÀÖÀ½
       Result := TRUE;
    {
    for i:=0 to MsgList.Count-1 do begin
       pmsg := MsgList[i];
       if pmsg.Ident = RM_MAKE_SLAVE then begin
          Result := TRUE;
          break;
       end;
    end;
    }
end;


procedure TUserHuman.ServerGetDealAddItem (iidx, count: integer; iname: string);
var
   i, k, iOldCount: integer;
   flag: Boolean;
   pstd, psDeal: PTStdItem;
   newpu: PTUserItem;
   iRet: Integer;
begin
   iRet := 0;

   //±³È¯ »ó´ë°¡ ¾Õ¿¡ ÀÖ´ÂÁö, ¾øÀ¸¸é °Å·¡ Ãë¼Ò
   if (DealCret <> nil) then begin
      if pos(' ', iname) >= 0 then
         GetValidStr3 (iname, iname, [' ']);
      flag := FALSE;
      if not DealCret.BoDealSelect then
         for i:=0 to ItemList.Count-1 do begin
            pstd := UserEngine.GetStdItem (PTUserItem(ItemList[i]).Index);
            if pstd <> nil then begin   //±³È¯ÀÌ ¾ÈµÇ´Â ÀÌº¥Æ® ¾ÆÀÌÅÛÀº Á¦¿Ü
               if (pstd.UniqueItem and $08) <> 0 then continue; //UNIQUEITEM ÇÊµå°¡ 00001000(2Áø¼ö)¸¦ Æ÷ÇÔÇÏ¸é ±³È¯ ¹× »óÁ¡°Å·¡ ÇÒ ¼ö ¾ø´Â ¾ÆÀÌÅÛ(sonmg 2005/03/14)
               if pstd.StdMode <> TAIWANEVENTITEM then begin
                  if PTUserItem(ItemList[i]).MakeIndex = iidx then
                     if CompareText (UserEngine.GetStdItemName (PTUserItem(ItemList[i]).Index), iname) = 0 then begin
                        if DealList.Count < MAXDEALITEM then begin
                           //Ä«¿îÆ® ¾ÆÀÌÅÛ.
                           if pstd.OverlapItem >= 1 then begin
                              if (count > 0) and (count <= MAX_OVERLAPITEM) then begin
                                 psDeal := UserEngine.GetStdItem (PTUserItem(ItemList[i]).Index);
                                 iOldCount := PTUserItem(ItemList[i]).Dura;

                                 iRet := UserCounterDealItemAdd(psDeal.StdMode, psDeal.Looks, count, psDeal.Name);
                                 if iRet = 1 then begin  // Success
                                    //DealÃ¢¿¡ ÇØ´ç Ä«¿îÆ® ¾ÆÀÌÅÛÀÌ ÀÖÀ¸¸é...
                                    // ÀÏºÎ Ãß°¡
                                    if iOldCount - count > 0 then begin
                                       //°¡¹æ Ã¢¿¡ ÀÖ´Â ¾ÆÀÌÅÛÀÇ Count¸¦ °¨¼Ò½ÃÅ²´Ù.
                                       PTUserItem(ItemList[i]).Dura := iOldCount - count;
                                       AddDealCounterItem(PTUserItem(ItemList[i])^, 0);
                                    // ÀüºÎ Ãß°¡
                                    end else if iOldCount - count = 0 then begin
                                       AddDealCounterItem(PTUserItem(ItemList[i])^, 0);
                                       //°¡¹æ Ã¢¿¡ ÀÖ´Â ¾ÆÀÌÅÛ »èÁ¦
                                       ItemList.Delete(i);
                                    end else begin
                                    end;

                                    flag := TRUE;
                                    CalcBagWeight;
                                    break;
                                 // MAX_OVERFLOW¸¦ ³Ñ¾úÀ» ¶§
                                 end else if iRet = 2 then begin  // Overflow
                                    flag := FALSE;
                                    break;
                                 // ÃÖ´ë ¾ÆÀÌÅÛ °³¼ö¸¦ ³Ñ¾úÀ» ¶§
                                 end else if iRet = 3 then begin  // OverCount
                                    flag := FALSE;
                                    SysMsg(IntToStr(MAX_OVERLAPITEM) + '¶à¸öÎÞ·¨', 0);
                                    break;
                                 end else begin
                                    //DealList¿¡ ÇØ´ç Ä«¿îÆ® ¾ÆÀÌÅÛÀÌ ¾øÀ¸¸é...
                                    // Ã³À½ ÀÏºÎ Ãß°¡
                                    if iOldCount - count > 0 then begin
                                       new(newpu);
                                       if UserEngine.CopyToUserItemFromName(iname, newpu^) then begin
                                          newpu.Dura := count;
                                          DealList.Add(newpu);
                                          PTUserItem(ItemList[i]).Dura := iOldCount - count;
                                          AddDealItem(newpu^, iOldCount - count);
                                       end else begin
                                          Dispose(newpu);
                                       end;
                                    // Ã³À½ ÀüºÎ Ãß°¡
                                    end else if iOldCount - count = 0 then begin
                                       DealList.Add(ItemList[i]);
                                       AddDealItem(PTUserItem(ItemList[i])^, 0);
                                       ItemList.Delete(i);
                                    end;
                                 end;
                              end else begin
                                 // count°¡ MAX_OVERLAPITEMº¸´Ù Å©¸é ¸Þ½ÃÁö º¸³¿.
                                 if count > MAX_OVERLAPITEM then
                                    SysMsg(IntToStr(MAX_OVERLAPITEM) + '°³ ÀÌ»ó ¿Ã¸± ¼ö ¾ø½À´Ï´Ù.', 0);

                                 // count°¡ 0 ÀÌÇÏÀÌ¸é ¸Þ½ÃÁö¸¦ º¸ÀÌÁö ¾Ê°í ±×³É ºüÁ®³ª°¨.
                                 break;
                              end;
                           //ÀÏ¹Ý ¾ÆÀÌÅÛ.
                           end else begin
                              DealList.Add (ItemList[i]);
                              AddDealItem (PTUserItem(ItemList[i])^, 0);
                              ItemList.Delete (i);
                           end;
                           flag := TRUE;
                           CalcBagWeight;
                           break;
                        end;
                     end;
               end;
            end;
         end;
      if not flag then
         SendDefMessage (SM_DEALADDITEM_FAIL, 0, 0, 0, 0, '');
   end;
end;

procedure TUserHuman.ServerGetDealDelItem (iidx: integer; iname: string);
var
   i, temp: integer;
   flag: Boolean;
   pu: PTUserItem;
   ps: PTStdItem;
begin
   //±³È¯ »ó´ë°¡ ¾Õ¿¡ ÀÖ´ÂÁö, ¾øÀ¸¸é °Å·¡ Ãë¼Ò
   if (DealCret <> nil) then begin
      if pos(' ', iname) >= 0 then
         GetValidStr3 (iname, iname, [' ']);
      flag := FALSE;
      if not DealCret.BoDealSelect then
         for i:=0 to DealList.Count-1 do begin
            pu := PTUserItem (DealList[i]);
            if pu.MakeIndex = iidx then
               if CompareText (UserEngine.GetStdItemName (pu.Index), iname) = 0 then begin
                  ps := UserEngine.GetStdItem (pu.Index);
                  if ps <> nil then begin
                     //Ä«¿îÆ® ¾ÆÀÌÅÛ.
                     if ps.OverlapItem >= 1 then begin
                        // °°Àº Á¾·ùÀÇ ÃÖ¼Ò °³¼ö ¾ÆÀÌÅÛ¿¡ ÇÕ»ê.
                        // µé°í ÀÖ´Â ¾ÆÀÌÅÛÀº ÃÖ¼Ò °³¼ö ¾ÆÀÌÅÛ °Ë»ç¿¡¼­ Á¦¿Ü.
                        if UserCounterItemAdd(ps.StdMode, ps.Looks, pu.Dura, ps.Name, TRUE, pu.MakeIndex) then begin
                           DelDealItem(pu^);
                           DealList.Delete(i);
                           flag := TRUE;
                           break;
                        end else begin
                           ItemList.Add (DealList[i]); //±×·¡·Î À§Ä¡ ÀÌµ¿
                           SendAddItem (TUserItem(DealList[i]^));
                           DelDealItem(pu^);
                           DealList.Delete(i);
                           flag := TRUE;
                           break;
                        end;
                     end else begin
                        ItemList.Add(DealList[i]);
                        DelDealItem(pu^);
                        DealList.Delete(i);
                        flag := TRUE;
                        break;
                     end;
                  end;
               end;
         end;
      if not flag then
         SendDefMessage (SM_DEALDELITEM_FAIL, 0, 0, 0, 0, '');
   end;
end;

procedure TUserHuman.ServerGetDealChangeGold (dgold: integer);
var
   flag: Boolean;
begin
   // sonmg 2005/06/22
   if not BoDealing then exit;

   if dgold < 0 then begin
      SendDefMessage (SM_DEALCHGGOLD_FAIL, DealGold, Loword(Gold), Hiword(Gold), 0, '');
      exit;
   end;

   if DealGold > 0 then begin
      boxmsg( '½»Ò×Í¾ÖÐ²»ÄÜ¸Ä±ä½ð¶î', 1 );
      exit;
   end;

   flag := FALSE;
   if (GetFrontCret = DealCret) and (DealCret <> nil) and (UserName <> DealCret.UserName) then
      if not DealCret.BoDealSelect then begin //»ó´ë¹æÀÌ ¼±ÅÃ ¿Ï·á
         if self.Gold + DealGold >= dgold then begin
//            self.Gold := (self.Gold + DealGold) - dgold;
            self.IncGold( DealGold );
            self.DecGold( dgold );
            DealGold := dgold;
            SendDefMessage (SM_DEALCHGGOLD_OK, DealGold, Loword(Gold), Hiword(Gold), 0, '');
            if DealCret <> nil then begin
               TUserHuman(DealCret).SendDefMessage (SM_DEALREMOTECHGGOLD, DealGold, 0, 0, 0, '');
               TUserHuman(DealCret).DealItemChangeTime := GetTickCount;
            end;
            flag := TRUE;
            DealItemChangeTime := GetTickCount;
         end;
       end;
   if not flag then
      SendDefMessage (SM_DEALCHGGOLD_FAIL, DealGold, Loword(Gold), Hiword(Gold), 0, '');
end;

procedure TUserHuman.ServerGetDealEnd;
var
   i, temp, j: integer;
   pu, pu_org: PTUserItem;
   ps, ps_org: PTStdItem;
   flag: Boolean;
   agitnumber : integer;
begin
  // BoDealEnding := TRUE;          //½»Ò×¹ý¿ì²»¹Ø±Õ½»Ò×£¬
   BoDealSelect := TRUE; //±³È¯ ¹öÆ°À» ´©¸§
   if BoDealing and (DealCret <> nil) then begin
      if (GetTickCount - DealItemChangeTime < 1000) or (GetTickCount - DealCret.DealItemChangeTime < 1000) then begin
         //°Å·¡ Á÷Àü 1ÃÊÀÌÀü¿¡ ¹°°ÇÀÇ ÀÌµ¿ÀÌ ÀÖ¾úÀ½.
         SysMsg ('Äã¹ýÔçµÄµãÁË½»Ò×°´Å¥¡£', 0);
         BrokeDeal;  //°Å·¡°¡ Ãë¼Ò
       //  BoDealEnding := FALSE;              //½»Ò×¹ý¿ì²»¹Ø±Õ½»Ò×£¬
         exit;
      end;
      if DealCret.BoDealSelect then begin //µÑ´Ù ´©¸§, ±³È¯ ½ÃÀÛ..
         flag := TRUE;
         //³»°¡ ±³È¯Ç°À» ¹ÞÀ» ¸¸Å­ °¡¹æ¿¡ ·ëÀÌ ÀÖ´ÂÁö °Ë»ç..
         if MAXBAGITEM - Itemlist.Count < TUserHuman(DealCret).DealList.Count then flag := FALSE;
         if AvailableGold - Gold < TUserHuman(DealCret).DealGold then flag := FALSE;
         //»ó´ë°¡ ±³È¯Ç°À» ¹ÞÀ» ¸¸Å­ °¡¹æ¿¡ ·ëÀÌ ÀÖ´ÂÁö °Ë»ç..
         if MAXBAGITEM - TUserHuman(DealCret).Itemlist.Count < DealList.Count then flag := FALSE;
         if TUserHuman(DealCret).AvailableGold - TUserHuman(DealCret).Gold < DealGold then flag := FALSE;

         if flag then begin
            //Àå¿ø °Å·¡.
            if BoGuildAgitDealTry then begin
               agitnumber := ExecuteGuildAgitTrade;
               if agitnumber > -1 then begin
                  //·Î±×³²±è
                  AddUserLog ('41'#9 + //Àå°Å·¡_
                              MapName + ''#9 +
                              IntToStr(CX) + ''#9 +
                              IntToStr(CY) + ''#9 +
                              UserName + ''#9 +
                              TGuild(MyGuild).GuildName + ''#9 +
                              IntToStr(agitnumber) + ''#9 +
                              '1'#9 +
                              DealCret.UserName);
//                              TGuild(DealCret.MyGuild).GuildName);

                  UserEngine.SendInterMsg (ISM_RELOADGUILDAGIT, ServerIndex, '');
                  BoGuildAgitDealTry := FALSE;  //Àå¿ø°Å·¡¿Ï·á.
               end else begin
                  BrokeDeal;  //°Å·¡°¡ Ãë¼Ò
                  BoDealEnding := FALSE;
                  exit;
               end;
            end;

            //»ó´ë°¡ °Å·¡ÁßÀÎÁö °Ë»ç(sonmg 2006/03/06)
            if DealCret.BoDealing then begin
               //³» ±³È¯Ç°À» »ó´ë¿¡°Ô ÁÜ.
               for i:=0 to DealList.Count-1 do begin
                  pu := PTUserItem (DealList[i]);
                  TUserHuman(DealCret).AddItem (pu);
                  TUserHuman(DealCret).SendAddItem (pu^);
                  ps := UserEngine.GetStdItem (pu.Index);
                  if ps <> nil then begin
                     //·Î±×³²±è
                     if not IsCheapStuff (ps.StdMode) then
                        AddUserLog ('8'#9 + //±³È¯_ +
                                    MapName + ''#9 +
                                    IntToStr(CX) + ''#9 +
                                    IntToStr(CY) + ''#9 +
                                    UserName + ''#9 +
                                    UserEngine.GetStdItemName (pu.Index) + ''#9 +
                                    IntToStr(pu.MakeIndex) + ''#9 +
                                    '1'#9 +
                                    DealCret.UserName);
                  end;
               end;
               if DealGold > 0 then begin
   //               DealCret.Gold := DealCret.Gold + DealGold;
                  DealCret.IncGold( DealGold );
                  DealCret.GoldChanged;
                  //·Î±×³²±è
                  AddUserLog ('8'#9 + //±³È¯_ +
                              MapName + ''#9 +
                              IntToStr(CX) + ''#9 +
                              IntToStr(CY) + ''#9 +
                              UserName + ''#9 +
                              NAME_OF_GOLD{'±ÝÀü'} + ''#9 +
                              IntToStr(DealGold) + ''#9 +
                              '1'#9 +
                              DealCret.UserName);
               end;
               //»ó´ëÀÇ ±³È¯Ç°À» °®´Â´Ù.
               for i:=0 to DealCret.DealList.Count-1 do begin
                  pu := PTUserItem (DealCret.DealList[i]);
                  AddItem (pu);
                  SendAddItem (pu^);
                  ps := UserEngine.GetStdItem (pu.Index);
                  if ps <> nil then begin
                     //·Î±×³²±è
                     if not IsCheapStuff (ps.StdMode) then
                        AddUserLog ('8'#9 + //±³È¯_ +
                                    DealCret.MapName + ''#9 +
                                    IntToStr(DealCret.CX) + ''#9 +
                                    IntToStr(DealCret.CY) + ''#9 +
                                    DealCret.UserName + ''#9 +
                                    UserEngine.GetStdItemName (pu.Index) + ''#9 +
                                    IntToStr(pu.MakeIndex) + ''#9 +
                                    '1'#9 +
                                    UserName);
                  end;
               end;
               if DealCret.DealGold > 0 then begin
   //               Gold := Gold + DealCret.DealGold;
                  IncGold( DealCret.DealGold );
                  GoldChanged;
                  //·Î±×³²±è
                  AddUserLog ('8'#9 + //±³È¯_ +
                              DealCret.MapName + ''#9 +
                              IntToStr(DealCret.CX) + ''#9 +
                              IntToStr(DealCret.CY) + ''#9 +
                              DealCret.UserName + ''#9 +
                              NAME_OF_GOLD{'½ð±Ò'} + ''#9 +
                              IntToStr(DealCret.DealGold) + ''#9 +
                              '1'#9 +
                              UserName);
               end;
            end;

            with TUserHuman(DealCret) do begin
               SendDefMessage (SM_DEALSUCCESS, 0, 0, 0, 0, '');
               SysMsg ('½»Ò×Íê³É', 1);
               DealCret := nil;
               BoDealing := FALSE;
               DealList.Clear;
               DealGold := 0;
               WeightChanged; //¹«°Ô º¯µ¿ ¹Ý¿µ(2004/08/30)
            end;
            SendDefMessage (SM_DEALSUCCESS, 0, 0, 0, 0, '');
            SysMsg ('½»Ò×Íê³É', 1);
            DealCret := nil;
            BoDealing := FALSE;
            DealList.Clear;
            DealGold := 0;
            WeightChanged; //¹«°Ô º¯µ¿ ¹Ý¿µ(2004/08/30)
         end else begin
            BrokeDeal;  //°Å·¡°¡ Ãë¼Ò
         end;
      end else begin
         SysMsg ('ÇëÈÃ¶Ô·½°´ÏÂ³É½»°´Å¥', 1);
         DealCret.SysMsg ('¶Ô·½ÔÙ´ÎÒªÇóÄãÈ·ÈÏ½»Ò×£¬°´ÏÂ£Û½»Ò×£Ý°´Å¥È·¶¨', 1);
      end;
   end;
   BoDealEnding := FALSE;
end;

procedure TUserHuman.ServerGetWantMiniMap;
var
   i, mini: integer;
begin
   mini := PEnvir.MiniMap;

   if mini > 0 then
      SendDefMessage (SM_READMINIMAP_OK, 0, mini, 0, 0, '')
   else
      SendDefMessage (SM_READMINIMAP_FAIL, 0, 0, 0, 0, '');
end;

procedure TUserHuman.SendChangeGuildName;
begin
   if MyGuild <> nil then begin
      SendDefMessage (SM_CHANGEGUILDNAME, 0, 0, 0, 0, TGuild(MyGuild).GuildName + '/' + GuildRankName);
   end else
      SendDefMessage (SM_CHANGEGUILDNAME, 0, 0, 0, 0, '');
end;

procedure TUserHuman.ServerGetQueryUserState (who: TCreature; xx, yy: integer);
var
   i: integer;
   ustate: TUserStateInfo;
   ps: PTStdItem;
   std: TStdItem;
   citem: TClientItem;
   backupWho : TCreature;
   opt : integer;
   FameGrade: integer;
begin
try
   if CretInNearXY (who, xx, yy) then begin
      backupWho := who;

      //ºÐ½Å
      if ( who.RaceServer = RC_CLONE ) and ( Who.Master <> nil ) then begin
         if ( Who.Master.RaceServer = RC_USERHUMAN )then begin
            backupWho := Who.Master;
         end else begin
            MainOutMessage('ERROR WANT STATE NOT HUMAN');
            Exit;
         end;
      end;

      FillChar (ustate, sizeof(TUserStateInfo), #0);
      ustate.Feature := backupwho.GetRelFeature (self);
      ustate.UserName := backupwho.UserName;
      ustate.NameColor := GetThisCharColor (backupwho);
      if backupwho.MyGuild <> nil then
         ustate.GuildName := TGuild(backupwho.MyGuild).GuildName;
      ustate.GuildRankName := backupwho.GuildRankName;
      ustate.bExistLover := Boolean(TUserHuman(backupwho).fLover.GetLoverCount);  //¿¬ÀÎ »óÅÂ
      ustate.LoverName := TUserHuman(backupwho).fLover.GetLoverName;  //¿¬ÀÎ ÀÌ¸§
      ustate.FameName := TUserHuman(backupwho).GetFameName(FameGrade);  //¸í¼º È£Äª

      // 2003/03/15 ¾ÆÀÌÅÛ ÀÎº¥Åä¸® È®Àå
      for i:=0 to U_TRANS do begin    // 8->12
         if backupwho.UseItems[i].Index > 0 then begin
            ps := UserEngine.GetStdItem (backupwho.UseItems[i].Index);
            if ps <> nil then begin
               std := ps^;
               opt := ItemMan.GetUpgradeStdItem (backupwho.UseItems[i], std);
               Move (std, citem.S, sizeof(TStdItem));
               citem.MakeIndex  := backupwho.UseItems[i].MakeIndex;
               citem.Dura       := backupwho.UseItems[i].Dura;
               citem.DuraMax    := backupwho.UseItems[i].DuraMax;
               citem.UpgradeOpt := opt;

               //ÃµÀÇ¹«ºÀ
               if (i = U_DRESS) then backupwho.ChangeItemWithLevel( citem , backupwho.Abil.Level );

               if (backupwho.UseItems[i].Index = 706) or (backupwho.UseItems[i].Index = 707) or (backupwho.UseItems[i].Index = 708) then
                  //¹ÝÂ¦ÀÌº¥Æ® 3Â÷
                  backupwho.BanjjakChangeItemByJob( citem, backupwho.Abil.Level )
               else
               //¿ë¾ÆÀÌÅÛÀÏ °æ¿ì ´É·ÂÄ¡°¡ ¹Ù²ï´Ù.
               backupwho.ChangeItemByJob (citem, backupwho.Abil.Level);

               ustate.UseItems[i] := citem;
            end;
         end;
      end;
      Def := MakeDefaultMsg (SM_SENDUSERSTATE, 0, 0, 0, 1);
      SendSocket (@Def, EncodeBuffer (@ustate, sizeof(TUserStateInfo)));
   end;

except
   MainOutMessage('EXCEPT : ServerQueryUserState');
end;

end;

procedure TUserHuman.ServerGetOpenGuildDlg;
var
   i: integer;
   data: string;
begin
   if MyGuild <> nil then begin
      data := TGuild(MyGuild).GuildName + #13;
      data := data + ' '#13; //¹®ÆÄ±ê¸» ÆÄÀÏ ÀÌ¸§
      if GuildRank = 1 then data := data + '1'#13  //¹®ÁÖ
      else data := data + '0'#13;  //ÀÏ¹Ý

      //NoticeList
      data := data + '<Notice>'#13;
      if TGuild(MyGuild).NoticeList <> nil then
         for i:=0 to TGuild(MyGuild).NoticeList.Count-1 do begin
            if Length(data) > 5000 then break;
            data := data + TGuild(MyGuild).NoticeList[i] + #13;
         end;
      //KillGuilds
      data := data + '<KillGuilds>'#13;
      if TGuild(MyGuild).KillGuilds <> nil then
         for i:=0 to TGuild(MyGuild).KillGuilds.Count-1 do begin
            if Length(data) > 5000 then break;
            data := data + TGuild(MyGuild).KillGuilds[i] + #13;
         end;
      //AllyGuilds
      data := data + '<AllyGuilds>'#13;
      if TGuild(MyGuild).AllyGuilds <> nil then
         for i:=0 to TGuild(MyGuild).AllyGuilds.Count-1 do begin
            if Length(data) > 5000 then break;
            data := data + TGuild(MyGuild).AllyGuilds[i] + #13;
         end;

      Def := MakeDefaultMsg (SM_OPENGUILDDLG, 0, 0, 0, 1);
      SendSocket (@Def, EncodeString (data));
   end else
      SendDefMessage (SM_OPENGUILDDLG_FAIL, 0, 0, 0, 0, '');
end;

procedure TUserHuman.ServerGetGuildHome;
begin
   ServerGetOpenGuildDlg;
end;

procedure TUserHuman.ServerGetGuildMemberList;
var
   i, k: integer;
   data: string;
   pgrank: PTGuildRank;
begin
   if MyGuild <> nil then begin
      data := '';
      if TGuild(MyGuild).MemberList <> nil then begin
         for i:=0 to TGuild(MyGuild).MemberList.Count-1 do begin
            pgrank := TGuild(MyGuild).MemberList[i];
            data := data + '#' + IntToStr(pgrank.Rank) + '/*' + pgrank.RankName + '/';
            for k:=0 to pgrank.MemList.Count-1 do begin
               if Length(data) > 5000 then break;
               data := data + pgrank.MemList[k] + '/'
            end;
         end;
      end;

      Def := MakeDefaultMsg (SM_SENDGUILDMEMBERLIST, 0, 0, 0, 1);
      SendSocket (@Def, EncodeString (data));
   end;
end;

procedure TUserHuman.ServerGetGuildAddMember (who: string);
var
   error: integer;
   hum: TUserHuman;
begin
   error := 1; //¹®ÁÖ¸¸ »ç¿ë°¡´É
   if IsGuildMaster then begin  //¹®ÁÖ¸¸ °¡´É
      hum := UserEngine.GetUserHuman (who);
      if hum <> nil then begin
         if hum.GetFrontCret = self then begin
            if hum.AllowEnterGuild then begin
               if not TGuild(MyGuild).IsMember (who) then begin
                  if (hum.MyGuild = nil) and  //°¡ÀÔ¹®ÆÄ ¾øÀ» ¶§
                     (TGuild(MyGuild).MemberList.Count < MAXGUILDMEMBER)  //ÀÎ¿ø Á¦ÇÑ
                  then begin
                     TGuild(MyGuild).AddMember (hum);
                     UserEngine.SendInterMsg (ISM_RELOADGUILD, ServerIndex, TGuild(MyGuild).GuildName);

                     //»õ ¸Ê¹ö¸¦ ¹®ÆÄ¿¡ °¡ÀÔ½ÃÅ´
                     hum.MyGuild := MyGuild;
                     hum.GuildRankName := TGuild (MyGuild).MemberLogin (hum, hum.GuildRank);
                     //hum.SendMsg (self, RM_CHANGEGUILDNAME, 0, 0, 0, 0, '');

                     ChangeNameColor;  //ÀÌ¸§»ö ¾÷µ¥ÀÌÆ®(sonmg 2004/12/29)
                     error := 0;
                  end else
                     error := 4;  //´Ù¸¥ ¹®ÆÄ¿¡ °¡ÀÔµÇ¾î ÀÖÀ½.
               end else
                  error := 3; //ÀÌ¹Ì °¡ÀÔµÇ¾î ÀÖÀ½.
            end else begin
               error := 5; //»ó´ë¹æÀÌ ¹®ÆÄ °¡ÀÔÀ» Çã¿ë¾ÈÇÔ.
               hum.SysMsg ('[Äã¾Ü¾ø¼ÓÈëÐÐ»á]', 0);
            end;
         end else
            error := 2;
      end else
         error := 2; //Á¢¼ÓÇÏ°í ¸¶ÁÖº¸°í ÀÖ¾î¾ß ÇÔ.
   end;
   if error = 0 then SendDefMessage (SM_GUILDADDMEMBER_OK, 0, 0, 0, 0, '')
   else SendDefMessage (SM_GUILDADDMEMBER_FAIL, error, 0, 0, 0, '');
end;

procedure TUserHuman.ServerGetGuildDelMember (who: string);
var
   error: integer;
   hum: TUserHuman;
   gname: string;
   flag: Boolean;
begin
   error := 1; //¹®ÁÖ¸¸ »ç¿ë°¡´É
   if IsGuildMaster then begin  //¹®ÁÖ¸¸ °¡´É
      if TGuild(MyGuild).IsMember (who) then begin
         if self.UserName <> who then begin
            flag := TRUE;
            hum := UserEngine.GetUserHuman (who);
            if hum <> nil then begin
               ////////////////////////////////////
               //¹®ÆÄÀü Áß¿¡´Â ¹®ÆÄÅ»ÅðÇÒ ¼ö ¾øÀ½.(sonmg)
               if hum.LastHiter <> nil then begin
                  if hum.LastHiter.MyGuild <> nil then begin
                     //µÑ´Ù ¹®ÆÄ¿¡ °¡ÀÔµÈ »óÅÂ¿¡¼­
                     if hum.GetGuildRelation (hum, hum.LastHiter) = 2 then begin //¹®Àü(¹®ÆÄÀü)ÁßÀÓ
                        flag := FALSE;
                     end;
                  end;
               end;
               ////////////////////////////////////
            end;

            if flag and TGuild(MyGuild).DelMember (who) then begin
               //·Î±×³²±è
               AddUserLog ('50'#9 + //¹®Å»_   //LastLogNumber
                           MapName + ''#9 +
                           IntToStr(CX) + ''#9 +
                           IntToStr(CY) + ''#9 +
                           UserName + ''#9 +
                           TGuild(MyGuild).GuildName + ''#9 +
                           '1'#9 +
                           '1'#9 +
                           '0');

               if hum <> nil then begin
                  hum.MyGuild := nil;
                  hum.GuildRankChanged (0, '');
                  hum.UserNameChanged;
                  hum.ChangeNameColor;
               end;
               UserEngine.SendInterMsg (ISM_RELOADGUILD, ServerIndex, TGuild(MyGuild).GuildName);
               error := 0;
            end else begin
               error := 4; //ÇÒ ¼ö ¾øÀ½.
            end;
         end else begin
            error := 3; //¹®ÁÖ º»ÀÎÀº Å»Åð ¾ÈµÊ.
            //¹®ÁÖº»ÀÎÀÌ Å»ÅðÇÏ·Á¸é ¹®¿øÀÌ ¾Æ¹«µµ ¾ø´Â»óÅÂ¿¡¼­ ÀÚ½ÅÀ» »©¸éµÊ, ¹®ÆÄµµ ±úÁü
            gname := TGuild(MyGuild).GuildName;
            if TGuild(MyGuild).DelGuildMaster (who) then begin
               //·Î±×³²±è
               AddUserLog ('50'#9 + //¹®Å»_   //LastLogNumber
                           MapName + ''#9 +
                           IntToStr(CX) + ''#9 +
                           IntToStr(CY) + ''#9 +
                           UserName + ''#9 +
                           TGuild(MyGuild).GuildName + ''#9 +
                           '1'#9 +
                           '2'#9 +
                           '0');

               // Àå¿ø ¹ÝÈ¯ ÈÄ ¹®ÆÄ»èÁ¦.
//               GuildAgitMan.DelGuildAgit( gname );

               //--------------------------
               //¸í¼ºÄ¡ °¨¼Ò(¹®ÆÄÇØÃ¼(X))
               //--------------------------

               GuildMan.DelGuild (gname);  //¹®ÆÄ°¡ »ç¶óÁø´Ù.
               UserEngine.SendInterMsg (ISM_DELGUILD, ServerIndex, gname);
               //UserEngine.SendInterMsg (ISM_RELOADGUILD, ServerIndex, TGuild(MyGuild).GuildName);
               MyGuild := nil;
               GuildRankChanged (0, '');
               SysMsg ('"' + gname + '" ÐÐ»áÒÑ¾­±»È¡ÏûÁË', 0);
               error := 0;
            end;
         end;
      end else
         error := 2; //¹®¿øÀÌ ¾Æ´Ô
   end;
   if error = 0 then begin
      //--------------------------
      //¸í¼ºÄ¡ °¨¼Ò(¹®ÆÄ¿¡¼­ Ãß¹æ)
      if ENABLE_FAME_SYSTEM then begin
         hum := UserEngine.GetUserHuman (who);
         if hum <> nil then begin
            hum.DecFamePoint( 400 );
         end;
      end;
      //--------------------------
      SendDefMessage (SM_GUILDDELMEMBER_OK, 0, 0, 0, 0, '');
   end else SendDefMessage (SM_GUILDDELMEMBER_FAIL, error, 0, 0, 0, '');
end;

procedure TUserHuman.ServerGetGuildUpdateNotice (body: string);
var
   data: string;
begin
   if MyGuild = nil then exit;
   if GuildRank <> 1 then exit; //¹®ÆÄÀÇ ¹®ÁÖ¸¸ º¯°æ °¡´É

   TGuild(MyGuild).NoticeList.Clear;

   while TRUE do begin
      if body = '' then break;
      body := GetValidStr3 (body, data, [#13]);
      TGuild(MyGuild).NoticeList.Add (data);
   end;
   TGuild(MyGuild).SaveGuild;
   UserEngine.SendInterMsg (ISM_RELOADGUILD, ServerIndex, TGuild(MyGuild).GuildName);

   ServerGetOpenGuildDlg;
end;

procedure TUserHuman.ServerGetGuildUpdateRanks (body: string);
var
   error: integer;
begin
   if MyGuild = nil then exit;
   if GuildRank <> 1 then exit; //¹®ÆÄÀÇ ¹®ÁÖ¸¸ º¯°æ °¡´É

   error := TGuild(MyGuild).UpdateGuildRankStr (body);
   if error = 0 then begin
      UserEngine.SendInterMsg (ISM_RELOADGUILD, ServerIndex, TGuild(MyGuild).GuildName);
      ServerGetGuildMemberList;
   end else if error <= -2 then
      SendDefMessage (SM_GUILDRANKUPDATE_FAIL, error, 0, 0, 0, '');
   //-1: ÀÌÀü°ú °°À½.. Ã³¸®ÇÏÁö ¾Ê´Â´Ù.
end;

//»ó´ëÆí ¹®ÁÖ¿Í ¸¶ÁÖº¸°í
procedure TUserHuman.ServerGetGuildMakeAlly;
var
   error: integer;
   hum: TUserHuman;
begin
   error := -1; //¹®ÁÖ¸¸ »ç¿ë°¡´É
   hum := TUserHuman(GetFrontCret);
   if hum <> nil then begin
      if hum.RaceServer = RC_USERHUMAN then begin
         if hum.GetFrontCret = self then begin  //¾ó±¼À» ¸¶ÁÖº¸°í ÀÖ´ÂÁö
            if TGuild(hum.MyGuild).AllowAllyGuild then begin
               if IsGuildMaster and hum.IsGuildMaster then begin  //¹®ÁÖ¸¸ °¡´É
                  if TGuild(MyGuild).CanAlly(TGuild(hum.MyGuild)) and TGuild(hum.MyGuild).CanAlly(TGuild(MyGuild)) then begin
                     //µ¿¸Í Á¶°Ç ÃæÁ·
                     TGuild(MyGuild).MakeAllyGuild (TGuild(hum.MyGuild));
                     TGuild(hum.MyGuild).MakeAllyGuild (TGuild(MyGuild));
                     TGuild(MyGuild).GuildMsg (TGuild(hum.MyGuild).GuildName + 'ÒÑ¾­ºÍÄúµÄÐÐ»áÁªÃËÍê³É');
                     TGuild(hum.MyGuild).GuildMsg (TGuild(MyGuild).GuildName + 'ÒÑ¾­ºÍÄúµÄÐÐ»áÁªÃËÍê³É');

                     TGuild(MyGuild).MemberNameChanged;
                     TGuild(hum.MyGuild).MemberNameChanged;

                     //´Ù¸¥ ¼­¹ö¿¡ Àû¿ë
                     UserEngine.SendInterMsg (ISM_RELOADGUILD, ServerIndex, TGuild(MyGuild).GuildName);
                     UserEngine.SendInterMsg (ISM_RELOADGUILD, ServerIndex, TGuild(hum.MyGuild).GuildName);
                     error := 0;
                  end else
                     error := -2;  //µ¿¸Í ½ÇÆÐ
               end else
                  error := -3;  //¹®ÁÖ³¢¸® ¸¶ÁÖº¸°í ÇØ¾ß ÇÑ´Ù.
            end else
               error := -4;  //»ó´ë°¡ µ¿¸ÍÀ» Çã¿ëÇÏÁö ¾Ê°í ÀÖÀ½.
         end;
      end;
   end;
   if error = 0 then  //¼º°ø
      SendDefMessage (SM_GUILDMAKEALLY_OK, 0, 0, 0, 0, '')
   else SendDefMessage (SM_GUILDMAKEALLY_FAIL, error, 0, 0, 0, '');
end;

procedure TUserHuman.ServerGetGuildBreakAlly (gname: string);
var
   aguild: TGuild;
   error: integer;
begin
   error := -1;
   if IsGuildMaster then begin
      aguild := GuildMan.GetGuild (gname);
      if aguild <> nil then begin
         if TGuild(MyGuild).IsAllyGuild (aguild) then begin
            TGuild(MyGuild).BreakAlly (aguild);
            aguild.BreakAlly (TGuild(MyGuild));
            TGuild(MyGuild).GuildMsg (aguild.GuildName + 'ÒÑ¾­ºÍÄúµÄÐÐ»á½â³ýÁªÃË');
            aguild.GuildMsg (TGuild(MyGuild).GuildName + '½â³ýÁËÓëÄúµÄÐÐ»áµÄÁªÃË');

            TGuild(MyGuild).MemberNameChanged;
            aguild.MemberNameChanged;

            //´Ù¸¥ ¼­¹ö¿¡ Àû¿ë
            UserEngine.SendInterMsg (ISM_RELOADGUILD, ServerIndex, TGuild(MyGuild).GuildName);
            UserEngine.SendInterMsg (ISM_RELOADGUILD, ServerIndex, aguild.GuildName);
            error := 0;
         end else error := -2;  //µ¿¸ÍÁß ¾Æ´Ô
      end else error := -3; //±×·± ¹®ÆÄ ¾øÀ½
   end;
   if error = 0 then  //¼º°ø
      SendDefMessage (SM_GUILDBREAKALLY_OK, 0, 0, 0, 0, '')
   else SendDefMessage (SM_GUILDBREAKALLY_FAIL, error, 0, 0, 0, '');
end;

procedure TUserHuman.ServerGetAdjustBonus (remainbonus: integer; bodystr: string);
   function CalcLoHi (abil, point: word): word;
   var
      i, lo, hi: integer;
   begin
      lo := Lobyte(abil);
      hi := Hibyte(abil);
      for i:=1 to point do begin
         if lo + 1 < hi then Inc (lo)
         else Inc (hi);
      end;
      Result := MakeWord(lo, hi);
   end;
var
   cha: TNakedAbility;
   sum: integer;
   ptk: PTNakedAbility;
begin
{$IFDEF FOR_ABIL_POINT}
//4/16ÀÏºÎÅÍ Àû¿ë
   if (remainbonus >= 0) and (remainbonus < BonusPoint) then begin
      DecodeBuffer (bodystr, @cha, sizeof(TNakedAbility));
      //°ËÁõ...
      sum := cha.DC + cha.MC + cha.SC + cha.AC + cha.MAC + cha.HP + cha.MP + cha.Hit + cha.Speed;
      ptk := nil;
      case Job of
         0: ptk := @WarriorBonus;
         1: ptk := @WizzardBonus;
         2: ptk := @PriestBonus;
      end;
      if (ptk <> nil) and (sum = (BonusPoint - remainbonus)) then begin
         BonusPoint := remainbonus;
         CurBonusAbil.DC := CurBonusAbil.DC + cha.DC;
         CurBonusAbil.MC := CurBonusAbil.MC + cha.MC;
         CurBonusAbil.SC := CurBonusAbil.SC + cha.SC;
         CurBonusAbil.AC := CurBonusAbil.AC + cha.AC;
         CurBonusAbil.MAC := CurBonusAbil.MAC + cha.MAC;
         CurBonusAbil.HP := CurBonusAbil.HP + cha.HP;
         CurBonusAbil.MP := CurBonusAbil.MP + cha.MP;
         CurBonusAbil.Hit := CurBonusAbil.Hit + cha.Hit;
         CurBonusAbil.Speed := CurBonusAbil.Speed + cha.Speed;

         BonusAbil.DC := CalcLoHi (BonusAbil.DC, CurBonusAbil.DC div ptk.DC);
         CurBonusAbil.DC := CurBonusAbil.DC mod ptk.DC;

         BonusAbil.MC := CalcLoHi (BonusAbil.MC, CurBonusAbil.MC div ptk.MC);
         CurBonusAbil.MC := CurBonusAbil.MC mod ptk.MC;

         BonusAbil.SC := CalcLoHi (BonusAbil.SC, CurBonusAbil.SC div ptk.SC);
         CurBonusAbil.SC := CurBonusAbil.SC mod ptk.SC;

         BonusAbil.AC := MakeWord(0, Hibyte(BonusAbil.AC) + CurBonusAbil.AC div ptk.AC);   //CalcLoHi (BonusAbil.AC, CurBonusAbil.AC div ptk.AC);
         CurBonusAbil.AC := CurBonusAbil.AC mod ptk.AC;

         BonusAbil.MAC := MakeWord(0, Hibyte(BonusAbil.MAC) + CurBonusAbil.MAC div ptk.MAC);//CalcLoHi (BonusAbil.MAC, CurBonusAbil.MAC div ptk.MAC);
         CurBonusAbil.MAC := CurBonusAbil.MAC mod ptk.MAC;

         BonusAbil.HP := BonusAbil.HP + CurBonusAbil.HP div ptk.HP;
         CurBonusAbil.HP := CurBonusAbil.HP mod ptk.HP;

         BonusAbil.MP := BonusAbil.MP + CurBonusAbil.MP div ptk.MP;
         CurBonusAbil.MP := CurBonusAbil.MP mod ptk.MP;

         BonusAbil.Hit := BonusAbil.Hit + CurBonusAbil.Hit div ptk.Hit;
         CurBonusAbil.Hit := CurBonusAbil.Hit mod ptk.Hit;

         BonusAbil.Speed := BonusAbil.Speed + CurBonusAbil.Speed div ptk.Speed;
         CurBonusAbil.Speed := CurBonusAbil.Speed mod ptk.Speed;

         RecalcLevelAbilitys;
         RecalcAbilitys;
         SendMsg (self, RM_ABILITY, 0, 0, 0, 0, '');
         SendMsg (self, RM_SUBABILITY, 0, 0, 0, 0, '');
      end;
      ServerSendAdjustBonus;  //º¸³Ê½º Æ÷ÀÎÆ®¸¦ ´Ù½Ã º¸³»ÁØ´Ù.
   end;
{$ENDIF}
end;


procedure TUserHuman.RmMakeSlaveProc (pslave: PTSlaveInfo);
var
   cret: TCreature;
   maxcount: integer;
begin
   if Job = 2 then  //µµ»çÀÎ°æ¿ì
      maxcount := 3 //1    //¼öÁ¤sonmg(2006/01/24)
   else maxcount := 5;
//   Inc(maxcount);   //ÃÖ´ë ²¿ºÀ ¸ó½ºÅÍ 1¸¶¸® Áõ°¡(sonmg 2005/09/02)
   cret := MakeSlave (pslave.SlaveName,
                      pslave.SlaveMakeLevel,
                      maxcount,
                      pslave.RemainRoyalty);
   if cret <> nil then begin
      cret.SlaveExp := pslave.SlaveExp;
      cret.SlaveExpLevel := pslave.SlaveExpLevel;
      cret.WAbil.HP := pslave.HP;
      cret.WAbil.MP := pslave.MP;


      if cret.NextWalkTime > 1500-(pslave.SlaveMakeLevel*200)  then cret.NextWalkTime := 1500-(pslave.SlaveMakeLevel*200);
      if cret.NextHitTime > 2000-(pslave.SlaveMakeLevel*200) then cret.NextHitTime := 2000-(pslave.SlaveMakeLevel*200);

      cret.RecalcAbilitys;

   end;
end;

// ¿¬ÀÎ»çÁ¦ ¿É¼Çº¯°æ
procedure TUserHuman.ServerGetRelationOptionChange( OptionType : integer ; Enable : integer );
begin

    case OptionType of
    1   : begin // ¿¬ÀÎÀÏ °æ¿ì¿¡
            // ÀÌÀüÀÇ »óÅÂÀÇ ¹ÝÀüÀ» ÇÑ´Ù.
            if 0 = Enable then
                Self.fLover.SetEnable( RsState_Lover , 0 )
            else
                Self.fLover.SetEnable( RsState_Lover , 1 );
            SendDefMessage ( SM_LM_OPTION,0, OPtionType, Self.flover.GetEnable(RsState_Lover), 0, '');
          end;
    end;
end;

// ¿¬ÀÎ»çÁ¦ °ü°è ¿äÃ»
procedure TUserHuman.ServerGetRelationRequest( ReqType : integer ;ReqSeq : integer );
var
   cert        : TCreature;
   Target      : TUserHuman;
   ListCount   : Integer;
   msgstr      : string;
   Date        : string;
   str         : string;
   CheckResult : integer;
begin
   // ¾Õ¿¡ ÀÖ´Â »ó´ë¸¦ ¾ò´Â´Ù.
   cert := GetFrontCret;
   // Å¸°ÙÀÌ ¾ø°Å³ª , ¸¶ÁÖº¸°í ÀÖÁö ¾Ê°Å³ª , ÀÎ°£ÀÌ ¾Æ´Ï¸é ³ª°£´Ù.
   if ( cert = nil ) or ( cert.GetFrontCret <> Self ) or ( cert.RaceServer <> RC_USERHUMAN ) then begin
      BoxMsg('ÌáÊ¾£ºÏëÒª½¨Á¢Ê¦Í½¹ØÏµ£¬Äã±ØÐëÓë¶Ô·½Ãæ¶ÔÃæ£¡', 0);
      Exit;
   end;

   // human À¸·Î Å¸ÀÔ ¹Ù²Þ
   Target := TUserHuman ( cert );

   // Á¶°ÇÃ¼Å©
   case ReqType of
   RsState_Lover : // ¿¬ÀÎÀÇ °æ¿ì Á¶°Ç Ã¼Å©
      begin
         // ÀÚ½ÅÀÇ ·¹º§Ã¼Å©
         if Self.WAbil.Level < 22 then begin
            SendDefMessage (SM_LM_RESULT, 0,ReqType, RsError_LessLevelMe,  0, '');
            Exit;
         end;
         // »ó´ë¹æÀÇ ·¹º§ Ã¼Å©
         if Target.WAbil.Level < 22 then begin
            SendDefMessage (SM_LM_RESULT, 0,ReqType, RsError_LessLevelOther,  0, Target.UserName);
            Exit;
         end;
         // »ó´ë¹æ°úÀÇ ¼ºº° Ã¼Å©
         if Self.Sex = Target.Sex  then begin
            SendDefMessage (SM_LM_RESULT, 0,ReqType, RsError_EqualSex,  0, '');
            Exit;
         end;
         // ±³Á¦°¡´É Á¶°Ç Ã¼Å© (Ã¼Å© ¼ø¼­ Á¶Á¤)
         CheckResult := Self.fLover.GetEnableJoin( ReqType );
         if CheckResult = 1 then begin
            //±³Á¦°¡´É »óÅÂ°¡ ¾Æ´Ô
            SendDefMessage (SM_LM_RESULT, 0,ReqType, RsError_RejectMe,  0, '');
            Exit;
         end else if CheckResult = 2 then begin
            //ÀÌ¹Ì ±³Á¦ÁßÀÎ »ç¶÷ÀÌ ÀÖÀ½
            SendDefMessage (SM_LM_RESULT, 0,ReqType, RsError_FullUser,  0, UserName);
            Exit;
         end else if CheckResult <> 0 then begin
            Exit;
         end;
         // ³ªÀÇ ±³Á¦°¡´É »óÅÂ Ã¼Å©
         if not Self.fLover.EnableJoinLover then begin
            SendDefMessage (SM_LM_RESULT, 0,ReqType, RsError_RejectMe,  0, '');
            Exit;
         end;
         // »ó´ë¹æÀÇ ±³Á¦°¡´É»óÅÂ Ã¼Å©
         if not Target.fLover.EnableJoinLover  then begin
            SendDefMessage (SM_LM_RESULT, 0,ReqType, RsError_RejectOther,  0, Target.UserName);
            Exit;
         end;
      end;
   // ¿¬ÀÎÀÌ ¾Æ´Ò°æ¿ìÀÇ Á¶°ÇÃ¼Å©
   RsState_Master:
      begin
         if (Self.WAbil.Level < ApprenticeMinLevel) or (Self.WAbil.Level > ApprenticeMaxLevel) then begin
            SendDefMessage (SM_LM_RESULT, 0,ReqType, RsError_LessLevelMe,  0, IntToStr(ApprenticeMinLevel)+'/'+IntToStr(ApprenticeMaxLevel)+'/');
            Exit;
         end;

         if Target.WAbil.Level < MasterOKLevel then begin
            SendDefMessage (SM_LM_RESULT, 0,ReqType, RsError_LessLevelOther,  0, Target.UserName+'/'+IntToStr(MasterOKLevel));
            Exit;
         end;
      end;
   RsState_Pupil:
      begin
         if Self.WAbil.Level < MasterOKLevel then begin
            SendDefMessage (SM_LM_RESULT, 0,ReqType, RsError_LessLevelMe,  0, IntToStr(MasterOKLevel));
            Exit;
         end;

         if (Target.WAbil.Level < ApprenticeMinLevel) or (Target.WAbil.Level > ApprenticeMaxLevel) then begin
            SendDefMessage (SM_LM_RESULT, 0,ReqType, RsError_LessLevelOther,  0, Target.UserName+'/'+IntToStr(ApprenticeMinLevel)+'/'+IntToStr(ApprenticeMaxLevel)+'/');
            Exit;
         end;
      end;
   else
      Exit;
   end;

  case ReqType of
  RsState_Lover :
    begin
   // Âü¿© ½ÃÄö½º º¯È­ ...
      case ReqSeq of
      RsReq_None             :; // ±âº»»óÅÂ
      RsReq_WantToJoinOther  : // ´©±¸¿¡°Ô Âü°¡½ÅÃ»À» ÇÔ
        begin
          if not Self.fLover.GetEnableJoinReq( ReqType ) then begin
            // ³»°¡ »ó´ë¹æ¿¡°Ô Âü¿©ÇÒ¼ö ¾ø´Â »óÅÂÀÌ´Ù.
            SendDefMessage ( SM_LM_RESULT,0, ReqType, RsError_DontJoin, 0, Target.UserName);
          end else begin
            // Âü¿©°¡´ÉÇÑÁö °ËÅä
            CheckResult := Target.fLover.GetEnableJoin( ReqType );
            if CheckResult = 1 then begin
               //±³Á¦°¡´É »óÅÂ°¡ ¾Æ´Ô
               SendDefMessage (SM_LM_RESULT, 0,ReqType, RsError_RejectOther,  0, Target.UserName);
            end else if CheckResult = 2 then begin
               //ÀÌ¹Ì ±³Á¦ÁßÀÎ »ç¶÷ÀÌ ÀÖÀ½
               SendDefMessage (SM_LM_RESULT, 0,ReqType, RsError_FullUser,  0, Target.UserName);
            end else if CheckResult = 0 then begin
               // »ó´ë¹æÀÌ ´Ù¸¥ ¿ä±¸¸¦ ¹Þ°í ÀÖ´Â»óÅÂ°¡ ¾Æ´Ï¸é
               if Target.fLover.ReqSequence = RsReq_None then begin
                  // ´©±º°¡ ½ÅÃ»Çß´Ù°í ¾Ë¸²
                  target.SendDefMessage ( SM_LM_REQUEST, 0,ReqType, RsReq_WhoWantJoin, 0, Self.UserName);
                  // ³ª´Â ´ë´äÀ» ±â´Ù¸®´Â »óÅÂÀÌ°í
                  Self.fLover.ReqSequence     := RsReq_WaitAnser;
                  // »ó´ë¹æÀº ´ë´äÀ» ÇØÁà¾ß ÇÏ´Â »óÅÂ
                  Target.flover.ReqSequence   := RsReq_WhoWantJoin;
               end else begin
                  // »ó´ë¹æÀÌ ÇöÀç ´Ù¸¥ ÀÀ´ä »óÅÂÀÌ´Ù.
                  SendDefMessage (SM_LM_RESULT, 0,ReqType, RsError_DontJoin,  0, Target.UserName);
               end;
            end; // if not Target.fLover.GetEnableJoin

          end; // if not Self.fLover.GetEnableJoinReq
        end;
      RsReq_AloowJoin        : // Âü°¡¸¦ Çã¶ôÇÔ
        begin
          if Target.fLover.ReqSequence = RsReq_WaitAnser then begin
            // Å¸°ÙÀ» µî·ÏÇÑ´Ù.
            Date := '';
            Self.fLover.ReqSequence := RsREq_None;
            self.flover.Add( Self.UserName , Target.Username , ReqType , Target.WAbil.Level , Target.Sex , Date , '');
            msgstr := Self.fLover.GetListmsg( ReqType , listCount);
            SendDefMessage (SM_LM_LIST, 0,ListCount, 0, 0, msgstr);
            SendDefMessage (SM_LM_RESULT,0, ReqType, RsError_SuccessJoin, 0, Target.UserName);

            // ÀÚ½ÅÀ» Å¸°Ù¿¡ µî·ÏÇÑ´Ù.
            Target.fLover.ReqSequence := RsREq_None;
            Target.flover.Add( Target.UserName , Self.Username , ReqType , Self.WAbil.Level , Self.Sex , Date , '');
            msgstr := Target.fLover.GetListmsg( ReqType , listCount);
            Target.SendDefMessage (SM_LM_LIST, 0,ListCount, 0, 0, msgstr);
            Target.SendDefMessage (SM_LM_RESULT,0, ReqType, RsError_SuccessJoined, 0, Self.UserName);

            // DB ¿¡ ÀúÀåÇÑ´Ù. ÇÑ¸í¸¸ ÀúÀåÇÏ¸é ³ª¸ÓÁö»ç¶÷Àº ¾Ë¾Æ¼­ ÀúÀåµÈ´Ù.
            SendMsg (Self,RM_LM_DBADD,0, 0, 0, 0, Target.UserName+':'+IntToStr(ReqType)+':'+Date+'/');

            // ÁÖº¯¿¡ ¿ÜÄ¡±â
            str :='¹§Ï² ' + UserName + ' Óë ' + target.UserName + ' Ï²½áÁ¼Ôµ£¬³ÉÎªºÏ·¨·òÆÞ£¡';
//            UserEngine.CryCry (RM_SYSMSG_PINK, PEnvir, CX, CY, 300, '(*)' + str);
            UserEngine.SysMsgAllEx('' + str, 0, 0, 0);    //µ¥ÒýºÅÀïÊÇºì×ÖÇ°µÄ·ûºÅ
            //·Î±×³²±è
            AddUserLog ('47'#9 + //¿¬ÀÎ_
                        MapName + ''#9 +
                        IntToStr(CX) + ''#9 +
                        IntToStr(CY) + ''#9 +
                        UserName + ''#9 +
                        '0'#9 +
                        '0'#9 +
                        '0'#9 +  //¸ÎÀ½:0
                        target.UserName);

          end else begin
            // »ó´ë¹æÀÌ ÇöÀç ´Ù¸¥ ÀÀ´ä »óÅÂÀÌ´Ù. µû¶ó¼­ Ãë¼Ò½ÃÅ²´Ù.
            self.fLover.ReqSequence := RsReq_None;
            SendDefMessage (SM_LM_RESULT,0, ReqType, RsError_CancelJoin, 0, Target.UserName);

            target.fLover.ReqSequence := RsReq_None;
            Target.SendDefMessage (SM_LM_RESULT,0, ReqType, RsError_CancelJoin, 0, Self.UserName);
          end;
        end;
      RsReq_DenyJoin         : // Âü°¡¸¦ °ÅÀýÇÔ
        begin
         self.fLover.ReqSequence := RsReq_None;
         SendDefMessage (SM_LM_RESULT, 0,ReqType, RsError_CancelJoin, 0, Target.UserName);

         target.fLover.ReqSequence := RsReq_None;
         target.SendDefMessage (SM_LM_RESULT, 0,ReqType, RsError_DenyJoin, 0, Self.UserName);
        end;
      RsReq_Cancel           : // Ãë¼Ò
        begin
         self.fLover.ReqSequence := RsReq_None;
         SendDefMessage (SM_LM_RESULT, 0,ReqType, RsError_CancelJoin, 0, Target.UserName);

         target.fLover.ReqSequence := RsReq_None;
         target.SendDefMessage (SM_LM_RESULT, 0,ReqType, RsError_CancelJoin, 0, Self.UserName);
        end;
      end;
    end;
  //°ÝÊ¦Ôö¼Ó
//  RsState_Master:
//    begin
//      case ReqSeq of
//      RsReq_None             :;
//      RsReq_WantToJoinOther  :
//        begin
//          CheckResult := Self.fMaster.GetEnableJoin( RsState_Pupil );
//          if CheckResult = 1 then begin
//            SendDefMessage (SM_LM_RESULT, 0,RsState_Pupil, RsError_FullUser,  0, UserName);
//            Exit;
//          end;
//          CheckResult := Target.fMaster.GetEnableJoin( ReqType );
//          if CheckResult = 1 then begin
//            SendDefMessage (SM_LM_RESULT, 0,ReqType, RsError_FullUser,  0, Target.UserName);
//          end else if CheckResult = 0 then begin
//            if Target.fMaster.Find(Self.UserName) then begin
//              SendDefMessage (SM_LM_RESULT, 0,ReqType, RsError_RelationShip,  0, Target.UserName);
//            end else if Target.fMaster.ReqSequence = RsReq_None then begin
//              if target.RufuseMaster then
//              begin
//              target.SendDefMessage ( SM_LM_REQUEST, 0,ReqType, RsReq_WhoWantJoin, 0, Self.UserName);
//              Self.fMaster.ReqSequence     := RsReq_WaitAnser;
//              Target.fMaster.ReqSequence   := RsReq_WhoWantJoin;
//              end else
//              begin
//                Self.SendDefMessage ( SM_LM_REQUEST, 0,ReqType, 50, 0, Target.UserName);
//              end;
//            end else begin
//              SendDefMessage (SM_LM_RESULT, 0,ReqType, RsError_DontJoin,  0, Target.UserName);
//            end;
//          end;
//        end;
//      RsReq_AloowJoin        :
//        begin
//          if Target.fMaster.ReqSequence = RsReq_WaitAnser then begin
//            Date := '';
//            Self.fMaster.ReqSequence := RsREq_None;
//            self.fMaster.Add( Self.UserName , Target.Username , ReqType , Target.WAbil.Level , Target.Sex , Date , '');
//            msgstr := Self.fMaster.GetListmsg( ReqType , listCount);
//            SendDefMessage (SM_LM_LIST, 0,ListCount, 0, 0, msgstr);
//            SendDefMessage (SM_LM_RESULT,0, ReqType, RsError_SuccessJoin, 0, Target.UserName);
//
//            Target.fMaster.ReqSequence := RsREq_None;
//            Target.fMaster.Add( Target.UserName , Self.Username , RsState_Pupil , Self.WAbil.Level , Self.Sex , Date , '');
//            msgstr := Target.fMaster.GetListmsg( RsState_Pupil , listCount);
//            Target.SendDefMessage (SM_LM_LIST, 0,ListCount, 0, 0, msgstr);
//            Target.SendDefMessage (SM_LM_RESULT,0, RsState_Pupil, RsError_SuccessJoined, 0, Self.UserName);
//
//            SendMsg (Self,RM_LM_DBADD,0, 0, 0, 0, Target.UserName+':'+IntToStr(RsState_Pupil)+':'+Date+'/');
//
//            str := '¹§Ï²£º' + target.UserName + ' ÐÂÊÕÈëµÜ×Ó ' + UserName + '';   //Ê¦¸µ·¢Æð
////            UserEngine.CryCry (RM_SYSMSG_PINK, PEnvir, CX, CY, 300, '(*)' + str);
//            UserEngine.SysMsgAllEx('' + str, 0, 0, 0);       //µ¥ÒýºÅÖÐ¼äÊÇºì×Ö¿ªÍ·µÄ·ûºÅ
//            self.UserNameChanged;
//          end else begin
//            self.fMaster.ReqSequence := RsReq_None;
//            SendDefMessage (SM_LM_RESULT,0, ReqType, RsError_CancelJoin, 0, Target.UserName);
//
//            target.fMaster.ReqSequence := RsReq_None;
//            Target.SendDefMessage (SM_LM_RESULT,0, RsState_Pupil, RsError_CancelJoin, 0, Self.UserName);
//          end;
//        end;
//      RsReq_DenyJoin         :
//        begin
//         self.fMaster.ReqSequence := RsReq_None;
//         SendDefMessage (SM_LM_RESULT, 0,ReqType, RsError_CancelJoin, 0, Target.UserName);
//
//         target.fMaster.ReqSequence := RsReq_None;
//         target.SendDefMessage (SM_LM_RESULT, 0,ReqType, RsError_DenyJoin, 0, Self.UserName);
//        end;
//      end;
//    end;
//  //ÊÕÍ½Ôö¼Ó
//  RsState_Pupil:
//    begin
//      case ReqSeq of
//      RsReq_None             :;
//      RsReq_WantToJoinOther  :
//        begin
//          if Target.fMaster.Find(Self.UserName) then begin
//            SendDefMessage (SM_LM_RESULT, 0,ReqType, RsError_RelationShip,  0, Target.UserName);
//            Exit;
//          end;
//          CheckResult := Self.fMaster.GetEnableJoin( RsState_Master );
//          if CheckResult = 1 then begin
//            SendDefMessage (SM_LM_RESULT, 0,RsState_Master, RsError_FullUser,  0, UserName);
//            Exit;
//          end;
//          CheckResult := Target.fMaster.GetEnableJoin( ReqType );
//          if CheckResult = 1 then begin
//            SendDefMessage (SM_LM_RESULT, 0,ReqType, RsError_FullUser,  0, Target.UserName);
//          end else if CheckResult = 0 then begin
//            if Target.fMaster.ReqSequence = RsReq_None then begin
//              if target.RufuseMaster then
//              begin
//              target.SendDefMessage ( SM_LM_REQUEST, 0,ReqType, RsReq_WhoWantJoin, 0, Self.UserName);
//              Self.fMaster.ReqSequence     := RsReq_WaitAnser;
//              Target.fMaster.ReqSequence   := RsReq_WhoWantJoin;
//              end else begin
//                Self.SendDefMessage ( SM_LM_REQUEST, 0,ReqType, 50, 0, target.UserName);
//              end;
//            end else begin
//              SendDefMessage (SM_LM_RESULT, 0,ReqType, RsError_DontJoin,  0, Target.UserName);
//            end;
//          end;
//        end;
//      RsReq_AloowJoin        :
//        begin
//          if Target.fMaster.ReqSequence = RsReq_WaitAnser then begin
//            Date := '';
//            Self.fMaster.ReqSequence := RsREq_None;
//            self.fMaster.Add( Self.UserName , Target.Username , ReqType , Target.WAbil.Level , Target.Sex , Date , '');
//            msgstr := Self.fMaster.GetListmsg( ReqType , listCount);
//            SendDefMessage (SM_LM_LIST, 0,ListCount, 0, 0, msgstr);
//            SendDefMessage (SM_LM_RESULT,0, ReqType, RsError_SuccessJoin, 0, Target.UserName);
//
//            Target.fMaster.ReqSequence := RsREq_None;
//            Target.fMaster.Add( Target.UserName , Self.Username , RsState_Master , Self.WAbil.Level , Self.Sex , Date , '');
//            msgstr := Target.fMaster.GetListmsg( RsState_Master , listCount);
//            Target.SendDefMessage (SM_LM_LIST, 0,ListCount, 0, 0, msgstr);
//            Target.SendDefMessage (SM_LM_RESULT,0, RsState_Master, RsError_SuccessJoined, 0, Self.UserName);
//
//            SendMsg (Self,RM_LM_DBADD,0, 0, 0, 0, Target.UserName+':'+IntToStr(RsState_Master)+':'+Date+'/');
//
//            str := '¹§Ï²£º' + UserName + ' ÐÂÊÕÈëµÜ×Ó ' + target.UserName + '';         //Í½µÜ·¢Æð
//            //shanUserEngine.CryCry (RM_SYSMSG_PINK, PEnvir, CX, CY, 300, '(*)' + str);
//            UserEngine.SysMsgAllEx('' + str, 0, 0, 0);      //µ¥ÒýºÅºÅÖÐ¼äÊÇºì×ÖÇ°µÄ·ûºÅ
//            self.UserNameChanged;
//          end else begin
//            self.fMaster.ReqSequence := RsReq_None;
//            SendDefMessage (SM_LM_RESULT,0, ReqType, RsError_CancelJoin, 0, Target.UserName);
//
//            target.fMaster.ReqSequence := RsReq_None;
//            Target.SendDefMessage (SM_LM_RESULT,0, RsState_Master, RsError_CancelJoin, 0, Self.UserName);
//          end;
//        end;
//      RsReq_DenyJoin         :
//        begin
//         self.fMaster.ReqSequence := RsReq_None;
//         SendDefMessage (SM_LM_RESULT, 0,ReqType, RsError_CancelJoin, 0, Target.UserName);
//
//         target.fMaster.ReqSequence := RsReq_None;
//         target.SendDefMessage (SM_LM_RESULT, 0,ReqType, RsError_DenyJoin, 0, Self.UserName);
//        end;
//      end;
//    end;
  end;
end;

// ¿¬ÀÎ »çÁ¦ »èÁ¦
procedure TUserHuman.ServerGetRelationDelete( ReqType : integer ; OtherName : String );
var
   svidx : Integer;
   hum   : TUserHuman;
   cert  : TCreature;
   strPayment : string;
begin
   //¿¬ÀÎ °ü°èÀÏ °æ¿ì...
   if ReqType = RsState_Lover then begin
      // ¾Õ¿¡ ÀÖ´Â »ó´ë¸¦ ¾ò´Â´Ù.
      cert := GetFrontCret;
      // Å¸°ÙÀÌ ¾ø°Å³ª , ¸¶ÁÖº¸°í ÀÖÁö ¾Ê°Å³ª , ÀÎ°£ÀÌ ¾Æ´Ï¸é ³ª°£´Ù.
      if ( cert = nil ) or ( cert.GetFrontCret <> Self ) or ( cert.RaceServer <> RC_USERHUMAN ) then begin
         BoxMsg('·ÖÊÖ, Äã±ØÐëÃæ¶Ô¶Ô·½.', 0);
         Exit;
      end;

      // human À¸·Î Å¸ÀÔ ¹Ù²Þ
      hum := TUserHuman ( cert );
      if hum = nil then exit;

      // »ó´ë¹æÀÌ ³ªÀÇ ¿¬ÀÎÀÎÁö Ã¼Å©
      if not ((hum.fLover.GetLoverName = UserName) and (fLover.GetLoverName = hum.UserName)) then begin
         BoxMsg('ÄÇ²»ÊÇÄãµÄ°®ÈË.', 0);
         Exit;
      end;

      // À§ÀÚ·á ³¾ µ·ÀÌ ÀÖ´ÂÁö È®ÀÎ
      if Gold < COMPENSATORY_PAYMENT then begin
         strPayment := IntToStr(COMPENSATORY_PAYMENT div 10000);
         BoxMsg('·ÖÊÖ, Äã½«³Ðµ£ ' + strPayment + '0,000½ð±ÒµÄ·ÑÓÃ.', 0);
         exit;
      end;

      //-------------------
      //¿¬ÀÎ ÇØÁ¦ È®ÀÎ
      hum.SendDefMessage (SM_LM_DELETE_REQ, 0, 0, 0, 0, UserName);
      /////////////////////
      exit;
      //-------------------


      if RelationShipDeleteOther( ReqType , OtherName ) then begin
         hum := UserEngine.GetUserHuman( OtherName );
         if hum <> nil then begin
            hum.RelationShipDeleteOther( ReqType , UserName );
         end else begin
            if UserEngine.FindOtherServerUser (OtherName, svidx) then begin
               UserEngine.SendInterMsg (ISM_LM_DELETE, svidx, OtherName + '/' + UserName + '/' + IntToStr(ReqType));
            end
         end;

      end else begin
         SendDefMessage (SM_LM_RESULT, ReqType, RsError_DontDelete, 0, 0, OtherName);
      end;
   end;
   //ÍÑÀëÊ¦ÃÅ
   if ReqType = RsState_Master then begin
      if Gold < COMPENSATORY_PAYMENT then begin
         strPayment := IntToStr(COMPENSATORY_PAYMENT div 10000);
         BoxMsg('ÌáÊ¾£ºÄãµÄ½ð±Ò²»¹»£¡ÍÑÀëÊ¦Í½¹ØÏµ, Äã±ØÐë³Ðµ£'+strPayment+'0,000½ð±ÒµÄ·ÑÓÃ£¡', 0);
         exit;
      end else begin
         DecGold(COMPENSATORY_PAYMENT);
         GoldChanged;
      end;

      if RelationShipDeleteOther( ReqType , OtherName ) then begin
         hum := UserEngine.GetUserHuman( OtherName );
         if hum <> nil then begin
            hum.RelationShipDeleteOther( RsState_Pupil , UserName );
         end else begin
            if UserEngine.FindOtherServerUser (OtherName, svidx) then begin
               UserEngine.SendInterMsg (ISM_LM_DELETE, svidx, OtherName + '/' + UserName + '/' + IntToStr(RsState_Pupil));
            end else begin
               SendMsg (Self,RM_LM_DBEDIT,0, 0, 0, 0, OtherName+':'+IntToStr(RsState_PupilEnd)+':'+IntToStr(1)+'/');
            end;
         end;
         UserNameChanged;
      end else begin
         SendDefMessage (SM_LM_RESULT, ReqType, RsError_DontDelete, 0, 0, OtherName);
      end;
   end;
   //Öð³öÊ¦ÃÅ
   if ReqType = RsState_Pupil then begin
      if Gold < COMPENSATORY_PAYMENT then begin
         strPayment := IntToStr(COMPENSATORY_PAYMENT div 10000);
         BoxMsg('ÌáÊ¾£ºÄãµÄ½ð±Ò²»¹»£¡ÍÑÀëÊ¦Í½¹ØÏµ£¬Äã±ØÐë³Ðµ£'+strPayment+'0,000½ð±ÒµÄ·ÑÓÃ£¡', 0);
         exit;
      end else begin
         DecGold(COMPENSATORY_PAYMENT);
         GoldChanged;
      end;

      if RelationShipDeleteOther( ReqType , OtherName ) then begin
         hum := UserEngine.GetUserHuman( OtherName );
         if hum <> nil then begin
            hum.RelationShipDeleteOther( RsState_Master , UserName );
            hum.UserNameChanged;
         end else begin
            if UserEngine.FindOtherServerUser (OtherName, svidx) then begin
               UserEngine.SendInterMsg (ISM_LM_DELETE, svidx, OtherName + '/' + UserName + '/' + IntToStr(RsState_Master));
            end else begin
               SendMsg (Self,RM_LM_DBEDIT,0, 0, 0, 0, OtherName+':'+IntToStr(RsState_MasterEnd)+':'+IntToStr(1)+'/');
            end;
         end;

      end else begin
         SendDefMessage (SM_LM_RESULT, ReqType, RsError_DontDelete, 0, 0, OtherName);
      end;
   end;
end;

procedure TUserHuman.ServerGetRelationDeleteRequestOk( ReqType : integer ; OtherName : String );
var
   svidx : Integer;
   hum   : TUserHuman;
   cert  : TCreature;
   strPayment : string;
begin
   //¿¬ÀÎ °ü°èÀÏ °æ¿ì...
   if ReqType = RsState_Lover then begin
      // ¾Õ¿¡ ÀÖ´Â »ó´ë¸¦ ¾ò´Â´Ù.
      cert := GetFrontCret;
      // Å¸°ÙÀÌ ¾ø°Å³ª , ¸¶ÁÖº¸°í ÀÖÁö ¾Ê°Å³ª , ÀÎ°£ÀÌ ¾Æ´Ï¸é ³ª°£´Ù.
      if ( cert = nil ) or ( cert.GetFrontCret <> Self ) or ( cert.RaceServer <> RC_USERHUMAN ) then begin
         BoxMsg('½â³ýÁµÈË¹ØÏµ±ØÐëºÍ¶Ô·½Ãæ¶ÔÃæ', 0);
         Exit;
      end;

      // human À¸·Î Å¸ÀÔ ¹Ù²Þ
      hum := TUserHuman ( cert );
      if hum = nil then exit;

      // »ó´ë¹æÀÌ ³ªÀÇ ¿¬ÀÎÀÎÁö Ã¼Å©
      if not ((hum.fLover.GetLoverName = UserName) and (fLover.GetLoverName = hum.UserName)) then begin
         BoxMsg('¶Ô·½ÊÇÄãµÄÁµÈË×·Çó', 0);
         Exit;
      end;

      // À§ÀÚ·á ³¾ µ·ÀÌ ÀÖ´ÂÁö È®ÀÎ
      if Gold < COMPENSATORY_PAYMENT then begin
         strPayment := IntToStr(COMPENSATORY_PAYMENT div 10000);
         BoxMsg('½â³ýÊ§°Ü£¬ÄãÃ»ÓÐ' + strPayment + 'Íò½ð±Ò¡£', 0);
         exit;
      end;
   end;

   if RelationShipDeleteOther( ReqType , OtherName ) then begin

      if ReqType = RsState_Lover then begin
         //À§ÀÚ·á ÁöºÒ
         if Gold >= COMPENSATORY_PAYMENT then begin
            DecGold(COMPENSATORY_PAYMENT);
            GoldChanged;
         end;
         //»óÅÂ º¯°æ(µÐÈ­)
//         MakePoison( POISON_SLOW , 3 ,1 );
//         //HP, MP º¯°æ(50%)
//         WAbil.HP := _MAX(1, WAbil.HP div 2);
//         WAbil.MP := _MAX(1, WAbil.MP div 2);

         //Ãæ°Ý ¸Þ½ÃÁö
         SysMsg('¶Ô·½ÒÑ¾­ºÍÄã·ÖÊÖÁË', 0);

         //·Î±×³²±è
         AddUserLog ('47'#9 + //¿¬ÀÎ_
                     MapName + ''#9 +
                     IntToStr(CX) + ''#9 +
                     IntToStr(CY) + ''#9 +
                     UserName + ''#9 +
                     '0'#9 +
                     '0'#9 +
                     '2'#9 +  //ÇØÁ¦:2
                     OtherName);
      end;

      hum := UserEngine.GetUserHuman( OtherName );
      if hum <> nil then begin
         if hum.RelationShipDeleteOther( ReqType , UserName ) then begin
            if ReqType = RsState_Lover then begin
               //À§ÀÚ·á ÁöºÒ
               if hum.Gold >= COMPENSATORY_PAYMENT then begin
                  hum.DecGold(COMPENSATORY_PAYMENT);
                  hum.GoldChanged;
               end;
               //»óÅÂ º¯°æ(µÐÈ­)
//               hum.MakePoison( POISON_SLOW , 3 ,1 );
//               //HP, MP º¯°æ(50%)
//               hum.WAbil.HP := _MAX(1, hum.WAbil.HP div 2);
//               hum.WAbil.MP := _MAX(1, hum.WAbil.MP div 2);

               //Ãæ°Ý ¸Þ½ÃÁö
               hum.SysMsg('ÄãÒÑ¾­ºÍ¶Ô·½·ÖÊÖÁË', 0);

               //·Î±×³²±è
               AddUserLog ('47'#9 + //¿¬ÀÎ_
                           hum.MapName + ''#9 +
                           IntToStr(hum.CX) + ''#9 +
                           IntToStr(hum.CY) + ''#9 +
                           hum.UserName + ''#9 +
                           '0'#9 +
                           '0'#9 +
                           '2'#9 +  //ÇØÁ¦:2
                           UserName);
            end;
         end;
      end else begin
         if UserEngine.FindOtherServerUser (OtherName, svidx) then begin
            UserEngine.SendInterMsg (ISM_LM_DELETE, svidx, OtherName + '/' + UserName + '/' + IntToStr(ReqType));
         end
      end;

   end else begin
      SendDefMessage (SM_LM_RESULT, ReqType, RsError_DontDelete, 0, 0, OtherName);
   end;
end;

procedure TUserHuman.ServerGetRelationDeleteRequestFail( ReqType : integer ; OtherName : String );
var
   hum : TUserHuman;
begin
   hum := UserEngine.GetUserHuman(OtherName);
   if hum = nil then exit;

   //±³Á¦ °ÅºÎ ¸Þ½ÃÁö
   hum.SysMsg(UserName + '¾Ü¾øÁËÄãµÄÇëÇó',0);
end;

// »ó´ë¹æÀÌ ÀÚ½ÅÀ» °ü°èÇØÁ¦ ½ÃÄ×À» °æ¿ì
function TUserHuman.RelationShipDeleteOther( ReqType : integer ; OtherName : String):Boolean;
begin
  Result := false;

  case ReqType of
    RsState_Lover:
    begin
      if fLover.Find ( OtherName ) then begin
        fLover.Delete( OtherName );
        SendDefMessage (SM_LM_DELETE, 0,ReqType, 0, 0, OtherName);
        SendDefMessage (SM_LM_RESULT, 0,ReqType, RsError_SuccessDelete, 0, OtherName);
        // DB¿¡¼­ »èÁ¦ÇÑ´Ù.
        SendMsg (Self,RM_LM_DBDELETE,0,0,0,0,OtherName+':'+IntToStr(ReqType)+'/');
        Result := true;
      end;
    end;
//    RsState_Master,
//    RsState_Pupil:
//    begin
//      if fMaster.Find ( OtherName ) then begin
//        fMaster.Delete( OtherName );
//        SendDefMessage (SM_LM_DELETE, 0,ReqType, 0, 0, OtherName);
//        SendDefMessage (SM_LM_RESULT, 0,ReqType, RsError_SuccessDelete, 0, OtherName);
//        // DB¿¡¼­ »èÁ¦ÇÑ´Ù.
//        SendMsg (Self,RM_LM_DBDELETE,0,0,0,0,OtherName+':'+IntToStr(ReqType)+'/');
//        Result := true;
//      end;
//    end;
  end;

end;

procedure TUserHuman.ServerSetRelationDBWantList( body : String );
var
   msg : TDefaultMessage;
begin
   msg.Recog    := 0;
   msg.Ident    := DB_LM_LIST;
   msg.Param    := 0;
   msg.Tag      := 0;
   msg.Series   := 0;

   UserMgrEngine.ExternSendMsg( stDbServer, 0, 0, 0, 0, Self.UserName, msg, Body );
end;

procedure TUserHuman.ServerSetRelationDBAdd( body : String  );
var
   msg : TDefaultMessage;
begin
   msg.Recog    := 0;
   msg.Ident    := DB_LM_ADD;
   msg.Param    := 0;
   msg.Tag      := 0;
   msg.Series   := 0;

   UserMgrEngine.ExternSendMsg( stDbServer , 0,0,0,0, Self.UserName, msg , Body );
end;

procedure TUserHuman.ServerSetRelationDBEdit( body : String  );
var
   msg : TDefaultMessage;
begin
   msg.Recog    := 0;
   msg.Ident    := DB_LM_EDIT;
   msg.Param    := 0;
   msg.Tag      := 0;
   msg.Series   := 0;

   UserMgrEngine.ExternSendMsg( stDbServer , 0,0,0,0, Self.UserName, msg , Body );
end;

procedure TUserHuman.ServerSetRelationDBEdit2( body : String  );
var
   msg : TDefaultMessage;
begin
   msg.Recog    := 0;
   msg.Ident    := DB_LM_EDIT2;
   msg.Param    := 0;
   msg.Tag      := 0;
   msg.Series   := 0;

   UserMgrEngine.ExternSendMsg( stDbServer , 0,0,0,0, Self.UserName, msg , Body );
end;

procedure TUserHuman.ServerSetRelationDBDelete( body : String  );
var
   msg : TDefaultMessage;
begin
   msg.Recog    := 0;
   msg.Ident    := DB_LM_DELETE;
   msg.Param    := 0;
   msg.Tag      := 0;
   msg.Series   := 0;

   UserMgrEngine.ExternSendMsg( stDbServer , 0,0,0,0, Self.UserName, msg , Body );
end;

procedure TUserHuman.ServerSetFameDBAdd( body : String  );
var
   msg : TDefaultMessage;
begin
   msg.Recog    := 0;
   msg.Ident    := DB_FAME_ADD;
   msg.Param    := 0;
   msg.Tag      := 0;
   msg.Series   := 0;

   UserMgrEngine.ExternSendMsg( stDbServer , 0,0,0,0, Self.UserName, msg , Body );
end;

// °ü°è½Ã½ºÅÛµî¿¡¼­ ¸ÊÁ¤º¸¸¦ ¾Ë¾Æ¿Â´Ù.
function  TUserHuman.GetCharMapInfo( charname : string ) : String;
var
   userinfo : TUserHuman;
begin
   Result      := '';
   userinfo    := nil;
   if charname = '' then exit;

   userinfo := userengine.GetUserHuman( charname );
   if ( userinfo <> nil ) and ( userinfo.penvir <> nil )then begin
      Result := userinfo.penvir.MapTitle;
   end;
end;

// °ü°è½Ã½ºÅÛ¿¡¼­ ¸®½ºÆ®¸¦ DB ¿¡¼­ ¾ò¾î¿ÔÀ»°æ¿ì
procedure TUserHuman.ServerGetRelationDBGetList( body : String );
var
   count,i : integer;
   msgstr  : string;
   ListCnt : integer;
   str     : string;
   datastr : string;
   tempstr : string;
   _Name   : string;
   _State  : integer;
   _Msg    : integer;
   _Date   : string;
   _Level  : integer;
   _Sex    : integer;
   hum : TUserHuman;
   svidx: integer;
   lovername, mastername : string;
begin
   // Count / ÄÉ¸¯ÅÍÀÌ¸§:µî·Ï»óÅÂ:¸Þ¼¼Áö:µî·ÏÀÏÀÚ:·¹º§:¼ºº°/...

   str     := GetValidStr3( Body , Datastr , ['/']);
   count   := Str_ToInt( DataStr , 0 );
   _State  := 0;

   for i := 0 to Count -1 do begin
      str := GetValidStr3( str , Datastr , ['/']);
      if datastr <> '' then begin
         datastr := GetValidStr3( datastr , _Name   , [':']);
         datastr := GetValidStr3( datastr , tempstr , [':']);
                _State := Str_ToInt( tempstr , 0);
         datastr := GetValidStr3( datastr , tempstr, [':']);
                _msg   := Str_ToInt( tempstr , 0);
         datastr := GetValidStr3( datastr , _Date   , [':']);
         datastr := GetValidStr3( datastr , tempstr , [':']);
                _Level  := Str_ToInt( tempstr , 0);
                _Sex    := Str_ToInt( datastr , 0);


         case _State of
         rsState_Lover   :// ¿¬ÀÎ
            begin
            FLover.Add( UserName , _Name ,_State , _Level , _Sex , _Date , GetCharMapInfo(_Name) );
            end;
         RsState_LoverEnd:// ¿¬ÀÎÅ»Åð
            begin
            SendDefMessage (SM_LM_RESULT, 0,rsState_Lover, RsError_SuccessDelete, 0, _Name);
            // DB¿¡¼­ »èÁ¦ÇÑ´Ù.
            SendMsg (Self,RM_LM_DBDELETE,0,0,0,0,_Name+':'+IntToStr(_State)+'/');
            end;
//         RsState_Master   :// »çºÎ
//            begin
//            fMaster.Add( UserName , _Name ,_State , _Level , _Sex , _Date , GetCharMapInfo(_Name) );
//
//            end;
//         RsState_MasterEnd:// »çºÎÅ»Åð
//            begin
//            SendDefMessage (SM_LM_RESULT, 0,RsState_Master, RsError_SuccessDelete, 0, _Name);
//            // DB¿¡¼­ »èÁ¦ÇÑ´Ù.
//            SendMsg (Self,RM_LM_DBDELETE,0,0,0,0,_Name+':'+IntToStr(_State)+'/');
//            end;
//         RsState_Pupil   :// Á¦ÀÚ
//            begin
//            fMaster.Add( UserName , _Name ,_State , _Level , _Sex , _Date , GetCharMapInfo(_Name) );
//            end;
//         RsState_PupilEnd:// Á¦ÀÚÅ»Åð
//            begin
//            SendDefMessage (SM_LM_RESULT, 0,RsState_Pupil, RsError_SuccessDelete, 0, _Name);
//            // DB¿¡¼­ »èÁ¦ÇÑ´Ù.
//            SendMsg (Self,RM_LM_DBDELETE,0,0,0,0,_Name+':'+IntToStr(_State)+'/');
//            end;
         end;
      end;
   end; // for

   msgstr := Self.fLover.GetListmsg( 10 , ListCnt );
   if ( ListCnt > 0 ) then begin
      SendDefMessage (SM_LM_LIST, 0, ListCnt, 0, 0, msgstr);
   end;

   msgstr := Self.fMaster.GetListmsg( 30 , ListCnt );
   if ( ListCnt > 0 ) then begin
      SendDefMessage (SM_LM_LIST, 0, ListCnt, 0, 0, msgstr);
   end;

   msgstr := Self.fMaster.GetListmsg( 40 , ListCnt );
   if ( ListCnt > 0 ) then begin
      SendDefMessage (SM_LM_LIST, 0, ListCnt, 0, 0, msgstr);
   end;

   //ÃÖÃÊ Á¢¼Ó½Ã ¿¬ÀÎ¿¡°Ôµµ º¸³¿(sonmg)
   if not BoServerShifted then begin
      lovername := fLover.GetLoverName;
      hum := UserEngine.GetUserHuman(lovername);
      if hum <> nil then begin
         if hum.fLover.GetLoverName <> '' then begin
            case sex of
              0: begin
                hum.SysMsg(Format('ÄãµÄÕÉ·ò£º%s ÒÑÉÏÏß Ä¿Ç°ÔÚ [ %s ] ×ø±ê [%d£¬%d]',
                   [UserName, GetCharMapInfo(UserName), CX, CY]), 2);
                SysMsg(Format('ÄãµÄÆÞ×Ó£º%s Ä¿Ç°ÔÚ [ %s ] ×ø±ê [%d£¬%d]',
                   [hum.UserName, GetCharMapInfo(hum.UserName), hum.CX, hum.CY]), 2);
              end;
              1: begin
                hum.SysMsg(Format('ÄãµÄÆÞ×Ó£º%s ÒÑÉÏÏß Ä¿Ç°ÔÚ [ %s ] ×ø±ê [%d£¬%d]',
                   [UserName, GetCharMapInfo(UserName), CX, CY]), 2);
                SysMsg(Format('ÄãµÄÕÉ·ò£º%s Ä¿Ç°ÔÚ [ %s ] ×ø±ê [%d£¬%d]',
                   [hum.UserName, GetCharMapInfo(hum.UserName), hum.CX, hum.CY]), 2);
              end;
            end;


{
            //2005 »©»©·Î ÀÌº¥Æ®
            if LoverPlusAbility then begin
               StatusArr[STATE_TEMPORARY3] := 60000;
               CharStatus := GetCharStatus;
               CharStatusChanged;
            end;
            if hum.LoverPlusAbility then begin
               hum.StatusArr[STATE_TEMPORARY3] := 60000;
               hum.CharStatus := hum.GetCharStatus;
               hum.CharStatusChanged;
            end;
}
         end;
      end else begin
         if UserEngine.FindOtherServerUser (lovername, svidx) then begin
            UserEngine.SendInterMsg (ISM_LM_LOGIN, svidx, UserName + '/' + lovername + '/' + GetCharMapInfo(UserName));
         end;
      end;

//      if (fMaster <> nil) and (fMaster.GetMasterCount <> 0) then begin
//         mastername := TUserHuman(self).fMaster.GetMasterName;
//         if mastername <> '' then begin
//            hum := UserEngine.GetUserHuman(mastername);
//            if hum <> nil then begin
//               hum.SysMsg('ÄãµÄÍ½µÜ£º'+UserName+' ÉÏÏßÁË£¬Ä¿Ç°ÔÚ ['+ GetCharMapInfo(UserName)+'] ×ø±ê [XXX]', 2);
//               SysMsg('ÄãµÄÊ¦¸µ£º'+hum.UserName+' Ä¿Ç°Î»ÓÚ ['+GetCharMapInfo(hum.UserName)+'] ×ø±ê [XXX]', 2);
//            end else begin
//               if UserEngine.FindOtherServerUser (mastername, svidx) then begin
//                  UserEngine.SendInterMsg (ISM_LM_LOGIN, svidx, UserName + '/' + mastername + '/' + GetCharMapInfo(UserName));
//               end;
//            end;
//         end;
//      end;

//      if (TUserHuman(self).fMaster <> nil) and (TUserHuman(self).fMaster.GetPupilCount <> 0) then begin
//         for i := 0 to TUserHuman(self).fMaster.GetPupilCount -1 do begin
//            mastername := TUserHuman(self).fMaster.GetPupilName(i);
//            if mastername <> '' then begin
//               hum := UserEngine.GetUserHuman(mastername);
//               if hum <> nil then begin
//                  hum.SysMsg('ÄãµÄÊ¦¸µ£º'+UserName+' ÉÏÏßÁË£¬Ä¿Ç°ÔÚ ['+GetCharMapInfo(UserName)+'] ×ø±ê [XXX]', 2);
//                  SysMsg('ÄãµÄÍ½µÜ£º'+hum.UserName+' Ä¿Ç°Î»ÓÚ ['+GetCharMapInfo(hum.UserName)+'] ×ø±ê [XXX]', 2);
//               end else begin
//                  if UserEngine.FindOtherServerUser (mastername, svidx) then begin
//                     UserEngine.SendInterMsg (ISM_LM_LOGIN, svidx, UserName + '/' + mastername + '/' + GetCharMapInfo(UserName));
//                  end;
//               end;
//            end;
//         end;
//      end;


      //»ýÀÏ ÃàÇÏ ¸Þ½ÃÁö
      if PremiumBirthDay then begin
         SysMsg(UserName + '×£ÄãÉúÈÕ¿ìÀÖ£¡', 5);
      end;

      //EventCheck
      if EventCheckFlag then begin
         SysMsg(UserName + ' »¶Ó­Ì¤ÈëíÀÂë´óÂ½£¡', 5);
      end;
   end;

   GetQueryUsername(self, CX, CY);   //¿¬ÀÎ Ç¥½Ã
   UserNameChanged;
end;
(*
procedure TUserHuman.ServerGetRelationDBGetList( body : String );
var
   count,i : integer;
   msgstr  : string;
   ListCnt : integer;
   str     : string;
   datastr : string;
   tempstr : string;
   _Name   : string;
   _State  : integer;
   _Msg    : integer;
   _Date   : string;
   _Level  : integer;
   _Sex    : integer;
   hum : TUserHuman;
   svidx: integer;
   lovername, mastername : string;
begin
   // Count / ÄÉ¸¯ÅÍÀÌ¸§:µî·Ï»óÅÂ:¸Þ¼¼Áö:µî·ÏÀÏÀÚ:·¹º§:¼ºº°/...

   str     := GetValidStr3( Body , Datastr , ['/']);
   count   := Str_ToInt( DataStr , 0 );
   _State  := 0;

   for i := 0 to Count -1 do begin
      str := GetValidStr3( str , Datastr , ['/']);
      if datastr <> '' then begin
         datastr := GetValidStr3( datastr , _Name   , [':']);
         datastr := GetValidStr3( datastr , tempstr , [':']);
                _State := Str_ToInt( tempstr , 0);
         datastr := GetValidStr3( datastr , tempstr, [':']);
                _msg   := Str_ToInt( tempstr , 0);
         datastr := GetValidStr3( datastr , _Date   , [':']);
         datastr := GetValidStr3( datastr , tempstr , [':']);
                _Level  := Str_ToInt( tempstr , 0);
                _Sex    := Str_ToInt( datastr , 0);


         case _State of
         rsState_Lover   :// ¿¬ÀÎ
            begin
            FLover.Add( UserName , _Name ,_State , _Level , _Sex , _Date , GetCharMapInfo(_Name) );
            end;
         RsState_LoverEnd:// ¿¬ÀÎÅ»Åð
            begin
            SendDefMessage (SM_LM_RESULT, 0,rsState_Lover, RsError_SuccessDelete, 0, _Name);
            // DB¿¡¼­ »èÁ¦ÇÑ´Ù.
            SendMsg (Self,RM_LM_DBDELETE,0,0,0,0,_Name+':'+IntToStr(_State)+'/');
            end;
         RsState_Master   :// »çºÎ
            begin
            fMaster.Add( UserName , _Name ,_State , _Level , _Sex , _Date , GetCharMapInfo(_Name) );

            end;
         RsState_MasterEnd:// »çºÎÅ»Åð
            begin
            SendDefMessage (SM_LM_RESULT, 0,RsState_Master, RsError_SuccessDelete, 0, _Name);
            // DB¿¡¼­ »èÁ¦ÇÑ´Ù.
            SendMsg (Self,RM_LM_DBDELETE,0,0,0,0,_Name+':'+IntToStr(_State)+'/');
            end;
         RsState_Pupil   :// Á¦ÀÚ
            begin
            fMaster.Add( UserName , _Name ,_State , _Level , _Sex , _Date , GetCharMapInfo(_Name) );
            end;
         RsState_PupilEnd:// Á¦ÀÚÅ»Åð
            begin
            SendDefMessage (SM_LM_RESULT, 0,RsState_Pupil, RsError_SuccessDelete, 0, _Name);
            // DB¿¡¼­ »èÁ¦ÇÑ´Ù.
            SendMsg (Self,RM_LM_DBDELETE,0,0,0,0,_Name+':'+IntToStr(_State)+'/');
            end;

         end;
      end;
   end; // for

   msgstr := Self.fLover.GetListmsg( _State , ListCnt );
   if ( ListCnt > 0 ) then begin
      SendDefMessage (SM_LM_LIST, 0, ListCnt, 0, 0, msgstr);
   end;

   msgstr := Self.fMaster.GetListmsg( 30 , ListCnt );
   if ( ListCnt > 0 ) then begin
      SendDefMessage (SM_LM_LIST, 0, ListCnt, 0, 0, msgstr);
   end;

   msgstr := Self.fMaster.GetListmsg( 40 , ListCnt );
   if ( ListCnt > 0 ) then begin
      SendDefMessage (SM_LM_LIST, 0, ListCnt, 0, 0, msgstr);
   end;

   //ÃÖÃÊ Á¢¼Ó½Ã ¿¬ÀÎ¿¡°Ôµµ º¸³¿(sonmg)
   if not BoServerShifted then begin
      lovername := fLover.GetLoverName;
      hum := UserEngine.GetUserHuman(lovername);
      if hum <> nil then begin
         if hum.fLover.GetLoverName <> '' then begin
            hum.SysMsg(UserName + 'ºÍ ' + GetCharMapInfo(UserName) + '½øÀ´ÁË.', 6);
            SysMsg(hum.UserName + 'ºÍ ' + GetCharMapInfo(hum.UserName) + 'Ò»¸öÈË.', 6);
{
            //2005 »©»©·Î ÀÌº¥Æ®
            if LoverPlusAbility then begin
               StatusArr[STATE_TEMPORARY3] := 60000;
               CharStatus := GetCharStatus;
               CharStatusChanged;
            end;
            if hum.LoverPlusAbility then begin
               hum.StatusArr[STATE_TEMPORARY3] := 60000;
               hum.CharStatus := hum.GetCharStatus;
               hum.CharStatusChanged;
            end;
}
         end;
      end else begin
         if UserEngine.FindOtherServerUser (lovername, svidx) then begin
            UserEngine.SendInterMsg (ISM_LM_LOGIN, svidx, UserName + '/' + lovername + '/' + GetCharMapInfo(UserName));
         end;
      end;

      //»ýÀÏ ÃàÇÏ ¸Þ½ÃÁö
      if PremiumBirthDay then begin
         SysMsg(UserName + '×£ÄãÉúÈÕ¿ìÀÖ!!!', 5);
      end;

      //EventCheck
      if EventCheckFlag then begin
         SysMsg(UserName + 'ÍêÃÀµÄÊÀ½çÔÙ´Î»¶Ó­Äã!!!', 5);
      end;
   end;

   GetQueryUsername(self, CX, CY);   //¿¬ÀÎ Ç¥½Ã

end;   *)

procedure TUserHuman.ServerGetLoverLogout;
begin
   if fLover = nil then exit;

   //SysMsg('ÄãµÄ°®ÈË'+ fLover.GetLoverName + 'ÒÑÏÂÏß', 3);

{
   //2005 »©»©·Î ÀÌº¥Æ®
   if LoverPlusAbility then begin
      StatusArr[STATE_TEMPORARY3] := 0;
      StatusArr[STATE_TEMPORARY1] := 60000;
      CharStatus := GetCharStatus;
      CharStatusChanged;
   end;
}
end;

procedure TUserHuman.ServerSendItemCountChanged (mindex, icount, increase: integer; itmname: string);
begin
   if icount <= 0 then
      MainOutMessage ('[Caution!] icount <= 0 in TUserHuman.ServerSendItemCountChanged');

   Def := MakeDefaultMsg (SM_COUNTERITEMCHANGE, mindex, icount, increase, 0);
   SendSocket (@Def, EncodeString (itmname));
end;

// added by sonmg.
function TUserHuman.DoUpgradeItem( puSeed: PTUserItem; psSeed, psJewelry: PTStdItem ): integer;
begin
   Result := 1;

   // ¾÷±×·¹ÀÌµå °ª ¹Ý¿µ.
   case psSeed.StdMode of
      5, 6: // ¹«±â
         begin
            puSeed.Desc[0] := puSeed.Desc[0] + psJewelry.DC;
            puSeed.Desc[1] := puSeed.Desc[1] + psJewelry.MC;
            puSeed.Desc[2] := puSeed.Desc[2] + psJewelry.SC;

            if psJewelry.AtkSpd > 0 then begin
               // °ø¼Ó ¾÷±×·¹ÀÌµå
               puSeed.Desc[6] := ItemMan.UpgradeAttackSpeed( puSeed.Desc[6], psJewelry.AtkSpd );

{
               // °ø¼ÓÀÇ ½ÇÁ¦°ªÀÌ 1º¸´Ù Å©¸é
               if HiByte(psSeed.MAC) > 10 then begin
                  puSeed.Desc[6] := puSeed.Desc[6] + psJewelry.AtkSpd;
               end else begin // °ø¼ÓÀÌ À½¼öÀÌ¸é
                  puSeed.Desc[6] := puSeed.Desc[6] + psJewelry.AtkSpd;
               end;
}
               // °ø¼Ó ÇÑ°è¸¦ ³ÑÀ» °æ¿ì ÇÑ°è°ªÀ» ´ëÀÔÇÔ.
               puSeed.Desc[6] := _MIN(15 + 10, puSeed.Desc[6]);
            end;
            puSeed.Desc[12] := puSeed.Desc[12] + psJewelry.Slowdown;
            puSeed.Desc[13] := puSeed.Desc[13] + psJewelry.Tox;
         end;
      10, 11: // ¿Ê
         begin
            puSeed.Desc[0] := puSeed.Desc[0] + psJewelry.AC;
            puSeed.Desc[1] := puSeed.Desc[1] + psJewelry.MAC;
            puSeed.Desc[11] := puSeed.Desc[11] + psJewelry.Agility;
            puSeed.Desc[12] := puSeed.Desc[12] + psJewelry.MgAvoid;
            puSeed.Desc[13] := puSeed.Desc[13] + psJewelry.ToxAvoid;
         end;
      15: // Åõ±¸
         begin
            puSeed.Desc[0] := puSeed.Desc[0] + psJewelry.AC;
            puSeed.Desc[1] := puSeed.Desc[1] + psJewelry.MAC;
            puSeed.Desc[11] := puSeed.Desc[11] + psJewelry.Accurate;
            puSeed.Desc[12] := puSeed.Desc[12] + psJewelry.MgAvoid;
            puSeed.Desc[13] := puSeed.Desc[13] + psJewelry.ToxAvoid;
         end;
      19: // ¸ñ°ÉÀÌ19
         begin
            puSeed.Desc[2] := puSeed.Desc[2] + psJewelry.DC;
            puSeed.Desc[3] := puSeed.Desc[3] + psJewelry.MC;
            puSeed.Desc[4] := puSeed.Desc[4] + psJewelry.SC;

            // Á¤È®
            puSeed.Desc[11] := puSeed.Desc[11] + psJewelry.Accurate;
            //¸¶¹ýÀúÇ×
            puSeed.Desc[0] := puSeed.Desc[0] + psJewelry.MgAvoid;

            if psJewelry.AtkSpd > 0 then begin
               puSeed.Desc[9] := puSeed.Desc[9] + psJewelry.AtkSpd;
               // °ø¼Ó ÇÑ°è¸¦ ³ÑÀ» °æ¿ì ÇÑ°è°ªÀ» ´ëÀÔÇÔ.
               puSeed.Desc[9] := _MIN(15, puSeed.Desc[9]);
            end;
            puSeed.Desc[12] := puSeed.Desc[12] + psJewelry.Slowdown;
            puSeed.Desc[13] := puSeed.Desc[13] + psJewelry.Tox;
         end;
      20: // ¸ñ°ÉÀÌ
         begin
            puSeed.Desc[2] := puSeed.Desc[2] + psJewelry.DC;
            puSeed.Desc[3] := puSeed.Desc[3] + psJewelry.MC;
            puSeed.Desc[4] := puSeed.Desc[4] + psJewelry.SC;

            // Á¤È®
            puSeed.Desc[0] := puSeed.Desc[0] + psJewelry.Accurate;
            // ¹ÎÃ¸
            puSeed.Desc[1] := puSeed.Desc[1] + psJewelry.Agility;
            //¸¶¹ýÀúÇ×
            puSeed.Desc[11] := puSeed.Desc[11] + psJewelry.MgAvoid;

            if psJewelry.AtkSpd > 0 then begin
               puSeed.Desc[9] := puSeed.Desc[9] + psJewelry.AtkSpd;
               // °ø¼Ó ÇÑ°è¸¦ ³ÑÀ» °æ¿ì ÇÑ°è°ªÀ» ´ëÀÔÇÔ.
               puSeed.Desc[9] := _MIN(15, puSeed.Desc[9]);
            end;
            puSeed.Desc[12] := puSeed.Desc[12] + psJewelry.Slowdown;
            puSeed.Desc[13] := puSeed.Desc[13] + psJewelry.Tox;
         end;
      21: // ¸ñ°ÉÀÌ
         begin
            puSeed.Desc[2] := puSeed.Desc[2] + psJewelry.DC;
            puSeed.Desc[3] := puSeed.Desc[3] + psJewelry.MC;
            puSeed.Desc[4] := puSeed.Desc[4] + psJewelry.SC;

            //¸¶¹ýÀúÇ×
            puSeed.Desc[7] := puSeed.Desc[7] + psJewelry.MgAvoid;
            // Á¤È®
            puSeed.Desc[11] := puSeed.Desc[11] + psJewelry.Accurate;

            if psJewelry.AtkSpd > 0 then begin
               puSeed.Desc[9] := puSeed.Desc[9] + psJewelry.AtkSpd;
               // °ø¼Ó ÇÑ°è¸¦ ³ÑÀ» °æ¿ì ÇÑ°è°ªÀ» ´ëÀÔÇÔ.
               puSeed.Desc[9] := _MIN(15, puSeed.Desc[9]);
            end;
            puSeed.Desc[12] := puSeed.Desc[12] + psJewelry.Slowdown;
            puSeed.Desc[13] := puSeed.Desc[13] + psJewelry.Tox;
         end;
      22: // ¹ÝÁö
         begin
            puSeed.Desc[0] := puSeed.Desc[0] + psJewelry.AC;
            puSeed.Desc[1] := puSeed.Desc[1] + psJewelry.MAC;
            puSeed.Desc[2] := puSeed.Desc[2] + psJewelry.DC;
            puSeed.Desc[3] := puSeed.Desc[3] + psJewelry.MC;
            puSeed.Desc[4] := puSeed.Desc[4] + psJewelry.SC;
            if psJewelry.AtkSpd > 0 then begin
               puSeed.Desc[9] := puSeed.Desc[9] + psJewelry.AtkSpd;
               // °ø¼Ó ÇÑ°è¸¦ ³ÑÀ» °æ¿ì ÇÑ°è°ªÀ» ´ëÀÔÇÔ.
               puSeed.Desc[9] := _MIN(15, puSeed.Desc[9]);
            end;
            puSeed.Desc[12] := puSeed.Desc[12] + psJewelry.Slowdown;
            puSeed.Desc[13] := puSeed.Desc[13] + psJewelry.Tox;
         end;
      23: // ¹ÝÁö23
         begin
            puSeed.Desc[2] := puSeed.Desc[2] + psJewelry.DC;
            puSeed.Desc[3] := puSeed.Desc[3] + psJewelry.MC;
            puSeed.Desc[4] := puSeed.Desc[4] + psJewelry.SC;
            if psJewelry.AtkSpd > 0 then begin
               puSeed.Desc[9] := puSeed.Desc[9] + psJewelry.AtkSpd;
               // °ø¼Ó ÇÑ°è¸¦ ³ÑÀ» °æ¿ì ÇÑ°è°ªÀ» ´ëÀÔÇÔ.
               puSeed.Desc[9] := _MIN(15, puSeed.Desc[9]);
            end;
            puSeed.Desc[12] := puSeed.Desc[12] + psJewelry.Slowdown;
            puSeed.Desc[13] := puSeed.Desc[13] + psJewelry.Tox;
         end;
      24: // ÆÈÂî24
         begin
            puSeed.Desc[0] := puSeed.Desc[0] + psJewelry.Accurate; //Á¤È®
            puSeed.Desc[1] := puSeed.Desc[1] + psJewelry.Agility;  //¹ÎÃ¸
            puSeed.Desc[2] := puSeed.Desc[2] + psJewelry.DC;
            puSeed.Desc[3] := puSeed.Desc[3] + psJewelry.MC;
            puSeed.Desc[4] := puSeed.Desc[4] + psJewelry.SC;
         end;
      26: // ÆÈÂî26
         begin
            puSeed.Desc[0] := puSeed.Desc[0] + psJewelry.AC;
            puSeed.Desc[1] := puSeed.Desc[1] + psJewelry.MAC;
            puSeed.Desc[2] := puSeed.Desc[2] + psJewelry.DC;
            puSeed.Desc[3] := puSeed.Desc[3] + psJewelry.MC;
            puSeed.Desc[4] := puSeed.Desc[4] + psJewelry.SC;

            // Á¤È®
            puSeed.Desc[11] := puSeed.Desc[11] + psJewelry.Accurate;
            // ¹ÎÃ¸
            puSeed.Desc[12] := puSeed.Desc[12] + psJewelry.Agility;
         end;
      52: // ½Å¹ß
         begin
            puSeed.Desc[0] := puSeed.Desc[0] + psJewelry.AC;
            puSeed.Desc[1] := puSeed.Desc[1] + psJewelry.MAC;

            // ¹ÎÃ¸
            puSeed.Desc[3] := puSeed.Desc[3] + psJewelry.Agility;
         end;
      54: // º§Æ®
         begin
            puSeed.Desc[0] := puSeed.Desc[0] + psJewelry.AC;
            puSeed.Desc[1] := puSeed.Desc[1] + psJewelry.MAC;

            // Á¤È®
            puSeed.Desc[2] := puSeed.Desc[2] + psJewelry.Accurate;
            // ¹ÎÃ¸
            puSeed.Desc[3] := puSeed.Desc[3] + psJewelry.Agility;

            puSeed.Desc[13] := puSeed.Desc[13] + psJewelry.ToxAvoid;
         end;
      else
         begin
            Result := 0;
            exit;
         end;
   end;

   // ÃÖ´ë³»±¸·Â ¾÷±×·¹ÀÌµå
   puSeed.DuraMax := _MIN(65000, puSeed.DuraMax + psJewelry.DuraMax);

   SendUpdateItem (puSeed^);
   SendMsg (self, RM_ABILITY, 0, 0, 0, 0, '');
   SendMsg (self, RM_SUBABILITY, 0, 0, 0, 0, '');
end;

//±ÛÀÚ»ö Å×½ºÆ®
procedure TUserHuman.CmdLetterColor( strColor : string );
var
   Def: TDefaultMessage;
   str: string;
begin
   Def := MakeDefaultMsg (SM_WHISPER, integer(self), MakeWord(Str_ToInt(strColor, 0), 255), 0, 1);

   str := EncodeString ('²âÊÔÖÐÎÄ×ÖµÄÑÕÉ« ' + strColor);
   SendSocket (@Def, str);
end;

// Ä«¿îÆ® ¾ÆÀÌÅÛ ÅëÇÕ.
procedure TUserHuman.ServerGetSumCountItem(org_mindex, ex_mindex: integer; itmnames: string);
var
   flag: Boolean;
   i: integer;
   pu_org, pu_ex: PTUserItem;
   ps_org, ps_ex: PTStdItem;
   org_itmname, ex_itmname: string;
begin
   pu_org := nil;
   pu_ex := nil;
   ps_org := nil;
   ps_ex := nil;

   flag := FALSE;
   // RightStr := GetValidStr3 (OrgStr, LeftStr of Separator, Separator);
   ex_itmname := GetValidStr3(itmnames, org_itmname, ['/']);

   // Ex ¾ÆÀÌÅÛ °Ë»ö.
   for i:=0 to ItemList.Count-1 do begin
      if PTUserItem(ItemList[i]).MakeIndex = ex_mindex then begin
         if CompareText (UserEngine.GetStdItemName (PTUserItem(ItemList[i]).Index), ex_itmname) = 0 then begin
            pu_ex := PTUserItem(ItemList[i]);

            if pu_ex <> nil then begin
               ps_ex := UserEngine.GetStdItem (pu_ex.Index);

               if ps_ex <> nil then begin
                  if ps_ex.OverlapItem >= 1 then begin
                     flag := TRUE;
                     break;
                  end;
               end;
            end;
         end;
      end;
   end;

   if flag = FALSE then
      exit;

   if ps_ex = nil then
      exit;

   flag := FALSE;

   // °¡¹æÃ¢¿¡ ÀÖ´Â ÇØ´ç ¾ÆÀÌÅÛ¿¡ Ä«¿îÆ®¸¦ ÇÕ»êÇÑ´Ù.
   // Org ¾ÆÀÌÅÛÀ» °Ë»öÇØ¼­ Ä«¿îÆ® º¯°æ.
   for i:=0 to ItemList.Count-1 do begin
      if PTUserItem(ItemList[i]).MakeIndex = org_mindex then begin
         if CompareText (UserEngine.GetStdItemName (PTUserItem(ItemList[i]).Index), org_itmname) = 0 then begin
            pu_org := PTUserItem(ItemList[i]);

            if pu_org <> nil then begin
               ps_org := UserEngine.GetStdItem (pu_org.Index);

               if ps_org <> nil then begin
                  if (ps_org.OverlapItem >= 1) and (ps_ex.OverlapItem >= 1) then begin
                     if CompareText (ps_org.Name, ps_ex.Name) = 0 then begin
                        if pu_org.MakeIndex <> pu_ex.MakeIndex then begin

                           // ÃÖ´ë °³¼ö Á¦ÇÑ (sonmg)
                           if pu_org.Dura + pu_ex.Dura > MAX_OVERLAPITEM then
                              break;

                           // ÇÕÀÌ MAX_OVERFLOW°¡ ³ÑÀ¸¸é µû·Î »ý¼ºÇÏ°Å³ª °°Àº Á¾·ùÀÇ ¾ÆÀÌÅÛ¿¡ ÇÕ»ê.
                           if pu_org.Dura + pu_ex.Dura > MAX_OVERFLOW then begin
                              // °°Àº Á¾·ùÀÇ ÃÖ¼Ò °³¼ö ¾ÆÀÌÅÛ¿¡ ÇÕ»ê.
                              // µé°í ÀÖ´Â ¾ÆÀÌÅÛÀº ÃÖ¼Ò °³¼ö ¾ÆÀÌÅÛ °Ë»ç¿¡¼­ Á¦¿Ü.
                              if UserCounterItemAdd(ps_ex.StdMode, ps_ex.Looks, pu_ex.Dura, ps_ex.Name, TRUE, pu_ex.MakeIndex) then begin
                                 flag := TRUE;
                                 break;
                              end else begin
                                 // ÀÌ·± °æ¿ì´Â ¾ø¾î¾ß °ÚÁö¸¸ ÃÖ¾ÇÀÇ °æ¿ì
                                 // °¡¹æÃ¢ ¸ñ·ÏÀ» Å¬¶óÀÌ¾ðÆ®·Î º¸³½´Ù.
                                 // °¡¹æÃ¢ÀÇ ¾ÆÀÌÅÛ À§Ä¡°¡ ¹Ù²ð ¼ö ÀÖÀ½.
                                 SendBagItems;
                                 break;
                              end;
                           end else begin
                              // ÇÕÀÌ MAX_OVERFLOW°¡ ¾ÈµÇ¸é ±×³É ÇÕÄ§.
                              pu_org.Dura := pu_org.Dura + pu_ex.Dura;  // Ä«¿îÆ® ÅëÇÕ
                           end;
                           flag := TRUE;
                        end;
                        SendMsg(self, RM_COUNTERITEMCHANGE, 0, pu_org.MakeIndex, pu_org.Dura, 0, ps_org.Name);
                        WeightChanged;
                        break;
                     end;
                  end;
               end;
            end;
         end;
      end;
   end;

   if flag = FALSE then
      exit;

   // Ex ¾ÆÀÌÅÛ »èÁ¦
   DeletePItemAndSend (pu_ex);

end;

function TuserHuman.SetExpiredTime( min_ : integer ):Boolean;
begin
   Result := false;
   if Abil.Level > g_nExpErienceLevel then begin
      FExpireTime  := GetTickCount + (60 * 1000);
      FExpireCount := min_;
      Result := true;
   end;
end;

procedure TuserHuman.CheckExpiredTime;
begin
   if FExpireTime > 0 then begin
      if ( FExpireTime < GetTickCount ) then begin

         if FExpireCount > 0 then begin
            if (FExpireCount mod 60) = 0 then begin
               SysMsg( 'Ê¹ÓÃµ½ÆÚÁË ' + IntToStr(FExpireCount div 60) +
                       '·ÖÖÓºó¹Ø±Õ', 0);//Õâ¸ö¹¦ÄÜÄãÖªµÀÃ´
               FExpireCount := FExpireCount - 60;
            end;
            FExpireTime := GetTickCount + ( {60 *} 1000 );
         end else begin
            FExpireTime       := 0;
            FExpireCount      := 0;
            BoAccountExpired  := TRUE;
         end;
      end;
   end;
end;

// µ¥ÀÌÅÍ º£ÀÌ½º·Î ¿äÃ»ÇÏ´Â ºÎºÐ -----------------------------------------------
// Page_ = 0 Ã³À½ÆäÀÌÁö , 1=´ÙÀ½ÆäÀÌÁö
procedure TUserHuman.ServerGetMarketList( MarketNpc : TCreature ; page_ : integer ; body :string);
var
   ItemName_   : string;
begin
   if MarketNpc <> nil then FMarketNPC := MarketNpc;

   case Page_ of
   0   :
      begin
         RequireLoadRefresh;
      end;
   1   : SendUserMarketList( page_ );
   2   :
      begin
         ItemName_ :=  body ;
         if ( ItemName_ <> '')  and ( UserEngine.GetStdItemIndex( ItemName_ ) <> -1 ) then begin
            RequireLoadUserMarket( GetMarketName ,USERMARKET_TYPE_ITEMNAME , 1, '' , ItemName_ );
         end else begin
            SendMsg(self, RM_MARKET_RESULT, 0, 0, UMResult_NoItem, 0, '');
            BoxMsg ('ÎïÆ·Ãû×Ö´íÎó', 1);
         end;
     end;
   end;
end;

procedure TUserHuman.ServerGetMarketSell( MarketNpc: TCreature; count_: integer; makeindex_: integer; body: String );
var
   buffer1, buffer2 : string;
   money : integer;
begin

   if MarketNpc <> nil then FMarketNPC := MarketNpc;

   buffer1 := body;
   buffer1 := GetValidStr3( buffer1, buffer2, ['/'] );
   money := Str_ToInt(buffer2, 0);

   RequireSellUserMarket( MakeIndex_ , count_ , money );
end;

procedure TUserHuman.ServerGetMarketBuy( MarketNpc : TCreature; SellIndex_ : integer );
begin
   if MarketNpc <> nil then FMarketNPC := MarketNpc;

   RequireBuyUserMarket( MarketNpc , SellIndex_ );
end;

procedure TUserHuman.ServerGetMarketCancel( MarketNpc : TCreature; SellIndex_ : integer );
begin
   if MarketNpc <> nil then FMarketNPC := MarketNpc;

   RequireCancelUserMarket( MarketNpc , SellIndex_ );
end;

procedure TUserHuman.ServerGetMarketGetPay( MarketNpc : TCreature; SellIndex_ : integer );
begin
   if MarketNpc <> nil then FMarketNPC := MarketNpc;

   RequireGetPayUserMarket( MarketNpc , SellIndex_);
end;

procedure TUserHuman.ServerGetMarketClose;
begin
   FUserMarket.Clear;

{$IFDEF DEBUG}
   MainOutMessage('MarketClear :'+ UserName);
{$ENDIF}

end;

// Àå¿ø ¸ñ·Ï ÆäÀÌÁö º¯°æ ¸Þ½ÃÁö Ã³¸®.
procedure TUserHuman.ServerGetGuildAgitList ( page : integer );
begin
   CmdGuildAgitBuy( page );
end;

function TUserHuman.ServerGetGuildAgitTag ( who : TCreature; body : string ):Boolean; // Àå¿ø ÂÊÁö
var
   hum : TUserHuman;
begin
   Result := FALSE;

   hum := UserEngine.GetUserHuman(who.UserName);
   if hum <> nil then begin
//      if TGuild(hum.MyGuild).GetTotalMemberCount > MINAGITMEMBER then begin
      if hum.IsGuildMaster then begin
//         SysMsg('¹®ÁÖÀÔ´Ï´Ù.', 0);
         Result := TRUE;
      end else begin
         BoxMsg('Ö»ÓÐÐÐ»á¹ÜÀíÔ±²ÅÄÜÊ¹ÓÃ¡£', 0);
      end;
   end;
end;

// Àå¿ø °Ô½ÃÆÇ ¸ñ·Ï ÆäÀÌÁö º¯°æ ¸Þ½ÃÁö.
procedure TUserHuman.ServerGetGaBoardList ( page : integer );  //Àå¿ø°Ô½ÃÆÇ ¸ñ·Ï
begin
   CmdGaBoardList( page );
end;

// Àå¿ø °Ô½ÃÆÇ ±ÛÀÐ±â.
procedure TUserHuman.ServerGetGaBoardRead ( NumSeries : string );
var
   gname, gnameHere, data: string;
begin
   if MyGuild = nil then exit;
   if TGuild(MyGuild).GuildName = '' then exit;

   //¹®ÆÄ¸í º¹»ç.
   gname := TGuild(MyGuild).GuildName;
   gnameHere := GetGuildNameHereAgit;

   // ÇöÀç Àå¿øÀÇ ¹®ÆÄ°¡ ¾Æ´Ï¸é...
   if gname <> gnameHere then begin
      // ¿î¿µÀÚ´Â ¸ðµç °Ô½ÃÆÇÀ» º¼ ¼ö ÀÖÀ½.
      if UserDegree >= UD_ADMIN then begin
         gname := gnameHere;
      end else begin
         SysMsg('Äã²»ÄÜÔÄ¶ÁÎÄÕÂ¡£', 0);
         exit;
      end;
   end;

   data := GuildAgitBoardMan.GetArticle( gname, NumSeries );

//   SysMsg(data, 2);//Å×½ºÆ® °Ô½ÃÆÇ
   Def := MakeDefaultMsg (SM_GABOARD_READ, 0, 0, 0, 0);
   SendSocket (@Def, EncodeString (data));
end;

// Àå¿ø °Ô½ÃÆÇ ±Û¾²±â.
procedure TUserHuman.ServerGetGaBoardAdd ( nKind, nCurPage : integer; body : string );
var
   GuildAgitNum : integer;
   guildagit : TGuildAgit;
   strTemp : string;
   OrgNum : integer;
begin
   GuildAgitNum := 0;

   if nKind = KIND_NOTICE then begin
      if not IsMyGuildMaster then begin
         SysMsg('Ö»ÓÐÐÐ»á¹ÜÀíÔ±²ÅÄÜ±àÐ´¡£', 0);
         exit;
      end;
   end;

   if MyGuild = nil then exit;
   if TGuild(MyGuild).GuildName = '' then exit;

   //Äõ¸®¿¡ µé¾î°¡¼­´Â ¾ÈµÇ´Â ±ÛÀÚ.
   if StrScan(PChar(body), '''') <> nil then exit;

   guildagit := GuildAgitMan.GetGuildAgit( TGuild(MyGuild).GuildName );
   if guildagit <> nil then begin
      GuildAgitNum := guildagit.GuildAgitNumber;
   end;

   // ³»¿ë ¾Õ¿¡ À¯ÀúÀÌ¸§ Ãß°¡.
   if GuildAgitBoardMan.AddArticle( TGuild(MyGuild).GuildName, nKind, GuildAgitNum, UserName, body ) then begin
      if nKind = KIND_NOTICE then begin
         // Å¬¶óÀÌ¾ðÆ®·Î °Ô½ÃÆÇ ³»¿ë °»½Å.
         CmdReloadGaBoardList ( TGuild(MyGuild).GuildName, nCurPage{ÇöÀçÆäÀÌÁö} );
      end else begin
         // OrgNum ÃßÃâ.
         GetValidStr3( body, strTemp, ['/', #0] );
         OrgNum := Str_ToInt( strTemp, -1 );

         // ¿øº» ±Û¾²±âÀÌ¸é Ã¹ÆäÀÌÁö...
         if OrgNum = 0 then begin
            // Å¬¶óÀÌ¾ðÆ®·Î °Ô½ÃÆÇ ³»¿ë °»½Å.
            CmdReloadGaBoardList ( TGuild(MyGuild).GuildName, 1{Ã¹ÆäÀÌÁö} );
         end else begin
            // ¾Æ´Ï¸é ÇöÀçÆäÀÌÁö...
            // Å¬¶óÀÌ¾ðÆ®·Î °Ô½ÃÆÇ ³»¿ë °»½Å.
            CmdReloadGaBoardList ( TGuild(MyGuild).GuildName, nCurPage{ÇöÀçÆäÀÌÁö} );
         end;
      end;
   end;
end;

// Àå¿ø °Ô½ÃÆÇ ±Û»èÁ¦.
procedure TUserHuman.ServerGetGaBoardDel ( nCurPage: integer; body : string );
var
   GuildAgitNum : integer;
   guildagit : TGuildAgit;
begin
   GuildAgitNum := 0;

   if MyGuild = nil then exit;
   if TGuild(MyGuild).GuildName = '' then exit;

   //Äõ¸®¿¡ µé¾î°¡¼­´Â ¾ÈµÇ´Â ±ÛÀÚ.
   if StrScan(PChar(body), '''') <> nil then exit;

   guildagit := GuildAgitMan.GetGuildAgit( TGuild(MyGuild).GuildName );
   if guildagit <> nil then begin
      GuildAgitNum := guildagit.GuildAgitNumber;
   end;

   // ³»¿ë ¾Õ¿¡ À¯ÀúÀÌ¸§ Ãß°¡.
   if GuildAgitBoardMan.DelArticle( TGuild(MyGuild).GuildName, UserName, body ) then begin
      // Å¬¶óÀÌ¾ðÆ®·Î °Ô½ÃÆÇ ³»¿ë °»½Å.
      CmdReloadGaBoardList ( TGuild(MyGuild).GuildName, nCurPage{ÇöÀçÆäÀÌÁö} );
   end;
end;

procedure TUserHuman.ServerGetGaBoardDelAll ( nCurPage: integer; body : string );
var
   GuildAgitNum : integer;
   guildagit : TGuildAgit;
begin
   GuildAgitNum := 0;

   if MyGuild = nil then exit;
   if TGuild(MyGuild).GuildName = '' then exit;

   //¹®ÁÖ¸¸ ±ÇÇÑ
   if not IsGuildMaster then exit;

   //Àå¿øÀÇ ¹®ÁÖ°¡ ÇöÀç ÀÚ½ÅÀÇ Àå¿ø¿¡ ÀÖ¾î¾ß ÇÔ.
   if TGuild(MyGuild).GuildName <> GetGuildNameHereAgit then exit;

   //Äõ¸®¿¡ µé¾î°¡¼­´Â ¾ÈµÇ´Â ±ÛÀÚ.
   if StrScan(PChar(body), '''') <> nil then exit;

   guildagit := GuildAgitMan.GetGuildAgit( TGuild(MyGuild).GuildName );
   if guildagit <> nil then begin
      GuildAgitNum := guildagit.GuildAgitNumber;
   end;

   if GuildAgitNum > 0 then begin
      // Àå¿ø ¹øÈ£·Î °Ë»öÇÏ¿© ¸ðµÎ »èÁ¦ (°Ô½ÃÆÇÃÊ±âÈ­)
      if SQLEngine.RequestGuildAgitBoardDelAll( TGuild(MyGuild).GuildName, GuildAgitNum, UserName ) then begin
         // SQL¿¡¼­ ¼­¹ö·Î ´Ù½Ã ÀÐ¾î Å¬¶óÀÌ¾ðÆ®·Î °Ô½ÃÆÇ ³»¿ë °»½Å.
         GuildAgitBoardMan.LoadAllGaBoardList( '' );
{$IFDEF KOREA}
         BoxMsg('¹«¸æ°åÒÑ³õÊ¼»¯.', 0);
{$ELSE}
         BoxMsg('The Bulletin Board has been initialized.', 0);
{$ENDIF}
      end;
   end;
end;

// Àå¿ø °Ô½ÃÆÇ ±Û¼öÁ¤.
procedure TUserHuman.ServerGetGaBoardEdit ( nCurPage: integer; body : string );
var
   GuildAgitNum : integer;
   guildagit : TGuildAgit;
begin
   GuildAgitNum := 0;

   if MyGuild = nil then exit;
   if TGuild(MyGuild).GuildName = '' then exit;

   //Äõ¸®¿¡ µé¾î°¡¼­´Â ¾ÈµÇ´Â ±ÛÀÚ.
   if StrScan(PChar(body), '''') <> nil then exit;

   guildagit := GuildAgitMan.GetGuildAgit( TGuild(MyGuild).GuildName );
   if guildagit <> nil then begin
      GuildAgitNum := guildagit.GuildAgitNumber;
   end;

   // ³»¿ë ¾Õ¿¡ À¯ÀúÀÌ¸§ Ãß°¡.
   if GuildAgitBoardMan.EditArticle( TGuild(MyGuild).GuildName, UserName, body ) then begin
      // Å¬¶óÀÌ¾ðÆ®·Î °Ô½ÃÆÇ ³»¿ë °»½Å.
      CmdReloadGaBoardList ( TGuild(MyGuild).GuildName, nCurPage{ÇöÀçÆäÀÌÁö} );
   end;
end;

//Àå¿ø ¹®ÁÖ Ã¼Å©.
procedure TUserHuman.ServerGetGaBoardNoticeCheck;
begin
   if IsMyGuildMaster then begin
      SendMsg (self, RM_GABOARD_NOTICE_OK, 0, 0, 0, 0, UserName);
   end else begin
      SendMsg (self, RM_GABOARD_NOTICE_FAIL, 0, 0, 0, 0, UserName);
   end;
end;

procedure TUserHuman.ServerGetTrans (page : integer );
begin
  boShowTrans := Boolean(page);
  FeatureChanged;
end;

//Àå¿ø²Ù¹Ì±â ¾ÆÀÌÅÛ ±¸ÀÔ
procedure TUserHuman.ServerGetDecoItemBuy (msg, npcid, itemindex: integer; itemname: string);
var
   i: integer;
   npc: TCreature;
begin
   if BoDealing then exit;  //±³È¯Áß¿¡´Â ¹°°ÇÀ» »ì ¼ö ¾ø´Ù.
   npc := UserEngine.GetMerchant (npcid);
   if npc <> nil then begin
      if (npc.PEnvir = PEnvir) and (abs(npc.CX-CX) <= 15) and (abs(npc.CY-CY) <= 15) then begin
         if msg = CM_DECOITEM_BUY then begin
            if itemindex >= 0 then
               CmdBuyDecoItem( itemindex );
         end;
      end;
   end;
end;

procedure TUserHuman.ServerGetDeath(who: TCreature);
begin
//  who.SendRefMsg(RM_DEATH, who.Dir, who.CX, who.CY, 1, '');
//  who.Death2 := True;
end;

//procedure TUserHuman.ServerGetCashRefesh;
//begin
//  FrmIDSoc.SendPotCashList (UserName, UserId, Certification); //ÖØÐÂ¼ÓÔØPCÊýÁ¿
//end;

// Àå¿ø °Å·¡ ¼º»ç -> Àå¿ø ¸ñ·Ï¿¡ ±â·Ï.
// ¸®ÅÏ°ª : Àå¿ø¹øÈ£ (-1 ÀÌ¸é Error)
function TUserHuman.ExecuteGuildAgitTrade : integer;
var
   gname, mastername, deal_gname, deal_mastername: string;
   guildagit, deal_guildagit : TGuildAgit;
begin
   Result := -1;

   if IsGuildMaster then begin   // ¹®ÁÖÀÌ¸é
      if DealCret.IsGuildMaster then begin   // »ó´ë¹æµµ ¹®ÁÖÀÌ¸é
         gname := TGuild(MyGuild).GuildName;
         mastername := UserName;
         deal_gname := TGuild(DealCret.MyGuild).GuildName;
         deal_mastername := DealCret.UserName;

         // ÀÚ±â ÀÚ½ÅÀÇ ¹®ÆÄ Àå¿øÀ» Ã£´Â´Ù.
         guildagit := GuildAgitMan.GetGuildAgit( gname );
         deal_guildagit := GuildAgitMan.GetGuildAgit( deal_gname );

         // µÑ ´Ù Àå¿øÀ» ¼ÒÀ¯ÇÏ°í ÀÖÀ¸¸é
         if (guildagit <> nil) and (deal_guildagit <> nil) then begin
            BoxMsg('¶Ô·½ÒÑÓµÓÐÒ»¸öÐÐ»áµÄÁìÍÁ.', 0);
            DealCret.BoxMsg('¶Ô·½ÒÑÓµÓÐÒ»¸öÐÐ»áµÄÁìÍÁ.', 0);
            exit;
         end;

         if guildagit <> nil then begin
            if guildagit.GetCurrentDelayStatus <= 0 then begin
               BoxMsg('Õâ¸öÐÐ»á×¯Ô°×âÓÃÆÚÏÞ¼´½«µ½ÆÚ£¬Äã¿ÉÒÔ¹ºÂòÕâ¸öÐÐ»á×¯Ô°.', 0);
               DealCret.BoxMsg('ÐÐ»á×¯Ô°×âÓÃÆÚÏÞ¼´½«µ½ÆÚ£¬Äã¿ÉÒÔ³öÊÛÄãµÄÐÐ»á×¯Ô°.', 0);
               exit;
            end;
            if (guildagit.IsForSale = FALSE) or guildagit.IsSoldOut then begin
               BoxMsg('ÐÐ»á×¯Ô°Ä¿Ç°²»ÔÚÏúÊÛ×´Ì¬.', 0);
               DealCret.BoxMsg('ÐÐ»á×¯Ô°²»ÔÚÏúÊÛ×´Ì¬ÖÐ.', 0);
               exit;
            end;
            if GuildAgitMan.IsExistInForSaleGuild( TGuild(DealCret.MyGuild).GuildName ) then begin
               BoxMsg('¶Ô·½ÒÑ¾­Ìá³ö¹ºÂòÇëÇó.', 0);
               DealCret.BoxMsg('ÒÑ¾­Ìá³ö¹ºÂòÇëÇó.', 0);
               exit;
            end;
            if TGuild(DealCret.MyGuild).GetTotalMemberCount <= MINAGITMEMBER then begin
               BoxMsg('¶Ô·½ÖÁÉÙÐèÒª ' + IntToStr(MINAGITMEMBER) + '¸öÐÐ»á³ÉÔ±.', 0);
               DealCret.BoxMsg('ÄãÖÁÉÙÐèÒª ' + IntToStr(MINAGITMEMBER) + '¸öÐÐ»á³ÉÔ±.', 0);
               exit;
            end;
            // Àå¿ø °Å·¡ ¼º»ç
            if GuildAgitMan.GuildAgitTradeOk( gname, deal_gname, deal_mastername ) then begin
               DealCret.BoxMsg('½»Ò×Õâ¸öÐÐ»á×¯Ô°£¬ÔÚ ' + IntToStr(GUILDAGIT_SALEWAIT_DAYUNIT) + 'ÌìÒÔºó£¬½«È¡ÏûËùÓÐÈ¨¡£\ \Õâ¸öÐÐ»á×¯Ô°µÄ×âÓÃÆÚÏÞÎª ' + IntToStr( GuildAgitMan.GetTradingRemainDate( gname ) ) + 'Ìì.', 0);
               //--------------------------
               //¸í¼ºÄ¡ È¹µæ/°¨¼Ò(Àå¿ø°Å·¡)
               if ENABLE_FAME_SYSTEM then begin
                  DealCret.IncFamePoint( 500 );
                  DecFamePoint( 200 );
               end;
               //--------------------------
               Result := guildagit.GuildAgitNumber;
            end;
         end else begin
            if deal_guildagit <> nil then begin
               if deal_guildagit.GetCurrentDelayStatus <= 0 then begin
                  BoxMsg('ÐÐ»á×¯Ô°×âÓÃÆÚÏÞ¼´½«µ½ÆÚ£¬Äã¿ÉÒÔ³öÊÛÄãµÄÐÐ»á×¯Ô°.', 0);
                  DealCret.BoxMsg('Õâ¸öÐÐ»á×¯Ô°×âÓÃÆÚÏÞ¼´½«µ½ÆÚ£¬Äã¿ÉÒÔ¹ºÂòÕâ¸öÐÐ»á×¯Ô°.', 0);
                  exit;
               end;
               if (deal_guildagit.IsForSale = FALSE) or deal_guildagit.IsSoldOut then begin
                  BoxMsg('ÐÐ»á×¯Ô°²»ÔÚÏúÊÛ×´Ì¬ÖÐ.', 0);
                  DealCret.BoxMsg('ÐÐ»á×¯Ô°Ä¿Ç°²»ÔÚÏúÊÛ×´Ì¬.', 0);
                  exit;
               end;
               if GuildAgitMan.IsExistInForSaleGuild( TGuild(MyGuild).GuildName ) then begin
                  BoxMsg('ÒÑ¾­Ìá³ö¹ºÂòÇëÇó.', 0);
                  DealCret.BoxMsg('¶Ô·½ÒÑ¾­Ìá³ö¹ºÂòÇëÇó.', 0);
                  exit;
               end;
               if TGuild(MyGuild).GetTotalMemberCount <= MINAGITMEMBER then begin
                  BoxMsg('ÄãÖÁÉÙÐèÒª ' + IntToStr(MINAGITMEMBER) + '¸öÐÐ»á³ÉÔ±.', 0);
                  DealCret.BoxMsg('¶Ô·½ÖÁÉÙÐèÒª ' + IntToStr(MINAGITMEMBER) + '¸öÐÐ»á³ÉÔ±.', 0);
                  exit;
               end;
               // Àå¿ø °Å·¡ ¼º»ç
               if GuildAgitMan.GuildAgitTradeOk( deal_gname, gname, mastername ) then begin
                  BoxMsg('¹ºÂòÐÐ»á×¯Ô°ºó£¬ÔÚ ' + IntToStr(GUILDAGIT_SALEWAIT_DAYUNIT) + 'ÌìÖ®ºó£¬½«È¡ÏûËùÓÐÈ¨¡£\ \Õâ¸öÐÐ»á×¯Ô°µÄ×âÓÃÆÚÏÞÎª ' + IntToStr( GuildAgitMan.GetTradingRemainDate( deal_gname ) ) + 'Ìì.', 0);
                  //--------------------------
                  //¸í¼ºÄ¡ È¹µæ/°¨¼Ò(Àå¿ø°Å·¡)
                  if ENABLE_FAME_SYSTEM then begin
                     IncFamePoint( 500 );
                     DealCret.DecFamePoint( 200 );
                  end;
                  //--------------------------
                  Result := deal_guildagit.GuildAgitNumber;
               end;
            end else begin
               BoxMsg('²»ÄÜÊ¹ÓÃ.', 0);
               DealCret.BoxMsg('²»ÄÜÊ¹ÓÃ.', 0);
            end;
         end;
      end else begin
         SysMsg('Õâ¸öÈË²»ÊÇÐÐ»á¹ÜÀíÔ±.', 0);
      end;
   end else begin
      SysMsg('½öÐÐ»á¹ÜÀíÔ±²Å¿ÉÒÔÊ¹ÓÃÕâ¸öÃüÁî.', 0);
   end;
end;

procedure TUserHuman.SendUserMarketCloseMsg;
begin
    SendMsg(self, RM_MARKET_RESULT, 0, 0, UMResult_MarketNotReady, 0, '');
    BoxMsg ('Äã²»ÄÜÊ¹ÓÃ¼ÄÊÛÉÌÈË¹¦ÄÜ.', 1);
end;

procedure TUserHuman.RequireLoadRefresh;
begin

    if not SqlEngine.RequestLoadPageUserMarket( FUserMarket.REqInfo ) then
    begin
      SendUserMarketCloseMsg;
      Exit;
    end;

end;
//À§Å¹ÆÇ¸Å ¸®½ºÆ® ÀÐ±â.
procedure TUserHuman.RequireLoadUserMarket(
    MarketName  : string ;  // ¸¶ÄÏÀÌ¸§ : ¼­¹ö+NPC ÀÌ¸§
    ItemType    : integer;  // ¾ÆÀÌÅÛ Á¾·ù ±¸ºÐÀÚ
    UserMode    : integer;  // À¯ÀúÀÇ ÀÛ¾÷ Á¾·ù
    OtherName   : string;    // ´Ù¸¥»ç¶÷ÀÇ ÀÌ¸§À¸·Î °Ë»öÇÒ¶§ »ç¿ë : ÇöÀç ¹Ì»ç¿ë
    ItemName_   : string
);
var
    isok : boolean;
begin

    FUserMarket.ReqInfo.UserName    := UserName;
    FUserMarket.ReqInfo.MarketName  := MarketName;
    FUserMarket.ReqInfo.SearchWho   := OtherName;
    FUserMarket.ReqInfo.SearchItem  := ItemName_;
    FUserMarket.ReqInfo.ItemType    := ItemType;
    FUserMarket.ReqInfo.ItemSet     := 0;
    FUserMarket.ReqInfo.UserMode    := UserMode;

    isOk := false;

    case ItemType of

      USERMARKET_TYPE_ALL     ,         // ¸ðµÎ
      USERMARKET_TYPE_WEAPON  ,         // ¹«±â
      USERMARKET_TYPE_NECKLACE,         // ¸ñ°ÉÀÌ
      USERMARKET_TYPE_RING    ,         // ¹ÝÁö     ¤¡
      USERMARKET_TYPE_BRACELET,         // ÆÈÂî,Àå°©
      USERMARKET_TYPE_CHARM   ,         // ¼öÈ£¼®
      USERMARKET_TYPE_HELMET  ,         // Åõ±¸
      USERMARKET_TYPE_BELT    ,         // Çã¸®¶ì
      USERMARKET_TYPE_SHOES   ,         // ½Å¹ß
      USERMARKET_TYPE_ARMOR   ,         // °©¿Ê
      USERMARKET_TYPE_DRINK   ,         // ½Ã¾à
      USERMARKET_TYPE_JEWEL   ,         // º¸¿Á,½ÅÁÖ
      USERMARKET_TYPE_BOOK    ,         // Ã¥
      USERMARKET_TYPE_MINERAL ,         // ±¤¼®
      USERMARKET_TYPE_QUEST   ,         // Äù½ºÆ®
      USERMARKET_TYPE_ETC     ,         // ±âÅ¸
      USERMARKET_TYPE_OTHER   ,         // ´Ù¸¥»ç¶÷ÀÌ ÆÇ¹°°Ç
      USERMARKET_TYPE_ITEMNAME:         // ¾ÆÀÌÅÛ ÀÌ¸§À¸·Î °Ë»ö
      begin
        IsOk := true;
      end;
      // ¼ÂÆ®·ù
      USERMARKET_TYPE_SET     :         // ¼ÂÆ® ¾ÆÀÌÅÛ
      begin
        FUserMarket.ReqInfo.ItemSet     := 1;
        IsOk := true;
      end;
      // À¯Àú·ù
      USERMARKET_TYPE_MINE    :         // ÀÚ½ÅÀÌÆÇ¹°°Ç
      begin
        FUserMarket.ReqInfo.SearchWho   := UserName;
        IsOk := true;
      end;

    end;
    if IsOk then
    begin
        if not SqlEngine.RequestLoadPageUserMarket(FUserMarket.ReqInfo) then
        begin
          SendUserMarketCloseMsg;
          Exit;
        end;
    end;

end;

// Å¬¶óÀÌ¾ðÆ®¿¡ ¿äÃ»ÇÔ ---------------------------------------------------------
// °¡¹æ¿¡ Á¸ÀçÇÏ³ª °Ë»ç
function  TUserHUman.IsExistBagItem( makeindex_ : integer ): PTUserItem;
var
    i : integer;
begin
   Result := nil;
   for i:=0 to ItemList.Count-1 do begin
      if PTUserItem(ItemList[i]).MakeIndex = makeindex_ then begin
         Result := ItemList[i];
         Exit;
      end;
   end;
end;

// °¡¹æÀÌ ²ËÃ¡³ª °Ë»ç ÀÓ½Ã·Î...
function TUserHuman.IsFullBagCount : Boolean;
begin
   Result := true;
   if ItemList.Count < MAXBAGITEM then Result := false;
end;

//À§Å¹»óÁ¡À» »ç¿ëÇÒ¼ö ÀÖ´Â Áö ·¹º§µîÀ» °Ë»ç
function TUserHUman.IsEnableUseMarket : Boolean;
begin
   Result := false;

   //---------À§Å¹º¹»ç¹ö±× ¼öÁ¤----------
   // ÇöÀç ¿äÃ» ÁßÀÎ »óÅÂÀÌ¸é ÀÌ¿ëÇÒ ¼ö ¾ø´Ù.
   if BoFlagUserMarket then exit;

   if FMarketNPC <> nil then begin
      // À§Å¹ NPC¿Í ´Ù¸¥ ¸Ê¿¡ ÀÖÀ¸¸é À§Å¹ ±â´ÉÀ» ÀÌ¿ëÇÒ ¼ö ¾ø´Ù.
      if MapName <> FMarketNPC.MapName then exit;

      // À§Å¹ NPC·ÎºÎÅÍ ÀÏÁ¤ °Å¸®¸¦ ¹þ¾î³ª¸é À§Å¹ ±â´ÉÀ» ÀÌ¿ëÇÒ ¼ö ¾ø´Ù.
      if not ((abs(CX - FMarketNPC.CX) <= 8) and (abs(CY - FMarketNPC.CY) <= 8)) then exit;
   end else begin
      // À§Å¹ NPC°¡ Á¸ÀçÇÏÁö ¾ÊÀ¸¸é À§Å¹ ±â´ÉÀ» ÀÌ¿ëÇÒ ¼ö ¾ø´Ù.
      exit;
   end;
   //------------------------------------

   // ·¹º§ °Ë»ç
   if Abil.Level >= MARKET_ALLOW_LEVEL then begin
      Result := true;
   end else begin
      SendMsg(self, RM_MARKET_RESULT, 0, 0, UMResult_NoItem, 0, '');
      BoxMsg ('Ö»ÓÐ '+ IntToStr(MARKET_ALLOW_LEVEL)+'¼¶¼°ÒÔÉÏÍæ¼Ò²ÅÄÜÊ¹ÓÃ.', 1)
   end;

end;

//¾ÆÀÌÅÛ »èÁ¦ ¹× Àü¼Û....
function TUserHuman.DeleteFromBagItem( MakeIndex_ :integer ; SellCount_ : integer ):Boolean;
var
   i       : integer;
   ui ,pi  : PTUserItem;
   pstd    : PTStdItem;
   rmcount : integer;
   rmItemName : string;
begin
   Result := false;
   for i := ItemList.Count -1 downto 0 do begin
      ui := PTUserItem (ItemList[i]);
      if ( ui <> nil ) and ( ui.MakeIndex = MakeIndex_ ) then begin
         pStd := UserEngine.GetStdItem ( ui.Index );

         // °ãÄ¡±â ¾ÆÀÌÅÛÀÌ ºÐ¸®°¡ ÇÊ¿äÇÑ °æ¿ì¿¡´Â ³ª¸ÓÁö ¾ÆÀÌÅÛ °³¼ö¸¦ ¾ò°í
         rmCount := 0;
         if ( pStd.OverlapItem >= 1 ) and ( ui.Dura > SellCount_ ) then begin
            rmCount := ui.Dura - SellCount_ ;
            rmItemName := pStd.Name;
         end;

         // ¾ÆÀÌÅÛ »èÁ¦ÇÏ°í
         SendDelItem( ui^ );
         Dispose(ui);
         ItemList.Delete (i);

         // °ãÄ¡±âÀÎ °æ¿ì ³ª¸ÓÁö °ªÀ» »õ·Î¿î ¾ÆÀÌÅÛÀ¸·Î ³Ö¾îÁØ´Ù.
         if ( pStd.OverlapItem >= 1 ) and ( rmCount > 0 ) then begin
            new (pi);
            if UserEngine.CopyToUserItemFromName ( rmItemName, pi^ ) then begin
               //¾ÆÀÌÅÛ °³¼ö Àû¿ë(±¤¼®ÀÇ ¼øµµ Àû¿ë)....
               pi.Dura := rmCount;
               ItemList.Add (pi);
               SendAddItem (pi^);
            end else
               Dispose (pi);
         end;

         WeightChanged;

         Result := true;
         Exit;
      end;
   end;
end;

// ¸¶ÄÏÀÌ¸§À» ¾ò¾î¿ÀÀÚ.
function TUserHuman.GetMarketName : String;
begin
   if FMarketNPC <> nil then
      Result := ServerName + '_'+ FMarketNPC.UserName
   else
      Result := ServerName +'_'+'NO_NPC';
end;

// °¡¹æ¿¡ ¾ÆÀÌÅÛ ³Ö±â
function TUserHuman.AddToBagItem( UserItem_ : TUserItem  ):Boolean;
var
   pu  : PTuserItem;
begin
   Result := false;
   // °¡¹æ¿¡ µé¾î°¥¼ö ÀÖ³ª °Ë»ç
   if not IsFullBagCount then begin
      new ( pu );
      pu^ := UserItem_ ;
      Result := AddItem( pu );

      if Result then begin
         WeightChanged;
         SendAddItem( pu^ );
      end else begin
         dispose( pu );
      end;
   end;
end;

// ¾ÆÀÌÅÛÀ» ÆÈ¼ö ÀÖ´Â Ã¢À» ¶ç¿ì¶ó°í Å¬¶óÀÌ¾ðÆ®¿¡ ¾Ë¸²
procedure TUserHuman.SendUserMarketSellReady( MarKetNpc : TCreature);
begin
   if MarketNpc <> nil then FMarketNPC := MarketNpc;

   if not IsEnableUseMarket then begin
      BoxMsg('¼ÄÊÛÉÌÈË¹¦ÄÜÎÞ·¨Ê¹ÓÃ.', 0);
      Exit;
   end;

//   0,Recog , param , tag
//   SendMsg(self, RM_MARKET_RESULT, 0,1,2,3, '');
//   SendMsg(self, RM_MARKET_RESULT, 0,integer(Npc_),UMResult_ReadyToSell,0,'');

   //À§Å¹Ãë¼Ò
   if not SqlEngine.RequestReadyToSellUserMarket( UserName , GetMarketName, UserName ) then begin
      SendUserMarketCloseMsg;
      Exit;
   end;
end;

// ¾ÆÀÌÅÛ --> À§Å¹ÆÇ¸Å
procedure TUserHuman.RequireSellUserMarket(
   MakeIndex_ : Integer ;  // À§Å¹ÇÒ ¾ÆÀÌÅÛ
   SellCount_ : integer ;  // °³¼ö
   SellPrice_ : integer ); // À§Å¹±Ý¾×
var
   pInfo       : PTMarketLoad;
   pUserItem   : PTUserITem;
   ps          : PTStdItem;
begin
   if not IsEnableUseMarket then begin
      BoxMsg('¼ÄÊÛÉÌÈË¹¦ÄÜÎÞ·¨Ê¹ÓÃ.', 0);
      Exit;
   end;

   //À§Å¹±Ý¾×ÀÌ À§Å¹½Ã »¯´Â  ±Ý¾×º¸´Ù´Â Ä¿¾ßµÊ
   if ( SellPrice_ < MARKET_CHARGE_MONEY ) then begin
      // À§Å¹±Ý¾×ÀÌ ³Ê¹« ÀÛÀ½
      SendMsg(self, RM_MARKET_RESULT, 0, 0, UMResult_LessTrustMoney, 0, '');
      BoxMsg ('×îµÍÏÞ¶îÎª '+IntToStr(MARKET_CHARGE_MONEY)+'½ð±Ò.', 1);
      Exit;
   end;

   //ÃÖ´ë ±Ý¾×º¸´Ù Å¬¼ö´Â ¾ø´Ù.
   if SellPrice_ > MARKET_MAX_TRUST_MONEY then begin
      // À§Å¹±Ý¾×ÀÌ  ³Ê¹« Å­
      SendMsg(self, RM_MARKET_RESULT, 0, 0, UMResult_MaxTrustMoney, 0, '');
      BoxMsg ('×î¸ßÏÞ¶îÎª '+IntToStr(MARKET_MAX_TRUST_MONEY)+'½ð±Ò.', 1);
      Exit;
   end;

   //°¡Áö°í ÀÖ´Â µ·ÀÌ ÇÊ¿ä±Ý¾×º¸´Ù Ä¿¾ßµÊ
   if  Gold < MARKET_CHARGE_MONEY then begin
      //µ·ÀÌ ºÎÁ·ÇÏ´Ù.
      SendMsg(self, RM_MARKET_RESULT, 0, 0, UMResult_LessMoney, 0, '');
      BoxMsg ('È±ÉÙ½ð±Ò', 1);
      Exit;
   end;

   // ¾ÆÀÌÅÛÀÌ ÀÖ³ª °Ë»çÇÏÀÚ.
   pUserItem := IsExistBagItem( MakeIndex_ );
   if nil = pUserItem  then begin
      // ¾ÆÀÌÅÛÀÌ ¾ø±º..
      SendMsg(self, RM_MARKET_RESULT, 0, 0, UMResult_NoItem, 0, '');
      BoxMsg ('Ã»ÓÐ·¢ÏÖÎïÆ·.', 1);
      Exit;
   end;

   // ¾ÆÀÌÅÛÀ» µ¥ÀÌÅÍ º£ÀÌ½º¿¡ ÀúÀåÇÏÀÚ.
   // µ¥ÀÌÅÍ º£ÀÌ½º¿¡ ÀúÀåµÈ°ÍÀº ÀÓ½Ã·Î ÀúÀåµÇ°í³ª¼­ ´Ù½Ã °ÔÀÓÂÊ¿¡¼­
   // ÀÎÁõÀ» ÇØ¾ß Á¤»óÀûÀ¸·Î Ã³¸®µÈ´Ù.. ¼­¹ö´Ù¿î½Ã °í·ÁÇØ¾ßµÊ.

   new ( pInfo );
   ps := UserEngine.GetStdItem (pUserItem.Index);
   if ps = nil then begin
      dispose ( pInfo );
      Exit;
   end;

   if ps.ItemType = 0 then begin
      // ¾ÆÀÌÅÛÀÌ ¾ø±º..
      SendMsg(self, RM_MARKET_RESULT, 0, 0, UMResult_DontSell, 0, '');
//      BoxMsg ('À§Å¹ÇÒ ¼ö ¾ø´Â ¾ÆÀÌÅÛÀÔ´Ï´Ù.', 1);
      Exit;
   end;

   // °ãÄ¡±â ¾ÆÀÌÅÛÀÏ °æ¿ì
   if ps.OverlapItem >= 1 then begin
      // °¡Áö°í ÀÖ´Â ÃÖ´ë °³¼ö¸¦ ³ÑÀ»¼ö´Â ¾ø´Ù.
      if (pUserItem.Dura < SellCount_)  or ( SellCount_ <= 0 )then begin
         // ¾ÆÀÌÅÛÀÌ ¾ø±º..
         SendMsg(self, RM_MARKET_RESULT, 0, 0, UMResult_DontSell, 0, '');
//         BoxMsg ('À§Å¹ÇÒ ¼ö ¾ø´Â ¾ÆÀÌÅÛÀÔ´Ï´Ù.', 1);
         Exit;
      end;
   end else begin
      SellCount_ := 0;
   end;

   pInfo.UserItem  := pUserItem^;
   pInfo.SellPrice := SellPrice_;
   pInfo.MarketName:= GetMarketName;
   pInfo.ItemName  := ps.Name;
   pInfo.MarketType:= ps.ItemType;
   pInfo.Index     := 0;
   pInfo.SetType   := ps.ItemSet;
   pInfo.SellWho   := UserName;
   pInfo.SellCount := SellCount_;

   // °ãÄ¡±â ¾ÆÀÌÅÛÀÌ°í °³¼ö°¡ ºÐ¸®µÇ¾î¾ß µÉ °æ¿ìÀÌ¸é
   if (ps.OverlapItem >= 1) and (SellCount_ > 0 ) then begin
      pInfo.UserItem.dura := SellCount_;
   end;

   if not SqlEngine.RequestSellItemUserMarket( UserName , pInfo ) then begin
      SendUserMarketCloseMsg;
      BoFlagUserMarket := FALSE;
      Exit;
   end;

   BoFlagUserMarket := TRUE;
end;

// À§Å¹ÆÇ¸Å --> ¾ÆÀÌÅÛ , µ·°¨¼Ò
procedure TUserHuman.RequireBuyUserMarket( MarketNpc : TCreature ;SellIndex_ : Integer );
var
   rMoney      : integer;
begin
   if not IsEnableUseMarket then begin
      BoxMsg('¼ÄÊÛÉÌÈË¹¦ÄÜÎÞ·¨Ê¹ÓÃ.', 0);
      Exit;
   end;

   if not FuserMarket.IsExistIndex( SellIndex_ , rMoney) then begin
      // ÀÎµ¦½º°¡ Á¸ÀçÇÏÁö ¾Ê½À´Ï´Ù.
      SendMsg(self, RM_MARKET_RESULT, 0,0,UMResult_NoItem,0,'');
      BoxMsg ('Õâ¸öÎïÆ·²»´æÔÚ.', 1);
      Exit;
   end;

   if Gold < ( rMoney ) then begin
      //µ·ÀÌ ºÎÁ·ÇÏ´Ù.
      SendMsg(self, RM_MARKET_RESULT, 0,0,UMResult_LessMoney,0,'');
      BoxMsg ('È±ÉÙ½ð±Ò´Ù', 1);
      Exit;
   end;

   // °¡¹æÀÌ ²ËÃ¡³ª °Ë»ç
   if IsFullBagCount then begin
      // °¡¹æÀÌ ²ËÃ¡±º.
      SendMsg(self, RM_MARKET_RESULT, 0,0,UMResult_MaxBagItemCount,0,'');
      BoxMsg ('ÄãµÄ°üÄÒÒÑÂú.', 1);
      Exit;
   end;

   if FUserMarket.IsMyItem( SellIndex_ , UserName ) then begin
      SendMsg(self, RM_MARKET_RESULT, 0,0,UMResult_DontBuy,0,'');
      BoxMsg ('Äã²»ÄÜ¹ºÂòÄã×Ô¼º³öÊÛµÄÎïÆ·.', 1);
      Exit;
   end;

   // À§Å¹¹°Ç° »ç±â
   if not SqlEngine.RequestBuyItemUserMarket( UserName ,GetMarketName, UserName,SellIndex_ ) then begin
      SendUserMarketCloseMsg;
      BoFlagUserMarket := FALSE;
      Exit;
   end;

   BoFlagUserMarket := TRUE;
end;

// À§Å¹ÆÇ¸Å --> ¾ÆÀÌÅÛ , µ· º¯È­¾øÀ½.
procedure TUserHuman.RequireCancelUserMarket( MarketNpc : TCreature ;SellIndex_ : integer );
begin
   if not IsEnableUseMarket then begin
      BoxMsg('¼ÄÊÛÉÌÈË¹¦ÄÜÎÞ·¨Ê¹ÓÃ.', 0);
      Exit;
   end;

   if not FUserMarket.IsMyItem( SellIndex_ , Self.UserName ) then begin
      // ¾ÆÀÌÅÛÀÇ ÆÇ¸ÅÀÚ°¡ ÀÏÄ¡ÇÏÁö ¾ÊÀ½.
      SendMsg(self, RM_MARKET_RESULT, 0,0,UMResult_CancelFail,0,'');
      BoxMsg ('Õâ¸öÎïÆ·²»ÊôÓÚµ±Ç°Íæ¼Ò.', 1);
      Exit;
   end;

   // °¡¹æÀÌ ²ËÃ¡³ª °Ë»ç
   if IsFullBagCount then begin
      // °¡¹æÀÌ ²ËÃ¡±º.
      SendMsg(self, RM_MARKET_RESULT, 0,0,UMResult_MaxBagItemCount,0,'');
      boxMsg ('ÄãµÄ°üÄÒÒÑÂú.', 1);
      Exit;
   end;

   //À§Å¹Ãë¼Ò
   if not SqlEngine.RequestCancelSellUserMarket( UserName , GetMarketName, UserName , SellIndex_ ) then begin
      SendUserMarketCloseMsg;
      BoFlagUserMarket := FALSE;
      Exit;
   end;

   BoFlagUserMarket := TRUE;
end;

// À§Å¹ÆÇ¸Å --> µ·
procedure TUserHuman.RequireGetPayUserMarket( MarketNpc : TCreature ;SellIndex_ : integer );
var
   rMoney  : integer;
begin
   if not IsEnableUseMarket then begin
      BoxMsg('¼ÄÊÛÉÌÈË¹¦ÄÜÎÞ·¨Ê¹ÓÃ.', 0);
      Exit;
   end;

   // ¾ÆÀÌÅÛÀÌ ³»²«°¡ °Ë»ç
   if not FUserMarket.IsMyItem( SellIndex_ , Self.UserName ) then begin
      // ¾ÆÀÌÅÛÀÇ ÆÇ¸ÅÀÚ°¡ ÀÏÄ¡ÇÏÁö ¾ÊÀ½.
      SendMsg(self, RM_MARKET_RESULT, 0,0,UMResult_CancelFail,0,'');
      BoxMsg ('Õâ¸öÎïÆ·²»ÊôÓÚµ±Ç°Íæ¼Ò.', 1);
      Exit;
   end;

   // ÀÎµ¦½º°¡ Á¸ÀçÇÏ´ÂÁö °Ë»ç
   if not FuserMarket.IsExistIndex( SellIndex_ , rMoney) then begin
      // ¾ÆÀÌÅÛÀÇ ÆÇ¸ÅÀÚ°¡ ÀÏÄ¡ÇÏÁö ¾ÊÀ½.
      SendMsg(self, RM_MARKET_RESULT, 0,0,UMResult_NoItem,0,'');
      BoxMsg ('Ã»ÓÐÈÎºÎÎïÆ·.', 1);
      Exit;
   end;

   // ¼ÒÀ¯ÇÒ¼ö ÀÖ´Â ÃÖ´ë±Ý¾× °Ë»ç.
   if Gold + rMoney > AvailableGold then begin
      SendMsg(self, RM_MARKET_RESULT, 0,0,UMResult_OverMoney,0,'');
      BoxMsg ('×î´ó½ð¶î³¬¹ýÏÞÖÆÁË.', 1);
      Exit;
   end;

   //±Ý¾× È¸¼ö
   //À§Å¹Ãë¼Ò
   if not SqlEngine.RequestGetPayUserMarket( UserName , GetMarketName, UserName , SellIndex_ ) then begin
      SendUserMarketCloseMsg;
      BoFlagUserMarket := FALSE;
      Exit;
   end;

   BoFlagUserMarket := TRUE;
end;

//½ÇÁ¦·Î µ¥ÀÌÅÍ°¡ Àü¼Û ¹× º¯È­µÇ´Â ºÎºÐ -----------------------------------------

procedure TUserHuman.GetMarketData( pInfo:PTSearchSellItem);
var
    pMarketInfo : PTMarketItem;
    pDbInfo     : PTMarketLoad;
    i           : integer;
    ps          : PTStdItem;
    std         : TStdItem;
begin
    if pInfo.IsOK <> UMRESULT_SUCCESS then Exit;

    if pInfo.pList <> nil then
    begin
        //ÀÏ´Ü Áö¿ì°í...
        FUserMarket.Clear;
        // À¯Àú¸ðµå¸¦ ´Ù½ÃÁöÁ¤
        FUserMarket.UserMode := pInfo.UserMode;
        // ¾ÆÀÌÅÛ Å¸ÀÔÀ» ´Ù½ÃÁöÁ¤
        FUserMarket.ItemType := pInfo.ItemType;

        for i := 0 to pInfo.pList.count -1 do
        begin
            pDBInfo := pInfo.pList.Items[i];

            if pDBInfo <> nil then
            begin
               ps := UserEngine.GetStdItem (pDBInfo.UserItem.Index);
               if ps <> nil then
               begin
                new ( pMarketinfo );
                std := ps^;

                pMarketinfo.UpgCount :=  ItemMan.GetUpgradeStdItem (pDBInfo.UserItem, std);
                Move (std, pMarketinfo.item.S, sizeof(TStdItem));

                pMarketinfo.item.MakeIndex  := pDBInfo.UserItem.MakeIndex;
                pMarketinfo.item.Dura       := pDBInfo.UserItem.Dura;
                pMarketinfo.item.DuraMax    := pDBInfo.UserItem.DuraMax;

                pMarketinfo.Index           := pDBInfo.Index;
                pMarketinfo.SellPrice       := pDBInfo.SellPrice;
                pMarketinfo.SellDate        := pDBInfo.Selldate;
                pMarketinfo.SellState       := pDBInfo.SellState;
                pMarketinfo.SellWho         := pDBInfo.SellWho;


                FUserMarket.Add( pMarketInfo );
               end;
            end;
        end;   // for


    end;
end;
//À§Å¹ÆÇ¸Å ¸®½ºÆ® Àü¼Û
procedure TUserHuman.SendUserMarketList( NextPage : integer);
var
   marketitem   : PTMarketItem;
   count        : integer;
   i,cnt        : integer;
   Buffer       : string;
   cnt_start    : integer;
   cnt_end      : integer;
   bFirstSend   : integer;
   page         : integer;
   maxpage      : integer;
begin

   //µ¥ÀÌÅÍ¸¦ ¸ð¾Æ¼­...
   Buffer   := '';
   cnt      := 0;
   page     := 0;

   // page = 0 ÀÌ¸é Ã³À½ Àü¼ÛÇÏ´Â°ÍÀ¸·Î ÆÇ´ÜÇÑ´Ù.
   if NextPage = 0 then begin
      //Å¬¶óÀÌ¾ðÆ®¿¡°Ô ÃÊ±âÈ­¸¦ ¿ä±¸
      bFirstSend := 1;
      page := 1;
   end else begin
      //Å¬¶óÀÌ¾ðÆ®¿¡°Ô ÃÊ±âÈ­ ÇÏÁö ¸»±â¸¦ ¿ä±¸
      bFirstSend := 0;
   end;

   //´ÙÀ½ÆäÀÌÁö ¿ä±¸
   if ( NextPage = 1 ) then
   page := FUserMarket.CurrPage +1;

   //ÆäÀÌÁö ¼³Á¤
   FUserMarket.CurrPage := page;
   maxpage := FUserMarket.PageCount;
   // ½ÃÀÛÀ§Ä¡ ¾ò±â
   cnt_start    := ( page -1 ) * MAKET_ITEMCOUNT_PER_PAGE;
   // ³¡ À§Ä¡ ¾ò±â
   cnt_end      := cnt_start + MAKET_ITEMCOUNT_PER_PAGE -1 ;
   // ¹üÀ§°Ë»ç
   if cnt_end >= FUserMarket.count then cnt_end := FUserMarket.count-1;

   // µ¥ÀÌÅÍ ¸¸µé±â...
   for i := cnt_start to cnt_end do begin
      marketitem := FUserMarket.GetItem(i );

      if marketitem <> nil then begin
{$IFDEF DEBUG}
         MainOutMessage('LIST :'+ marketitem.SellWho+','+marketitem.Item.S.Name);
{$ENDIF}
         inc ( cnt );
         buffer := Buffer + EncodeBuffer ( pointer( marketitem ), sizeof(TMarketItem)) + '/';
      end;
   end;

   buffer := IntToStr(cnt)+'/'+IntToStr(Page)+'/'+IntToStr(maxpage)+'/'+Buffer;
   // µ¥ÀÌÅÍ Àü¼Û
   SendMsg(self, RM_MARKET_LIST, 0,FUserMarket.UserMode,FUsermarket.Itemtype, bFirstSend, buffer);

end;

// ¾ÆÀÌÅÛ --> À§Å¹ÆÇ¸Å
procedure TUserHuman.SellUserMarket( pSellItem : PTMarketLoad );
var
   _makeindex : integer;
   _SellCount : integer;
   countstr : string;
begin
   countstr := '';
   if pSellItem.IsOK <> UMRESULT_SUCCESS then Exit;

   _makeindex := pSellItem.UserItem.MakeIndex;
   _SellCount := pSellItem.SellCount;

   if not FlagReadyToSellCheck then begin
      // ¾ÆÀÌÅÛÀÌ ¾øÀ½ Àß¸øµÇ¾úÀ½À» DB¿¡ ¾Ë·ÁÁÖÀÚ
      SqlEngine.CheckToDB( UserName, pSellItem.MarketName, pSellItem.SellWho, _MakeIndex, 0, MARKET_CHECKTYPE_SELLFAIL );

      AddUserLog ('32'#9 + //À§¸Â_
                 MapName + ''#9 +
                 IntToStr(0) + ''#9 +
                 IntToStr(0) + ''#9 +
                 UserName + ''#9 +
                 pSellItem.ItemName + ''#9 +
                 IntToStr(_makeindex) + ''#9 +
                 '1'#9 +
                 '1');
      exit;
   end;

   // ¾ÆÀÌÅÛ »èÁ¦ÇÏÀÚ.
   if DeleteFromBagItem( _makeindex , _SellCount ) then begin
      countstr := '(' + IntToStr(_SellCount) + ')';
      // À§Å¹±Ý¾× »©ÀÚ.
      DecGold( MARKET_CHARGE_MONEY );
      GoldChanged;

      // Àß ¹Þ¾Ò´Ù°í DB¿¡ ¾Ë·ÁÁØ´Ù.
      SqlEngine.CheckToDB( UserName, pSellItem.MarketName, pSellItem.SellWho, _MakeIndex, 0, MARKET_CHECKTYPE_SELLOK );

      // ¾ÆÀÌÅÛÀ» Àß À§Å¹ÇÏ¿´À½
      SendMsg(self, RM_MARKET_RESULT, 0, 0, UMResult_SellOK, 0, '');
//      BoxMsg ('¾ÆÀÌÅÛÀ» À§Å¹ÇÏ¿´½À´Ï´Ù.', 1);

      AddUserLog ('32'#9 + //À§¸Â_
                 MapName + ''#9 +
                 IntToStr(MARKET_CHARGE_MONEY) + ''#9 +
                 IntToStr(Gold) + ''#9 +
                 UserName + ''#9 +
                 pSellItem.ItemName + ''#9 +
                 IntToStr(_makeindex) + ''#9 +
                 '1'#9 +
                 '0' + countstr); //°³¼ö·Î±×(sonmg 2005/01/07)

   end else begin
      // ¾ÆÀÌÅÛÀÌ ¾øÀ½ Àß¸øµÇ¾úÀ½À» DB¿¡ ¾Ë·ÁÁÖÀÚ
      SqlEngine.CheckToDB( UserName, pSellItem.MarketName, pSellItem.SellWho, _MakeIndex, 0, MARKET_CHECKTYPE_SELLFAIL );

      AddUserLog ('32'#9 + //À§¸Â_
                 MapName + ''#9 +
                 IntToStr(0) + ''#9 +
                 IntToStr(0) + ''#9 +
                 UserName + ''#9 +
                 pSellItem.ItemName + ''#9 +
                 IntToStr(_makeindex) + ''#9 +
                 '1'#9 +
                 '1');

   end;

   BoFlagUserMarket := FALSE;
   FlagReadyToSellCheck := FALSE;
end;

// À§Å¹ÆÇ¸Å °¡´ÉÇÑÁö °ËÅä
procedure TUserHuman.ReadyToSellUserMarket( pReadyItem   : PTMarketLoad );
begin
   if pReadyItem.IsOK <> UMRESULT_SUCCESS then Exit;

   if pReadyItem.SellCount < MARKET_MAX_SELL_COUNT then begin
      // ¾ÆÀÌÅÛÀ» À§Å¹ÇÒ¼ö ÀÖ½À´Ï´Ù.
      SendMsg(self, RM_MARKET_RESULT, 0, integer(FMarketNpc), UMResult_ReadyToSell, 0, '');
   end else begin
      // ¾ÆÀÌÅÛÀ» À§Å¹ÇÒ ¼ö ¾ø½À´Ï´Ù.
      SendMsg(self, RM_MARKET_RESULT, 0, 0, UMResult_OverSellCount, 0, '');
//      BoxMsg ('¾ÆÀÌÅÛÀ§Å¹ °³¼ö°¡ ÃÊ°úÇÏ¿© À§Å¹ÇÒ ¼ö ¾ø½À´Ï´Ù.', 1);
   end;

   FlagReadyToSellCheck := TRUE;
end;

// À§Å¹ÆÇ¸Å --> ¾ÆÀÌÅÛ , µ·°¨¼Ò
procedure TUserHuman.BuyUserMarket( pBuyItem : PTMarketLoad );
var
   pu  : PTUserItem;
   ps  : PTStdItem;
   countstr : string;
begin
   countstr := '';
   pu := nil;
   ps := nil;

   if pBuyItem.IsOK <> UMResult_Success then begin
      BoxMsg ('¹ºÂòÎïÆ·Ê§°Ü.', 1);
      Exit;
   end;

   // À§Å¹ µð¹ö±×(sonmg 2005/01/31)
   if Gold < pBuyItem.SellPrice then MainOutMessage('TUserHuman.BuyUserMarket : The Lack of Gold');

   // ¾ÆÀÌÅÛÀ» µî·ÏÇÏ±¸ ³ª¼­
   if AddToBagItem( pBuyItem.UserItem ) then begin
      ps := UserEngine.GetStdItem(pBuyItem.UserItem.Index);
      if ps <> nil then begin
         countstr := '(' + IntToStr(pBuyItem.UserItem.Dura) + ')';
      end;

      // µ·À» °¨¼Ò½ÃÅ°°í ³ª¼­
      DecGold( pBuyItem.SellPrice );
      GoldChanged;

      // Àß ¹Þ¾Ò´Ù°í DB ¿¡ ¾Ë·ÁÁØ´Ù.
      SqlEngine.CheckToDB( UserName , pBuyItem.MarketName, UserName,0 , pBuyItem.Index , MARKET_CHECKTYPE_BUYOK );


      // ¾ÆÀÌÅÛÀ» Àß ±¸ÀÔÇÏ¿´À½.
      SendMsg(self, RM_MARKET_RESULT, 0,0,UMResult_BuyOK,0,'');
//      BoxMsg (pBuyItem.ItemName+ ' ¾ÆÀÌÅÛÀ» ±¸ÀÔÇÏ¿´½À´Ï´Ù.', 1);

      RequireLoadRefresh;

      AddUserLog ('33'#9 + //À§±¸ÀÔ_(À§Ã£)
                 MapName + ''#9 +
                 IntToStr(pBuyItem.SellPrice) + ''#9 +
                 IntToStr(Gold) + ''#9 +
                 UserName + ''#9 +
                 pBuyItem.ItemName + ''#9 +
                 IntToStr(pBuyItem.UserItem.MakeIndex) + ''#9 +
                 '1'#9 +
                 '0' + countstr); //°³¼ö·Î±×(sonmg 2005/01/07)

   end else begin
      // ¾ÆÀÌÅÛ ÀúÀåÀÌ ½ÇÆÐ
      if pu <> nil then dispose( pu );

      SqlEngine.CheckToDB( UserName , pBuyItem.MarketName, pBuyItem.SellWho,0 , pBuyItem.Index , MARKET_CHECKTYPE_BUYFAIL );

      AddUserLog ('33'#9 + //À§±¸ÀÔ_(À§Ã£)
                 MapName + ''#9 +
                 IntToStr(0) + ''#9 +
                 IntToStr(0) + ''#9 +
                 UserName + ''#9 +
                 pBuyItem.ItemName + ''#9 +
                 IntToStr(pBuyItem.UserItem.MakeIndex) + ''#9 +
                 '1'#9 +
                 '1');

   end;

   BoFlagUserMarket := FALSE;
end;
// À§Å¹ÆÇ¸Å --> ¾ÆÀÌÅÛ , µ·°°À½
procedure TUserHuman.CancelUserMarket( pCancelItem : PTMarketLoad );
begin
   if pCancelItem.IsOK <> UMResult_Success then begin
      BoxMsg ('È¡Ïû¸ÃÎïÆ·ÏúÊÛÊ§°Ü.', 1);
      Exit;
   end;

   // ¾ÆÀÌÅÛÀ» µî·ÏÇÏ±¸ ³ª¼­.
   if AddToBagItem( pCancelItem.UserItem ) then begin

      // µ·ÀÇ º¯È­´Â ¾ø°í

      // Àß ¹Þ¾Ò´Ù°í DB ¿¡ ¾Ë·ÁÁØ´Ù.
      SqlEngine.CheckToDB( UserName , pCancelItem.MarketName, pCancelItem.SellWho,0  , pCancelItem.Index , MARKET_CHECKTYPE_CANCELOK );
      RequireLoadRefresh;
      // ¾ÆÀÌÅÛÀ» Àß Ãë¼ÒÇÏ¿´À½.
      SendMsg(self, RM_MARKET_RESULT, 0, 0, UMResult_CancelOK, 0, '');
//      BoxMsg ('À§Å¹ÇÑ '+pCancelItem.ItemName+' ¾ÆÀÌÅÛÀ» Ãë¼ÒÇÏ¿´½À´Ï´Ù.', 1);

      AddUserLog ('34'#9 + //À§Ãë_
                 MapName + ''#9 +
                 IntToStr(0) + ''#9 +
                 IntToStr(0) + ''#9 +
                 UserName + ''#9 +
                 pCancelItem.ItemName + ''#9 +
                 IntToStr(pCancelItem.UserItem.MakeIndex) + ''#9 +
                 '1'#9 +
                 '0');

   end else begin

      SqlEngine.CheckToDB( UserName , pCancelItem.MarketName, pCancelItem.SellWho,0 , pCancelItem.Index , MARKET_CHECKTYPE_CANCELFAIL );

      AddUserLog ('34'#9 + //À§Ãë_
                 MapName + ''#9 +
                 IntToStr(0) + ''#9 +
                 IntToStr(0) + ''#9 +
                 UserName + ''#9 +
                 pCancelItem.ItemName + ''#9 +
                 IntToStr(pCancelItem.UserItem.MakeIndex) + ''#9 +
                 '1'#9 +
                 '1');

   end;

   BoFlagUserMarket := FALSE;
end;

// À§Å¹ÆÇ¸Å --> µ·
procedure TUserHuman.GetPayUserMarket( pGetpayItem : PTMarketLoad );
var
   commision :integer;
begin
   if pGetpayItem.IsOK <> UMResult_Success then begin
      BoxMsg ('È¡»Ø½ð±ÒÊ§°Ü£¿', 1);
      Exit;
   end;

   if ( pGetpayItem.SellPrice >= 0  ) then begin

      commision := pGetpayItem.SellPrice * MARKET_COMMISION div 1000;
      // µ·À» ´õÇÏ°í + ¼ö¼ö·á´Â ¶¼°í
      IncGold( pGetpayItem.SellPrice );
      DecGold( commision );
      GoldChanged;
      // Àß ¹Þ¾Ò´Ù°í DB ¿¡ ¾Ë·ÁÁØ´Ù.
      SqlEngine.CheckToDB( UserName , pGetpayItem.MarketName, pGetPayItem.SellWho,0 , pGetPayItem.Index , MARKET_CHECKTYPE_GETPAYOK );

      RequireLoadRefresh;
      // ¾ÆÀÌÅÛÀ» Àß Ãë¼ÒÇÏ¿´À½.
      SendMsg(self, RM_MARKET_RESULT, 0, 0, UMResult_GetPayOK, 0, '');
      BoxMsg( 'Î¯ÍÐ½ð '+ IntToStr(pGetpayItem.SellPrice)+' ½ð±ÒÊÕµ½ºó½«Ö§¸¶ '+intToStr(commision) + '½ð±Ò×÷Îª¼ÄÊÛÓ¶½ð.',1);

      AddUserLog ('35'#9 + //À§µ·Ã£_ +
                 MapName + ''#9 +
                 IntToStr(pGetpayItem.SellPrice - Commision) + ''#9 +
                 IntToStr(Gold) + ''#9 +
                 UserName + ''#9 +
                 pGetpayItem.ItemName + ''#9 +
                 IntToStr(pGetpayItem.UserItem.MakeIndex) + ''#9 +
                 '1'#9 +
                 '0');

   end else begin
      // Àß ¸ø ¹Þ¾Ò´Ù°í DB ¿¡ ¾Ë·ÁÁØ´Ù.
      SqlEngine.CheckToDB( UserName , pGetpayItem.MarketName, pGetPayItem.SellWho,0 , pGetPayItem.Index , MARKET_CHECKTYPE_GETPAYFAIL );

      AddUserLog ('35'#9 + //À§µ·Ã£_ +
                 MapName + ''#9 +
                 IntToStr(0) + ''#9 +
                 IntToStr(0) + ''#9 +
                 UserName + ''#9 +
                 pGetpayItem.ItemName + ''#9 +
                 IntToStr(pGetpayItem.UserItem.MakeIndex) + ''#9 +
                 '1'#9 +
                 '1');

   end;

   BoFlagUserMarket := FALSE;
end;

procedure TUserHuman.CmdReloadGaBoardList ( gname : string; nPage : integer );
begin
   if MyGuild = nil then exit;
   if TGuild(MyGuild).GuildName = '' then exit;

   if TGuild(MyGuild).GuildName = gname then begin
      CmdGaBoardList ( nPage );
   end;
end;

//Àå¿ø°Ô½ÃÆÇ
procedure TUserHuman.CmdGaBoardList ( nPage : integer );
const
   ENDOFLINEFLAG = 100;
var
   i, orgnum : integer;
   strOrgnum, strIndent : string;
   gname, gnameHere, data : string;
   subjectlist : TStringList;
   allpage, count : integer; //ÀüÃ¼ÆäÀÌÁö, ¶óÀÎ³Ñ¹ö
   startline, lastline : integer;
begin
   data := '';

   if MyGuild <> nil then begin
      if TGuild(MyGuild).GuildName <> '' then begin
         //¹®ÆÄ¸í º¹»ç.
         gname := TGuild(MyGuild).GuildName;
         gnameHere := GetGuildNameHereAgit;

         // ÇöÀç Àå¿øÀÇ ¹®ÆÄ°¡ ¾Æ´Ï¸é...
         if gname <> gnameHere then begin
            // ¿î¿µÀÚ´Â ¸ðµç °Ô½ÃÆÇÀ» º¼ ¼ö ÀÖÀ½.
            if UserDegree >= UD_ADMIN then begin
               gname := gnameHere;
            end else begin
               SysMsg('Äã²»ÄÜä¯ÀÀ¸æÊ¾ÅÆ.', 0);
               exit;
            end;
         end;

         subjectlist := TStringList.Create;

         GuildAgitBoardMan.GetPageList( UserName, gname, nPage, allpage, subjectlist );

         if subjectlist.Count = 0 then begin
            SysMsg('×¯Ô°¸æÊ¾ÅÆÁÐ±íÃ»ÓÐÐÅÏ¢.', 0);
         end else begin
            if subjectlist.Count < GABOARD_NOTICE_LINE then begin
               MainOutMessage('[Caution] TUserHuman.CmdGaBoardList : subjectlist < 3');
            end else begin
               count := 0;
               for i:=0 to subjectlist.Count-1 do begin
                  Inc(count);
                  if i = subjectlist.Count-1 then count := ENDOFLINEFLAG;

                  // µ¥ÀÌÅÍ Á¶ÇÕ.
                  data := gname + '/' + subjectlist[i];
                  // ¸®½ºÆ®¸¦ º¸³¿
                  SendMsg (self, RM_GABOARD_LIST, 0, nPage, count, allpage, data);
//                  SysMsg(data, 2);  //Å×½ºÆ® °Ô½ÃÆÇ
               end;
            end;
         end;

         subjectlist.Free;
      end else begin
         SysMsg('Äã²»ÄÜä¯ÀÀ¸æÊ¾ÅÆ.', 0);
      end;
   end else begin
      SysMsg('Äã²»ÄÜä¯ÀÀ¸æÊ¾ÅÆ.', 0);
   end;
end;

procedure TUserHuman.CmdGaBoardDelAll;
begin
   ServerGetGaBoardDelAll ( 1, '' );
end;

procedure TUserHuman.CmdBuyDecoItem( nObjNum : integer );
var
   pu : PTUserItem;
   pstd : PTStdItem;
   pricestr : string;
   sellprice : integer;
   guildagit : TGuildAgit;
   gnamehere : string;
   flag : Boolean;
begin
   if nObjNum < 0 then exit;
   if ItemList.Count >= MAXBAGITEM then begin
      SysMsg('ÄãµÄ°ü¸¤ÒÑ¾­ÂúÁË.', 0);
      exit;
   end;

   // ÀÚ½ÅÀÇ Àå¿øÀÌ ¾Æ´Ï¸é ±¸ÀÔÇÒ ¼ö ¾ø´Ù.
   flag := FALSE;
   gnamehere := GetGuildNameHereAgit;
   if gnamehere <> '' then begin
      if MyGuild <> nil then begin
         if TGuild(MyGuild).GuildName = gnamehere then
            flag := TRUE;
      end;
   end;
   if not flag then begin
      BoxMsg(gnamehere + ' ÐÐ»á³ÉÔ±²ÅÄÜ¹ºÂò.', 0);
      exit;
   end;

   new (pu);
   if UserEngine.CopyToUserItemFromName (NAME_OF_DECOITEM, pu^) then begin
      pstd := UserEngine.GetStdItem (pu.Index);

      GuildAgitMan.GetDecoItemName(nObjNum, pricestr);
      sellprice := Str_ToInt(pricestr, DEFAULT_DECOITEM_PRICE);

      if pstd <> nil then begin
         //»óÇöÁÖ¸Ó´Ï(DecoItem)¸¦ ±¸ÀÔÇÑ´Ù.
         if (Gold >= sellprice) and (sellprice > 0) then begin
            if GuildAgitDecoItemSet( pu, nObjNum ) then begin
               if AddItem(pu) then begin
                  DecGold(sellprice);
                  GoldChanged;
                  SendAddItem(pu^);
                  //·Î±×³²±è
                  AddUserLog ('9'#9 + //±¸ÀÔ_
                              MapName + ''#9 +
                              IntToStr(CX) + ''#9 +
                              IntToStr(CY) + ''#9 +
                              UserName + ''#9 +
                              UserEngine.GetStdItemName (pu.Index) + ''#9 +
                              IntToStr(pu.MakeIndex) + ''#9 +
                              '1'#9 +
                              UserName);
                  //--------------------------
                  //¸í¼ºÄ¡ È¹µæ(²Ù¹Ì±â¾ÆÀÌÅÛ ±¸ÀÔ: ±¸ÀÔ°¡°ÝÀÇ 0.1%)
                  if ENABLE_FAME_SYSTEM then begin
                     IncFamePoint( Trunc(sellprice * 0.001) );
                  end;
                  //--------------------------
               end else begin
                  Dispose(pu);
               end;
            end else begin
               SysMsg('Ö»ÓÐ×¯Ô°×¢²áÐÐ»áµÄ³ÉÔ±²ÅÄÜ¹ºÂòÉÌÆ·.', 0);
               Dispose (pu);
            end;
         end else begin
            SysMsg('Ã»ÓÐ×ã¹»µÄ½ð±Ò.', 0);
            Dispose(pu);
         end;
      end else begin
         Dispose(pu);
      end;
   end else begin
      Dispose(pu);
   end;
end;

//Àå¿ø²Ù¹Ì±â ¾ÆÀÌÅÛ ¸ñ·Ï º¸³»±â
procedure TUserHuman.SendDecoItemList;
var
   i, count: integer;
   cg: TClientGoods;
   l: TList;
   pstd: PTStdItem;
   pu: PTUserItem;
   data: string;
   name, pricestr: string;
   num, kind : word;
   price : integer;
begin
   //¸®½ºÆ®¿¡ ³»¿ëÀÌ ¾øÀ¸¸é º¸³»Áö ¾ÊÀ½.
   if DecoItemList.Count <= 0 then exit;

   data := '';
   count := 0;
   for i:=0 to DecoItemList.Count-1 do begin
      name := DecoItemList[i];
      //°¡°Ý ÃßÃâ
      pricestr := GetValidStr3(name, name, ['/']);
      price := Str_ToInt(pricestr, DEFAULT_DECOITEM_PRICE);
      num := Loword(integer(DecoItemList.Objects[i]));
      kind := Hiword(integer(DecoItemList.Objects[i]));

      //ÀÌ¸§/ÀÎµ¦½º/°¡°Ý/Á¾·ù
      data := data + name + '/' + IntToStr(num) + '/' + IntToStr(price) + '/' + IntToStr(kind) + '/';
      Inc (count);
   end;
   SendMsg (self, RM_DECOITEM_LIST, 0, integer(self), count, 0, data);
end;

//¸í¼º È£Äª°ú µî±ÞÀ» ¾ò´Â ÇÔ¼ö
function TUserHuman.GetFameName( var nGrade: integer ) : string;
var
   strJob : string;
   strFame : string;
begin
   Result := '';

   //sonmg 2005/07/28
   if RaceServer <> RC_USERHUMAN then exit;

   strJob := '';
   strFame := '';

   nGrade := 0;

   //¸í¼º ¼ö½Ä¾î
   if Abil.FameBase <= 60 then begin
      nGrade := 1;
      strFame := '¹«¸íÀÇ';
      case Job of
      0: strJob := 'Àü»ç';
      1: strJob := '¼ú»ç';
      2: strJob := 'µµ»ç';
      end;
   end else if Abil.FameBase <= 700 then begin
      nGrade := 2;
      strFame := 'Æò¹üÇÑ';
      case Job of
      0: strJob := 'Àü»ç';
      1: strJob := '¼ú»ç';
      2: strJob := 'µµ»ç';
      end;
   end else if Abil.FameBase <= 4600 then begin
      nGrade := 3;
      strFame := '´É¶õÇÑ';
      case Job of
      0: strJob := 'Àü»ç';
      1: strJob := '¼ú»ç';
      2: strJob := 'µµ»ç';
      end;
   end else if Abil.FameBase <= 13000 then begin
      nGrade := 4;
      strFame := '³ë·ÃÇÑ';
      case Job of
      0: strJob := '³¶ÀÎ';
      1: strJob := 'È¯¼ú»ç';
      2: strJob := '¼öÇàÀÎ';
      end;
   end else if Abil.FameBase <= 40000 then begin
      nGrade := 5;
      strFame := '¶Ù¾î³­';
      case Job of
      0: strJob := '³¶ÀÎ';
      1: strJob := 'È¯¼ú»ç';
      2: strJob := '¼öÇàÀÎ';
      end;
   end else if Abil.FameBase <= 114000 then begin
      nGrade := 6;
      strFame := '¿ì¼öÇÑ';
      case Job of
      0: strJob := '³¶ÀÎ';
      1: strJob := 'È¯¼ú»ç';
      2: strJob := '¼öÇàÀÎ';
      end;
   end else if Abil.FameBase <= 230000 then begin
      nGrade := 7;
      strFame := '´ë´ÜÇÑ';
      case Job of
      0: strJob := '¹«»ç';
      1: strJob := 'ÁöÀÎ';
      2: strJob := 'µµÀÎ';
      end;
   end else if Abil.FameBase <= 360000 then begin
      nGrade := 8;
      strFame := 'ÃË¸Á¹Þ´Â';
      case Job of
      0: strJob := '¹«»ç';
      1: strJob := 'ÁöÀÎ';
      2: strJob := 'µµÀÎ';
      end;
   end else if Abil.FameBase <= 550000 then begin
      nGrade := 9;
      strFame := '´ö¸ÁÀÖ´Â';
      case Job of
      0: strJob := '¹«»ç';
      1: strJob := 'ÁöÀÎ';
      2: strJob := 'µµÀÎ';
      end;
   end else if Abil.FameBase <= 940000 then begin
      nGrade := 10;
      strFame := '°­ÀÎÇÑ';
      case Job of
      0: strJob := 'Çù°´';
      1: strJob := 'ÇöÀÎ';
      2: strJob := '¼±ÀÎ';
      end;
   end else if Abil.FameBase <= 1300000 then begin
      nGrade := 11;
      strFame := '¿ë¸ÍÇÑ';
      case Job of
      0: strJob := 'Çù°´';
      1: strJob := 'ÇöÀÎ';
      2: strJob := '¼±ÀÎ';
      end;
   end else if Abil.FameBase <= 3200000 then begin
      nGrade := 12;
      strFame := 'Çö¸íÇÑ';
      case Job of
      0: strJob := 'Çù°´';
      1: strJob := 'ÇöÀÎ';
      2: strJob := '¼±ÀÎ';
      end;
   end else if Abil.FameBase <= 5340000 then begin
      nGrade := 13;
      strFame := 'ºÒ±¼ÀÇ';
      case Job of
      0: strJob := '°ËÁ¦';
      1: strJob := '´ëÇöÀÎ';
      2: strJob := 'ÁøÀÎ';
      end;
   end else if Abil.FameBase <= 8580000 then begin
      nGrade := 14;
      strFame := 'ÅõÁöÀÇ';
      case Job of
      0: strJob := '°ËÁ¦';
      1: strJob := '´ëÇöÀÎ';
      2: strJob := 'ÁøÀÎ';
      end;
   end else if Abil.FameBase <= 13000000 then begin
      nGrade := 15;
      strFame := 'À§´ëÇÑ';
      case Job of
      0: strJob := '°ËÁ¦';
      1: strJob := '´ëÇöÀÎ';
      2: strJob := 'ÁøÀÎ';
      end;
   end else if Abil.FameBase <= 17000000 then begin
      nGrade := 16;
      strFame := 'ºñ¹üÇÑ';
      case Job of
      0: strJob := '°ËÈ²';
      1: strJob := '¸¶Á¸';
      2: strJob := 'ÅÂ¼±ÀÎ';
      end;
   end else if Abil.FameBase <= 21300000 then begin
      nGrade := 17;
      strFame := 'Á¸°æ¹Þ´Â';
      case Job of
      0: strJob := '°ËÈ²';
      1: strJob := '¸¶Á¸';
      2: strJob := 'ÅÂ¼±ÀÎ';
      end;
   end else if Abil.FameBase <= 25600000 then begin
      nGrade := 18;
      strFame := '¿µ¿¹·Î¿î';
      case Job of
      0: strJob := '°ËÈ²';
      1: strJob := '¸¶Á¸';
      2: strJob := 'ÅÂ¼±ÀÎ';
      end;
   end else if Abil.FameBase <= 30000000 then begin
      nGrade := 19;
      strFame := '¿µ±¤ÀÇ';
      //¼±ÅÃ»çÇ× Àû¿ë¿¹Á¤
      case Job of
      0: strJob := '°ËÈ²';
      1: strJob := '¸¶Á¸';
      2: strJob := 'ÅÂ¼±ÀÎ';
      end;
   end else begin
      nGrade := 20;
      strFame := 'ÃÖ°­ÀÇ';
      //¼±ÅÃ»çÇ× Àû¿ë¿¹Á¤
      case Job of
      0: strJob := '°ËÈ²';
      1: strJob := '¸¶Á¸';
      2: strJob := 'ÅÂ¼±ÀÎ';
      end;
   end;

   Result := strFame + ' ' + strJob;
end;

//¾ÆÀÌÅÛ ÇÕÃ¼
//ÇØ´ç ¾ÆÀÌÅÛÀ» °¡¹æ Ã¢¿¡ ÀÖ´Â °°Àº Á¾·ùÀÇ ¾ÆÀÌÅÛÀ» ÀÌ¿ëÇÏ¿© ³»±¸¸¦ Áõ°¡ ½ÃÅ´
procedure TUserHuman.UserUnifyItem (npcid: integer; itemkind: string);
const
   NUMOFITEM = 3;
var
   i, j: integer;
   npc: TCreature;
   pu, puSelect, puMinDura, puMaxDura: PTUserItem;
   ps, psSelect: PTStdItem;
   puArray: array [1..NUMOFITEM] of PTUserItem;
   flag: Boolean;
   totaldura, itemcount, nFactor: integer;
   LimitDura, OrgDura: integer;
begin

 try
   LimitDura := 60000;
   npc := nil;
   pu := nil;
   ps := nil;
   puSelect := nil;
   psSelect := nil;
   puMinDura := nil;
   puMaxDura := nil;
   for j:=1 to NUMOFITEM do begin
      puArray[j] := nil;
   end;
   totaldura := 0;
   itemcount := 0;
   nFactor := 3;

   //³» °¡¹æÀÇ ¾ÆÀÌÅÛ¿¡¼­ 3°³ÀÇ ¾ÆÀÌÅÛÀ» Ã£´Â´Ù.
   for i:=ItemList.Count-1 downto 0 do begin
      pu := PTUserItem(ItemList[i]);
      ps := UserEngine.GetStdItem( pu.Index );
      npc := UserEngine.GetMerchant (npcid);
      if npc = nil then npc := UserEngine.GetNpc (npcid);
      if (npc <> nil) and (pu <> nil) and (ps <> nil) then begin
         if (npc.PEnvir = PEnvir) and (abs(npc.CX-CX) <= 15) and (abs(npc.CY-CY) <= 15) then begin
            flag := FALSE;
            //³»±¸ °ø½Ä¿¡ ÀÇÇØ ÇÕÃ¼ÇÑ´Ù.
            if (UPPERCASE(itemkind) = 'NECKLACE') or (itemkind = 'ÏîÁ´') then begin
               if ps.StdMode in [19, 20, 21] then begin
                  flag := TRUE;
               end;
            end else if (UPPERCASE(itemkind) = 'BRACELET') or (itemkind = 'ÊÖïí') then begin
               if ps.StdMode in [24, 26] then begin
                  flag := TRUE;
               end;
            end else if (UPPERCASE(itemkind) = 'RING') or (itemkind = '½äÖ¸') then begin
               if ps.StdMode in [22, 23] then begin
                  flag := TRUE;
               end;
            end;

            if flag then begin
               Inc(itemcount);
               puArray[itemcount] := pu;
               //ÃÖ¼Ò ³»±¸ ¾ÆÀÌÅÛ
               if puMinDura = nil then begin
                  puMinDura := pu;
               end else begin
                  if puMinDura.DuraMax > pu.DuraMax then begin
                     puMinDura := pu;
                  end;
               end;
               //ÃÖ´ë ³»±¸ ¾ÆÀÌÅÛ
               if puMaxDura = nil then begin
                  puMaxDura := pu;
               end else begin
                  if puMaxDura.DuraMax < pu.DuraMax then begin
                     puMaxDura := pu;
                  end;
               end;
{
               totaldura := totaldura + pu.DuraMax;
//               if Random(Round(pu.DuraMax /1000) + nFactor) = 0 then begin
               //ÀüÃ¼ ³»±¸ Áß¿¡¼­ ÇöÀç ¾ÆÀÌÅÛÀÇ ³»±¸ÀÇ È®·ü·Î ³²À» ¾ÆÀÌÅÛ ¼±ÅÃ
               if Random(totaldura) < pu.DuraMax then begin
                  if puSelect = nil then begin
                     puSelect := pu;
                  end;
               end;
}
               if itemcount >= NUMOFITEM then begin
                  break;
               end;
            end;
         end;
      end;
   end;

   if itemcount < NUMOFITEM then begin
      SysMsg('ÎïÆ·ÊýÁ¿²»×ã.', 0);
      exit;
   end;

   //¼±ÅÃµÈ ¾ÆÀÌÅÛÀÌ ¾øÀ¸¸é...
{
   while nFactor > 0 do begin
      Dec(nFactor);
      if puSelect = nil then begin
         for j:=1 to NUMOFITEM do begin
            if Random(Round(puArray[j].DuraMax / 1000) + nFactor) = 0 then begin
               if puSelect = nil then begin
                  puSelect := puArray[j];
               end;
            end;
         end;
      end;
   end;
}

   //¼¼°³ÀÇ ¾ÆÀÌÅÛÀÇ ÃÑ ³»±¸ÀÇ ÇÕÀ» ±¸ÇÑ´Ù.
   for j:=1 to NUMOFITEM do begin
      totaldura := totaldura + puArray[j].DuraMax;
   end;

   for j:=1 to NUMOFITEM do begin
      if Random(totaldura) < puArray[j].DuraMax then begin
         puSelect := puArray[j];
      end;
   end;

   if puSelect = nil then begin
      puSelect := puMaxDura;
   end;

   if (puSelect <> nil) and (puSelect.DuraMax < LimitDura) then begin
      psSelect := UserEngine.GetStdItem( puSelect.Index );
      if psSelect <> nil then begin
         //¼±ÅÃµÈ ¾ÆÀÌÅÛÀÇ DB DuraMaxÄ¡·Î ³»±¸ Á¦ÇÑ.
         LimitDura := _MIN(LimitDura, psSelect.DuraMax);
      end;
      OrgDura := puSelect.DuraMax;
      puSelect.DuraMax := _MIN(LimitDura, totaldura * 1000);
      // Æ¯Á¤ È®·ü·Î ÃÑ³»±¸¿¡¼­ Random(ÃÑ³»±¸ Æò±Õ)À» »©ÁØ´Ù.
      if Random(totaldura * 1000) < OrgDura then begin
         puSelect.DuraMax := puSelect.DuraMax - Random(puSelect.DuraMax div 3);
      end;
      //ÇöÀç³»±¸ > ÃÑ³»±¸ÀÌ¸é ÃÑ³»±¸¸¦ ÇöÀç³»±¸¿¡ ¼ÂÆÃ(sonmg)
      if puSelect.Dura > puSelect.DuraMax then begin
         puSelect.Dura := puSelect.DuraMax;
      end;
      SendUpdateItem(puSelect^);
      SysMsg(UserEngine.GetStdItemName(puSelect.Index) + 'ÎïÆ·µÄÄÍ¾Ãµ÷Õû.', 0);

      //°¡¹æÃ¢¿¡¼­ ¾ÆÀÌÅÛÀ» »èÁ¦ÇÑ´Ù.
      for i:=ItemList.Count-1 downto 0 do begin
         pu := PTUserItem(ItemList[i]);
         for j:=1 to NUMOFITEM do begin
            //¼±ÅÃµÈ ¾ÆÀÌÅÛÀÌ ¾Æ´Ï¸é »èÁ¦
            if (pu = puArray[j]) and (pu <> puSelect) then begin
               if (pu <> nil) and (npc <> nil) then begin
                  //·Î±×³²±è
                  AddUserLog ('44'#9 + //Á¦Á¶»è_
                              MapName + ''#9 +
                              IntToStr(CX) + ''#9 +
                              IntToStr(CY) + ''#9 +
                              UserName + ''#9 +
                              UserEngine.GetStdItemName(pu.Index) + ''#9 +
                              IntToStr(pu.MakeIndex) + ''#9 +
                              '2'#9 +
                              npc.UserName);
               end;

               SendDelItem( pu^ );
               Dispose (pu);
               ItemList.Delete (i);
            end;
         end;
      end;

   end;
 except
   MainOutMessage('UnifyItem Exception...');
 end;

end;

function TUserHuman.DeathFunc: Boolean;
begin
  Result := False;
  if QFunctionNpc <> nil then
  begin
    QFunctionNpc.NpcSayTitle(TUserHuman(Self), '@PlayDie');
    Result := True;
  end;
end;

function TUserHuman.KillHumFunc: Boolean;
begin
  Result := False;
  if QFunctionNpc <> nil then
  begin
    QFunctionNpc.NpcSayTitle(TUserHuman(Self), '@KillPlay');
    Result := True;
  end;
end;

function TUserHuman.DeathAndKillsFunc(): Boolean;
begin
  Result := False;
  if (LastHiter <> nil) and (RaceServer = RC_USERHUMAN) then
  begin
    if LastHiter.Master <> nil then
    begin
      if LastHiter.Master.RaceServer = RC_USERHUMAN then
      begin
        TUserHuman(LastHiter.Master).KillHumFunc;
      end;
    end
    else
    if LastHiter.RaceServer = RC_USERHUMAN then
    begin
      TUserHuman(LastHiter).KillHumFunc;
    end;
    //ËÀÍö´¥·¢
    Result := DeathFunc();
  end;
end;

procedure TUserHuman.ClearTimeLabel();
var
  i: Integer;
  ptl: PTTimeLabel;
begin
  for i := TimeLabelList.Count - 1 downto 0 do begin
    ptl := TimeLabelList.Items[i];
    if ptl <> nil then begin
      ptl.boDelete := True;
    end;
  end;
end;
procedure TUserHuman.ClearAllDelayLabel;
var
  i: Integer;
  ptl: PTTimeLabel;
begin
  for i := 0 to TimeLabelList.Count - 1 do begin
    ptl := TimeLabelList.Items[i];
    Dispose(ptl);
  end;
  TimeLabelList.Clear;
end;
//PCÔö¼Ó»òÕß¼õÉÙ
function  TUserHuman.IncPotCash (igold: integer): Boolean;
var
   strlevel: string;
begin
   Result := FALSE;
   if igold < 0 then exit; // (sonmg 2005/06/22)

   if Int64(PotCash) + igold <= AvailableGold then begin
      PotCash := PotCash + igold;
//      FrmIDSoc.SendPotCashAdd (UserName, UserId, igold);
      Result := TRUE;
      //±ÝÀüº¯µ¿
      if igold >= EXORBITANT_PC then begin
//         MainOutMessage('***±ÝÀüº¯µ¿: +' + GetGoldStr(igold) + ' ' + UserName + ' (Lv:' + IntToStr(Abil.Level) + ') => ' + GetGoldStr(Gold));

         //·¹º§ÀÇ 10ÀÇ ÀÚ¸®¼ö
         strlevel := IntToStr( _MIN(9, Abil.Level div 10) );
         //·Î±× ³²°Ü¾ß ÇÔ
         AddUserLog ('51'#9 + //±ÝÀü_
                     MapName + ''#9 +
                     IntToStr(CX) + ''#9 +
                     IntToStr(CY) + ''#9 +
                     UserName + ''#9 +
                     NAME_OF_PC{'Ôª±¦'} + ''#9 +
                     IntToStr(igold) + ''#9 +
                     strlevel + ''#9 +
                     IntToStr(PotCash));
      end;
   end;
end;

function TUserHuman.DecPotCash (igold: integer): Boolean;
var
   strlevel: string;
begin
   Result := FALSE;
   if igold < 0 then Exit;

   if Int64(PotCash) - igold >= 0 then begin
      PotCash := PotCash - igold;
//      MainOutMessage('¼õÉÙPC=' + IntToStr(igold) + ' Ê£ÓàPC=' + IntToStr(nPotCash));
//      FrmIDSoc.SendPotCashDel (UserName, UserId, igold);
      Result := TRUE;
      //±ÝÀüº¯µ¿
      if igold >= EXORBITANT_PC then begin
//         MainOutMessage('***±ÝÀüº¯µ¿: -' + GetGoldStr(igold) + ' ' + UserName + ' (Lv:' + IntToStr(Abil.Level) + ') => ' + GetGoldStr(Gold));

         //·¹º§ÀÇ 10ÀÇ ÀÚ¸®¼ö
         strlevel := IntToStr( _MIN(9, Abil.Level div 10) );
         //·Î±× ³²°Ü¾ß ÇÔ
         AddUserLog ('51'#9 + //±ÝÀü_
                     MapName + ''#9 +
                     IntToStr(CX) + ''#9 +
                     IntToStr(CY) + ''#9 +
                     UserName + ''#9 +
                     NAME_OF_PC{'Ôª±¦'} + ''#9 +
                     IntToStr(-igold) + ''#9 +
                     strlevel + ''#9 +
                     IntToStr(PotCash));
      end;
   end;
end;

function TUserHuman.LeftMarry:Boolean;  // Àë»é
var
  Lname : string;
  Target    : TUserHuman;
begin
  Result := false;
  if Gold < 1000000 then begin
    SysMsg('ÄãÎÞÅäÅ¼»òËùÐ¯´øµÄ½ð±Ò²»¹»£¬²»ÄÜÀë»é!', 1);
    Exit;
  end;

  Lname := fLover.GetLoverName;
  if Lname <> '' then begin
    DecGold(1000000);
    GoldChanged;
    fLover.Delete(Lname);
    SendDefMessage (SM_LM_DELETE, 0,10, 0, 0, Lname);
    SendDefMessage (SM_LM_RESULT, 0,10, RsError_SuccessDelete, 0, Lname);
    // DB¿¡¼­ »èÁ¦ÇÑ´Ù.
    SendMsg (Self,RM_LM_DBDELETE,0,0,0,0,Lname+'/');


    Target := UserEngine.GetUserHuman(Lname);
    if Target <> nil then begin
      Target.fLover.Delete(UserName);
      Target.UserNameChanged;
    end;

    UserNameChanged;
    Result := true;
  end else begin
    SysMsg('ÄãÎÞÅäÅ¼»òËùÐ¯´øµÄ½ð±Ò²»¹»£¬²»ÄÜÀë»é!', 1);
  end;
end;

procedure TUserHuman.GetSaleItemListEx(pmsg: pTMessageInfo);
var
  sSENDMSG, sSENDMSGSP: string;
  i, nCount, nCountsp: Integer;
  ShopItem          : TShopItem;
  pShopItem         : pTShopItem;
begin
  sSENDMSG := '';
  sSENDMSGSP := '';
  nCount := 0;
  nCountsp := 0;
  ShopItemList.Lock;
  try
    for i := 0 to ShopItemList.Count - 1 do begin
      pShopItem := ShopItemList.Items[i];
      if pShopItem^.btClass = 5 then begin
        ShopItem := pShopItem^;
        sSENDMSGSP := sSENDMSGSP + (EncodeBuffer(@ShopItem, SizeOf(TShopItem))) + '/';
        Inc(nCountsp);
        if nCountsp >= 5 then
          Break;
      end else if pmsg.lParam1 = pShopItem^.btClass then begin
        ShopItem := pShopItem^;
        sSENDMSG := sSENDMSG + (EncodeBuffer(@ShopItem, SizeOf(TShopItem))) + '/';
        Inc(nCount);
        if nCount >= 255 then  //ÐÞÕýÉÌÆÌÒ³ÊýÖ§³Ö255
          Break;
      end;
    end;
  finally
    ShopItemList.UnLock;
  end;
  if (pmsg.lParam1 in [0..4]) and (m_btGetShopItem[pmsg.lParam1] = 0) then begin
    m_btGetShopItem[pmsg.lParam1] := 1;
    Def := MakeDefaultMsg(SM_SPECOFFERITEM, Integer(pmsg.sender), {g_Config.btSellType}0, 0, 0);
    if sSENDMSG <> '' then SendSocket(@Def, sSENDMSG);
  end;
  if (m_btGetShopItem[5] = 0) then begin
    m_btGetShopItem[5] := 1;
    Def := MakeDefaultMsg(SM_OFFERITEM, Integer(pmsg.sender), {g_Config.btSellType}0, 0, 0);
    if sSENDMSGSP <> '' then SendSocket(@Def, sSENDMSGSP);
  end;
end;

procedure TUserHuman.BuySaleItemListEx(pmsg: pTMessageInfo);
var
  sItemName         : string;
  nRetCode          : Integer;
  pStdItem          : pTStdItem;
  pUserItem         : pTUserItem;
  pShopItem         : pTShopItem;
label
  lab, lab2;
begin
  if boDealing or (GetTickCount - DealItemChangeTime <= 1000) then begin
    SysMsg('[½»Ò××´Ì¬] ²»ÄÜÊ¹ÓÃÉÌÆÌ¹¦ÄÜ£¡', 0);
    Exit;
  end;

//  if g_Config.btSellType = 0 then begin
    if GetTickCount - m_dwBuyShopItemTick >= 500 then begin
      m_dwBuyShopItemTick := GetTickCount();
      if PotCash > 0 then begin
        sItemName := DecodeString(pmsg.description);
        if sItemName <> '' then begin
          pShopItem := UserEngine.GetShopItemByName(sItemName);
          if pShopItem <> nil then begin
            pStdItem := UserEngine.GetStdItemFromName(pShopItem^.sItemName);
            if pStdItem <> nil then begin
              if (pShopItem^.wPrice >= 0) and (PotCash >= pShopItem^.wPrice) then begin
                /////////////////////
                if pStdItem.OverlapItem >= 1 then begin
                  if UserCounterItemAdd(pStdItem.StdMode, pStdItem.Looks, 1, pStdItem.Name, False) then begin
                    Dec(PotCash, pShopItem^.wPrice);
                    PotCashChanged();
                    Exit;
                  end else begin
                    goto lab;
                  end;
                end else begin
                  lab:
                  if IsEnoughBag then begin
                    New(pUserItem);
                    if UserEngine.CopyToUserItemFromName(sItemName, pUserItem^) and AddToBagItem(pUserItem^) then begin

                      Dec(PotCash, pShopItem^.wPrice);
//                      SendAddItem(pUserItem^);
                      PotCashChanged();
                    end else
                      Dispose(pUserItem);
                    Exit;
                  end else
                    nRetCode := -4;
                end;
              end else
                nRetCode := -3;
            end else
              nRetCode := -1;
          end else
            nRetCode := -5;
        end else
          nRetCode := 0;
      end else
        nRetCode := -2;
    end else
      nRetCode := -6;
    SendDefMessage(SM_BUGITEMFAIL, nRetCode, 0, 0, 0, '');
//  end else begin
//    if GetTickCount - m_dwBuyShopItemTick >= 500 then begin
//      m_dwBuyShopItemTick := GetTickCount();
//      if m_nGold > 0 then begin
//        sItemName := DecodeString(ProcessMessage.sMsg);
//        if sItemName <> '' then begin
//          pShopItem := GetShopItemByName(sItemName);
//          if pShopItem <> nil then begin
//            pStdItem := UserEngine.GetStdItem(pShopItem^.sItemName);
//            if pStdItem <> nil then begin
//              if (pShopItem^.wPrice >= 0) and (m_nGold >= pShopItem^.wPrice) then begin
//                /////////////////////
//                if pStdItem.Overlap >= 1 then begin
//                  if UserCounterItemAdd(pStdItem.StdMode, pStdItem.Looks, 1, pStdItem.Name, False) then begin
//                    Dec(m_nGold, pShopItem^.wPrice);
//                    GoldChanged();
//                    if pStdItem.NeedIdentify = 1 then
//                      AddGameDataLogAPI('9' + #9 +
//                        m_sMapName + #9 +
//                        IntToStr(m_nCurrX) + #9 +
//                        IntToStr(m_nCurrY) + #9 +
//                        m_sCharName + #9 +
//                        pStdItem.Name + #9 +
//                        '9999' + #9 +
//                        '1' + #9 +
//                        'ÉÌÆÌ¹ºÂò-' + IntToStr(pShopItem^.wPrice) + '½ð±Ò');
//                    Exit;
//                  end else begin
//                    goto lab2;
//                  end;
//                end else begin
//                  lab2:
//                  if IsEnoughBag then begin
//                    New(pUserItem);
//                    if UserEngine.CopyToUserItemFromName(sItemName, pUserItem) and AddItemToBag(pUserItem) then begin
//
//                      Dec(m_nGold, pShopItem^.wPrice);
//                      SendAddItem(pUserItem);
//                      GoldChanged();
//                      if pStdItem.NeedIdentify = 1 then
//                        AddGameDataLogAPI('9' + #9 +
//                          m_sMapName + #9 +
//                          IntToStr(m_nCurrX) + #9 +
//                          IntToStr(m_nCurrY) + #9 +
//                          m_sCharName + #9 +
//                          pStdItem.Name + #9 +
//                          IntToStr(pUserItem.MakeIndex) + #9 +
//                          '1' + #9 +
//                          'ÉÌÆÌ¹ºÂò-' + IntToStr(pShopItem^.wPrice) + '½ð±Ò');
//                      if g_Config.nShopItemBind = 1 then
//                        BindItemCharName(pUserItem^.wIndex, pUserItem^.MakeIndex, m_sCharName)
//                      else if g_Config.nShopItemBind = 2 then
//                        BindItemAccount(pUserItem^.wIndex, pUserItem^.MakeIndex, m_sUserID);
//                    end else
//                      Dispose(pUserItem);
//                    Exit;
//                  end else
//                    nRetCode := -4;
//                end;
//              end else
//                nRetCode := -3;
//            end else
//              nRetCode := -1;
//          end else
//            nRetCode := -5;
//        end else
//          nRetCode := 0;
//      end else
//        nRetCode := -2;
//    end else
//      nRetCode := -6;
//    SendDefMessage(SM_BUGITEMFAIL, nRetCode, 1, 1, 1, '');
//  end;
end;

procedure TUserHuman.PresendItem(pmsg: pTMessageInfo);
var
  PlayObject        : TUserHuman;
  s, sWho, sItemName: string;
  nRetCode          : Integer;
  pStdItem          : pTStdItem;
  pUserItem         : pTUserItem;
  pShopItem         : pTShopItem;
label
  lab, lab2;
begin

//  if not g_Config.boPresendItem then begin
//    SendDefMessage(SM_PRESENDITEMFAIL, -9, g_Config.btSellType, g_Config.btSellType, g_Config.btSellType, '');
//    Exit;
//  end;

  if GetTickCount - m_dwBuyShopItemTick >= 500 then begin
    m_dwBuyShopItemTick := GetTickCount();
//    if g_Config.btSellType = 0 then begin
      if PotCash > 0 then begin
        s := DecodeString(pmsg.description);
        sItemName := GetValidStr3(s, sWho, ['/']);
        if CompareText(sWho, UserName) <> 0 then begin
          PlayObject := UserEngine.GetUserHuman(sWho);
          if PlayObject <> nil then begin
            if not PlayObject.BoExchangeAvailable then begin
              PlayObject.SysMsg(Format('%sÏòÄãÔùËÍ%sÎ´³É¹¦,Äã±ØÐëÏÈÔÊÐí½»Ò×²ÅÄÜ½ÓÊÜÔùËÍ', [UserName, sItemName]), 1);
              SysMsg(Format('%s µ±Ç°²»ÔÊÐí½»Ò×,¶Ô·½±ØÐëÔÊÐí½»Ò×ºóÄã²ÅÄÜÔÙ½øÐÐÔùËÍ', [PlayObject.UserName]), 0);
              Exit;
            end;
            if sItemName <> '' then begin
              pShopItem := UserEngine.GetShopItemByName(sItemName);
              if pShopItem <> nil then begin
                pStdItem := UserEngine.GetStdItemFromName(pShopItem^.sItemName);
                if pStdItem <> nil then begin
                  if (pShopItem^.wPrice >= 0) and (PotCash >= pShopItem^.wPrice) then begin
                    /////////////////////
                    if pStdItem.OverlapItem >= 1 then begin
                      if PlayObject.UserCounterItemAdd(pStdItem.StdMode, pStdItem.Looks, 1, pStdItem.Name, False) then begin
                        Dec(PotCash, pShopItem^.wPrice);
                        PotCashChanged();
                        PlayObject.SysMsg(Format('%sÏòÄãÔùËÍÁË%s£¬Çë×¢Òâ²éÊÕ', [UserName, sItemName]), 4);
                        nRetCode := 1;
                      end else begin
                        goto lab;
                      end;
                    end else begin
                      lab:
                      if PlayObject.IsEnoughBag then begin
                        New(pUserItem);
                        if UserEngine.CopyToUserItemFromName(sItemName, pUserItem^) and PlayObject.AddToBagItem(pUserItem^) then begin
                          Dec(PotCash, pShopItem^.wPrice);
//                          PlayObject.SendAddItem(pUserItem^);
                          PotCashChanged();

                          PlayObject.SysMsg(Format('%sÏòÄãÔùËÍÁË%s£¬Çë×¢Òâ²éÊÕ', [UserName, sItemName]), 4);
                          nRetCode := 1;
                        end else begin
                          Dispose(pUserItem);
                          nRetCode := -1;
                        end;
                      end else
                        nRetCode := -4;
                    end;
                  end else
                    nRetCode := -3;
                end else
                  nRetCode := -1;
              end else
                nRetCode := -5;
            end else
              nRetCode := 0;
          end else
            nRetCode := -7;
        end else
          nRetCode := -8;
      end else
        nRetCode := -2;
//    end else begin
//      if m_nGold > 0 then begin
//        s := DecodeString(pmsg.sMsg);
//        sItemName := GetValidStr3(s, sWho, ['/']);
//        if CompareText(sWho, m_sCharName) <> 0 then begin
//          PlayObject := UserEngine.GetPlayObject(sWho);
//          if PlayObject <> nil then begin
//            if not PlayObject.m_boAllowDeal then begin
//              PlayObject.SysMsg(Format('%sÏòÄãÔùËÍ%sÎ´³É¹¦,Äã±ØÐëÏÈÔÊÐí½»Ò×²ÅÄÜ½ÓÊÜÔùËÍ', [m_sCharName, sItemName]), c_Blue, t_Hint);
//              SysMsg(Format('%s µ±Ç°²»ÔÊÐí½»Ò×,¶Ô·½±ØÐëÔÊÐí½»Ò×ºóÄã²ÅÄÜÔÙ½øÐÐÔùËÍ', [PlayObject.m_sCharName]), c_Red, t_Hint);
//              Exit;
//            end;
//            if sItemName <> '' then begin
//              pShopItem := GetShopItemByName(sItemName);
//              if pShopItem <> nil then begin
//                pStdItem := UserEngine.GetStdItem(pShopItem^.sItemName);
//                if pStdItem <> nil then begin
//                  if (pShopItem^.wPrice >= 0) and (m_nGold >= pShopItem^.wPrice) then begin
//                    /////////////////////
//                    if pStdItem.Overlap >= 1 then begin
//                      if PlayObject.UserCounterItemAdd(pStdItem.StdMode, pStdItem.Looks, 1, pStdItem.Name, False) then begin
//                        Dec(m_nGold, pShopItem^.wPrice);
//                        GoldChanged();
//                        if pStdItem.NeedIdentify = 1 then
//                          AddGameDataLogAPI('9' + #9 +
//                            m_sMapName + #9 +
//                            IntToStr(m_nCurrX) + #9 +
//                            IntToStr(m_nCurrY) + #9 +
//                            m_sCharName + #9 +
//                            pStdItem.Name + #9 +
//                            '9999' + #9 +
//                            '1' + #9 +
//                            'ÉÌÆÌÔùËÍ¸ø:' + PlayObject.m_sCharName + '-' + IntToStr(pShopItem^.wPrice) + '½ð±Ò');
//                        PlayObject.SysMsg(Format('%sÏòÄãÔùËÍÁË%s£¬Çë×¢Òâ²éÊÕ', [m_sCharName, sItemName]), c_Purple, t_Hint);
//                        nRetCode := 1;
//                      end else begin
//                        goto lab2;
//                      end;
//                    end else begin
//                      lab2:
//                      if PlayObject.IsEnoughBag then begin
//                        New(pUserItem);
//                        if UserEngine.CopyToUserItemFromName(sItemName, pUserItem) and PlayObject.AddItemToBag(pUserItem) then begin
//                          Dec(m_nGold, pShopItem^.wPrice);
//                          PlayObject.SendAddItem(pUserItem);
//                          GoldChanged();
//                          if pStdItem.NeedIdentify = 1 then
//                            AddGameDataLogAPI('9' + #9 +
//                              m_sMapName + #9 +
//                              IntToStr(m_nCurrX) + #9 +
//                              IntToStr(m_nCurrY) + #9 +
//                              m_sCharName + #9 +
//                              pStdItem.Name + #9 +
//                              IntToStr(pUserItem.MakeIndex) + #9 +
//                              '1' + #9 +
//                              'ÉÌÆÌÔùËÍ¸ø:' + PlayObject.m_sCharName + '-' + IntToStr(pShopItem^.wPrice) + '½ð±Ò');
//                          PlayObject.SysMsg(Format('%sÏòÄãÔùËÍÁË%s£¬Çë×¢Òâ²éÊÕ', [m_sCharName, sItemName]), c_Purple, t_Hint);
//                          if g_Config.nShopItemBind = 1 then
//                            BindItemCharName(pUserItem^.wIndex, pUserItem^.MakeIndex, PlayObject.m_sCharName)
//                          else if g_Config.nShopItemBind = 2 then
//                            BindItemAccount(pUserItem^.wIndex, pUserItem^.MakeIndex, PlayObject.m_sUserID);
//                          nRetCode := 1;
//                        end else begin
//                          Dispose(pUserItem);
//                          nRetCode := -1;
//                        end;
//                      end else
//                        nRetCode := -4;
//                    end;
//                  end else
//                    nRetCode := -3;
//                end else
//                  nRetCode := -1;
//              end else
//                nRetCode := -5;
//            end else
//              nRetCode := 0;
//          end else
//            nRetCode := -7;
//        end else
//          nRetCode := -8;
//      end else
//        nRetCode := -2;
//    end;
  end else
    nRetCode := -6;
  SendDefMessage(SM_PRESENDITEMFAIL, nRetCode, {g_Config.btSellType}0, {g_Config.btSellType}0, {g_Config.btSellType}0, '');
end;


end.



